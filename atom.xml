<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-04-07T09:14:55.353Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>……</title>
    <link href="https://gift1a.github.io/2022/04/07/%E2%80%A6%E2%80%A6/"/>
    <id>https://gift1a.github.io/2022/04/07/%E2%80%A6%E2%80%A6/</id>
    <published>2022-04-07T09:13:08.000Z</published>
    <updated>2022-04-07T09:14:55.353Z</updated>
    
    <content type="html"><![CDATA[<p>先放下手中的东西，去啃书了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先放下手中的东西，去啃书了&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BlockChain</title>
    <link href="https://gift1a.github.io/2022/04/06/BlockChain/"/>
    <id>https://gift1a.github.io/2022/04/06/BlockChain/</id>
    <published>2022-04-06T12:44:16.000Z</published>
    <updated>2022-04-06T13:31:27.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00-环境配置"></a>0x00-环境配置</h1><p><a href="https://www.cnblogs.com/KRDecad3/p/10798383.html">https://www.cnblogs.com/KRDecad3/p/10798383.html</a></p><p>Rinkeby获取测试币网站</p><p><a href="https://faucets.chain.link/rinkeby">https://faucets.chain.link/rinkeby</a></p><p>其他的获取都没啥问题，选择购买-&gt;第二个即可</p><p><img src="/2022/04/06/BlockChain/1649249439831.png"></p><h1 id="0x01-基础使用"><a href="#0x01-基础使用" class="headerlink" title="0x01-基础使用"></a>0x01-基础使用</h1><p>可以本地化安装，也可以使用在线网站 <a href="http://remix.ethereum.org/">http://remix.ethereum.org</a> </p><h2 id="0x00-创建文件"><a href="#0x00-创建文件" class="headerlink" title="0x00-创建文件"></a>0x00-创建文件</h2><p>按照如下操作创建新文件，名称后缀为.sol</p><p><img src="/2022/04/06/BlockChain/1649250592024.png"></p><h2 id="0x01-源码编译"><a href="#0x01-源码编译" class="headerlink" title="0x01-源码编译"></a>0x01-源码编译</h2><p>源代码</p><pre class="language-solidity" data-language="solidity"><code class="language-solidity">pragma solidity ^0.4.23;contract Trans{        string flag;    mapping(address =&gt; uint256) balances;    constructor () public {        //flag = WHAT_YOU_WANT;    }        function getBalance() public returns (bool){        balances[msg.sender] = 100;        return true;    }        function showBalance() public view returns (uint256){        return balances[msg.sender];    }        function Transfer(address[] _addr, uint256 _value) public returns (bool){        uint times = _addr.length;        uint256 amount = uint256(times) * _value;        require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);        require(times &gt; 0 &amp;&amp; times &lt; 10);        balances[msg.sender] -= amount;        for(uint i = 0; i &lt; times; i++){            balances[_addr[i]] += _value;        }        return true;    }        function getFlag() public view returns (string){        require(balances[msg.sender] &gt; 9999999);        return flag;    }}</code></pre><p>一些说明</p><p>我们选择的COMPILER需要和题目的源码的版本一致</p><p><img src="/2022/04/06/BlockChain/1649250475741.png"></p><p>然后我选择了自动编译</p><h2 id="0x02-配置题目合约"><a href="#0x02-配置题目合约" class="headerlink" title="0x02-配置题目合约"></a>0x02-配置题目合约</h2><p><img src="/2022/04/06/BlockChain/1649251440698.png" alt="一些说明"></p><p>弄好之后点击Deploy即可，然后他会连接并让我们确认支付</p><p>然后这些就是函数</p><p><img src="/2022/04/06/BlockChain/1649251873154.png"></p><h1 id="0x02-刷题网站"><a href="#0x02-刷题网站" class="headerlink" title="0x02-刷题网站"></a>0x02-刷题网站</h1><p><a href="https://chainflag.org/challenges">https://chainflag.org/challenges</a></p><p>因为智能合约基本是solidity语法，所以需要学习一下</p><p><a href="https://www.jianshu.com/p/70aecda3212e">https://www.jianshu.com/p/70aecda3212e</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-环境配置&quot;&gt;&lt;a href=&quot;#0x00-环境配置&quot; class=&quot;headerlink&quot; title=&quot;0x00-环境配置&quot;&gt;&lt;/a&gt;0x00-环境配置&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/KRDecad3/</summary>
      
    
    
    
    
    <category term="BlockChain" scheme="https://gift1a.github.io/tags/BlockChain/"/>
    
  </entry>
  
  <entry>
    <title>PWN基本工具</title>
    <link href="https://gift1a.github.io/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    <id>https://gift1a.github.io/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/</id>
    <published>2022-04-06T02:25:58.000Z</published>
    <updated>2022-04-07T08:43:08.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-GDB工具安装"><a href="#0x00-GDB工具安装" class="headerlink" title="0x00-GDB工具安装"></a>0x00-GDB工具安装</h1><p><a href="https://zhuanlan.zhihu.com/p/129837931">https://zhuanlan.zhihu.com/p/129837931</a></p><p>gdb这三个插件不能同时运行，可以使用命令</p><pre class="language-none"><code class="language-none">vim ~/.gdbinit</code></pre><p><img src="/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/1649212326580.png" alt="gdbinit"></p><p>不需要使用哪个就注释掉哪个</p><h1 id="0x01-GDB基本使用"><a href="#0x01-GDB基本使用" class="headerlink" title="0x01-GDB基本使用"></a>0x01-GDB基本使用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先先使用gcc生成elf文件，-g表示可以debug</p><pre class="language-none"><code class="language-none">gcc inputfile -o outputfile -g</code></pre><p>使用下面命令打开</p><pre class="language-none"><code class="language-none">gdb file</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">https://blog.csdn.net/Breeze_CAT/article/details/103789233</a></p><p><a href="https://www.cnblogs.com/zhwer/p/12494317.html">https://www.cnblogs.com/zhwer/p/12494317.html</a></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre class="language-c" data-language="c"><code class="language-c">help//帮助i//infoi b//info break查看所有断点信息i r//info registers 查看各个寄存器当前的值i f//info function 查看所有函数名，保留符号show //和info相似，但是是查看调试器的基本信息show args//查看参数backtrace//查看调用堆栈q//quit退出</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><pre class="language-c" data-language="c"><code class="language-c">s//step，单步步入，跟进函数中，也就是step into，源码层面的一步，F7si//同s，汇编层面的一步n//next，单步补过，F8，源码层面的一步ni//同n，汇编层面的一步c//continue，F9，继续执行到断点r//run，重新开始执行</code></pre><h3 id="断点指令-break"><a href="#断点指令-break" class="headerlink" title="断点指令-break"></a>断点指令-break</h3><pre class="language-c" data-language="c"><code class="language-c">b*(0x123456)//给0x123456地址的指令下断点b*$rebase(0x123456)//$rebase在调试开PIE的程序的时候可以直接加上程序的随即地址b func_name//给函数func_name下断点，目标文件要保留符号才行    b file_name:func_nameb file_name:15//给file_name的15行下断点，需要有源码    b 15b +0x10//在程序当前停住的位置下0x10的位置下断点，也可以-0x10，就是前0x10break fun if $rdi==5//条件断点，rdi的值为5的时候才断</code></pre><p>删除、禁用断点的指令</p><pre class="language-c" data-language="c"><code class="language-c">//先使用i b查看断点编号delete 5//删除5号断点，如果直接delete不加数字，表示删除所有断点disable 5//禁用5号断点    enable 5//启用5号断点clear//清除下面的所有断点</code></pre><p>内存断点指令</p><pre class="language-c" data-language="c"><code class="language-c">watch 0x123456//0x123456地址的数据改变的时候会断watch a//变量a改变的时候会断info watchpoints//查看watch断点信息</code></pre><h3 id="打印指令"><a href="#打印指令" class="headerlink" title="打印指令"></a>打印指令</h3><p>查看内存指令x</p><pre class="language-c" data-language="c"><code class="language-c">x /nuf 0x123456//x指令的格式是：x /nfu，nfu代表三个参数    n//代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在'/'后面    u//代表一个单元几个字节，b(一个字节),h(两个字节)，w(四字节)，g(八字节)    f//代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n    x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。        t 按二进制格式显示变量。        a 按十六进制格式显示变量。        c 按字符格式显示变量。        f 按浮点数格式显示变量。        s 按字符串显示。        b 按字符显示。        i 显示汇编指令。x /10gx 0x123456//从0x123456开始每个单元八个字节，十六进制显示十个单元的数据x /10xd $rdi//从rdi指向的地址向后打印十个单元，每个单元四字节的十进制数x /10i 0x123456//从0x123456处向后显示十条汇编指令</code></pre><p>打印指令p(print)</p><pre class="language-c" data-language="c"><code class="language-c">p func_name//打印func_name的地址，需要保留符号p 0x10-0x8//计算0x10-0x8的结果p &amp;a//查看变量a的地址p *(0x123456)//查看0x123456的值p $rdi//显示rdi寄存器的值    p *($rdi)//显示rdi指向的值</code></pre><p>打印汇编指令disass(disassemble)</p><pre class="language-c" data-language="c"><code class="language-c">disass 0x123456//显示0x123456前后的汇编指令x /10i //前面说过了</code></pre><p>打印源代码list</p><pre class="language-c" data-language="c"><code class="language-c">list//查看当前附近10行的代码    list 38//查看28行附近10行的代码    list 1,10//查看1-10行代码    list main//查看main函数的开始10行</code></pre><h3 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h3><pre class="language-c" data-language="c"><code class="language-c">search rdi//从当前位置向后查找包含rdi的指令find "hello"//查找hello字符串，pwndbg独有</code></pre><h3 id="修改数据指令-set"><a href="#修改数据指令-set" class="headerlink" title="修改数据指令-set"></a>修改数据指令-set</h3><pre class="language-c" data-language="c"><code class="language-c">set $rdi=0x10//把寄存器的值变为0x10set *(0x123456)=0x10//把0x123456地址的值变为0x10，注意带星号set args "abc" "def" "gh"//给参数123赋值</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class="language-c" data-language="c"><code class="language-c">堆操作指令（pwndbg插件独有）arena //显示arena的详细信息arenas //显示所有arena的基本信息arenainfo //好看的显示所有arena的信息bins //常用，查看所有种类的堆块的链表情况fastbins //单独查看fastbins的链表情况largebins //同上，单独查看largebins的链表情况smallbins //同上，单独查看smallbins的链表情况unsortedbin //同上，单独查看unsortedbin链表情况tcachebins //同上，单独查看tcachebins的链表情况tcache //查看tcache详细信息heap //数据结构的形式显示所有堆块，会显示一大堆heapbase //查看堆起始地址heapinfo、heapinfoall //显示堆得信息，和bins的挺像的，没bins好用parseheap //显示堆结构，很好用tracemalloc //好用，会跟提示所有操作堆的地方其他pwndbg插件独有指令cyclc 50 //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama$reabse //开启PIE的情况的地址偏移b *$reabse(0x123456) //断住PIE状态下的二进制文件中0x123456的地方codebase //打印PIE偏移，与rebase不同，这是打印，rebase是使用stack //查看栈retaddr //打印包含返回地址的栈地址canary //直接看canary的值plt //查看plt表got //查看got表hexdump //像IDA那样显示数据，带字符串</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-GDB工具安装&quot;&gt;&lt;a href=&quot;#0x00-GDB工具安装&quot; class=&quot;headerlink&quot; title=&quot;0x00-GDB工具安装&quot;&gt;&lt;/a&gt;0x00-GDB工具安装&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhih</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://gift1a.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库创建与使用</title>
    <link href="https://gift1a.github.io/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://gift1a.github.io/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-04T08:59:59.000Z</published>
    <updated>2022-04-06T05:48:00.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-参考文章"><a href="#0x00-参考文章" class="headerlink" title="0x00-参考文章"></a>0x00-参考文章</h1><p><a href="https://blog.csdn.net/LyRics1996/article/details/120246497">https://blog.csdn.net/LyRics1996/article/details/120246497</a></p><h1 id="0x01-创建动态链接库"><a href="#0x01-创建动态链接库" class="headerlink" title="0x01-创建动态链接库"></a>0x01-创建动态链接库</h1><p>下面以VS为例</p><p>在创建新项目找到动态链接库DLL</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068184192.png"></p><p>创建之后是这样的</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068250968.png"></p><p>替换成我们待会要调用的函数</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070264273.png" alt="替换之后"></p><p>之所以要在函数前面加上extern “C” __declspec(dllexport)</p><p>是因为在导出的时候可能会增加一些符号，这样的话函数的名称会被修改，待会GetProcAddress就无法调用了</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070418832.png" alt="说明"></p><h1 id="0x03-调用动态链接库"><a href="#0x03-调用动态链接库" class="headerlink" title="0x03-调用动态链接库"></a>0x03-调用动态链接库</h1><p>首先先要加载动态链接库，使用LoadLibrary，有两种方式</p><pre class="language-c" data-language="c"><code class="language-c">handle = LoadLibrary(L"Dll1.dll");handle = LoadLibrary(_TEXT("D:\\new\\AD\\C语言\\Dll1\\Debug\\Dll1.dll"));</code></pre><p>使用下面这种方式的话需要#include&lt;tcahr.h&gt;</p><p>GetProcAddress调用DLL文件中的函数</p><p>我们需要使用typedef为函数指针创建匹配类型的指针</p><p>因为函数名就是函数的地址，所以可以直接赋值和调用，下面两种都可以调用函数，震惊！C语言白学了</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649072130088.png"></p><p>代码如下</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include &lt;tchar.h&gt;typedef int(*Lpfunc)(int a,int b);//先定义函数指针int main(){HMODULE handle;handle = LoadLibrary(L"Dll1.dll");handle = LoadLibrary(_TEXT("Dll1.dll"));Lpfunc add = NULL;add = (Lpfunc)GetProcAddress(handle, "add");printf("%d\n", add(3, 4));FreeLibrary(handle);//释放资源return 0;}</code></pre><p>typedef声明函数指针</p><p><a href="https://blog.csdn.net/afei__/article/details/82011613">https://blog.csdn.net/afei__/article/details/82011613</a></p><p>当然我们也可以多层调用</p><p>dll文件中</p><pre class="language-c" data-language="c"><code class="language-c">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "pch.h"#include&lt;stdio.h&gt;extern "C" _declspec (dllexport)void Print(int k){    printf("%d\n", k);}extern "C" _declspec (dllexport)int add(int a, char b){    int c = a + b;    Print(c);    return c;}</code></pre><p>python调用dll-ctype</p><p><a href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-参考文章&quot;&gt;&lt;a href=&quot;#0x00-参考文章&quot; class=&quot;headerlink&quot; title=&quot;0x00-参考文章&quot;&gt;&lt;/a&gt;0x00-参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/LyRics1996/</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>近期题目复现</title>
    <link href="https://gift1a.github.io/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-04T07:15:00.000Z</published>
    <updated>2022-04-07T09:12:07.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Zer0pts2022-service"><a href="#0x00-Zer0pts2022-service" class="headerlink" title="0x00-Zer0pts2022-service"></a>0x00-Zer0pts2022-service</h1><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>先定位到正确的判断，进入加密函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057498918.png"></p><p>可以看到有几个api函数，并且只有所有的值都相等，才能实现return的值为1</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057543911.png"></p><p>但是动调的时候很多函数看不到，而且这里面有很多东西未被正确识别，所以使用X64DBG打开并定位到加密函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057759455.png" alt="加密函数"></p><p>首先我们要知道x64的函数调用机制</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057831750.png"></p><p>所以在call前的那几个mov就是函数的参数</p><p>先看循环的次数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057937520.png" alt="rbp-0x44"></p><p>很明显这段就是循环的判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057978804.png" alt="循环判断"></p><p>循环内部，可以看到有三个api函数，先不管</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058022189.png"></p><p>因为刚才在ida看到，最后是有一个比较的，我们先确定存储加密后字符串的位置，根据这个跳转和0x1F也就是31，确定这就是判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058122264.png"></p><p>可以看到在这之前先把两个地址存放的一个byte放入edx和eax中，我们就可以定位过去，先运行到这</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058190552.png" alt="关键判断"></p><p>可以看到，我们通过64FD80-0x40得到了存放加密字符串的地址，那么这一段就是循环判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058453221.png"></p><p>接下来我们重新运行一下，然后这次我们先右键锁定堆栈，观察他的变化</p><p>先来看一下第一个API函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058638150.png" alt="CryptCreateHash"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptCreateHash(  [in]  HCRYPTPROV hProv,  [in]  ALG_ID     Algid,  [in]  HCRYPTKEY  hKey,  [in]  DWORD      dwFlags,  [out] HCRYPTHASH *phHash);</code></pre><p>而前面的一些是函数的参数，关键的是下面这个，我们点进这个链接</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058819510.png" alt="关键参数"></p><p>0x800C，和我们的参数对应上了，那么这个应该就是加密的方式</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058866139.png"></p><p>再看第二个函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058990852.png" alt="CryptHashData"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptHashData(  [in] HCRYPTHASH hHash,  [in] const BYTE *pbData,  [in] DWORD      dwDataLen,  [in] DWORD      dwFlags);</code></pre><p>关键是是我们加密的数据和数据的长度，也就是说每次取出2长度的字符串生成hashdata</p><p>再看第三个</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059153629.png" alt="CryptGetHashParam"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptGetHashParam(  [in]      HCRYPTHASH hHash,  [in]      DWORD      dwParam,  [out]     BYTE       *pbData,  [in, out] DWORD      *pdwDataLen,  [in]      DWORD      dwFlags);</code></pre><p>具体的可以不用细看，只需知道这一段是真正的加密，因为在执行前，目标地址没有数据</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059338076.png"></p><p>执行后</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059375141.png"></p><p>所以整个过程就是将我们输入的每两位进行sha256加密，然后和他给我们的hash表进行表，那我们就可以先生成两字符的sha256彩虹表，然后反查</p><p>验证一下</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059489991.png" alt="sha256表"></p><p>flag格式是zer0pts，取前两个字符进行sha256加密，正好对应</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059547681.png"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-python" data-language="python"><code class="language-python">hash = [  "33129567e0bd787efb15a26307e5311e06ba66e3b8dbc2206ad59f99780a4d78",  "dd191696e15e2ee293410d02454c5f9461a2249dee6d57c75f264eaeb83a3782",  "e75b11da693d7bb5273985dcf9f02729455da7e7c80e54a0615e00ec2ae76d8e",  "04249e0c258e1a4e43cfdae291a835cd15735f650bbbba0465ada1cd9846622a",  "e4223ed20d7ea5740a326e2b268ca6db91d041cf5194f577e393a8ba3b85d8e9",  "8b53639f152c8fc6ef30802fde462ba0be9cf085f7580dc69efd72e002abbb35",  "0117834bf60dcf977229bf1e982cf9bc63b60ef42052f7ce7e800ce1216a9af6",  "741d14df730e53a5a019a710116f696db4ec23a132b74cf6fbb3cf7617e68313",  "e30e580a4c2916bcff30ca047f2d6a494168ceaf8fb9171037a773a9f8e7268e",  "294763754a8efd4c739d9f679bfca3ab510106f42ddb5dc0216ba8bc98ba3158",  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",  "68dbf73d03d3a5107edad3b05676eee240e68c280296e52b6986873c54cef3cb",  "c1818d580d8c8bc111302f4a5e6903ef2d32b11a5613efba507693de8060fb8c",  "44ad63f60af0f6db6fdde6d5186ef78176367df261fa06be3079b6c80c8adba4",  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",  "5e07d6fdc602b0f9b99f6ea24c39e65835992faac400264c52449bc409cf4efa",  "e4dcd6d313af71559596d3009c12d025301842d8c7f888c2850333e91a9bda68",  "fffdff4b07a9d973fd1c3a6be443851bc13e82c4af94c88325244694e352aa31",  "3fffd018d2223020be85670d93f565b63df54a9ce3ed2cdf6347a61df016938c",  "b2941852282562cc3d813e8bf1705d0480a7a008ffa2475501d7c5161165a7fb",  "635ca73d00d4f28b5f573b16eea56e9e4579d77e561c32aa68189d9769fa1753",  "a4d0ef23161b5b7c6a8d5b287543fd74e16b3bf313d71aa187c24cdd728a7b1e",  "e0b9a8799f32453a478c9122f8b83cee68e16db18f493ac81bc1d474594b5df4",  "564999cbbfea80170ba068dcf961d9914625f3be951b2c1fe163bae0f8156c24",  "4a44dc15364204a80fe80e9039455cc1608281820fe2b24f1e5233ade6af1dd5",  "e91787068a3c60e9712a7abeb6a67f518a40723c1b89c11d6070fe5f9389ebf9",  "7eb70257593da06f682a3ddda54a9d260d4fc514f645237f5ca74b08f8da61a6",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",]import hashlibimport itertoolsdef dec(h):  for l in range(2,3):    for p in itertools.product(range(128), repeat=l):      if hashlib.sha256(bytes(p)).hexdigest()==h:        return bytes(p)flag = b""for h in hash:  flag += dec(h)print(flag.decode())</code></pre><p>zer0pts{m0d1fy1ng_PE_1mp0rts_1s_4n_34sy_0bfusc4t10n}</p><p><a href="https://www.cnblogs.com/xxxxxxxxx/p/11544432.html">https://www.cnblogs.com/xxxxxxxxx/p/11544432.html</a></p><p>这里介绍了itertools.product，其实目的就是生成2位字符的彩虹表，然后和密文对比</p><h1 id="SpaceHeroesCtf2022-Shai-Hulud"><a href="#SpaceHeroesCtf2022-Shai-Hulud" class="headerlink" title="SpaceHeroesCtf2022-Shai-Hulud"></a>SpaceHeroesCtf2022-Shai-Hulud</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p>比较有趣的一道题，当时专注于改源码搞定游戏，然后一直失败，主要是自己写的C语言生成的随机数和调试得到的不同（其实是没注意linux和windows生成随机数的不同），所以就想玩游戏得到flag</p><p>另外的解法</p><p><a href="https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud">https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud</a></p><h2 id="0x01-分析过程"><a href="#0x01-分析过程" class="headerlink" title="0x01-分析过程"></a>0x01-分析过程</h2><p>运行程序知道这是个贪吃蛇小游戏，通过不等于0x295判断这就是贪吃蛇长度，然后SHA256_Init可以看出这是sha256加密</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148254617.png"></p><p>前面的一些函数就是生成地图，初始化游戏等操作</p><p>主要看下面这个函数，是随机生成需要吃掉的点的</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148425600.png" alt="vibration"></p><p>这两个函数是一些规则，告诉你wasd是移动</p><p>主要看frame函数</p><p>下面这个函数是说不能碰到尾巴，继续往下看</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148585642.png" alt="判定退出"></p><p>可以看到等于-2的时候，而-2刚好对应随机生产点函数的-2，然后对该值进行sha256加密，并且重新生成-2的点，然后长度+1</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148702003.png"></p><p>所以我们接下来只需要跑到最后的长度即可得到最后的sha256加密值，然后在print_flag函数中，最后进行了一次异或</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148830700.png" alt="print_flag"></p><p>本来修改好规则打算玩到0x294的，但是在长度为195的时候随机点找不到。所以只能老实做</p><p>在导入表可以看到SHA256_Init，SHA256_Update，SHA256_Final函数，可以知道调用了OPENSSL，版本为1.1.0</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148953206.png" alt="导入表"></p><p>安装好之后，模仿该过程生成SHA256加密，注意因为每次都会Update，所以不能将最后一次生成的值直接SHA256加密，这样得到的结果不一样</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649153105553.png" alt="函数说明"></p><p>这也就是前面说的，每加密完一次，hash初始值都会被改变</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;openssl/sha.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char const* argv[]){SHA256_CTX ctx;srand(0x2454);char output[256];__int64_t buffer;int x, y;SHA256_Init(&amp;ctx);for (int i = 0; i &lt; 0x294; ++i){x = rand() % 33;y = rand() % 20;buffer = 16 * x + y;SHA256_Update(&amp;ctx, &amp;buffer, 8);SHA256_Final(output, &amp;ctx);}for(int i = 0; i&lt;32; i++) //将SHA256以16进制输出{         printf("%02x", (int)output[i]&amp;0xff);    }     puts("\n");return 0;</code></pre><p>编译</p><blockquote><p>g++ -o openssl-sha256 openssl-sha256.c -std=c++11 -lssl -lcrypto</p></blockquote><p>也可以动调得到最后的sha256值</p><p>最后异或一下即可</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const* argv[]){char data[33] = {0xC2, 0x98, 0xD1, 0x8E, 0xC8, 0xBF, 0x99, 0x75, 0x50, 0x41, 0x54, 0x5D, 0x3C, 0x39, 0xA8, 0x05,0x73, 0x7B, 0xDE, 0xEA, 0xA3, 0xBE, 0x4C, 0x40, 0x2B, 0xE2, 0x48, 0x90, 0x80, 0x7F, 0x7B, 0x8D };unsigned char magic_bytes[32] = {0xB2, 0xEA, 0xE5, 0xBF, 0xBB, 0x8C, 0xC6, 0x01, 0x38, 0x72, 0x0B, 0x2F, 0x0F, 0x54, 0x9C, 0x6E,0x40, 0x24, 0xEA, 0x84, 0xC7, 0xE1, 0x7D, 0x34, 0x58, 0xBD, 0x2E, 0xE2, 0xB4, 0x12, 0x48, 0xFE};for (int i = 0; i &lt; strlen(data); ++i){data[i] ^= magic_bytes[i];}printf("%s", data);return 0;}</code></pre><p><a href="https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2</a></p><p>上面介绍了openssl的一些加密算法使用，下面这个是函数说明</p><p><a href="https://www.jianshu.com/p/3c59291f8f98">https://www.jianshu.com/p/3c59291f8f98</a></p><h1 id="SpaceHeroesCtf2022-Timesup"><a href="#SpaceHeroesCtf2022-Timesup" class="headerlink" title="SpaceHeroesCtf2022-Timesup"></a>SpaceHeroesCtf2022-Timesup</h1><p>进去就是输入三个数满足一个方程式</p><p>计算方法就不多说了，可以看这篇wp</p><p><a href="https://ctftime.org/writeup/32973">https://ctftime.org/writeup/32973</a></p><p>主要看第二个限制，可以看到这里有个限制应该是在16到17秒之间，但是wp里说的是17分，我自己写了代码发现第一个参数是秒，这里也有说明</p><p><a href="https://www.runoob.com/cprogramming/c-function-localtime.html">https://www.runoob.com/cprogramming/c-function-localtime.html</a></p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649157668565.png"></p><p>那么我们就需要借助工具来进行传送参数，需要pwntools</p><pre class="language-none"><code class="language-none">process是连接本地连接remote是连接远端的，格式t=remote('网址',端口)我们可以发送数据过去，也可以接受数据</code></pre><pre class="language-python" data-language="python"><code class="language-python">val = 0xa4c570a = 1b = (val * 7 - 4) // 2c = 1def testfunc(a, b, c):    return (a + b + c &lt;&lt; ((a % b) &amp; 0x1f)) // ((2 &lt;&lt; (a &amp; 0x1f) ^ 3) * c)result = testfunc(a, b, c)print(val)print(result, hex(result))print(hex(a), hex(b), hex(c))from pwn import *#s = process('./timesup')s = remote('0.cloud.chals.io', 26020)print(s.readuntil(b'&gt;&gt;&gt; ').decode())s.writeline('{} {} {}'.format(hex(a), hex(b), hex(c)).encode())s.interactive()</code></pre><p>直接贴代码吧，感觉需要系统学pwntools</p><h1 id="Hgame2022-week4-hardasm"><a href="#Hgame2022-week4-hardasm" class="headerlink" title="Hgame2022-week4-hardasm"></a>Hgame2022-week4-hardasm</h1><p>一打开有几千行的汇编代码，先定位到关键判断</p><p>可以看到有很多的比较+跳转，而跳转的位置都是error</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300239189.png"></p><p>那么只需要保证不符合等于0即可</p><p>构造flag：hgame{12345678901234567890}动调</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300476017.png" alt="比较内容"></p><p>可以看到只要输入正确，最后得到的值是0xFF，不正确则为0，可以采取爆破的方式爆破出flag</p><p>可以看到printf的参数是通过rcx传入的，所以我们可以patch程序，让他打印[rsp+70h+var_50]的值，而不是success或error</p><p> <img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1c8291f15811477c8fbbd7d6a480bca0.png" alt="asm-print"> </p><p>edit-&gt;patch Program-&gt;Assemble，不知道为什么KeyPatch改不了</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649301043777.png"></p><h2 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h2><p> subprocess模块可以生成新的进程，连接到它们的input/output/error管道，同时获取它们的返回值</p><p>我们可以使用该模块进行爆破</p><pre class="language-python" data-language="python"><code class="language-python">import subprocessreal_flag="hgame{"#绝对正确的前6个字符cur_index=6#当前爆破的位置while cur_index&lt;32:    for i in range(32,128):#当前爆破的位置上的字符        real_flag_arr = [0] * 32        for j in range(len(real_flag)):#正确的先复制一下            real_flag_arr[j]=ord(real_flag[j])        real_flag_arr[cur_index]=i#设置当前爆破的位置上的字符        real_flag_arr_s="".join(chr(k) for k in real_flag_arr)#输入到程序中的字符串        #上面都是一些初始化        p = subprocess.Popen(["D:\\new\\AD\\game\\hgame2022\\week4\\hardasm.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        p.stdin.write(real_flag_arr_s.encode())        p.stdin.close()#停止输入        out = p.stdout.read()        if len(out)&gt;cur_index:#判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置上的字符设置的是正确的，因为存储的内容为0时，printf不打印            real_flag+=chr(i)            cur_index+=1            print(real_flag)            break# hgame{r# hgame{ri# hgame{rig# hgame{righ# hgame{right# hgame{right_# hgame{right_y# hgame{right_yo# hgame{right_you# hgame{right_your# hgame{right_your_# hgame{right_your_a# hgame{right_your_as# hgame{right_your_asm# hgame{right_your_asm_# hgame{right_your_asm_i# hgame{right_your_asm_is# hgame{right_your_asm_is_# hgame{right_your_asm_is_g# hgame{right_your_asm_is_go# hgame{right_your_asm_is_goo# hgame{right_your_asm_is_good# hgame{right_your_asm_is_good!# hgame{right_your_asm_is_good!!# hgame{right_your_asm_is_good!!}# hgame{right_your_asm_is_good!!}</code></pre><p>代码来源-<a href="https://blog.csdn.net/weixin_45582916/article/details/122909419">https://blog.csdn.net/weixin_45582916/article/details/122909419</a></p><p>POpen参数说明</p><pre class="language-none"><code class="language-none">stdin stdout和stderr：stdin stdout和stderr，分别表示子程序的标准输入、标准输出和标准错误。可选的值有PIPE或者一个有效的文件描述符（其实是个正整数）或者一个文件对象，还有None。如果是PIPE，则表示需要创建一个新的管道，如果是None，不会做任何重定向工作，子进程的文件描述符会继承父进程的。另外，stderr的值还可以是STDOUT，表示子进程的标准错误也输出到标准输出。</code></pre><pre class="language-python" data-language="python"><code class="language-python">stdin.write()#输入stdin.close()#关闭输入stout.read()#获取输出</code></pre><h1 id="Foobarctf2022-Matrix"><a href="#Foobarctf2022-Matrix" class="headerlink" title="Foobarctf2022-Matrix"></a>Foobarctf2022-Matrix</h1><p>一道vm题+angr求解</p><p>vm分析部分</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char opcode[124] = {    0x04, 0x0B, 0x1D, 0x1C, 0x1B, 0x1A, 0x04, 0x0A, 0x5A, 0x50, 0x4E, 0x5D, //先把mov后面四个进行异或，然后将异或后的值与我们的输入异或 0x00, 0x0A, 0x0B, 0x00, 0x00, 0x0A, //0x00存的是我们的输入 0x04, 0x0B, 0x2D, 0x2C, 0x2B, 0x2A, 0x04, 0x0A, 0x56, 0x69, 0x58, 0x49, 0x00, 0x0A, 0x0B, 0x00, 0x01, 0x0A, 0x04, 0x0B, 0x3D, 0x3C, 0x3B, 0x3A, 0x04, 0x0A, 0x5C, 0x6C, 0x08, 0x65,     0x00, 0x0A, 0x0B, 0x00, 0x02, 0x0A, 0x04, 0x0B, 0x4D, 0x4C, 0x4B, 0x4A, 0x04, 0x0A, 0x7A, 0x04, 0x2E, 0x15, 0x00, 0x0A, 0x0B, 0x00, 0x03, 0x0A, 0x04, 0x0B, 0x5D, 0x5C, 0x5B, 0x5A, 0x04, 0x0A, 0x30, 0x1C, 0x0F, 0x08, 0x00, 0x0A, 0x0B, 0x00, 0x04, 0x0A, 0x04, 0x0B, 0x6D, 0x6C, 0x6B, 0x6A,     0x04, 0x0A, 0x24, 0x14, 0x16, 0x6A, 0x00, 0x0A, 0x0B, 0x00, 0x05, 0x0A, 0x02, 0x00, 0x01, //将我们异或后的值|=其后面一个值 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x04, 0x02, 0x00, 0x05, 0xFF</code></pre><p>angr求解，因为最后的结果字符串存在GLUG，所以直接angr</p><pre class="language-python" data-language="python"><code class="language-python">import angrimport claripyimport sysproj = angr.Project("./matrix")#创建文件state = proj.factory.entry_state()simgr = proj.factory.simgr()simgr.run()if simgr.deadended:    for s in simgr.deadended:        tmp = s.posix.dumps(0)#获取最终结果        if b"glug" in tmp.lower():            print(tmp)</code></pre><p>不知道为啥只能在linux跑，在windows跑会报错</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Zer0pts2022-service&quot;&gt;&lt;a href=&quot;#0x00-Zer0pts2022-service&quot; class=&quot;headerlink&quot; title=&quot;0x00-Zer0pts2022-service&quot;&gt;&lt;/a&gt;0x00-Zer0pts20</summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>Crackme算法</title>
    <link href="https://gift1a.github.io/2022/04/03/Crackme%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/04/03/Crackme%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-03T03:27:49.000Z</published>
    <updated>2022-04-05T00:53:15.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>因为汇编太水了，所以决定做一下CrackMe练习，可能不会一直弄，精力有限</p><h1 id="0x01-笔记"><a href="#0x01-笔记" class="headerlink" title="0x01-笔记"></a>0x01-笔记</h1><blockquote><p> XCHG（交换数据）指令交换两个操作数内容 </p></blockquote><blockquote><p>mov和lea的区别</p><p>mov:当mov eax,[]表示将[]中地址存储的值存放到eax中，当然也可以直接mov地址到eax中，如mov eax,地址</p><p>lea:当lea eax,[]，表示将[]中的地址存放到eax中，相当于指针，主要是计算地址</p></blockquote><h1 id="002-abexcm5"><a href="#002-abexcm5" class="headerlink" title="002-abexcm5"></a>002-abexcm5</h1><p>首先先通过字符串引用定位到正确判断的位置</p><blockquote><p>调用函数前需要将参数压入堆栈中，并且靠前的参数后压入栈中</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964360285.png" alt="正确判断"></p><p>接下来可以按x寻找调用位置，红色框中的就是跳转的位置</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964520801.png" alt="调用位置"></p><p>再往上找比较函数</p><p>可以看到这里调用了cmp函数，而且压入了两个参数，第一个是真正的注册码，第二个是我们的输入</p><blockquote><p>cmp:比较两个操作数，根据相减结果来改变零标志位，结果为0时，零标志位为1（Z位）</p><p>当第一位小于第二位时，S位为1</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964586990.png" alt="比较函数"></p><p>寻找对注册码的操作</p><p>可以看到这里进行了两次拼接操作</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964780202.png" alt="两次拼接"></p><p>这个拼接的字符串是已知的，再看另一个</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964832766.png"></p><p>可以看到先通过GetVolumeInformationA获取驱动器信息，并生成字符串存储到aData4562Abex中，然后将字符串String2拼接到生成的字符串后</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964910270.png" alt="aData4562Abex操作"></p><p>接下来重点讲讲ds段寄存器和重要的操作数</p><blockquote><p>ds:[地址]就相当于ds:地址，而且取出的是里面的内容，然后进行加一，</p><p>dec dl是dl的值–，并且除了CF标志位，其他都会改变。</p><p>dec dl对ZF标志位的影响，jnz跳转的条件是ZF==0，当dl的值为0时，设置ZF=1；否则设置为0</p><p>而一开始mov dl,2就是初始化迭代的次数，那么从mov到jnz这一段就是一个循环。</p></blockquote><p>总的加密就是取出aData字符串的前四位进行两次+1</p><p>所以我们还原一下过程即可得到注册码，但是我不明白GetVolumeInformationA生成的字符串，所以动调了</p><p>最后注册码L2C-5781Fcvc4562-ABEX</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648965721476.png" alt="注册成功"></p><h1 id="003-Cruehead-CrackMe-3"><a href="#003-Cruehead-CrackMe-3" class="headerlink" title="003-Cruehead-CrackMe-3"></a>003-Cruehead-CrackMe-3</h1><p>运行时发现是未cracked的</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648979391664.png" alt="运行时"></p><p>了解到这是需要KEY文件才能正确crack的，我们从头开始分析</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648980725152.png" alt="CreateFileA"></p><pre class="language-c" data-language="c"><code class="language-c">HANDLE CreateFileA(  [in]           LPCSTR                lpFileName,  [in]           DWORD                 dwDesiredAccess,  [in]           DWORD                 dwShareMode,  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,  [in]           DWORD                 dwCreationDisposition,  [in]           DWORD                 dwFlagsAndAttributes,  [in, optional] HANDLE                hTemplateFile);</code></pre><p>具体参数参考<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea</a></p><p>注意压入栈的顺序即可，这里根据参数应该是打开CRACKME3.KEY文件，如果没有的话返回值设置为-1</p><blockquote><p>返回值一般存储在eax寄存器中</p></blockquote><blockquote><p>CMP汇编指令会修改ZF和CF标志寄存器，如果相同的话设置ZF为1，否则为0</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981137536.png" alt="跳转"></p><p>如果不相等，就跳转到401043，这里我们默认打开了</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981237587.png" alt="ReadFile"></p><p>可以看到先把0x12存入eax，把字符串地址放入ebx中</p><blockquote><p>offset存储的是字符串的地址</p></blockquote><p>接下来调用ReadFile读取文件内容，长度是0x12，位置是字符串地址存储的内容</p><pre class="language-c" data-language="c"><code class="language-c">BOOL ReadFile(    HANDLE hFile,            //文件的句柄    LPVOID lpBuffer,          //用于保存读入数据的一个缓冲区    DWORD nNumberOfBytesToRead,    //要读入的字节数    LPDWORD lpNumberOfBytesRead,    //指向实际读取字节数的指针    LPOVERLAPPED lpOverlapped    //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。    //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL);</code></pre><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981665617.png" alt="加密函数之一"></p><p>先来看加密函数的初始化操作</p><p>两个xor是将ecx和eax的值清空</p><p>将esp+arg_0存储的值赋值到esi中，也就是读取字符串的地址</p><blockquote><p>这里可以看到arg_0=DWORD 4，esp+4就是我们压入栈中的参数，因为call会让ESP往低地址移动</p></blockquote><p>再将0x41赋值给bl</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981700071.png" alt="初始化操作"></p><p>接下来看加密的操作，首先先将esi的存储的值看作地址，取出里面的内容放到al中，再将al异或上bl的值，再存放回原来的地址</p><blockquote><p>inc实现的是自增1</p></blockquote><p>esi存放的是地址，+1就相当于指针后移</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981955860.png" alt="加密操作"></p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982311802.png" alt="指针移动"></p><p>然后将异或后的结果加到ds:dword_4020F9存储的内容中</p><p>判断al的值是否为0，如果是的话，跳转到</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982477054.png" alt="当al为0时跳转的地址"></p><p>接着就是cl++，然后判断bl的值是否为0x4F，因为初始时bl的值为0x41，所以加密数据的长度是0x4f-0x41</p><p>最后，函数loc_401335结束前把ecx的值存放到ds段寄存器地址的内容中</p><p>因为异或后相加的结果存储在dword_4020F9中，这里将它和0x12345678异或</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982757718.png"></p><blockquote><p>add esp,4是因为call的时候将其下一条指令压入栈中，所以需要add esp,4</p></blockquote><p>接下来又将我们加密后的内容压入栈，进行下一个函数的操作</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983002897.png" alt="第二轮操作"></p><p>先把esp+4存储的内容也就是存储字符串的首地址存放到esi中，然后esi+0xE，也就是地址后移0xE，再将其存储的值放入eax中，0x12-0xE=4，也就是将最后四个存放到eax寄存器中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983018786.png" alt="第二轮操作"></p><p>将最后四位与dword_4020F9，也就是刚才和0x12345678异或后的值比较</p><blockquote><p>setz al；如果ZF=1，则设置目标数为1，否则则为0</p><p>test al,al;如果al&amp;al==0，也就是al的值为0，那么ZF会被设置为1，否则则为0</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983201869.png" alt="比较"></p><p>接下来是一些创建窗口和弹出窗口的代码</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983983571.png" alt="窗口代码"></p><p>看一下成功的部分代码</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984022368.png" alt="成功部分"></p><p>主要看一下这个</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984126580.png" alt="移动字符串"></p><blockquote><p> 即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。 </p></blockquote><p>先把DWORD_402149，也就是前面说的加密的长度</p><p>也就是先把传入的两个参数的地址分别存入esi和edi中</p><p>而第一个参数也就是arg_0(后压入栈)，被存放到esi中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984644479.png"></p><p>同时，第一个参数也是前面存放我们字符串的地址</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984708951.png"></p><p>然后edi指向的地址后移</p><p>再循环将esi的值存入edi中，循环次数为ecx的值</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984226522.png"></p><p>这段话就是将我们最后加密的字符串拼接到Cracked By:后面</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>先打开CRACKME3.KEY文件，读取前十八个字符，然后对前14个字符异或加密，并且将异或后的值和0x12345678异或后与最后四位进行比较，前十四个密文为<a href="mailto:wanao@yahoo.cn">wanao@yahoo.cn</a>，然后动调得到最后四位字符，填充进去即可，注意大小端序</p><p>前十四位字符脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char name[]="wanao@yahoo.cn";char key='A';int num=0;for(int i=0;i&lt;strlen(name);++i){name[i]^=key++;num+=name[i];}printf("%s\n",name);printf("%d\n",num);int key2=0x12345678;return 0; } </code></pre><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985143096.png" alt="最后四位字符"></p><p>最终效果</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985203991.png"></p><h1 id="004-Acid-Bytes-2"><a href="#004-Acid-Bytes-2" class="headerlink" title="004-Acid Bytes.2"></a>004-Acid Bytes.2</h1><p>upx壳，去掉后很快就能找到比较</p><h1 id="006-ArturDents-CrackMe-2"><a href="#006-ArturDents-CrackMe-2" class="headerlink" title="006-ArturDents-CrackMe#2"></a>006-ArturDents-CrackMe#2</h1><p>先找到成功的函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033728711.png" alt="验证正确的函数"></p><p>然后找到关键比较</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033782005.png" alt="关键函数和跳转"></p><p>根据程序运行知道我们需要输入name和序列号，找到获取输入的函数</p><pre class="language-c" data-language="c"><code class="language-c">UINT GetDlgItemTextA(  [in]  HWND  hDlg,  [in]  int   nIDDlgItem,  [out] LPSTR lpString,  [in]  int   cchMax);//返回值是字符串的长度</code></pre><p>lpstring就是我们的输入</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034100647.png" alt="关键函数"></p><p>箭头处可以看到cmp esi,5，而前面将函数的返回值也就是eax的值存储到esi中，所以这是长度比较，可以看到jge下一段是说name长度必须大于5。</p><p>再看下面红色框，获取我们的输入密码后，将input和password的地址存放到eax和ebx中，再把esi也就是name的长度存入ecx中</p><p>看加密函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034490927.png" alt="关键加密函数"></p><p>先把eax存储的值取出，然后减去cl的值，再与ebx存放的值作比较</p><p>下面那个跳转是跳转到离开的函数</p><p>inc是自增，也就是让寄存器指向password和input下一个字符</p><blockquote><pre class="language-c" data-language="c"><code class="language-c">    mov cx, 循环的次数 (当遇到Loop标号时 cx就代表循环的次数)标号: (标明后面就是需要循环的循环体)    循环执行的程序代码    Loop 标号//注意：每执行一次loop，ecx的值都会减1</code></pre></blockquote><p>每执行一次loop，ecx的值都会减1</p><p>所以注意这一点即可</p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>name为99999，序列号为45678即可满足</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034817650.png" alt="成功"></p><h1 id="007-reg"><a href="#007-reg" class="headerlink" title="007-reg"></a>007-reg</h1><p>这是一个共享软件，打开时需要我们输入UserName和SN，然后生成reg.dll，再打开软件验证。</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040536751.png" alt="reg.dll内容"></p><p>先定位到关键的字符串</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040650078.png" alt="关键字符串"></p><p>定位过去</p><p>可以看到先把字符串也就是reg.dll移动到eax中，然后call，再对al进行验证，所以这个函数应该是打开这个文件，没有这个文件的话就返回0</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040684329.png"></p><p>接下来这一段应该是将dll文件的username和sn读取出来</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040844910.png" alt="读取函数"></p><p>可以看到先把刚才读取的username和sn存放到edx和eax中，然后调用函数，调用结束后进行test和跳转，所以这个函数应该是加密函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040977142.png" alt="加密函数"></p><p>加密函数中，先将变量的值清0，并且将username和sn存放到第一个和第二个参数中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041483499.png"></p><p>往下看，这里先把第二个参数（序列号）的地址读取到eax中，然后返回值和0x10作比较，那么这段应该就是计算序列号的长度</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041704450.png" alt="关键比较"></p><p>在函数出事的地方，可以看到var_8=-8，然后ebp-8就是存放的序列号</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042026513.png" alt="计算位置"></p><p>看一下函数调用的堆栈图，EBP+x就是压入的参数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042190963.png" alt="堆栈图"></p><p>下面这一段应该是对序列号验证，因为sub会让标志寄存器改变</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042492337.png" alt="验证"></p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042642683.png"></p><p>FTSP汇编指令</p><p><a href="https://blog.csdn.net/liujiayu2/article/details/77711838">https://blog.csdn.net/liujiayu2/article/details/77711838</a></p><p>最后在这里的堆栈图找到了正确的序列号，长度正好是0x10</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042753681.png"></p><p>先把两个参数存放的内容以及第三个参数也就是var_10的地址存储到ecx中，那么这个应该就是正确的序列号</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042840725.png" alt="在调用前面的函数前"></p><p>函数有点复杂，有时间再看，据说后面有md5</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649043390270.png" alt="ZF标志位"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00前言&quot;&gt;&lt;a href=&quot;#0x00前言&quot; class=&quot;headerlink&quot; title=&quot;0x00前言&quot;&gt;&lt;/a&gt;0x00前言&lt;/h1&gt;&lt;p&gt;因为汇编太水了，所以决定做一下CrackMe练习，可能不会一直弄，精力有限&lt;/p&gt;
&lt;h1 id=&quot;0x01</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://gift1a.github.io/2022/03/31/C/"/>
    <id>https://gift1a.github.io/2022/03/31/C/</id>
    <published>2022-03-31T06:08:13.000Z</published>
    <updated>2022-04-01T05:54:55.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类-this指针"><a href="#C-类-this指针" class="headerlink" title="C++类-this指针"></a>C++类-this指针</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>C语言中，结构体作为函数参数时传参传的是副本，而数组传递的是指针，所以我们将结构体作为参数时，最好传入指针</p><p>封装-就是将函数放入结构体内部，每次调用函数都会传递当前结构体的首地址，这样我们使用里面的变量就会比较方便</p><p>类-这个结构体就叫做类，在结构体插入函数时，结构体大小不变，因为函数不在结构体内部，可以看到sizeoftest=8，也就是两个int</p><p><img src="/2022/03/31/C/1648776748495.png"></p><p>对象-当使用使用类型创建变量时，创建的名称就叫做对象，比如Base base，Base是类，那么base就叫做对象</p><p>成员-里面的参数都是成员</p><p>成员函数-顾名思义，结构体中函数类型的成员</p><p><img src="/2022/03/31/C/1648776093255.png" alt="成员、类、对象"></p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>在反汇编中，调用类中的函数之前会先把结构体对象的首地址传入ecx中，ecx存放的值就是this指针，我们可以通过它来使用结构体成员，this-&gt;x,this-&gt;y(在类的函数中)，当函数参数和结构体变量同名时，使用this可以帮助编译器区分</p><p><img src="/2022/03/31/C/1648776666723.png" alt="调用类方法时的初始化操作"></p><p>我们知道指针可以进行加法减法操作，但是this指针不能进行这些操作，编译器不允许</p><h1 id="继承-构造-析构函数"><a href="#继承-构造-析构函数" class="headerlink" title="继承 构造-析构函数"></a>继承 构造-析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先他是个函数，其次他没有返回值，第三他跟当前的类名是完全一样的</p><p>他跟成员函数不同，他是在创建对象的时候使用的</p><p>作用：通过构造函数，在创建对象的同时给成员赋值</p><p><img src="/2022/03/31/C/1648776892810.png" alt="使用构造函数初始化"></p><p>注意事项：构造函数不是一定要有的，但是定义了构造函数就一定要使用，否则会报错</p><p>重载构造函数：多个构造函数，但是构造函数的参数个数不能一样</p><blockquote><p>只要函数的参数个数或者参数类型不一样，就可以存在多个同名函数，这些函数就是重载函数-成员函数</p></blockquote><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>不是必须提供的</p><p>在类中，当我们malloc时，在堆中开辟空间，但是堆中的空间使用完一般要释放，而我们无法知道什么时候才可以释放掉这个堆的空间-因为其他函数可能会继续使用。</p><p>但是，当对象不再使用的时候（对象为局部变量时），堆就可以释放掉了</p><p>析构函数-无需调用、不能重载、名字与类名相同并在其之前加个~</p><pre class="language-c" data-language="c"><code class="language-c">~Persion(){ free(arr);}</code></pre><p><img src="/2022/03/31/C/1648777636920.png"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>本质是数据的复制</p><p>当在多个结构体存在相同的成员时，我们可以将相同的成员提取出来创建一个新的结构体，在使用时只需要</p><pre class="language-c" data-language="c"><code class="language-c">struct persion{int age;int sex;}struct student:persion{int grade;int count;}struct teacher:persion{int level;int p;}teacher s；student t;</code></pre><p>上面的代码在teacher和student结构体都有四个成员，相同成员有两个</p><p><img src="/2022/03/31/C/1648778055143.png" alt="相同部分"></p><p><img src="/2022/03/31/C/1648778255917.png" alt="修改后以及Student结构体大小"></p><p>1、Persion称为父类或者基类</p><p>2、teacher、student称为子类或者派生类</p><p>3、s、t称为对象或者实例</p><p>4、可以用父类的指针指向子类的对象</p><p>示例：</p><pre class="language-none"><code class="language-none">persion*pt=&amp;t;</code></pre><p><img src="/2022/03/31/C/1648713557915.png" alt="子、父类关系"></p><p>所以我们取得子类对象地址，就可以通过其来访问父类成员，但是不能访问子类成员，因为是Persion类型的指针</p><p><img src="/2022/03/31/C/1648778654017.png" alt="通过子类访问父类"></p><p>但是不能用子类指针指向父类对象</p><p>会一直往上继承父类</p><p><img src="/2022/03/31/C/1648714159618.png" alt="多重继承"></p><p>当多重继承出现相同的名称是，需要告诉编译器是谁的a，z.x::a,z.y::a​</p><p>可以同时继承两个父类</p><h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><blockquote><p>在类中，如果我们将函数写入会让类变得十分庞大，所以可以在类中进行函数声明，然后再去类外实现，但是我们需要告诉编译器，该函数属于谁，就需要用到 void 类名::函数名(函数参数)</p></blockquote><p><img src="/2022/03/31/C/1648777822123.png" alt="函数声明"></p><h2 id="public和private"><a href="#public和private" class="headerlink" title="public和private"></a>public和private</h2><p>存储的地方没变，只是告诉编译器不能直接访问private</p><p>可以修饰函数也可以修饰变量</p><p>public是指该成员在哪里都可以使用，不用担心被修改，所以一旦发布成public成员，是不能修改名字的。而private这个成员只用于内部使用，不要在其他地方使用</p><p>一般不想被外部访问的或者以后还会修改的就发布为private</p><p>常见的类的定义应该是把变量设为private，将修改private的方法-也就是函数发布为public，并在其中加入一定的限制</p><p>使用指针可访问private成员</p><p><img src="/2022/03/31/C/1648786703451.png" alt="class"></p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class和struct的不同是权限不一样，class默认为private，struct则为public，注意class的构造函数也需要声明为public</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>如果按照struct的格式进行继承，编译器会修改成员属性为private，所以如果需要访问，需要在继承时使用:public 父类名​​，可以看到我们只能继承public类的，一旦修改为private就会报错</p><p><img src="/2022/03/31/C/1648787335642.png" alt="父类继承"></p><p>private成员只能在当前类被使用，不能被继承</p><blockquote><p>编译器会默认生成构造函数，如果存在继承关系，他会先调用父类的构造函数，因为父辈的内容也需要初始化</p></blockquote><p><img src="/2022/03/31/C/1648792481902.png" alt="子类父类构造函数执行顺序"></p><p>我们可以先得到子类的地址，然后访问，即使父类的成员是private，也会被复制过来，只是不能直接访问，下面可以看到这是3个int的大小</p><p><img src="/2022/03/31/C/1648791796705.png"></p><p>但是我们可以知道子类的地址，然后通过指针访问私有的父类</p><p><img src="/2022/03/31/C/1648792223939.png" alt="指针访问私有父类"></p><h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-类-this指针&quot;&gt;&lt;a href=&quot;#C-类-this指针&quot; class=&quot;headerlink&quot; title=&quot;C++类-this指针&quot;&gt;&lt;/a&gt;C++类-this指针&lt;/h1&gt;&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AES-C语言实现</title>
    <link href="https://gift1a.github.io/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-29T06:57:00.000Z</published>
    <updated>2022-03-31T07:25:44.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://ppppz.net/2022/01/31/AES-P-Z/">https://ppppz.net/2022/01/31/AES-P-Z/</a></p><p>无论是实现还是debug的时候都离不开大佬的博客</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>实现的时候发现没学完整，导致中间实现的时候出现了问题，代码写的有点丑，我自己都看不下去了（</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;//用于字节代换的S盒static const int S[16][16] ={0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};//用于列混合乘法的表static int colM[4][4]{2,3,1,1,1,2,3,1,1,1,2,3,3,1,1,2};//密钥扩展存储的w表int w[44]={0};int round_const[10] = {0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1B000000,0x36000000};int CharToInt(char* key){int a[4] = { 0 };a[0] = (int) * key &lt;&lt; 24;a[1] = (int) * (key + 1) &lt;&lt; 16;a[2] = (int) * (key + 2) &lt;&lt; 8;a[3] = (int) * (key + 3);return a[0] | a[1] | a[2] | a[3];}int GetWordFromStr(char* key){int tmp=0;//因为最后返回的是一个整型，而我们传入的是四个字节，所以要先转为tmp = CharToInt(key);return tmp;}void IntToArray(int w, int* array){array[0] = (w &gt;&gt; 24)&amp;0xff;array[1] = (w &gt;&gt; 16)&amp;0xff;array[2] = (w &gt;&gt; 8) &amp; 0xff;array[3] = w &amp; 0xff;return ;}void ByteLeftMove(int* array){int tmp = array[0];for (int i = 0; i &lt; 3; ++i){array[i] = array[i + 1];}array[3] = tmp;return;}int ByteChange(int byte){int left = (byte &amp; 0xF0) &gt;&gt; 4;int right = (byte &amp; 0xF);return S[left][right];}int ArrayToInt(int* temp){int one = temp[0] &lt;&lt; 24;int two = temp[1] &lt;&lt; 16;int three = temp[2] &lt;&lt; 8;int four = temp[3];return one | two | three | four;}int T(int w, int round){int temp[4] = { 0 };IntToArray(w, temp);//先把int型的w转为数组，方便进行字循环操作ByteLeftMove(temp);//字节代换，此时需要用到S表for (int i = 0; i &lt; 4; ++i){temp[i]=ByteChange(temp[i]);}//轮常量异或，为了方便异或，先把数组转为int整型w=ArrayToInt(temp);w ^= round_const[round];return w;}void ExtendKey(char* key){//先生成一个子表，在此基础上扩展-子密钥初始化for (int i = 0; i &lt; 4; ++i){w[i] = GetWordFromStr(key + i * 4);//每四个字节生成一个w数组的元素，便于待会异或}//密钥扩展for (int i = 4,j=0; i &lt; 44; ++i){if (i % 4 == 0)//根据是否是4的整数倍，进行操作{//j表示轮数，因为最终为10轮，所以只要是4的倍数就需要+1w[i] = w[i - 4] ^ T(w[i - 1], j);j++;}elsew[i] = w[i - 4] ^ w[i - 1];}return;}void PlainToMatrix(char* Plain, int array[4][4]){//矩阵 存放和二维数组不同，这里需要注意一下int k = 0;for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[j][i] = Plain[k++];}}return;}void w_To_matrix(int array[4][4]){//先把每个w转为数组，然后再依次赋值给二维数组for (int i = 0; i &lt; 4; ++i){int w_temp[4];//使用临时数组存放w的值IntToArray(w[i],w_temp);for (int j = 0; j &lt; 4; ++j){array[j][i] = w_temp[j];}}return;}void Matrix_Bytechange(int array[4][4]){for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[i][j]=ByteChange(array[i][j]);}}return;}//行移位void RowMove(int array[4][4]){//第二行往左移动一个字符int temp = array[1][0];for (int i = 0; i &lt; 3; ++i){array[1][i] = array[1][i + 1];}array[1][3] = temp;//第三行往左移动两个字符int temp2 = array[2][0];int temp3 = array[2][1];array[2][0] = array[2][2];array[2][1] = array[2][3];array[2][2] = temp2;array[2][3] = temp3;//第四行往左移动三个字符,相当于往右移动一位int temp4 = array[3][3];for (int i = 3; i &gt;= 0; --i){array[3][i] = array[3][i - 1];}array[3][0] = temp4;return;}unsigned char XTIME(unsigned char x){return ((x &lt;&lt; 1) ^ ((x &amp; 0x80) ? 0x1b : 0x00));}//GF基于有限域上的运算int GFMul(int a, int b){unsigned char temp[8] = { a };unsigned char tempmultiply = 0x00;int i = 0;for (i = 1; i &lt; 8; i++){temp[i] = XTIME(temp[i - 1]);}tempmultiply = (b &amp; 0x01) * a;for (i = 1; i &lt;= 7; i++){tempmultiply ^= (((b &gt;&gt; i) &amp; 0x01) * temp[i]);}return tempmultiply;}//列混合void Line_Change(int array[4][4]){//这里需要用到列混合异或的表colMint temparray[4][4] = { 0 };for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){temparray[i][j] = array[i][j];}}//列混合的矩阵计算方式不同for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[i][j] = GFMul(colM[i][0], temparray[0][j]) ^GFMul(colM[i][1], temparray[1][j]) ^GFMul(colM[i][2], temparray[2][j]) ^GFMul(colM[i][3], temparray[3][j]);}}return;}//将矩阵的每一列转为整型int Matrix_ArraytoInt(int one, int two, int three, int four){one &lt;&lt;= 24;two &lt;&lt;= 16;three &lt;&lt;= 8;return one | two | three | four;}//将加密后的每一个整型还原到矩阵的每一列int Restore_Matrix(int temp,int num){switch(num){case 0:return temp &gt;&gt; 24;case 1:return temp &gt;&gt; 16;case 2:return temp &gt;&gt; 8;case 3:return temp;}}//轮密钥加void AddRoundKey(int array[4][4], int round){//对每一轮都要进行异或操作,为了方便异或操作，先转为整型int temp[4] = { 0 };//待会可以直接和w[round]异或，四轮for (int i = 0; i &lt; 4; ++i){IntToArray(w[round * 4 + i], temp);for (int j = 0; j &lt; 4; ++j){array[j][i] ^= temp[j];}}return;}//最终轮void FinalRound(int matrix[4][4]){Matrix_Bytechange(matrix);//行移位RowMove(matrix);//轮密钥加，注意是对应轮数的密钥AddRoundKey(matrix, 10);return;}//将矩阵还原到字符串void MatrixToPlain(char* String, int array[4][4]){int k = 0;for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){String[k++] = array[j][i];}}//字符串以'\0'结尾String[k] = 0;}void AES_Encode(char* p, int plen, char* key){//先判断明文长度是否为16的倍数，判断密钥是否为16个字节int Text_len = strlen(p);if (strlen(p) % plen != 0){printf("长度出错，明文长度需为十六的倍数");exit(0);}//密钥长度if (strlen(key) != 16){printf("密钥长度出错，密钥长度必须为十六个字节");}//密钥扩展，通过子密钥生成ExtendKey(key);//下面进行初始变换，先把明文放入矩阵中，再与第0轮的密钥进行对应位置的逐字节异或int matrix[4][4] = { 0 };for (int k = 0; k &lt; plen; k += 16){PlainToMatrix(p+k, matrix);//明文矩阵和密钥矩阵进行轮密钥加，也就是逐字节异或AddRoundKey(matrix,0);  //问题//进行九轮相同的加密for (int i = 1; i &lt; 10; ++i){//字节代换Matrix_Bytechange(matrix);//行移位RowMove(matrix);//列混合Line_Change(matrix);//轮密钥加，注意是对应轮数的密钥AddRoundKey(matrix, i);}FinalRound(matrix);//最后还要把矩阵还原为字符串MatrixToPlain(p+k, matrix);}}int main(){char key[] = "ABCDEFGHIJKLMNOP";char PlainText[] = "ABCDEFGHIJKLMNOP";AES_Encode(PlainText, 16, key);printf("加密后的密文为:");for (int i = 0; i &lt; strlen(PlainText); ++i){printf("0x%X,",PlainText[i]&amp;0xff);}return 0;}</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>看完AES的代码，做点AES的题巩固一下</p><h2 id="GWCTF2019-re3"><a href="#GWCTF2019-re3" class="headerlink" title="GWCTF2019-re3"></a>GWCTF2019-re3</h2><h3 id="考点-SMC、AES"><a href="#考点-SMC、AES" class="headerlink" title="考点-SMC、AES"></a>考点-SMC、AES</h3><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>这一段是SMC的解密代码，加上前面的mprotect名称，也可以大致确定，动调跑一下即可</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542144906.png" alt="SMC"></p><p>init_key函数</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542218644.png"></p><p>看到了各种table，开始不知道是什么，但是不影响，因为并没有对我们的输入进行处理，到后面可以知道这是个生成密钥的函数</p><p> <img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/IVT%7DV%7DA4I1PSHR2NX%60EP_F.png" alt="key_generate"> </p><p>刚好长度为16，对应AES的密钥长度</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542330250.png" alt="encode函数"></p><p>可以看到中间有三个函数，最后的循环对加密后的数据进行比较</p><p>而三个函数中，有两个是一样的，这是因为将我们32长度的flag分成了两段进行加密，因为这是128bits的AES加密</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542489870.png" alt="key_add"></p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542517975.png" alt="key_add"></p><p>对比AES的w表生成方式，不难看出这一段是生成w表，不过有点不同，因为我们是在矩阵中进行，并且每一次将一个w元素转为int型，倒是+0x3FFFFFFF那段不知道什么意思，网上说是无穷大的数，这里不是很影响我们的分析，就不纠结了</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542810371.png" alt="AES_Encode"></p><p>可以看出这里就是加密过程，因为先进行第0轮的轮密钥加</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542901636.png" alt="Add_Round_Key"></p><p>然后进行字节替换</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542937639.png" alt="ByteReplace"></p><p>行移位，中间有很多暂时变量，然后实现互换</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542961376.png" alt="RowMov"></p><p>列混合</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648543006962.png" alt="MixLine"></p><p>重复进行9轮，最后进行第十轮（不包括列混合）</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648543079057.png" alt="第十轮"></p><p>至此key和密文都有了，解密</p><p> <img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/GN37@K06OO18H7U6%5DX8W%5DYY.png"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://ppppz.net/2022/01/31/AES-P-Z/&quot;&gt;https://ppppz.</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>反调试大杂烩</title>
    <link href="https://gift1a.github.io/2022/03/27/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
    <id>https://gift1a.github.io/2022/03/27/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%A4%A7%E6%9D%82%E7%83%A9/</id>
    <published>2022-03-27T07:09:14.000Z</published>
    <updated>2022-03-27T07:20:58.359Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/example/">https://ctf-wiki.org/reverse/windows/anti-debug/example/</a> </p><p><a href="https://anti-debug.checkpoint.com/techniques/assembly.html">https://anti-debug.checkpoint.com/techniques/assembly.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://ctf-wiki.org/reverse/windows/anti-debug/example/&quot;&gt;https://ctf-wiki.org/reverse/windows/anti-debug/example/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>压缩壳的学习</title>
    <link href="https://gift1a.github.io/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-03-26T08:00:50.000Z</published>
    <updated>2022-03-27T06:57:50.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/iBinary/p/7764483.html">https://www.cnblogs.com/iBinary/p/7764483.html</a></p><p><a href="https://bbs.pediy.com/thread-265766.htm">https://bbs.pediy.com/thread-265766.htm</a></p><p><a href="https://www.52pojie.cn/thread-727090-1-1.html">https://www.52pojie.cn/thread-727090-1-1.html</a></p><p>upx源码</p><p><a href="https://www.cnblogs.com/ichunqiu/p/7245329.html">https://www.cnblogs.com/ichunqiu/p/7245329.html</a></p><h1 id="壳的介绍"><a href="#壳的介绍" class="headerlink" title="壳的介绍"></a>壳的介绍</h1><p>壳根据不同可以分成压缩壳、加密壳、其他</p><h2 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h2><p>压缩壳，顾名思义，就是让程序变小，但是程序执行是没有问题的，主要有UPX和Aspack等</p><h2 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h2><p>加密壳就是为了保护程序而设计的，主要用于商业程序，主要有ASProtect、Armadillo、EXECryptor、Themida</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>主要是一些病毒的壳</p><h1 id="UPX压缩壳"><a href="#UPX压缩壳" class="headerlink" title="UPX压缩壳"></a>UPX压缩壳</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>压缩能让我们程序的体积变小，就类似于123456使用%x替换，672324ADB使用%C替换，这样程序代码体积就变小了</p><p>压缩壳的工作原理首先在程序开头或者其他合适的地方插入一段代码（包括解压缩的代码），然后再将程序的其他地方进行压缩</p><p>压缩的数据主要是PE文件的节的数据</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/vv0bcog94g.png" alt="压缩"></p><p>当程序执行时，实现对程序的解压缩，所以不会影响程序的执行</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344699085.png" alt="正常程序"></p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344795798.png" alt="加壳后的程序"></p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344833463.png" alt="程序解压缩"></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/v3o2hqc77w.png"></p><p>因为程序需要解压缩，但是原来的节的位置已经被占据，那么壳是怎么恢复数据的呢</p><p>首先我们知道原PE的节的个数以及大小，那么此时我们生成的新的带壳PE，则会获得大小。然后在其带壳PE的下面申请怎么大小的节用来占位置即可，也就是说运行时，shell会进行偏移，不会占用解压缩的节的位置</p><p>那么此时我们解压的数据，则会写到我们占位置的地方。</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/wbx7n8dg8k.png"></p><h1 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h1><h2 id="1、保存入口参数"><a href="#1、保存入口参数" class="headerlink" title="1、保存入口参数"></a>1、保存入口参数</h2><p>加壳程序在初始化时会保存各寄存器的值，等到外壳执行完毕，再恢复各个寄存器的值，最后跳转到原程序执行。通常使用Push ad/pop ad、pushfd/popfd指令来保存和恢复现场</p><h2 id="2、获取壳本身需要使用的API地址"><a href="#2、获取壳本身需要使用的API地址" class="headerlink" title="2、获取壳本身需要使用的API地址"></a>2、获取壳本身需要使用的API地址</h2><p>在一般情况下，外壳的输入表只有GetProcAddress、GetModuleHandle和LoadLibary这三个API函数，甚至只有Kernel32.dll及GetProcAddress。如果需要使用其他API函数，可以通过LoadLibaryA或者LoadLibaryExA将DLL文件映像映射到调用进程的地址空间中，函数返回的HINSTANCE值用于标识文件映像所映射的虚拟内存地址。也就相当于DLL的基址</p><h3 id="LoadLibrary函数"><a href="#LoadLibrary函数" class="headerlink" title="LoadLibrary函数"></a>LoadLibrary函数</h3><p>原型如下</p><pre class="language-c" data-language="c"><code class="language-c">HINSTANCE LoadLibary{LPCTSTR lpLibFIlenam;//DLL文件名地址}</code></pre><p>返回值：成功则返回模块的句柄，失败则返回”NULL”。</p><h2 id="GetModuleHandle函数"><a href="#GetModuleHandle函数" class="headerlink" title="GetModuleHandle函数"></a>GetModuleHandle函数</h2><p>如果DLL文件已被映射到调用进程的地址空间中，可以调用GetModuleHandleA函数获取DLL模块的句柄，函数原型如下</p><pre class="language-c" data-language="c"><code class="language-c">HMODULE GetModuleHandle{LPCTSTR lpModuleName//DLL文件名地址}</code></pre><h2 id="GetProcAddress函数"><a href="#GetProcAddress函数" class="headerlink" title="GetProcAddress函数"></a>GetProcAddress函数</h2><p>一旦DLL模块被加载，线程就可以调用GetProcAddress函数来获取输入函数的地址了，该函数原型如下</p><pre class="language-c" data-language="c"><code class="language-c">FARPROC GetProcAddress{HMODULE hModule,//DLL模块句柄LPCSTR lpProName //函数名}</code></pre><p>但是有些壳为了提高强度，不使用系统提供的GetProcAddress函数，而是自己编写函数来替代这个API函数，以提高函数调用的隐蔽性</p><h2 id="3、解密原程序的各个区块的数据"><a href="#3、解密原程序的各个区块的数据" class="headerlink" title="3、解密原程序的各个区块的数据"></a>3、解密原程序的各个区块的数据</h2><p>为了保护原程序代码和数据，壳一般会加密原程序文件的各个区块。在执行时进行解密，因为壳一般是按区块进行加密的，所以在解密的时候也是按照区块解密的，并且将解密的区块数据按照区块的定义放入内存中合适的位置</p><h2 id="4、IAT的初始化"><a href="#4、IAT的初始化" class="headerlink" title="4、IAT的初始化"></a>4、IAT的初始化</h2><p>IAT的填写本来是由 PE装载器实现，但是由于在加壳时构造了一个自建输入表，并且让PE文件头数据目录表的输入表指针指向新建的输入表，PE装载器就会对自建输入表进行填写。而程序的原始输入表被被外壳变形后储存，所以IAT表的填写需要外壳程序来实现。外壳需要做的就是将这个变形输入表从头到尾扫描一遍，重新获取每一个DLL引入的所有函数的地址，并将其填写在IAT表中</p><h2 id="5、重定位项的处理"><a href="#5、重定位项的处理" class="headerlink" title="5、重定位项的处理"></a>5、重定位项的处理</h2><p>对于EXE文件，Windows会尽量满足其需求。比如EXE文件的基址一般是4000000h，那么加载到内存中就是4000000，这种情况下就不需要进行重定位。</p><p>但是对DLL就不一样了，因为Windows系统没办法保证每次运行时都提供相同的基地址，所以需要重定位，所以加壳的DLL一般会多一个重定位表</p><h2 id="6、Hook-API"><a href="#6、Hook-API" class="headerlink" title="6、Hook API"></a>6、Hook API</h2><p>在程序文件中，输入表的作用是让windows操作系统在程序运行时将API的实际地址提供给程序使用。在程序第一行代码被执行前，Windows操作系统就完成了这个操作。</p><p>而壳大多在修改原程序文件的输入表之后自己模仿Windows操作系统的工作流程，向输入表填充相关数据，在填充过程中，外壳可以Hook API代码的地址，从而间接获得程序的控制权</p><h2 id="7、跳转到原程序入口-OEP"><a href="#7、跳转到原程序入口-OEP" class="headerlink" title="7、跳转到原程序入口-OEP"></a>7、跳转到原程序入口-OEP</h2><p>从这个时候开始，壳将控制权还给原程序</p><h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p>引用了别人的图，看起来比较清晰，不过这个是x64下的</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/842206_VKJXADJYNEQVSUQ.jpg"></p><p>可以发现在磁盘文件中，upx0是不存在的，使用工具也可以看到</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648358178362.png"></p><p>但是看UPX1的VirtualAddress可以知道这两个节中间有很大的空余区域，这些区域是存放解压缩后的原程序数据的</p><h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>这里以UPX壳为例</p><p>首先我们知道压缩壳会修改程序入口，拖进OD发现断在了push ad</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648345714976.png"></p><h2 id="寻找OEP"><a href="#寻找OEP" class="headerlink" title="寻找OEP"></a>寻找OEP</h2><h3 id="根据跨段指令寻找OEP"><a href="#根据跨段指令寻找OEP" class="headerlink" title="根据跨段指令寻找OEP"></a>根据跨段指令寻找OEP</h3><p><a href="https://www.cnblogs.com/dilex/p/5547241.html">https://www.cnblogs.com/dilex/p/5547241.html</a></p><p><a href="https://www.52pojie.cn/thread-294773-1-1.html">https://www.52pojie.cn/thread-294773-1-1.html</a></p><h3 id="用内存访问断点寻找OEP"><a href="#用内存访问断点寻找OEP" class="headerlink" title="用内存访问断点寻找OEP"></a>用内存访问断点寻找OEP</h3><p>先码着</p><p><a href="https://blog.csdn.net/jyk764717697/article/details/7306621?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;utm_relevant_index=1">https://blog.csdn.net/jyk764717697/article/details/7306621?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1</a></p><h3 id="根据栈平衡寻找OEP-ESP定律"><a href="#根据栈平衡寻找OEP-ESP定律" class="headerlink" title="根据栈平衡寻找OEP-ESP定律"></a>根据栈平衡寻找OEP-ESP定律</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>首先，我们知道壳相当于一个子程序，它在程序运行时首先获得控制权并对程序进行压缩，同时隐藏程序的OEP。</p><p>在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是一致的（主要是ESP、EBP等重要的寄存器）。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复现场环境。通常用的指令前面也介绍了。</p><p>在脱壳时，根据栈平衡原理（因为壳相当于子程序嘛，所以我们要保证壳运行完，将控制权交换程序的时候堆栈要平衡）对ESP下断，很快就能找到OEP</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>可以看到刚载入时断在了push ad，这时候我们F8</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361229454.png" alt="刚载入"></p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361410288.png" alt="F8前寄存器和堆栈"></p><p>F8之后，ESP发生改变，寄存器的值也被压入了栈中</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361564539.png" alt="F8之后"></p><p>对ESP下硬件访问断点</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361685665.png"></p><p>也可以现在右键ESP，在数据窗口跟随，然后选中前四个字节右键-&gt;断点-&gt;硬件访问-&gt;DWORD</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361790656.png" alt="数据窗口设置断点"></p><p>设置好断点后F9</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361835848.png" alt="F9之后"></p><p>然后一直单步到jmp</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361889146.png"></p><p>这里有个往上跳的，只需要在jnz下一行处按F4即可</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361978941.png" alt="jmp之后"></p><p>这时候已经到达OEP了，可以发现堆栈和刚载入时一样</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648362682513.png" alt="对比"></p><p>dump下来即可-&gt;右键-&gt;使用OllyDump脱壳调试进程即可</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648362058903.png" alt="Dump"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/iBinary/p/7764483.html&quot;&gt;https</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Gcc中在main前和后执行的函数</title>
    <link href="https://gift1a.github.io/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://gift1a.github.io/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2022-03-25T12:38:43.000Z</published>
    <updated>2022-04-06T01:38:09.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gcc在主函数前后运行的函数"><a href="#gcc在主函数前后运行的函数" class="headerlink" title="gcc在主函数前后运行的函数"></a>gcc在主函数前后运行的函数</h1><p>逆向的时候我们直到elf文件在start函数中有main函数、init和fini函数，init就是初始化，即在主函数前运行的函数，fini就是在主函数之后执行的函数</p><p><img src="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/1648278715009.png"></p><p>那么我们怎么实现呢，windows下我没找到好方法</p><p>但是linux下则可以，我们需要用到gcc编译器</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>gcc支持_<em>attribute_</em>((constructor)) void FunctionName()，这样这个函数就是在主函数运行前的函数，_<em>attribute_</em>((destructor)) void FunctionName{}是在主函数运行之后执行的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char string[]="123456";__attribute__((constructor)) void FunctionName(){printf("helloworld");}int main(){printf("%s",string);return 0;}</code></pre><p>效果</p><p><img src="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/1648279627114.png"></p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>我们可以定义全局变量的密钥，然后在init中修改密钥，进而阻碍他人的静态分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;gcc在主函数前后运行的函数&quot;&gt;&lt;a href=&quot;#gcc在主函数前后运行的函数&quot; class=&quot;headerlink&quot; title=&quot;gcc在主函数前后运行的函数&quot;&gt;&lt;/a&gt;gcc在主函数前后运行的函数&lt;/h1&gt;&lt;p&gt;逆向的时候我们直到elf文件在start函数</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://gift1a.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Vim编辑器使用</title>
    <link href="https://gift1a.github.io/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://gift1a.github.io/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2022-03-25T08:24:35.000Z</published>
    <updated>2022-03-26T07:57:43.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vim键盘图"><a href="#Vim键盘图" class="headerlink" title="Vim键盘图"></a>Vim键盘图</h1><p><img src="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/1648206284939.png" alt="Vim键盘图"></p><h1 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h1><p>vim分成三种模式，分别是命令模式、输入模式、底线命令模式</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>用户刚进入vim，便进入命令模式</p><p>这时我们敲击键盘的动作被识别为命令</p><p>以下是常用的几个命令</p><p>i：进入输入模式</p><p>x：删除当前光标所在处的字符</p><p>：：切换到底线命令模式，这样我们就可以在最底一行输入命令</p><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>1、字符按键和shift组合：输入字符</p><p>2、ENTER：回车键，换行</p><p>3、BaceSpace：退格键，删除光标前一个字符</p><p>4、DEL：删除键，删除光标后一个字符</p><p>5、方向键：移动光标</p><p>6、HOME/END：移动光标到行首、行尾</p><p>7、Page Up/Page Down：上/下翻页</p><p>8、Insert： 切换光标为输入/替换模式，光标将变成竖线/下划线 </p><p>9、 退出输入模式，切换到命令模式 </p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>省略掉冒号的基本命令</p><p>1、q：退出程序</p><p>2、w：保存文件</p><p>3、命令末尾加上!表示强制执行</p><h1 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h1><p><a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p><p>vim复制粘贴-这里wo</p><p><a href="https://www.cnblogs.com/huahuayu/p/12235242.html">https://www.cnblogs.com/huahuayu/p/12235242.html</a></p><p>Vim配置</p><p><a href="https://blog.csdn.net/Doctor_xiong/article/details/78663590">https://blog.csdn.net/Doctor_xiong/article/details/78663590</a></p><h1 id="GCC生成可执行文件"><a href="#GCC生成可执行文件" class="headerlink" title="GCC生成可执行文件"></a>GCC生成可执行文件</h1><h2 id="Vim生成-c文件"><a href="#Vim生成-c文件" class="headerlink" title="Vim生成.c文件"></a>Vim生成.c文件</h2><p>vim 文件名.c即可生成.c文件</p><h2 id="GCC编译成可执行文件"><a href="#GCC编译成可执行文件" class="headerlink" title="GCC编译成可执行文件"></a>GCC编译成可执行文件</h2><p>gcc 文件名.c -o 输入文件名</p><p><img src="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/1648209669071.png"></p><h1 id="Vim复制和粘贴"><a href="#Vim复制和粘贴" class="headerlink" title="Vim复制和粘贴"></a>Vim复制和粘贴</h1><p>这个链接解决了系统粘贴板和vim粘贴板的共通</p><p><a href="https://www.cnblogs.com/Biiigwang/p/12086514.html">https://www.cnblogs.com/Biiigwang/p/12086514.html</a></p><p>我们先把光标移动到我们需要复制数据的起始位置，然后在命令模式中按v进入可视模式，然后移动光标来选中，按v就可以实现复制，按p粘贴</p><h1 id="Vim的撤销与恢复撤销"><a href="#Vim的撤销与恢复撤销" class="headerlink" title="Vim的撤销与恢复撤销"></a>Vim的撤销与恢复撤销</h1><p>在命令模式中，我们按u可以撤销插入模式中的操作，而Ctrl+r可以恢复我们的撤销</p><h1 id="Vim直接编译C"><a href="#Vim直接编译C" class="headerlink" title="Vim直接编译C"></a>Vim直接编译C</h1><p>配置好之后按F5即可运行，并生成可执行文件</p><p><a href="https://blog.csdn.net/qq_33505303/article/details/66473907">https://blog.csdn.net/qq_33505303/article/details/66473907</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vim键盘图&quot;&gt;&lt;a href=&quot;#Vim键盘图&quot; class=&quot;headerlink&quot; title=&quot;Vim键盘图&quot;&gt;&lt;/a&gt;Vim键盘图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://gift1a.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>LLVM程序集</title>
    <link href="https://gift1a.github.io/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/"/>
    <id>https://gift1a.github.io/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/</id>
    <published>2022-03-24T10:36:01.000Z</published>
    <updated>2022-03-25T12:40:42.960Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h1><p>这里我没办法细讲，因为也是第一次接触，后续深入了解后再补</p><p><a href="https://www.1024sou.com/article/387833.html">https://www.1024sou.com/article/387833.html</a></p><p>clang常用编译命令</p><p><a href="https://blog.csdn.net/pc153262603/article/details/89553688">https://blog.csdn.net/pc153262603/article/details/89553688</a></p><p>指令集</p><p><a href="https://blog.csdn.net/qq_37206105/article/details/115274241">https://blog.csdn.net/qq_37206105/article/details/115274241</a></p><h1 id="LLVM程序集转为ELF可执行文件"><a href="#LLVM程序集转为ELF可执行文件" class="headerlink" title="LLVM程序集转为ELF可执行文件"></a>LLVM程序集转为ELF可执行文件</h1><p>打开附件发现有点难看懂，搜索其中一段指令集后发现是LLVM指令集</p><p><img src="/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/1648121627952.png"></p><h2 id="转为ELF可执行文件"><a href="#转为ELF可执行文件" class="headerlink" title="转为ELF可执行文件"></a>转为ELF可执行文件</h2><p> clang task.ll -mllvm -W -g -W1,-pie -o task.out </p><p>使用上面的命令即可生成elf文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习链接&quot;&gt;&lt;a href=&quot;#学习链接&quot; class=&quot;headerlink&quot; title=&quot;学习链接&quot;&gt;&lt;/a&gt;学习链接&lt;/h1&gt;&lt;p&gt;这里我没办法细讲，因为也是第一次接触，后续深入了解后再补&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.1024s</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>sha256</title>
    <link href="https://gift1a.github.io/2022/03/23/sha256/"/>
    <id>https://gift1a.github.io/2022/03/23/sha256/</id>
    <published>2022-03-23T11:15:53.000Z</published>
    <updated>2022-04-01T12:52:07.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/94619052">https://zhuanlan.zhihu.com/p/94619052</a></p><p><a href="https://www.52pojie.cn/forum.php">https://www.52pojie.cn/forum.php</a></p><h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="符号替换-使用函数"><a href="#符号替换-使用函数" class="headerlink" title="符号替换-使用函数"></a>符号替换-使用函数</h2><ul><li><img src="https://www.zhihu.com/equation?tex=%5Coplus" alt="[公式]">: 按位异或</li><li><img src="https://www.zhihu.com/equation?tex=%5Cwedge" alt="[公式]">: 按位与</li><li><img src="https://www.zhihu.com/equation?tex=%5Cvee" alt="[公式]">: 按位或</li><li><img src="https://www.zhihu.com/equation?tex=%5Clnot" alt="[公式]">: 补位</li><li><img src="https://www.zhihu.com/equation?tex=+" alt="[公式]">: 相加以后对<img src="https://www.zhihu.com/equation?tex=2%5E%7B32%7D" alt="[公式]">求余</li><li><img src="https://www.zhihu.com/equation?tex=R%5En" alt="[公式]">: 右移n位</li><li><img src="https://www.zhihu.com/equation?tex=S%5En" alt="[公式]">: 循环右移n位</li></ul><p> <img src="/2022/03/23/sha256/equation-1648645011885.svg" alt="使用到的函数"> </p><h2 id="消息预处理"><a href="#消息预处理" class="headerlink" title="消息预处理"></a>消息预处理</h2><h3 id="消息补位"><a href="#消息补位" class="headerlink" title="消息补位"></a>消息补位</h3><p>先对消息摘要实现补码，假设消息M的二进制编码长度为l位。那么我们现在消息末尾补上一位1，然后再补上k个0，其中k为下列方程的最小非负整数</p><p> <img src="/2022/03/23/sha256/equation-1648645283142.svg" alt="计算K的公式"> </p><blockquote><p>特殊情况：当l长度为448时要填充加上512bits，449的话就填充511bits</p><p>447的话直接填充一个1即可</p></blockquote><p>最后填充64位，这64位是l的二进制编码</p><p>补完位的消息长度为512的倍数</p><h3 id="将补位完的消息进行分组"><a href="#将补位完的消息进行分组" class="headerlink" title="将补位完的消息进行分组"></a>将补位完的消息进行分组</h3><p> 将补码处理后的消息以512位为单位分块为: <img src="/2022/03/23/sha256/equation-1648645770037.svg" alt="[公式]"> </p><p>将每个消息块分为16×32bits， 前32位表示为: <img src="/2022/03/23/sha256/equation-1648645804943.svg" alt="[公式]">, 后面32位为: <img src="/2022/03/23/sha256/equation-1648645804934.svg" alt="[公式]">, 以此类推, 最后32位的消息块可表示为: <img src="/2022/03/23/sha256/equation-1648645804929.svg" alt="[公式]"> ，而在C语言中，32位正好对应unsigned int</p><h3 id="消息块扩充"><a href="#消息块扩充" class="headerlink" title="消息块扩充"></a>消息块扩充</h3><p>这里我们得到的是16个32bits消息块，要把其扩展为64个32bits的消息块</p><p>扩展代码</p><pre class="language-c" data-language="c"><code class="language-c">for i from 16 to 63    s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)    s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)    w[i] := w[i-16] + s0 + w[i-7] + s1</code></pre><h2 id="Hash主要加密流程"><a href="#Hash主要加密流程" class="headerlink" title="Hash主要加密流程"></a>Hash主要加密流程</h2><h3 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h3><p>初始哈希值取自自然数前8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位的十六进制表示，比如：</p><p><img src="/2022/03/23/sha256/equation-1648646228740.svg" alt="[公式]">小数部分约为0.414213562373095048 </p><p> <img src="/2022/03/23/sha256/equation-1648646248870.svg" alt="根号2的十六进制表示"> </p><p>于是，取出前32位对应0x6a09e667</p><p>依次得到初始化的H值</p><p> <img src="/2022/03/23/sha256/equation-1648646313831.svg" alt="初始化H值"> </p><h3 id="sha256的64个常数"><a href="#sha256的64个常数" class="headerlink" title="sha256的64个常数"></a>sha256的64个常数</h3><p> 取自自然数中前面64个素数的立方根的小数部分的前32位的十六进制表示</p><pre class="language-c" data-language="c"><code class="language-c">428a2f98 71374491 b5c0fbcf e9b5dba53956c25b 59f111f1 923f82a4 ab1c5ed5d807aa98 12835b01 243185be 550c7dc372be5d74 80deb1fe 9bdc06a7 c19bf174e49b69c1 efbe4786 0fc19dc6 240ca1cc2de92c6f 4a7484aa 5cb0a9dc 76f988da983e5152 a831c66d b00327c8 bf597fc7c6e00bf3 d5a79147 06ca6351 1429296727b70a85 2e1b2138 4d2c6dfc 53380d13650a7354 766a0abb 81c2c92e 92722c85a2bfe8a1 a81a664b c24b8b70 c76c51a3d192e819 d6990624 f40e3585 106aa07019a4c116 1e376c08 2748774c 34b0bcb5391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3748f82ee 78a5636f 84c87814 8cc7020890befffa a4506ceb bef9a3f7 c67178f2</code></pre><p>进行64次循环加密，流程图如下：</p><p><img src="/2022/03/23/sha256/600px-SHA-2.svg.png" alt="主要加密"></p><p>这里介绍一下ABCDEFGH的值以及K数组，W是我们扩展后的消息块</p><p>先把第一个W块和K相加后mod2^32，但是在C语言中，会进行截断，超过32位直接不管超过的那一位</p><p>接着先把H7和前一个得到的结果相加后mod2^32</p><p>再把H4、H5、H6取出进行Ch加密，再和前一个结果相加后mod2^32</p><p>将H4取出进行什么1操作，再和前一步的结果相加后mod2^32</p><p>接下来分为两步，第一步把前一个的结果和H3相加后mod2^32并存储在H4，第二步，先把H0、H1、H2进行Ma操作，再和前一步的结果相加再mod2^32</p><p>然后把H0取出进行什么0操作，再和前面第二步的结果相加后mod32后存储在H0</p><p>最后进行移位存储操作，就是除了H0和H4，剩下的H值存入前一个的H值</p><p>这个步骤循环64步就是加密后的H值，这个H值会被用于下一个512bits消息块的初始H值，最后的H数组加上原来的中间Hash值就是该消息区块的Hash值</p><h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;#define SHA256_ROTL(a,b) (((a&gt;&gt;(32-b))&amp;(0x7fffffff&gt;&gt;(31-b)))|(a&lt;&lt;b))#define SHA256_SR(a,b) ((a&gt;&gt;b)&amp;(0x7fffffff&gt;&gt;(b-1)))#define SHA256_CH(x,y,z) ((x&amp;y)^((~x)&amp;z))#define SHA256_Maj(x,y,z) ((x&amp;y)^(x&amp;z)^(y&amp;z))#define SHA256_E0(x) (SHA256_ROTL(x,30)^SHA256_ROTL(x,19)^SHA256_ROTL(x,10))#define SHA256_E1(x) (SHA256_ROTL(x,26)^SHA256_ROTL(x,21)^SHA256_ROTL(x,7))#define SHA256_O0(x) (SHA256_ROTL(x,25)^SHA256_ROTL(x,14)^SHA256_SR(x,3))#define SHA256_O1(x) (SHA256_ROTL(x,15)^SHA256_ROTL(x,13)^SHA256_SR(x,10)) void SHA256_ENCODE(char* input, int len){int i;char* pos,*posend;long A, B, C, D, E, F, G, I;long W[64] = { 0 };//初始化常量数据long long H[8] = {0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19};unsigned int K[64] = {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,};//消息补位,一个字符8位，而448位为56个字符,128个字符是1024位，512的两倍long long len_final = len + ((len % 64 &gt;= 56) ? (128 - len % 64) : (64 - len % 64));//printf("%d", len_final);//开辟空间if (!(pos = (char*)malloc(len_final))){printf("开辟空间失败！\n");exit(0);}//将字符串赋值到堆中，注意因为后面需要转为long类型运算，所以赋值时要注意大小端序的问题for ( i = 0; i &lt; len; ++i){pos[i + 3 - 2 * (i % 4)] = input[i];}//字符串后面的1和填充0pos[i + 3 - 2 * (i % 4)] = 0x80;i++;for (; i &lt; len_final; ++i){pos[i + 3 - 2 * (i % 4)] = 0;}//填充字符串的真实长度，并扩展为64位,64位也就是8个字符*((long*)(pos + len_final - 4)) = len &lt;&lt; 3;*((long*)(pos + len_final - 8)) = len &gt;&gt; 29;//每512位进行加密for (posend = pos + len_final; pos &lt; posend; pos += 64){//先分组为16*32bitfor (int j = 0; j &lt; 16; ++j){W[j] = ((long*)pos)[j];}//扩展为64*32bitfor (int j = 16; j &lt; 64; ++j){W[j] = (SHA256_O1(W[j - 2]) + W[j - 7] + SHA256_O0(W[j - 15]) + W[j - 16]);}//下面开始进行64轮加密//因为中间哈希值最后时为原来的+加密的哈希值，所以先储存A = H[0], B = H[1], C = H[2], D = H[3], E = H[4], F = H[5], G = H[6], I = H[7];for (i = 0; i &lt; 64; ++i){//T1存储加密的前一部分,T2存储加密的后一部分long T1 = I + SHA256_CH(E, F, G) + K[i] + W[i]+SHA256_E1(E);long T2 = SHA256_Maj(A, B, C) + SHA256_E0(A);//只能从后往前赋值，否则会覆盖I = G;G = F;F = E;E = D + T1;D = C;C = B;B = A;A = T1 + T2;}H[0] += A; H[1] += B;H[2] += C; H[3] += D;H[4] += E; H[5] += F;H[6] += G; H[7] += I;for (i = 0; i &lt; 8; ++i){printf("%X", H[i]);}}return;}int main(){char input[] = "ze";SHA256_ENCODE(input, strlen(input));return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/94619052&quot;&gt;https://zhuanl</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>PE-滴水逆向-手动实现</title>
    <link href="https://gift1a.github.io/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-11T12:03:07.000Z</published>
    <updated>2022-03-14T12:17:23.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码节空白节区添加代码"><a href="#代码节空白节区添加代码" class="headerlink" title="代码节空白节区添加代码"></a>代码节空白节区添加代码</h1><p>这里我们在notepad++增加MessageBoxA函数，保证先调用我们的函数再运行notepad++</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在代码区先加入对函数的调用，再将原来的OEP修改为我们插入代码在内存中的位置</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p> ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。 所以我们要先关闭</p><p><a href="https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr">https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr</a></p><p>在标准PE头属性中的第一个值改为1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647081337731.png"></p><p>这样PE文件加载到内存中就不会随机化了</p><h2 id="提取关键数据"><a href="#提取关键数据" class="headerlink" title="提取关键数据"></a>提取关键数据</h2><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>DWORD AddressOfEntryPoint-10E5DBh</p><p>DWORD ImageBase-400000h</p><h3 id="节表信息"><a href="#节表信息" class="headerlink" title="节表信息"></a>节表信息</h3><p>MIsc.DWORD VirtualSize-17C51Eh</p><p>DWORD VirtualAddress-1000h</p><p>DWORD PointerToRawData-400h</p><p>DWORD SizeOfRawData-17C600h</p><h2 id="判断能否添加"><a href="#判断能否添加" class="headerlink" title="判断能否添加"></a>判断能否添加</h2><p>如果SizeOfRawData-MIsc.DWORD VirtualSize&gt;=0x12，即可添加，这里是可以的</p><h2 id="找到在文件中代码结束的位置"><a href="#找到在文件中代码结束的位置" class="headerlink" title="找到在文件中代码结束的位置"></a>找到在文件中代码结束的位置</h2><p>先找到在文件中的偏移PointerToRawData，再找到数据段大小MIsc.DWORD VirtualSize，两者相加就是真实数据段的结束位置</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082425978.png"></p><h2 id="添加硬编码"><a href="#添加硬编码" class="headerlink" title="添加硬编码"></a>添加硬编码</h2><p>MessageBoxA需要四个参数</p><p>call指令长度为5</p><p>jmp指令长度为5</p><blockquote><p>真正要跳转的地址=E8/E9指令的下一条指令在内存中的地址+X（X就是E8后边跟着的四个字节）</p></blockquote><p>所以我们需要添加的硬编码为6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082868490.png"></p><h2 id="计算E8和E9的后四个字节"><a href="#计算E8和E9的后四个字节" class="headerlink" title="计算E8和E9的后四个字节"></a>计算E8和E9的后四个字节</h2><p>先找到E8对应的真实地址，也就是MessageBoxA的地址，在od里面command-&gt;输入bp MessageBoxA-&gt;状态栏b-&gt;找到MessageBoxA的地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083046046.png"></p><h3 id="E8后四字节计算"><a href="#E8后四字节计算" class="headerlink" title="E8后四字节计算"></a>E8后四字节计算</h3><p>真实地址为MessageBoxA的地址</p><p>X为MessageBoxA地址-VirtualAddress+ImageBase+8+5+Misc.VirtualSize</p><p>76BA5865</p><h3 id="E9后四字节计算"><a href="#E9后四字节计算" class="headerlink" title="E9后四字节计算"></a>E9后四字节计算</h3><p>真实地址为原来的OEP</p><p>X为ImageBase+AddressOfEntryPoint-VirtualAddress+ImageBase+8+5+5+Misc.VirtualSize</p><p>为FFF910AB</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083638028.png"></p><h2 id="修改AddressOfPoint"><a href="#修改AddressOfPoint" class="headerlink" title="修改AddressOfPoint"></a>修改AddressOfPoint</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083743309.png"></p><p>让他先执行我们的代码，也就是修改其为插入硬编码的地址</p><p>VirtualAddress+Misc.VirtualSize=17D51Eh</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>先执行MessageBoxA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084038464.png"></p><p>再运行程序</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084072618.png"></p><h1 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h1><h2 id="大小判断"><a href="#大小判断" class="headerlink" title="大小判断"></a>大小判断</h2><p>首先我们需要知道能否新增节SizeofHeaders-最后一个节表 的位置，如果大于或等于两个节表的大小（因为节表最后必须有长度为一个节表的00填充），则可以插入</p><h2 id="修改节表数量"><a href="#修改节表数量" class="headerlink" title="修改节表数量"></a>修改节表数量</h2><p>标准PE头-&gt;WORD NumberOfSections，+1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647140787003.png"></p><h2 id="添加节表信息"><a href="#添加节表信息" class="headerlink" title="添加节表信息"></a>添加节表信息</h2><p>这里直接复制.text段的信息，因为其可读可写可执行，后续可以不用再去修改节表属性</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141001170.png"></p><h2 id="确定插入的大小"><a href="#确定插入的大小" class="headerlink" title="确定插入的大小"></a>确定插入的大小</h2><p>根据情况自行选择，这里假设我们插入0x1000字节</p><h2 id="修改内存对齐后的大小"><a href="#修改内存对齐后的大小" class="headerlink" title="修改内存对齐后的大小"></a>修改内存对齐后的大小</h2><p>SizeOfImage+插入的大小（按照内存对齐）</p><h2 id="修正节表信息"><a href="#修正节表信息" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>先看关键数据</p><p>DWORD VirtualAddress</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD PointerToRawData</p><p>这里为了方便将Misc.DWORD VirtualSize和DWORD SizeOfRawData都改为0x1000，注意如果插入的是其他字节数，需要计算按照文件和内存对齐来调整</p><h3 id="计算VirtualAddress"><a href="#计算VirtualAddress" class="headerlink" title="计算VirtualAddress"></a>计算VirtualAddress</h3><p>前面一个节表的VirtualAddress+Max(Misc.DWORD VirtualSize,SizeOfRawData)-按内存对齐后的</p><p>这里SizeOfRawData大于前者，按内存对齐后是15000h，加上该节表的VirtualAddress就是我们插入节表在内存中的偏移地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141493979.png"></p><h3 id="计算PointerToRawData"><a href="#计算PointerToRawData" class="headerlink" title="计算PointerToRawData"></a>计算PointerToRawData</h3><p>和前面类似SizeOfRawData（文件对齐）+PointerToRawData</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141658195.png"></p><h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141708469.png"></p><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p>在PointerToRawData插入0x1000字节</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141776493.png"></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>在PE解析工具可以看到插入的节表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141801656.png"></p><h1 id="新增节-节表信息后不够位置"><a href="#新增节-节表信息后不够位置" class="headerlink" title="新增节-节表信息后不够位置"></a>新增节-节表信息后不够位置</h1><p>我们直到DOS和NT头之前有一段垃圾数据，当节表末尾没位置插入80个字节，我们需要将NT头和节表信息前移，这样就可以空出一段无用字节，长度为垃圾数据长度</p><blockquote><p>注意要修改LONG AddressOfNewExeHeader-NT头的位置</p></blockquote><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142922682.png"></p><p>直接复制到垃圾数据的起始地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142986819.png"></p><p>这就是空出来的节表，后续操作和前面新增节一样，就不赘述了</p><h1 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h1><p>当前面两种做法都不能满足，我们采取扩大节的办法，可以在任意节区末尾添加，但是如果不是在最后一个节添加，后面的节表偏移都要修改，所以我们扩大最后一个节</p><p>需要修改的数据</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD SizeOfImage</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>将最后一个节的SizeOfRawData和VirtualSize改成N，N = 节内存对齐后的大小 + 要扩大的大小</li><li>修改 SizeOfImage大小=SizeOfImage大小+要扩大的大小</li><li>分配一块新的空间，大小为：节内存对齐增加的大小+要扩大的大小</li></ol><h2 id="修正节表信息-1"><a href="#修正节表信息-1" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>这里我们假设扩大0x1000个字节</p><p>要改为Max(DWORD VirtualSize,DWORD SizeOfRawData)内存对齐的大小+我们扩大的大小=16000h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147742819.png"></p><h2 id="修正SizeOfImage"><a href="#修正SizeOfImage" class="headerlink" title="修正SizeOfImage"></a>修正SizeOfImage</h2><p>直接加上0x1000即可</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>节内存对齐增加的大小=N-DWORD SizeOfRawData，即C00</p><p>在节区尾部增加即可，有时候最后一个节区尾部之后还有别的程序，那么就需要计算最后一个节区的结束地址</p><p>求和得到2B6C00h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147968238.png"></p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647148042480.png"></p><h1 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h1><h2 id="修改节表个数"><a href="#修改节表个数" class="headerlink" title="修改节表个数"></a>修改节表个数</h2><p>合并之后节数量-1，这里改为7</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149630089.png"></p><h2 id="修改节表信息"><a href="#修改节表信息" class="headerlink" title="修改节表信息"></a>修改节表信息</h2><p>要将节进行合并，就需要修改节表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149670756.png"></p><h3 id="DWORD-SizeOfRawData和DWORD-VirtualSize"><a href="#DWORD-SizeOfRawData和DWORD-VirtualSize" class="headerlink" title="DWORD SizeOfRawData和DWORD VirtualSize"></a>DWORD SizeOfRawData和DWORD VirtualSize</h3><p>将这两个值改为该节的Max(SizeOfRawData,VirtualSize)+下一个节的Max(SizeOfRawData,VirtualSize)</p><p>最后保存即可</p><p>那么剩下的节表信息没用了，我们可以再次新增节</p><h2 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150089815.png"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150123108.png"></p><h1 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h1><p>移动前，我们需要先开辟节区，先将后面三个表指向的数据复制到新的节区中，再复制那三个表的信息过去，最后将数据目录指向导出表开始的地方</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647219750918.png" alt="移动前"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647220007029.png" alt="移动后"></p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>在数据目录找到导入表的RVA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228628138.png"></p><p>根据节的RVA和大小确定在哪个表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228686574.png"></p><p>计算FOA=Export .RVA-rdata.RVA+rdata. PointerToRawData</p><p>计算得到F2270，跳转，根据Export.Size确定大小</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228914109.png"></p><h2 id="新增节-1"><a href="#新增节-1" class="headerlink" title="新增节"></a>新增节</h2><p>前面说过，就不细🔒了</p><h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2><p>前面四个是DWORD函数地址，DWORD函数名称表，WORD函数序号-这里比较少，就一个函数</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229009740.png"></p><p>这两个分别是dll名字和函数名称</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229076116.png"></p><p>直接复制剩下的导出表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229244730.png"></p><h2 id="修改RVA"><a href="#修改RVA" class="headerlink" title="修改RVA"></a>修改RVA</h2><p>这里我已经改好了，因为该节的RVA-PointOfRawData=1600，所以修改的时候将FOA+1600h=RVA</p><p>要修改的有</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229408065.png"></p><h2 id="数据目录修改"><a href="#数据目录修改" class="headerlink" title="数据目录修改"></a>数据目录修改</h2><p>将Export.RVA指向我们复制导出表的初始位置</p><h1 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h1><p>新增节-&gt;复制数据-&gt;数据目录修改重定位表位置</p><h2 id="修改ImageBase"><a href="#修改ImageBase" class="headerlink" title="修改ImageBase"></a>修改ImageBase</h2><p>我们修改ImageBase时，重定位表也需要修改，其他不用改，因为其他节表信息映射到内存中时，都是按照ImageBase进行的</p><p>而重定位表是按照VirtualAddress+小表进行修复的，所以ImageBase修改了，重定位表的VirtualAddress也需要修改</p><p>假如ImageBase+1000，重定位表的VirtualAddress也需要+1000</p><h1 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h1><p>每个DLL对应一个导入表，DLL存放着我们的函数</p><p>导入表后面还有一堆数据，我们不能直接添加，所以要新开辟节区，然后复制原来的导入表之后再在末尾添加导入表</p><h2 id="新增节区"><a href="#新增节区" class="headerlink" title="新增节区"></a>新增节区</h2><h2 id="复制导入表信息"><a href="#复制导入表信息" class="headerlink" title="复制导入表信息"></a>复制导入表信息</h2><p> 拷贝原来的导入表到新节中 </p><h2 id="新增导入表"><a href="#新增导入表" class="headerlink" title="新增导入表"></a>新增导入表</h2><h2 id="新增INT表和IAT表"><a href="#新增INT表和IAT表" class="headerlink" title="新增INT表和IAT表"></a>新增INT表和IAT表</h2><p>至少八字节</p><h2 id="修改Name"><a href="#修改Name" class="headerlink" title="修改Name"></a>修改Name</h2><p> 存储要注入的dll的名称 ，并且将DLL名称的RVA赋值给新增导入表的Name</p><h2 id="创建struct-IMAGE-IMPORT-BY-NAME"><a href="#创建struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="创建struct _IMAGE_IMPORT_BY_NAME"></a>创建struct _IMAGE_IMPORT_BY_NAME</h2><p>将函数名称赋值给结构体的第二个变量</p><h2 id="修改INT和IAT指向的地址"><a href="#修改INT和IAT指向的地址" class="headerlink" title="修改INT和IAT指向的地址"></a>修改INT和IAT指向的地址</h2><p>将IMAGE_IMPORT_BY_NAME的RVA赋值给INT和IAT的第一项，因为INT和IAT都指向_IMAGE_IMPORT_BY_NAME</p><h2 id="修改数据目录"><a href="#修改数据目录" class="headerlink" title="修改数据目录"></a>修改数据目录</h2><p>指向我们的新增位置， 修改IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码节空白节区添加代码&quot;&gt;&lt;a href=&quot;#代码节空白节区添加代码&quot; class=&quot;headerlink&quot; title=&quot;代码节空白节区添加代码&quot;&gt;&lt;/a&gt;代码节空白节区添加代码&lt;/h1&gt;&lt;p&gt;这里我们在notepad++增加MessageBoxA函数，保证先调</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>PE解析代码实现</title>
    <link href="https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-11T05:19:10.000Z</published>
    <updated>2022-03-21T03:43:02.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打印PE文件头部和节区信息"><a href="#打印PE文件头部和节区信息" class="headerlink" title="打印PE文件头部和节区信息"></a>打印PE文件头部和节区信息</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;malloc.h&gt;#include&lt;Windows.h&gt;//宏定义，方便后续使用//定义变量IMAGE_DOS_HEADER myDOS;LONG elf_new;IMAGE_NT_HEADERS32 myNTheader;IMAGE_OPTIONAL_HEADER32 myOPTIONheader;IMAGE_SECTION_HEADER mysection[100];int NUM_SECTION;int main(){FILE* pfile;pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");//打开文件fseek(pfile, 0, SEEK_SET);//参数说明，将fp指针从文件开头移动到0的位置fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);//表示从fp开始的地方读取一次长度为sizeof(IMAGE_DOS_HEADER)的字节，存储到myDOS中//DOSprintf("==============IMAGE_DOS_HEADER==============\n");printf("DOS头：          %08X\n", myDOS.e_magic);printf("NT头所在位置：   %08X\n", myDOS.e_lfanew);elf_new = myDOS.e_lfanew;//将NT头的偏移存储起来//NT头fseek(pfile, elf_new, SEEK_SET);//注意不是sizeof(elf_new)fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS), 1, pfile);printf("==============IMAGE_NT_HEADERS==============\n");//打印PE标志printf("PE标志：         %08X\n", myNTheader.Signature);//打印标准PE头信息printf("==============IMAGE_FILE_HEADERS==============\n");printf("节区数量：       %08X\n", myNTheader.FileHeader.NumberOfSections);NUM_SECTION = myNTheader.FileHeader.NumberOfSections;printf("可选PE头大小：   %08X\n", myNTheader.FileHeader.SizeOfOptionalHeader);//打印ASLR的信息，方便查看和修改printf("ASLR属性：       %08X\n", (myNTheader.FileHeader.Characteristics ) &amp; 1);//打印可选PE头信息printf("==============IMAGE_OPTIONAL_HEADERS==============\n");fseek(pfile, elf_new+sizeof(IMAGE_FILE_HEADER)+sizeof(myNTheader.Signature), SEEK_SET);//因为标准PE头长度为20fread(&amp;myOPTIONheader, sizeof(IMAGE_OPTIONAL_HEADER), 1, pfile);printf("DWORD AddressOfEntryPoint：   %08llX\n", myOPTIONheader.AddressOfEntryPoint);printf("基址：%08X\n", myOPTIONheader.ImageBase);//注意这里的可选PE头类型必须是IMAGE_OPTIONAL_HEADER32printf("文件对齐大小：%08X\n", myOPTIONheader.FileAlignment);printf("内存对齐大小：%08X\n", myOPTIONheader.SectionAlignment);printf("文件头和节表大小：  %08X\n", myOPTIONheader.SizeOfHeaders);printf("内存拉伸大小：%08X\n", myOPTIONheader.SizeOfImage);//打印节表信息，前面我们已经存储了节表数量了printf("==============IMAGE_SECTION_HEADER SectionHeaders==============\n");fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);for (int i = 0; i &lt; NUM_SECTION; ++i){printf("NAME：        %s\n", mysection[i].Name);printf("DWORD VirtualAddress：        %08X\n", mysection[i].VirtualAddress);printf("DWORD SizeOfRawData：        %08X\n", mysection[i].SizeOfRawData);printf("DWORD PointerToRawData：        %08X\n", mysection[i].PointerToRawData);printf("DWORD VirtualSize：        %08X\n", mysection[i].Misc.VirtualSize);}fclose(pfile);//关闭文件return 0;}</code></pre><h1 id="RVA转FOA"><a href="#RVA转FOA" class="headerlink" title="RVA转FOA"></a>RVA转FOA</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;/** RVA转FOA的思路* 1、先判断所在节区，设计思路：首先我们必须拿的是内存对齐后的来比较大小，先把RVA-virtualaddress，再和max(MISC,SizeofRawData)按照内存对齐的值作比较* 2、循环判断节区* 3、计算FOA，偏移是一样的，那就是RVA-virtualaddress+节区的PointerOfdata*/IMAGE_NT_HEADERS32 myNTheader;IMAGE_DOS_HEADER myDOS;//因为PE头长度不变，所以我们只需要找到elf_new的内容就可以知道节区的起始地址IMAGE_SECTION_HEADER mysection[10];int NUM_SECTION;//我们还需要知道节区的数量int elf_new;int RVA = 0x20d000;long long MAX(DWORD a, DWORD b){//计算MISC和SizeOFRAWDATA，并返回按照内存对齐后的值if (a &gt; b){return (a%myNTheader.OptionalHeader.SectionAlignment)?((a / myNTheader.OptionalHeader.SectionAlignment)+1) * myNTheader.OptionalHeader.SectionAlignment : ((a / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;}elsereturn (b % myNTheader.OptionalHeader.SectionAlignment) ? ((b / myNTheader.OptionalHeader.SectionAlignment) + 1) * myNTheader.OptionalHeader.SectionAlignment : ((b / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;;}int main(){FILE* pfile;pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");fseek(pfile,0, SEEK_SET);fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);elf_new = myDOS.e_lfanew;fseek(pfile, elf_new, SEEK_SET);fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS32), 1, pfile);NUM_SECTION = myNTheader.FileHeader.NumberOfSections;//得到节区fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);for (int i = 0; i &lt; NUM_SECTION; ++i){if (RVA - mysection[i].VirtualAddress &lt; MAX(mysection[i].Misc.VirtualSize, mysection[i].SizeOfRawData)){printf("所在节区为：%s\n", mysection[i].Name);printf("FOA为：%08X", RVA - mysection[i].VirtualAddress + mysection[i].PointerToRawData);}}fclose(pfile);return 0;}</code></pre><h1 id="PE插入shellcode"><a href="#PE插入shellcode" class="headerlink" title="PE插入shellcode"></a>PE插入shellcode</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;#define MessageBoxA_ADDR 0x76C20F40//MessageBoxA的地址#define shellcode_len 0x12//定义shellcode的长度//输入路径和输出路径char file_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe";char final_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\5.exe";//插入的shellcodeBYTE shellcode[] = {0x6A,0x00,0x6A,0x00,0x6A,0x00,0x6A,0x00,0xE8,0x00,0x00,0x00,0x00,0xE9,0x00,0x00,0x00,0x00};int LoadPE(LPVOID*pFileBuffer)//二级指针存储的是一级指针的地址{FILE* pfile;DWORD FileSize = 0;LPVOID pTempBuffer;pfile = fopen(file_path, "rb");//通过fseek和ftell返回文件长度，fseek将fp指针设置在文件尾，ftell获取当前fp指针的位置与文件首的偏移fseek(pfile, 0, SEEK_END);FileSize = ftell(pfile);//重新设置回开头fseek(pfile, 0, SEEK_SET);//开辟空间，malloc函数返回开辟空间的起始地址pTempBuffer = malloc(FileSize);//将文件中的内容读取到临时Buffer中fread(pTempBuffer, FileSize, 1, pfile);//将分配返回的地址存储到FileBuffer中*pFileBuffer = pTempBuffer;//temp指针指向空pTempBuffer = NULL;fclose(pfile);return FileSize;}int CopyFileBufferToImageBuffer(LPVOID pFileBuffer,LPVOID* pImageBuffer)//pImageBuffer是void类型指针，指向的是读取到内存中的文件内容首地址{//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//初始化tempBufferLPVOID pTempBuffer = NULL;//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息pDOSHeader = PIMAGE_DOS_HEADER(pFileBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//分配ImageBuffer内存pTempBuffer = malloc(pOptionalHeader-&gt;SizeOfImage);//初始化ImageBuffer内存memset(pTempBuffer, 0, pOptionalHeader-&gt;SizeOfImage);//拷贝数据memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//参数说明，目标数据、被使用数据，长度//循环拷贝节表信息PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++,pTempSectionHeader++){//因为memcpy只接受void类型的指针，所以要先强制转换memcpy((void*)((DWORD)pTempBuffer + pTempSectionHeader-&gt;VirtualAddress), (void*)((DWORD)pFileBuffer + pTempSectionHeader-&gt;PointerToRawData), pTempSectionHeader-&gt;SizeOfRawData);}//赋值给pImageBuffer*pImageBuffer = pTempBuffer;pTempBuffer = NULL;return pOptionalHeader-&gt;SizeOfImage;}int CopyImageBufferToNewBuffer(LPVOID pImageBuffer,LPVOID* pNewBuffer){//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//初始化TempBufferLPVOID pTempBuffer = NULL;//结构体强制转换pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//计算NewBuffer大小DWORD new_buffer_size = pOptionalHeader-&gt;SizeOfHeaders;//节表大小计算PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;//注意这里要使用临时变量，否则循环的时候，结构体指针后移，指向改变for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pTempSectionHeader++){new_buffer_size += pTempSectionHeader-&gt;SizeOfRawData;//printf("%X\n", pSectionHeader-&gt;SizeOfRawData);}printf("%X\n", new_buffer_size);//开辟空间并且设置为0pTempBuffer = malloc(new_buffer_size);memset(pTempBuffer, 0, new_buffer_size);//复制ImageBuffer信息memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//复制节表信息pTempSectionHeader = pSectionHeader;for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, ++pTempSectionHeader){//因为memcpy只接受void类型的指针，所以要先强制转换memcpy((PWORD)((DWORD)pTempBuffer + pTempSectionHeader-&gt;PointerToRawData), (PWORD)((DWORD)pImageBuffer + pTempSectionHeader-&gt;VirtualAddress), pTempSectionHeader-&gt;SizeOfRawData);}//赋值给pImageBuffer*pNewBuffer = pTempBuffer;pTempBuffer = NULL;return new_buffer_size;}void newbuffer_write2_exe(PVOID NewFileBuffer, DWORD FileSize, char* FilePath){FILE* fp1 = fopen(FilePath, "wb");if (fp1 != NULL){fwrite(NewFileBuffer, FileSize, 1, fp1);printf("成功存盘");}fclose(fp1);return ;}void ADD_Opcode(LPVOID pImageBuffer, LPVOID* pNewBuffer){//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//判断能否插入if (shellcode_len &gt; pSectionHeader-&gt;SizeOfRawData - pSectionHeader-&gt;Misc.VirtualSize){printf("长度不足，无法插入\n");free(pImageBuffer);}//计算空白位置，转为char*指针PBYTE code_begin = (PBYTE)((DWORD)pImageBuffer + pSectionHeader-&gt;VirtualAddress+ pSectionHeader-&gt;Misc.VirtualSize);//插入shellcodememcpy(code_begin, shellcode, shellcode_len);//计算E8地址DWORD callADDr = (MessageBoxA_ADDR - (pOptionalHeader-&gt;ImageBase + pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize + 0xD));//将callADDR插入到E8之后,填充数据*(PDWORD)((DWORD)code_begin + 0x09) = callADDr;//计算jmp地址,跳转的值=真实地址-下一条指令地址DWORD jmpADDr = pOptionalHeader-&gt;ImageBase + pOptionalHeader-&gt;AddressOfEntryPoint - ((DWORD)code_begin + pOptionalHeader-&gt;ImageBase + shellcode_len-(DWORD)pImageBuffer);*(PDWORD)((code_begin + 14)) = jmpADDr;//修改OEPpOptionalHeader-&gt;AddressOfEntryPoint = ((DWORD)code_begin - (DWORD)pImageBuffer);//也可以使用VirtualAddress+VirtualSize//还原为NewBufferDWORD ret2=CopyImageBufferToNewBuffer(pImageBuffer, pNewBuffer);//存盘newbuffer_write2_exe(*pNewBuffer,ret2, final_path);return ;}void operate_pe(){LPVOID pFileBuffer = NULL;//LPVOID相当于void*LPVOID pNewBuffer = NULL;LPVOID pImageBuffer = NULL;//读取文件内容到FileBuffer中dDWORD file_size = LoadPE(&amp;pFileBuffer);//二级指针void**,将存储指针的地址传过去printf("文件长度为：  %08X\n", file_size);//将FileBuffer拉伸为ImageBufferDWORD Image_Size = CopyFileBufferToImageBuffer(pFileBuffer,&amp;pImageBuffer);printf("拉伸后的大小为：  %08X\n",Image_Size);//添加opcodeADD_Opcode(pImageBuffer, &amp;pNewBuffer);//开辟的内存需要free掉free(pFileBuffer);free(pNewBuffer);free(pImageBuffer);return;}int main(){operate_pe();return 0;}</code></pre><h1 id="PE文件新增节"><a href="#PE文件新增节" class="headerlink" title="PE文件新增节"></a>PE文件新增节</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;/*思路：1、读取文件信息到buffer中判断节区信息够不够大小，两个节表的大小2、找到节区的最后位置，开辟指定大小的空间3、修改信息-NumberOfSection、SizeOfRawData、VirtualSize（注意要对齐）*/#define New_Buffer_Size 0x1000#define File_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe"#define Final_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\6++.exe"int Open_File(LPVOID *pFileBuffer){FILE* pfile = NULL;LPVOID TempBuffer = NULL;pfile = fopen(File_Path, "rb");fseek(pfile, 0, SEEK_END);DWORD file_size = ftell(pfile);//设置文件指针到文件头fseek(pfile, 0, SEEK_SET);TempBuffer = malloc(file_size);fread(TempBuffer , file_size, 1, pfile);*pFileBuffer = TempBuffer;TempBuffer = NULL;fclose(pfile);return file_size;}int Add_Section(LPVOID FileBuffer, LPVOID* pNewBuffer,DWORD file_size){//定义结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS32 pNTHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSection = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PVOID pNewTempBuffer = NULL;DWORD New_File_Size = 0;//新增节New_File_Size = file_size + 0x1000;pNewTempBuffer = (PVOID)malloc(New_File_Size);// 判断开辟空间是否成功if (!pNewTempBuffer){printf("pNewTempBuffer开辟空间失败!\n");return 0;}// 初始化内存memset(pNewTempBuffer, 0, New_File_Size);// 将旧空间的内容copy到新的空间memcpy(pNewTempBuffer, FileBuffer, file_size);//读取信息pDOSHeader = (PIMAGE_DOS_HEADER)(pNewTempBuffer);pNTHeader = (PIMAGE_NT_HEADERS32)((DWORD)pNewTempBuffer + pDOSHeader-&gt;e_lfanew);pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));pSection = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));//找到节表的最后位置PIMAGE_SECTION_HEADER pfinal_Section = &amp;(pSection[pFileHeader-&gt;NumberOfSections - 1]);//判断能否插入节表,因为在文件和内存中PE头和DOS头大小不变，直接计算即可DWORD remain_size = (pOptionalHeader-&gt;SizeOfHeaders - pDOSHeader-&gt;e_lfanew - 4 - sizeof(IMAGE_FILE_HEADER) - sizeof(IMAGE_OPTIONAL_HEADER32) - sizeof(IMAGE_SECTION_HEADER) * pFileHeader-&gt;NumberOfSections);if (remain_size &lt; 2 * sizeof(IMAGE_SECTION_HEADER)){printf("位置不够捏，想想其他办法吧~\n");}//修改信息// 初始化新增节信息PVOID pSecName = &amp;pSection[pFileHeader-&gt;NumberOfSections].Name;PDWORD pSecMisc = &amp;pSection[pFileHeader-&gt;NumberOfSections].Misc.VirtualSize;PDWORD pSecVirtualAddress = &amp;pSection[pFileHeader-&gt;NumberOfSections].VirtualAddress;PDWORD pSecSizeofRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].SizeOfRawData;PDWORD pSecPointerToRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].PointerToRawData;PDWORD pSecCharacteristic = &amp;pSection[pFileHeader-&gt;NumberOfSections].Characteristics;//名字memcpy(pSecName, ".mycode", 8);//Misc*pSecMisc = 0x1000;//计算VirtualAddress=前一个节的VA+sizeofrawdata或者virtualSize内存对齐大小DWORD Sec_Size = (pfinal_Section-&gt;SizeOfRawData &gt; pfinal_Section-&gt;Misc.VirtualSize) ? pfinal_Section-&gt;SizeOfRawData : pfinal_Section-&gt;Misc.VirtualSize;//内存对齐Sec_Size= (Sec_Size % pOptionalHeader-&gt;SectionAlignment) ? ((Sec_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : Sec_Size;//修改VirtualAddress*pSecVirtualAddress = pfinal_Section-&gt;VirtualAddress + Sec_Size;//修改sizeofRawData*pSecSizeofRawData = 0x1000;//修改PointerDWORD size = pfinal_Section-&gt;SizeOfRawData;DWORD File_Size= (size % pOptionalHeader-&gt;FileAlignment) ? ((size / pOptionalHeader-&gt;FileAlignment) + 1) * pOptionalHeader-&gt;FileAlignment : size;*pSecPointerToRawData = pfinal_Section-&gt;PointerToRawData + File_Size;*pSecCharacteristic = 0xFFFFFFFF;//头部信息,先计算增加的长度在内存和文件拉伸的长度DWORD Sec_ADD = (New_Buffer_Size % pOptionalHeader-&gt;SectionAlignment) ? ((New_Buffer_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : New_Buffer_Size;DWORD File_ADD = pOptionalHeader-&gt;SizeOfImage += Sec_ADD;pFileHeader-&gt;NumberOfSections += 1;*pNewBuffer = pNewTempBuffer;pNewTempBuffer = NULL;return New_File_Size;}void Write_To_Newfile(DWORD New_File_Size, LPVOID pNewBuffer){FILE* fp;fp = fopen(Final_Path, "wb");fwrite(pNewBuffer, New_File_Size, 1, fp);fclose(fp);return ;}void PE_operate(){DWORD new_file_size = 0;PVOID pNewBuffer = NULL;PVOID FileBuffer = NULL;DWORD file_size = 0;DWORD New_File_Size = 0;//打开文件读取信息file_size = Open_File(&amp;FileBuffer);//新增节并且修改信息New_File_Size=Add_Section(FileBuffer,&amp;pNewBuffer,file_size);Write_To_Newfile(New_File_Size, pNewBuffer);}int main(){PE_operate();return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;打印PE文件头部和节区信息&quot;&gt;&lt;a href=&quot;#打印PE文件头部和节区信息&quot; class=&quot;headerlink&quot; title=&quot;打印PE文件头部和节区信息&quot;&gt;&lt;/a&gt;打印PE文件头部和节区信息&lt;/h1&gt;&lt;pre class=&quot;language-c&quot; data-</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>PE文件结构</title>
    <link href="https://gift1a.github.io/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://gift1a.github.io/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-03T06:13:58.000Z</published>
    <updated>2022-03-27T02:53:01.734Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>主要有exe、dll、sys文件，这些都是可执行文件</p><p>exe由多个exe文件组成，dll之类的</p><h1 id="PE文件头解析"><a href="#PE文件头解析" class="headerlink" title="PE文件头解析"></a>PE文件头解析</h1><p>在内存中和硬盘中数据几乎是一样的，但是存在差异，且程序开始的位置不同，所以可以知道存储信息的位置是可以改变的</p><p>根据不同的功能分了不同的节，也就是程序不同的块，这样做1、可以节省硬盘空间，在内存中占用空间大于硬盘占用空间（节之间的间隔较小）</p><p>2、节省内存，当程序需要多开的时候，只需要将可读可写的数据段重新复制一份即可，不需要对只读的数据进行复制</p><h2 id="硬盘（文件）对齐和内存对齐"><a href="#硬盘（文件）对齐和内存对齐" class="headerlink" title="硬盘（文件）对齐和内存对齐"></a>硬盘（文件）对齐和内存对齐</h2><p>目的都是为了提升读写的速度</p><p>老的编译器，硬盘对齐是200h个字节<strong>（当不够200h字节，会自动填充）</strong>，内存对齐是1000h个字节，所以PE结构执行（<strong>操作系统运行exe文件</strong>）时会发生拉伸的过程，即在内存中占用空间大于硬盘占用空间</p><p>新的编译器在硬盘和内存都采用1000h，这是因为编译器发展，这样内存和硬盘对齐一样，运行时可以减少运算，这样虽然牺牲了空间，但是缩短了时间</p><h2 id="PE磁盘文件与内存映像结构图"><a href="#PE磁盘文件与内存映像结构图" class="headerlink" title="PE磁盘文件与内存映像结构图"></a>PE磁盘文件与内存映像结构图</h2><p>块表（节表）概括节的基本信息（起始和终止位置，节的大小），DOS头和PE头对当前exe文件做的概要性描述（拉伸完后的大小，堆栈大小），节表存储信息</p><p> <img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/19100019-8692ac67434949cb9ec42764cab75468-1646313270630.jpg"> </p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>DOS长度确定</p><p>解析exe文件时，先解析前两个字节，并通过DOS头找到exe文件真正开始的地方</p><p>第一个WORD MZSignature（e_magic）-MZ标记</p><p>最后一个LONG AddressOfNewExeHeader（e_lfanew）-指向了PE文件的真正开始地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646292642401.png"></p><p>这里的0108表示从文件开始的地方计算0108个字节就是PE结构开始的地方</p><h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>DOS头和NT头中间是一段空间，可以自由发挥，多与少不确定，我们可以在这一段写入shellcode（ <strong>利用软件漏洞而执行的代码</strong> ），在程序中调用。有地址我们就可以访问和执行</p><p>PE的标记-DWORD Signature-四个字节</p><h3 id="标准PE头-20字节"><a href="#标准PE头-20字节" class="headerlink" title="标准PE头-20字节"></a>标准PE头-20字节</h3><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646295409969.png"></p><p>关键信息</p><p>enum IMAGE_MACHINE Machine-程序运行的CPU型号：0x0 任何处理器 /0x14C 386及后续处理器</p><p>WORD NumberOfSections-文件中存在的节的数量，如果需要新增或者合并节，就要修改这个值</p><p>time_t TimeDateStamp-文件创建时间，编译器填写</p><p><strong>WORD SizeOfOptionalHeader</strong>-可选PE头的大小，32位PE文件默认E0h、64位PE文件默认为F0h  大小可以自定义.</p><p>struct FILE_CHARACTERISTICS Characteristics-每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 </p><p>这里的102拆成二进制</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296388161.png"></p><p>勾中即为1</p><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296662617.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296680675.png"></p><p>关键信息</p><p>enum OPTIONAL_MAGIC Magic-说明文件类型：10B 32位下的PE文件、20B 64位下的PE文件</p><p>DWORD SectionAlignment-内存对齐</p><p>DWORD FileAlignment-文件对齐</p><p>DWORD SizeOfCode-所有代码节的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfInitializedData-已初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfUninitializedData-未初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p><em><strong>DWORD AddressOfEntryPoint-程序入口</strong></em></p><p>DWORD BaseOfCode-代码开始的基址，编译器填的，不会被使用</p><p>DWORD BaseOfData-数据开始的基址，编译器填的，不会被使用</p><p>！！<em><strong>DWORD ImageBase-内存镜像基址</strong></em>（不从0开始是因为需要内存保护）</p><p><em><strong>把文件拖入OD时会断在ImageBase+AddressOfEntryPoint这个地址，也就是OEP</strong></em></p><blockquote><p>程序入口可以修改-加壳</p><p>加壳之后入口点EP（RVA）和OEP（RAW）都会改变，但是内存镜像基址不变</p></blockquote><blockquote><p>内核重载：（有一些软件会通过hook技术，检测是否调用函数）相当于PEloader（加载）-把硬盘文件拷贝到内存中进而执行exe文件，但是在拷贝过程中还会有一个文件的缓冲区，这个缓冲区也是在内存中的。装载到内存时是以ImageBase为起点的</p></blockquote><p>DWORD SizeOfImage-内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍，也就是PE文件在内存中被拉伸后的大小</p><p>DWORD SizeOfHeaders-所有头+节表按照文件对齐后的大小，否则加载会出错</p><p>DWORD CheckSum-校验和，一些系统文件有要求，用来判断文件是否被修改</p><p>DWORD SizeOfStackReserve-初始化时保留的堆栈大小</p><p>DWORD SizeOfStackCommit-初始化时实际提交的大小</p><p>DWORD SizeOfHeapReserve-初始化时保留的堆的大小</p><p>DWORD SizeOfHeapCommit-初始化时实际提交的大小</p><p>DWORD NumberOfRvaAndSizes-目录项数目</p><h1 id="节表-每个节有28字节的信息"><a href="#节表-每个节有28字节的信息" class="headerlink" title="节表-每个节有28字节的信息"></a>节表-每个节有28字节的信息</h1><p>节表定位-DOS+PE+OPTIONPE</p><p>描述每个节的信息</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306378425.png"></p><p>节的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306828500.png"></p><p>BYTE Name[8]是八个字节，不够补’\0’，在内存是0，所以不能使用char*，而要用char [9]，且可以随便改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306924262.png"></p><p>第二个成员是union Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确（可能被别的软件加工过），但是不会妨碍运行，<strong>里面的成员DWORD VirtualSize-存放PE文件放入内存时的数据宽度，他的值可能大于文件对齐后的数据宽度（SizeofRawData），这是因为未初始化的变量不会被存入文件中</strong></p><p>第三个成员-DWORD VirtualAddress-节区在内存中的相对偏移（拉伸-内存对齐后的），加上ImageBase才是在内存中的真正地址（跟文件中无关）</p><p>第四个成员-DWORD SizeOfRawData-节在文件中对齐后的尺寸</p><p>第五个成员-DWORD PointerToRawData-节区在文件中的偏移,所以.text是从400h开始的（跟内存中无关）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646309678678.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646308057578.png"></p><p>第二个和第四个是在调试时使用的，编译完这四个默认为0</p><p>struct SECTION_CHARACTERISTICS Characteristics-节的属性</p><p>最后一个成员struct SECTION_CHARACTERISTICS Characteristics-里面有32位，但不是每一位都用</p><pre class="language-c" data-language="c"><code class="language-c">--&gt; 标志(属性块) 常用特征值对照表：&lt;--[值:00000020h](*包含可执行代码)[值:00000040h](*该块包含已初始化的数据)[值:00000080h](*该块包含未初始化的数据)[值:00000200h][Section contains comments or some other type of information.][值:00000800h][Section contents will not become part of image.][值:00001000h][Section contents comdat.][值:00004000h][Reset speculative exceptions handling bits in the TLB entries for this section.][值:00008000h][Section content can be accessed relative to GP.][值:00500000h][Default alignment if no others are specified.][值:01000000h][Section contains extended relocations.][值:02000000h][Section can be discarded.][值:04000000h][Section is not cachable.][值:08000000h][Section is not pageable.][值:10000000h](*该块为共享块).[值:20000000h](*该块可执行)[值:40000000h](*该块可读)[值:80000000h](*该块可写)</code></pre><h1 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h1><p>拉伸完之后还需要进行一些准备步骤</p><p>先把文件对齐后的数据拷贝到内存中，根据SizeofHeades，直接copy，因为头和节表是不会变化的，但是节表后面不一定是节区，这是因为文件对齐和内存对齐不同</p><p>循环赋值节的内容，复制到内存的地方由节表信息里面的VirtualAddress决定，PointerToRawData决定了文件复制到内存的起始位置</p><p>复制数据的大小根据SizeofRawData（Misc也可以，但是如果MIsc存在大量未初始化数据，会变得很大，可能将下一节的信息也copy到内存中）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646548848907.png"></p><h2 id="根据内存数据存储的位置查找在文件中的位置"><a href="#根据内存数据存储的位置查找在文件中的位置" class="headerlink" title="根据内存数据存储的位置查找在文件中的位置"></a>根据内存数据存储的位置查找在文件中的位置</h2><p>假设内存开始位置是500000，数据在内存存储位置是501234</p><p>1、确定节</p><p>先确定偏移501234-500000</p><p>根据节的不同偏移（VirtualAddress）</p><p>1234&gt;VirtualAddress</p><p>1234&lt;VirtualAddress+Misc.VirtualSize</p><p>2、计算距离节初始位置的长度</p><p>1234-1000=234h</p><p>3、在文件中寻找</p><p>因为在文件中和在内存中距离节初始位置的长度相同，所以地址为400+234h</p><h1 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h1><p>MessageBoxA-四个参数，执行后会出现弹窗-一般exe都有这个函数-user32.dll里面</p><p>让程序执行我们的代码，需要先找到OEP，修改为call我们函数的地址，然后再jmp回到原程序的OEP</p><p>call=E8+四个字节，jmp=E9+四个字节</p><p>但是这四个字节不是直接的地址，需要进行计算</p><blockquote><p>真正要跳转的地址=E8这条指令的下一行地址（当前指令地址+5，因为call长度是5）+X（X就是E8后边跟着的四个字节）</p></blockquote><p>push=0x6A</p><p>所以我们要加的程序硬编码 = 6A 00  6A 00  6A 00  6A 00  E8 00 00 00 00 E9 00 00 00 00</p><p>我们加入的代码必须加在拉伸后的文件中，也就是内存中的，因为我们计算的地址是拉伸后的地址</p><h2 id="添加代码过程-文件注入"><a href="#添加代码过程-文件注入" class="headerlink" title="添加代码过程-文件注入"></a>添加代码过程-文件注入</h2><p>1、先看代码空白区能不能填充那十八个字节——（SizeofRawData-VirtualSize）</p><p>2、找到添加的地方，假设我们开始是从1000h开始的，而SizeofRawData是1a0000，所以两者相加就是当前节结束的地址，而在1b0000之前为0的部分是代码块的空白部分</p><p>3、开始填充我们的那十八个字节</p><p>4、算地址，要计算内存对齐的地址，而不是文件对齐的，因为我们需要的是运行时的地址（内存对齐和文件对齐不同）</p><p>先找到MessageBoxA在内存中的地址，在OD里面使用命令bp MessageBoxA，按状态栏的B可以找到内存的地址</p><p>5、填充，注意小端序，E8跟着计算后的地址，E9跟着计算后的OEP（ImageBase+EntryPoint）</p><p>6、将原本的EntryOfPoint改为我们填充数据在内存中的地址</p><h1 id="任意代码节空白区添加代码"><a href="#任意代码节空白区添加代码" class="headerlink" title="任意代码节空白区添加代码"></a>任意代码节空白区添加代码</h1><p>从内存转为硬盘文件计算大小-最后一个节的初始位置+最后一个节的大小</p><h1 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h1><p>新增之后，修改NumberOfSections，节表信息，节表后面必须跟着一定长度的00数据（空白区），所以要计算增加之后SizeofHeaders会不会大于PointerOfRawData，并且在新增节最后加上一个节表信息长度的00</p><p>计算内存偏移VirtualAddress（RVA）时，根据上一个节区的VirtualAddress+（SizofRawData/VirtualSize[谁大加谁]）按照内存对齐后的数</p><p>如果编译器在节表中加入一些数据，而我们不能修改，节表又不能断，只能将NT头前移（加入数据之前的），这样再去添加新的节表信息，就不会占用编译器加入的数据</p><p>当DOS到NT头大小不够开辟一个节表的信息，只能扩充最后一个节</p><h1 id="扩大节-合并节-数据目录"><a href="#扩大节-合并节-数据目录" class="headerlink" title="扩大节-合并节-数据目录"></a>扩大节-合并节-数据目录</h1><p>扩大节：在内存中进行扩大，然后再还原回文件中，还原的时候要修改参数</p><p>1、拉伸到内存</p><p>2、分配新空间N=SizeofImage+Ex</p><p>3、将最后一个节的SizeOfRawdata和VirtualSize改为N</p><p>4、修改SizeofImage</p><p>合并节：合并之后节表有空间进行添加节区</p><p>VirtualSize=SizeofImage-VIrtualAddress</p><blockquote><p>数据目录-里面存储各种表的信息</p></blockquote><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646564515662.png"></p><p>下面介绍几种比较重要的</p><h1 id="DLL-动态链接库和静态链接库"><a href="#DLL-动态链接库和静态链接库" class="headerlink" title="DLL-动态链接库和静态链接库"></a>DLL-动态链接库和静态链接库</h1><p>使用的时候都需要include</p><p>程序编译的过程为将.h和.cpp等文件进行预编译，然后进行编译，再进行汇编，最后链接上（.a/.lib/.so/.dll）成为可执行文件</p><p>静态库、动态库区别来自【链接阶段】如何处理库（处理方式不同来区分），链接成可执行程序。分别称为静态链接方式、动态链接方式</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>使用的时候需要include和#pragma comment(lib,”xxx.lib”)</p><p>因为头文件只包含函数声明，函数实现在lib文件中</p><p>即在链接阶段，将源文件用到的库函数与汇编生成的文件.o等合并（即函数被包含在exe文件中）生成可执行文件</p><p>好处：方便程序移植，因为可执行程序与库函数再无关系，放入任何环境当中都可以执行</p><p>缺点：可执行文件太大（因为包含了库函数），每次库文件升级都需要重新编译源文件，每个可执行程序都会合并库函数，存在很大的重复性，占用空间大</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>两个程序应用一个库，目标文件在内存中只有一份，供所有程序使用，但是可移植性太差，如果两台电脑运行环境不同，动态库存放位置不同，可能会导致程序运行失败</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>1、将dll，lib文件添加到调用文件中</p><p>2、将#pragma comment(lib,”xxx.lib”)添加到调用文件中</p><p>3、加入函数的声明</p><p>extern “C” _declspec(dllimport) _stdcall int Plus(int x,int y);</p><p>导出则为dllexport，dll导出和导入的方式必须一致，即导出的时候使用了_stdcall，导入的时候也应该是__stdcall</p><p>这样的话如果需要修改函数，只需要在dll文件修改即可，程序不用编译</p><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>1、定义函数指针</p><p>typedef int (__stdcall *lpPlus)(int,int);</p><p>2、声明函数指针变量</p><p>lpPlus myPlus</p><p>3、动态加载dll到内存中</p><p>HINSTANCE hModule=LoadLibrary(“DllDemo.dll”);</p><p>4、获取函数地址</p><p>myPlus=(lpPlus)GetProcAddress(hModule,”_Plus@8”);(__stdcall为了区分会自动加符号)，如果导入的时候没加stdcall就不需要加符号，即myPlus=(lpPlus)GetProcAddress(hModule,”Plus”);</p><p>5、调用函数</p><p>int a=myPlus(1,2);</p><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>Handle是代表系统内核的对象，如文件句柄、线程句柄、进程句柄</p><p>HMODULE代表应用程序载入的模块-在内存中拉伸的起始位置</p><p>HINSTANCE在win32是和前一个一样的 win16遗留</p><p>HWND是窗口句柄</p><blockquote><p>上面的都是无符号整数，四个字节</p></blockquote><p>这样做是为了方便区分，操作系统给的</p><h3 id="def文件导出"><a href="#def文件导出" class="headerlink" title="def文件导出"></a>def文件导出</h3><p>为了隐藏函数的名字</p><p>和前面的类似，先创建动态链接库，头文件只需要函数声明</p><p>创建def文件后，在def文件中写入</p><blockquote><p>EXPORTS</p><p>(函数名)                编号</p><p>Plus                    @12——导出序号是12</p><p>在编号后面+NONAME 可以隐藏函数名</p></blockquote><h2 id="dll导出函数的方式"><a href="#dll导出函数的方式" class="headerlink" title="dll导出函数的方式"></a>dll导出函数的方式</h2><p>extern表示是个全局函数，可以供各个其他的函数调用</p><p>声明导出：_declspec(dllexport)</p><p>def文件导出</p><p>dll函数调用</p><p>隐式链接</p><p>包含头文件，载入lib库</p><p>显式链接</p><p>LoadLibary，GetProAddress</p><h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><p>作用：记载我们写的dll或者exe导出的函数</p><h2 id="导出表重要成员"><a href="#导出表重要成员" class="headerlink" title="导出表重要成员"></a>导出表重要成员</h2><p>1、指向导出表文件名的字符串-DWORD Name</p><p>2、导出函数的起始序号-DWORD Base</p><p>3、导出函数地址表RVA-DWORD AddressOfFunctions</p><p>4、函数名称地址表RVA-DWORD AddressOfNames</p><p>5、函数序号地址表RVA-DWORD AddressOfNameOrdinals</p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>1、找出导出表RVA的偏移</p><p>首先我们要在数据目录的导出表信息的第一项，也就是导出表地址的RVA偏移是多少</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621065982.png"></p><p>可以看出c000h是RVA偏移，大小是164个字节</p><h3 id="判断属于哪一个节"><a href="#判断属于哪一个节" class="headerlink" title="判断属于哪一个节"></a>判断属于哪一个节</h3><p>根据节区的VIrtualAddress判断</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621026524.png"></p><p>所以可以知道在.edata节</p><h3 id="算出FOA位置"><a href="#算出FOA位置" class="headerlink" title="算出FOA位置"></a>算出FOA位置</h3><p>我们知道是在.rdata节的，可以算出FOA</p><p>FOA=RVA-节区的VA（VirtualAddress）+节.PointerOfRawData</p><p>计算发现为8200h</p><h3 id="通过FOA找到导出表位置"><a href="#通过FOA找到导出表位置" class="headerlink" title="通过FOA找到导出表位置"></a>通过FOA找到导出表位置</h3><p>找到后根据前面的导出表大小可以知道导出表的范围</p><p>跳转过去即可</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621157564.png"></p><h2 id="导出表的存储方式"><a href="#导出表的存储方式" class="headerlink" title="导出表的存储方式"></a>导出表的存储方式</h2><p>一个导出表大小为0x28个字节，也就是两行半</p><p>分段讲解</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621661598.png"></p><p>前面十二个字节没用，就不讲了</p><h3 id="Dword-Name"><a href="#Dword-Name" class="headerlink" title="Dword Name"></a>Dword Name</h3><p>绿框的4个字节存储的是dll名称的RVA，想查看的话，可以计算FOA，和前面一样的，得到8250地址存储的是我们的dll名称，以00结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621843130.png"></p><h3 id="Dword-Base"><a href="#Dword-Base" class="headerlink" title="Dword Base"></a>Dword Base</h3><p>导出函数的起始序号</p><p> DLL导出的函数如果给序号了，那么就从这个序号开始</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622459296.png"></p><h3 id="Dword-NumberOfFunctions-所有的导出函数的个数"><a href="#Dword-NumberOfFunctions-所有的导出函数的个数" class="headerlink" title="Dword NumberOfFunctions-所有的导出函数的个数"></a>Dword NumberOfFunctions-所有的导出函数的个数</h3><p>前四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622410901.png"></p><h3 id="DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数"><a href="#DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数" class="headerlink" title="DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数"></a>DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数</h3><p>可以将两个不同的名字指向相同的地址</p><p>有一些是无名函数不会在里面</p><p>后四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622415877.png"></p><p>下面就是子表了，三个子表都是RVA，要转为FOA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622483098.png"></p><p>分别是函数地址表0x8228，函数名称表0x8238，函数序号表0x8248</p><blockquote><p>先去找函数名称表，根据名称的下标再去序号表找对应，然后再去函数地址表找</p></blockquote><h4 id="函数地址表-AddressOfFunctions"><a href="#函数地址表-AddressOfFunctions" class="headerlink" title="函数地址表-AddressOfFunctions"></a>函数地址表-AddressOfFunctions</h4><p>函数地址表指向一个偏移，这个偏移存放了所有导出函数的地址，每个地址占四个字节，存放的是RVA地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622927186.png"></p><p>ImageBase+函数偏移就是函数在内存中的实际地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646623978690.png"></p><p>可以看到这就是函数</p><p> 还需要注意的就是，如果你按照序号导出1 3 4 5这4个函数，在导入表中我们的函数地址表中的地址会有5个，原因就是：中断的序号会给我们用0填充，２虽然没有，但是也会给我们导出. </p><h4 id="函数名称表-AddressOfNames"><a href="#函数名称表-AddressOfNames" class="headerlink" title="函数名称表-AddressOfNames"></a>函数名称表-AddressOfNames</h4><p>函数名称表也是存储名称的RVA，四个字节存储一个，RVA的个数由以函数名称导出函数个数来决定（DWORD  NumberOfNames）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625166524.png"></p><p>转为FOA就是0x805e，0x8071,0x8082,0x8093</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625255683.png"></p><p>排序的时候是按照字母顺序排列的，而不是按照导出时函数的顺序进行排序的</p><p>例如:</p><p>　　EXPORT</p><p>　　　　SUB</p><p>　　　　ADD</p><p>　　　　MUL</p><p>导出三个函数，那么第一项就为 ADD，因为按照字母排序，A在前边，后面依次类推，所以我们上面看到的函数名称 ACquireSRW 这个函数名称，并不是第一个导出的函数.</p><h4 id="函数序号表-AddressOfNumberOrdinals－存储的是RVA"><a href="#函数序号表-AddressOfNumberOrdinals－存储的是RVA" class="headerlink" title="函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ"></a>函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ</h4><p>给名称用的中转表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625803927.png"></p><p>和函数名称表大小相同</p><h4 id="按名称导出"><a href="#按名称导出" class="headerlink" title="按名称导出"></a>按名称导出</h4><p>得到函数名称后去AddressOfNames中的函数名称对比，得到索引后根据索引取出AddressOfNameOrdinals存储的值，以此为索引去函数地址表找到函数的地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647329750554.png" alt="按名称导出过程"></p><p>函数数量计算方式=最大序号-最小序号+1，（连续的算得准）不连续的话在函数地址表会留有多余的地址，但是多余的地址没有被使用</p><h4 id="按序号导出"><a href="#按序号导出" class="headerlink" title="按序号导出"></a>按序号导出</h4><blockquote><p>当使用序号导出的时候不需要使用序号表，直接将序号-Base作为索引去函数地址表找即可</p></blockquote><h4 id="导出的过程"><a href="#导出的过程" class="headerlink" title="导出的过程"></a>导出的过程</h4><p>系统和我们前面说的不一样</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724098510.png" alt="1"></p><p>根据函数地址表找，如果索引在序号表中，说明是按名字导出的，再去名称表找对应，索引和序号表中的相同</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724264502.png"></p><p>这里的100a索引是3，在序号表中没有，所以不是按照序号导出的，序号可算，为索引+Base=005</p><h1 id="重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable"><a href="#重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable" class="headerlink" title="重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable"></a>重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable</h1><h2 id="程序的加载过程"><a href="#程序的加载过程" class="headerlink" title="程序的加载过程"></a>程序的加载过程</h2><p>系统加载的dll一般在高空间运行，一般是71**************</p><p>先像贴图一样把dll贴在内存中，最后指向exe文件的入口点，exe开始运行</p><p>我们自己写的dll的imageBase都是1000000，所以当多个dll同时使用，会存在地址已经被占用的问题，所以dl只能往后放，但是：</p><p>编译器生成的地址=ImageBase+RVA，这个地址在程序编译完成后，已经写入文件了。但是如果当程序加载时没有按照原来的ImageBase载入，但是此时程序还是会按照前面生成的地址进行使用</p><p>所以一般exe不存在重定位表，而dll一般都有，用于记录需要修改的地方</p><h2 id="重定位表解析"><a href="#重定位表解析" class="headerlink" title="重定位表解析"></a>重定位表解析</h2><p>重定位表是分块，根据RVA计算得到FOA，跳转过去发现有几个重定位表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727831045.png"></p><p>这两个数据分别存储RVA和大小</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727910599.png"></p><p>下面的数据中，每两个字节代表这一段有多少个数据需要修复，一般是绝对地址需要修改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646728080337.png"></p><p>只需要基础地址加上小表的值就可以定位到需要修改的地方，而不用四个字节来存储地址，节省了空间，而这个基础地址就是前面记录的RVA</p><p>而基础地址可以不同，所以才需要分块操作</p><p>可以发现每一块的间隔是1000h，也就是内存对齐的大小</p><p>一个页是1000h，所以只需要1000个十六进制的地址就可以记录完一页的每个位置，对应十进制的4096个</p><p>2^12=4096，所以只需要十二个二进制位就可以表示完所有可能，两个字节有十六位，所以最后找地址的时候，只用取低十二位，高四位有别的用处-如果高四位的值是3就说明这个地方需要修改</p><h3 id="判断块数"><a href="#判断块数" class="headerlink" title="判断块数"></a>判断块数</h3><p>下一块的开始地址都可以通过RVA+SizeOfBlock来得到</p><p>直到遇到全为零的块</p><p>计算需要修改的数据个数：(SizeOfBlock-8)/2，因为前面两个数据是8个字节，剩下的两个字节为1组</p><h1 id="移动导出表-重定位表"><a href="#移动导出表-重定位表" class="headerlink" title="移动导出表-重定位表"></a>移动导出表-重定位表</h1><p>表的数据也在节区中，加密代码时，表的信息也会被加密，这样程序无法初始化，所以要先增节，再移动表，学会移动各种表是对程序加密和破解的基础</p><h2 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h2><p>比较繁琐，因为要移动多张表</p><h3 id="在DLL文件中新增节"><a href="#在DLL文件中新增节" class="headerlink" title="在DLL文件中新增节"></a>在DLL文件中新增节</h3><p>先计算大小</p><p>并且返回新增节的FOA，因为后面的数据还要从新增节的开头开始</p><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>需要复制的数据类型和长度</p><h4 id="复制AddressOfFunctions"><a href="#复制AddressOfFunctions" class="headerlink" title="复制AddressOfFunctions"></a>复制AddressOfFunctions</h4><p>长度：4×NumberOfFunctions</p><h4 id="复制AddressOfNameOrdinals"><a href="#复制AddressOfNameOrdinals" class="headerlink" title="复制AddressOfNameOrdinals"></a>复制AddressOfNameOrdinals</h4><p>长度：2×NumberOfNames</p><h4 id="复制AddressOfNames"><a href="#复制AddressOfNames" class="headerlink" title="复制AddressOfNames"></a>复制AddressOfNames</h4><p>长度：4×NumberOfNames</p><h4 id="复制所有函数名"><a href="#复制所有函数名" class="headerlink" title="复制所有函数名"></a>复制所有函数名</h4><p>长度不确定，复制时直接修复AddressOfName（因为名字的地址也改变了），每复制完一个名字，都需要计算下一个复制的地方</p><h4 id="复制导出表的整体结构"><a href="#复制导出表的整体结构" class="headerlink" title="复制导出表的整体结构"></a>复制导出表的整体结构</h4><h3 id="修复地址"><a href="#修复地址" class="headerlink" title="修复地址"></a>修复地址</h3><p>AddressOfName</p><p>目录项指向新的导出表的位置</p><p>函数地址表、序号表、名称表都需要修复</p><h3 id="将目录项中的RVA修正"><a href="#将目录项中的RVA修正" class="headerlink" title="将目录项中的RVA修正"></a>将目录项中的RVA修正</h3><p>指向我们新的导出表的位置</p><h2 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h2><p>直接复制过去，修改RVA即可</p><p>加载程序：（当前面已经有DLL被加载）</p><p>1、将新的DLL复制到新的位置</p><p>2、修复重定位表，修改每一个重定位表的偏移</p><h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>作用：从其他第三方程序导入API，以供本程序调用</p><p>在exe运行的时候加载器会遍历导入表，将导入表中所有dll加载到进程中，被加载的DLL的DLLMain就会被调用</p><p>通过导入表可以知道程序使用了哪些函数</p><p> 导入表，是为了提供的要导入的dll的函数的地址，只不过由于dll地址不固定，所以每次都会重新修正 </p><h2 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h2><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><pre class="language-c" data-language="c"><code class="language-c">DWORD OriginalFirstThunk;</code></pre><p>指向导入名称表（INT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   FirstThunk;</code></pre><p>指向导入地址表（IAT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   Name;</code></pre><p>指向导入映像文件的名字</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788456499.png"></p><p>计算后跳转过去，注意要算的是FOA，但是这里RVA和FOA一样 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788490238.png"></p><p>其中IAT与INT都指向 IMAGE_THUNK_DATA32（虽然二者的地址不同）</p><p>INT-以全0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788999608.png">          函数名数组(对应IMAGE_THUNK_DATA32结构体数组,每一个结构体就是一个联合体-4字节) </p><pre class="language-c" data-language="c"><code class="language-c">typedef struct  _IMAGE_THUNK_DATA32{union{//联合体，实际是4字节DWORD ForwarderString;DWORD Function;//导入函数的地址,在加载到内存之后,这里才起作用DWORD Ordinal;//假如是序号导入的,会用到这里DWORD AddressOfData;//假如是函数名导入,会用到这里,它指向另外一个结构体PIMAGE_IMPORT_BY_NAME}u1;}IMAGE_THUNK_DATA32;//如果是函数名导入的,AddressOfData会指向下面这个结构体typedef struct _IMAGE_IMPORT_BY_NAME{WORD  Hint;//序号CHAR Name[1];//不定长,字符串}</code></pre><h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><p>在可选PE头最后的十六个数组的导入表结构，这里存放的是RVA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646998855451.png"></p><p>跳转过去发现存储的是struct IMAGE_IMPORT_DESCRIPTOR ImportDescriptor[0]，这里存放的是真正的导入表结构</p><p>有多少个DLL，对应的结构体数组就有几个</p><p>关键的数据有下面三个，也要注意这里的TimeDateStamp-时间戳</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999149540.png"></p><h3 id="INT表"><a href="#INT表" class="headerlink" title="INT表"></a>INT表</h3><p><em><strong>ULONG OriginalFirstThunk-RVA</strong></em>，存放的是IMAGE_THUNK_DATA这个结构体数组，四字节数，以0结尾</p><p>跳转过去</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999423139.png"></p><p> 但是之前学导出表有了解到，导出函数可以以名字导出，亦可以序号导出。所以为了方便区分，就将这INT表的每个值做了细微调整。</p><blockquote><p> 如果这个4字节数的最高位（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。 </p></blockquote><p>根据INT存储的RVA进行跳转</p><h4 id="struct-IMAGE-IMPORT-BY-NAME"><a href="#struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="struct _IMAGE_IMPORT_BY_NAME"></a>struct _IMAGE_IMPORT_BY_NAME</h4><p>1、WORD Hint，可能为0，编译器决定，如果不为0，则是函数在导出表中的索引</p><p>2、BYTE Name[1]，函数名称，以0结尾</p><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>DLL的名字，以0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999638790.png"></p><h3 id="ULONG-FirstThunk"><a href="#ULONG-FirstThunk" class="headerlink" title="ULONG FirstThunk"></a>ULONG FirstThunk</h3><p>根据RVA跳转，发现存储的值和INT的一样，这个存储的是IAT，当文件加载后，会发现IAT会改变</p><h4 id="IAT表-导入地址表"><a href="#IAT表-导入地址表" class="headerlink" title="IAT表-导入地址表"></a>IAT表-导入地址表</h4><p> 记录程序正在使用哪些库中的哪些函数 </p><p>分为两个过程，在文件中存储的是存放函数的地址，在内存中存放函数</p><p>在文件运行前类似于call [地址]</p><p>在文件运行时类似于call [上面地址存放的值，也就是函数]</p><h4 id="IAT表存在的原因"><a href="#IAT表存在的原因" class="headerlink" title="IAT表存在的原因"></a>IAT表存在的原因</h4><p> 一般程序在调用自身函数的时候，自身函数地址RAV是固定的；但是当程序在调用dll里的函数的时候，由于dll的地址会发生重定位，导致dll里的函数地址每次都会发生变化。 </p><p>为了准确调用dll函数的地址，构造了IAT表来存储程序运行时，即DLL文件重定位之后的dll函数的位置</p><h2 id="导入表加载过程"><a href="#导入表加载过程" class="headerlink" title="导入表加载过程"></a>导入表加载过程</h2><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAzMjg0Ni5wbmc-1647000237348.png" alt="PE文件加载前"></p><p>加载过程</p><p>先找DLL，再确定使用的函数</p><h3 id="寻找DLL"><a href="#寻找DLL" class="headerlink" title="寻找DLL"></a>寻找DLL</h3><p>先根据导入表的NAME找到DLL名称和DLL的INT和IAT表，开始的时候INT和IAT数据相同，但是存储位置不同</p><h3 id="查INT表"><a href="#查INT表" class="headerlink" title="查ＩＮＴ表"></a>查ＩＮＴ表</h3><p>因为导出的时候可以按序号导出也可以按函数名称导出，所以为了区分，ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ最高位为１时，表示其存储的是序号，而剩下的３１位表示序号，否则ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ存储的是函数名称的ＲＶＡ</p><h3 id="修改IAT"><a href="#修改IAT" class="headerlink" title="修改ＩＡＴ"></a>修改ＩＡＴ</h3><p>使用ＧＥＴＰｒｏＡｄｄｒ（ｍｏｄｕｌｅ）</p><p>将前面查找到的函数地址填充进ＩＡＴ表中</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAyNTEwMy5wbmc.png" alt="PE文件加载后"> </p><p>可以看到IAT表变成了函数的地址</p><p> IAT表会存储dll的函数的地址，方便调用该函数时，直接取IAT表这个地址内的值，作为函数地址，去CALL。</p><h1 id="绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR"><a href="#绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR" class="headerlink" title="绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR"></a>绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR</h1><p>可选NT头里的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647001593786.png"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 有些windows程序，如notepad，为了提高加载速度，会直接把DLL中的函数地址写入到IAT表，省去了加载时的计算。 </p><h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p> 第一，当DLL没有占住ImageBase时，IAT中的地址就是错的；第二，当链接的DLL被修改了，那IAT里写的地址也是错的。遇到这两种情形之一，加载时就必须修复IAT了。 </p><p>对于第二种情形，DLL是否被修改，是根据比较DLL的时间戳和绑定导入表中的记录的DLL时间戳来判断的，如果不一致，说明DLL被修改了。</p><p>加载程序时，操作系统根据导入表中的时间戳来判断程序是否使用了绑定导入。当时间戳为0，表示不使用绑定导入表；当时间戳为0xFFFFFFFF，说明该程序使用绑定导入。</p><h2 id="绑定导入表结构"><a href="#绑定导入表结构" class="headerlink" title="绑定导入表结构"></a>绑定导入表结构</h2><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    NumberOfModuleForwarderRefs;// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></pre><p> TimeDateStamp 是时间戳，用于和DLL中的时间戳比较，判断DLL是否已经发生变化； </p><p> OffsetModuleName 是当前模块名距离第一个 _IMAGE_BOUND_IMPORT_DESCRIPTOR 的偏移。</p><p>  NumberOfModuleForwarderRefs 是该模块依赖的模块数量； </p><h3 id="依赖模块结构"><a href="#依赖模块结构" class="headerlink" title="依赖模块结构"></a>依赖模块结构</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_FORWARDER_REF {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    Reserved;} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;</code></pre><p> 除了第三个属性保留，其他与 _IMAGE_BOUND_IMPORT_DESCRIPTOR 相同。 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647049008006.png" alt="绑定导入表"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PE文件&quot;&gt;&lt;a href=&quot;#PE文件&quot; class=&quot;headerlink&quot; title=&quot;PE文件&quot;&gt;&lt;/a&gt;PE文件&lt;/h1&gt;&lt;p&gt;主要有exe、dll、sys文件，这些都是可执行文件&lt;/p&gt;
&lt;p&gt;exe由多个exe文件组成，dll之类的&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>hgame2022-WOW-patch数据段</title>
    <link href="https://gift1a.github.io/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/"/>
    <id>https://gift1a.github.io/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/</id>
    <published>2022-02-22T11:57:59.000Z</published>
    <updated>2022-03-11T05:10:53.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531507324.png"></p><p>可以看到上面这一段是输入并且把加密后的输入赋值给Buf2，在这之后已经结束了判断，所以下面红色框的代码应该是解密代码，只需要把Buf在栈中进行修改为final字符串即可</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531624170.png"></p><p>这里点过去发现并没有数据，这可能是一些数据没有反编译出来，但是在图中蓝色部分可以看到地址是ebp-54</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531725452.png">计算一下，在堆栈窗口按g进行跳转</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531744867.png"></p><p>跳转之后</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531761124.png"></p><p>然后右键Edit，或者按快捷键F2，然后进行修改，注意大小端序的问题，这里使用lazyida选择DWORD导出来就很方便，再次右键，应用修改</p><p>然后运行即可，就可以在input看到flag了</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531871154.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1</summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>hgame-misc</title>
    <link href="https://gift1a.github.io/2022/02/19/hgame-misc/"/>
    <id>https://gift1a.github.io/2022/02/19/hgame-misc/</id>
    <published>2022-02-18T19:05:16.000Z</published>
    <updated>2022-03-11T05:11:08.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总算是结束了，下面就记录一下misc遇到的一些题目</p><h1 id="这个压缩包有点麻烦"><a href="#这个压缩包有点麻烦" class="headerlink" title="这个压缩包有点麻烦"></a>这个压缩包有点麻烦</h1><h2 id="相关知识-压缩包"><a href="#相关知识-压缩包" class="headerlink" title="相关知识-压缩包"></a>相关知识-压缩包</h2><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p><img src="/2022/02/19/hgame-misc/1645212044252.png"></p><p>可以看到在zip给出了密码的提示，六位纯数字，Advanced Archive Password Recovery爆破</p><p><img src="/2022/02/19/hgame-misc/1645212152522.png"></p><p><img src="/2022/02/19/hgame-misc/1645212207157.png"></p><p>根据提示，给出的应该是字典，我们同样在爆破软件中选择字典</p><p><img src="/2022/02/19/hgame-misc/1645212320305.png"></p><p>继续下一步</p><p><img src="/2022/02/19/hgame-misc/1645212429206.png"></p><p>他让我们重新储存，把readme文件选择以存储的方式压缩发现</p><p><img src="/2022/02/19/hgame-misc/1645212573216.png"></p><p>这两个的CRC32的值是一样的，但是我们知道CRC32的值只有一个，所以使用明文攻击，这里4.5没跑出来，4.0跑出来了</p><p>在jpg文件尾部发现了zip，另存一下，是伪加密</p><p><img src="/2022/02/19/hgame-misc/1645213950846.png"></p><p>修复后得到flag</p><p><img src="/2022/02/19/hgame-misc/1645214098403.png"></p><h1 id="你上当了-我的很大"><a href="#你上当了-我的很大" class="headerlink" title="你上当了 我的很大"></a>你上当了 我的很大</h1><h2 id="相关知识-二维码"><a href="#相关知识-二维码" class="headerlink" title="相关知识-二维码"></a>相关知识-二维码</h2><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p>解压之后得到很多的视频，但都是重复的，有用的就几个，主要记录一下各种二维码的样子，以免之后认不出来</p><p><a href="https://barcode.tec-it.com/zh/CodablockF">https://barcode.tec-it.com/zh/CodablockF</a></p><p>这个网站可以生成不同的二维码，便于识别</p><p><a href="https://products.aspose.app/barcode/recognize#">https://products.aspose.app/barcode/recognize#</a></p><p>这个网站识别比较全</p><p><img src="/2022/02/19/hgame-misc/1645213399267.png"></p><p><img src="/2022/02/19/hgame-misc/1645213453036.png"></p><p><img src="/2022/02/19/hgame-misc/1645213467874.png"></p><h1 id="谁不喜欢猫猫呢"><a href="#谁不喜欢猫猫呢" class="headerlink" title="谁不喜欢猫猫呢"></a>谁不喜欢猫猫呢</h1><p><a href="https://blog.csdn.net/mochu7777777/article/details/122631962-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E8%84%9A%E6%9C%AC%E4%B8%8D%E4%BC%9A%E5%86%99">https://blog.csdn.net/mochu7777777/article/details/122631962-可以看看，脚本不会写</a></p><h1 id="摆烂"><a href="#摆烂" class="headerlink" title="摆烂"></a>摆烂</h1><h2 id="相关知识-盲水印、APng、零宽隐写"><a href="#相关知识-盲水印、APng、零宽隐写" class="headerlink" title="相关知识-盲水印、APng、零宽隐写"></a>相关知识-盲水印、APng、零宽隐写</h2><h2 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h2><p>foremost分离压缩包得到png文件，也可以复制文件信息之后另存为，将png拖进010发现奇怪的地方</p><p><img src="/2022/02/19/hgame-misc/1645214249445.png"></p><p>正常的png文件是没有fdAT数据段的 APng-<a href="https://www.jianshu.com/p/5333bcc20ba7">https://www.jianshu.com/p/5333bcc20ba7</a></p><p>查阅资料发现是Apng，这里介绍一个分解Apng的网址</p><p><a href="https://ezgif.com/split">https://ezgif.com/split</a></p><p>得到两张一模一样的图片，这时候就想到了盲水印</p><p><img src="/2022/02/19/hgame-misc/1645214469303.png"></p><p>得到带有密码的图片</p><p><img src="/2022/02/19/hgame-misc/1645214585213.png"></p><p>得到密钥解压压缩包，拼接二维码，扫码得到</p><p><img src="/2022/02/19/hgame-misc/1645214612749.png"></p><p>发现很多问号，应该就是零宽了，这里我手机扫码后的信息再拿去解密-<a href="https://330k.github.io/misc_tools/unicode_steganography.html">https://330k.github.io/misc_tools/unicode_steganography.html</a></p><p><img src="/2022/02/19/hgame-misc/1645214720413.png"></p><h1 id="At0m的给你们的-迟到的-情人节礼物"><a href="#At0m的给你们的-迟到的-情人节礼物" class="headerlink" title="At0m的给你们的(迟到的)情人节礼物"></a>At0m的给你们的(迟到的)情人节礼物</h1><h2 id="相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具"><a href="#相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具" class="headerlink" title="相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具"></a>相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具</h2><h2 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h2><p>一般数据流隐写都采取winrar，所以要关注rar文件</p><p>这里解压之后时候NTFS工具得到</p><p><img src="/2022/02/19/hgame-misc/1645214827597.png"></p><p>四个方向对应四进制，解码的到 6557225 </p><p>还有一个avi文件，一般是MSU StegoVideo工具</p><p>下载好之后选择好avi文件，并且指定写入的文本 ，输入密码即可</p><p>hgame{Q1ng_R3n_J1e_Da_Sh4_CTF}                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;总算是结束了，下面就记录一下misc遇到的一些题目&lt;/p&gt;
&lt;h1 id=&quot;这个压缩包有点麻烦&quot;&gt;&lt;a href=&quot;#这个压缩包有点麻烦&quot; </summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>pyc加花指令</title>
    <link href="https://gift1a.github.io/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <id>https://gift1a.github.io/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/</id>
    <published>2022-02-14T12:10:12.000Z</published>
    <updated>2022-03-11T05:12:19.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VNCTF2022-BabyMaze"><a href="#VNCTF2022-BabyMaze" class="headerlink" title="VNCTF2022-BabyMaze"></a>VNCTF2022-BabyMaze</h1><p>pyc相关知识-<a href="https://zhuanlan.zhihu.com/p/145811103">https://zhuanlan.zhihu.com/p/145811103</a></p><p>使用uncompyle6发现无法反编译，应该是添加了花指令</p><p>先查看字节码</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import marshal, disf = open("D:\\new\\AD\\game\\vnctf2022\\re\\BabyMaze.pyc", "rb").read()code = marshal.loads(f[16:]) #这边从16位开始取因为是python3 python2从8位开始取dis.dis(code)</code></pre><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848858641.png"></p><p>发现这一段就是花指令</p><p>去python的包里面搜索opcode.h，找到对应的字节码</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848986760.png"></p><p>转为十六进制后去010editor修改，去掉即可</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849226023.png"></p><p>但是发现还是不行，这是因为</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849421077.png"></p><p>pyc文件有co_code，所以修改长度之后要修改它</p><p>先打印出来长度，然后计算后修改</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849766935.png"></p><p>2030-6=7E8</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849849453.png"></p><p>重新uncompyle6</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849958666.png"></p><p>反编译成功，接下来就是maze图，打印出来之后手打</p><h1 id="Pyc字节码阅读-unctf2021-pytrade"><a href="#Pyc字节码阅读-unctf2021-pytrade" class="headerlink" title="Pyc字节码阅读-unctf2021-pytrade"></a>Pyc字节码阅读-unctf2021-pytrade</h1><p>得到两个txt文件，一个是py的字节码，一个是输出</p><p>对字节码进行分析</p><p><a href="https://www.jianshu.com/p/557cfe36f0f0">https://www.jianshu.com/p/557cfe36f0f0</a></p><p><a href="https://bbs.pediy.com/thread-246683.htm">https://bbs.pediy.com/thread-246683.htm</a></p><p><a href="https://docs.python.org/zh-cn/3/library/dis.html">https://docs.python.org/zh-cn/3/library/dis.html</a>  这是python3的</p><pre class="language-python" data-language="python"><code class="language-python">0 LOAD_CONST               1 ('XXXXXX')       //This is flag,try to figure it out ! Don't forget to fill it in flag{} !             2 STORE_FAST               0 (flag)</code></pre><p>LOAD_CONST加载const变量，比如数值、字符串等，一般用于传给函数参数</p><p>STORE_FAST 一般用于保存值到局部变量</p><p>这句话意思是</p><pre class="language-none"><code class="language-none">flag='XXXXXXXX'</code></pre><p>第二段</p><pre class="language-python" data-language="python"><code class="language-python">4 LOAD_CONST               2 (0) const变量，一般用于传给函数的参数             6 BUILD_LIST               1  创建列表             8 LOAD_CONST               3 (18)   const变量  num=[0]*18            10 BINARY_MULTIPLY                12 STORE_FAST               1 (num) 保存值到局部变量中</code></pre><p>BINARY_MULTIPLY 是二元运算，即将栈顶的前两个元素取出进行计算，结果压回栈中 </p><p>BUILD_LIST 创建列表</p><pre class="language-none"><code class="language-none">num=[0]*18</code></pre><p>第三段</p><pre class="language-python" data-language="python"><code class="language-python">14 LOAD_CONST               2 (0)             16 STORE_FAST               2 (k)</code></pre><pre class="language-python" data-language="python"><code class="language-python">k=0</code></pre><p>第四段</p><pre class="language-python" data-language="python"><code class="language-python">18 LOAD_GLOBAL              0 (range) 加载全局变量             20 LOAD_GLOBAL              1 (len)              22 LOAD_FAST                0 (flag)              24 CALL_FUNCTION            1调用一个函数，在此之前要先赋值 len(flag)             26 CALL_FUNCTION            1  range(len(flag))             28 GET_ITER取迭代器        &gt;&gt;   30 FOR_ITER               112 (to 144)  一直到144都是for循环             32 STORE_FAST               3 (i) </code></pre><p> LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。当和函数搭配时，要注意有CALL_FUNCTION</p><p>LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。这里调用完len之后，要使用其传值，这里传入flag</p><p>前半段意思是</p><pre class="language-python" data-language="python"><code class="language-python">range(len(flag))</code></pre><p>GET_ITER创建迭代器，一般是for循环</p><p>FOR_ITER(to 144)表示迭代器一直到144</p><p>STORE_FAST 创建局部变量，这里作为for循环的索引</p><pre class="language-python" data-language="python"><code class="language-python">for i in range(len(flag)):</code></pre><p>第五段</p><pre class="language-python" data-language="python"><code class="language-python">7          34 LOAD_GLOBAL              2 (ord)             36 LOAD_FAST                0 (flag)            38 LOAD_FAST                3 (i)            40 BINARY_SUBSCR索引运算            42 CALL_FUNCTION            1ord(flag[i])            44 LOAD_FAST                3 (i)            46 BINARY_ADD+i            48 LOAD_FAST                2 (k)            50 LOAD_CONST               4 (3)            52 BINARY_MODULO//取模运算 k%3            54 LOAD_CONST               5 (1)             56 BINARY_ADD(k%3)+1            58 BINARY_XOR(ord(flag[i])+i)^(k%3+1)            60 LOAD_FAST                1 (num)            62 LOAD_FAST                3 (i)            64 STORE_SUBSCR num[i]</code></pre><p>BINARY_SUBSCR下标 访问操作</p><p>BINARY_ADD也是二元运算，相加</p><p>BINARY_MODULO，二元运算取模</p><p>BINARY_XOR二元运算异或</p><p>STORE_SUBSCR下标访问操作</p><pre class="language-python" data-language="python"><code class="language-python">num[i]= (ord(flag[i]) + i) ^ (k % 3 + 1)</code></pre><p>第六段</p><pre class="language-python" data-language="python"><code class="language-python">8          66 LOAD_GLOBAL              2 (ord)             68 LOAD_FAST                0 (flag)             70 LOAD_GLOBAL              1 (len)             72 LOAD_FAST                0 (flag)             74 CALL_FUNCTION            1len(flag)             76 LOAD_FAST                3 (i)len(flag)-i             78 BINARY_SUBTRACT             80 LOAD_CONST               5 (1)             82 BINARY_SUBTRACT减法len(flag)-i-1             84 BINARY_SUBSCR索引运算flag[len(flag)-i-1]             86 CALL_FUNCTION            1ord(flag[len(flag)-i-1])             88 LOAD_GLOBAL              1 (len)             90 LOAD_FAST                0 (flag)             92 CALL_FUNCTION            1len(flag)             94 BINARY_ADDord(flag[len(flag)-i-1])+len(flag)-i-1             96 LOAD_FAST                3 (i)             98 BINARY_SUBTRACT            100 LOAD_CONST               5 (1)            102 BINARY_SUBTRACT            104 LOAD_FAST                2 (k)            106 LOAD_CONST               4 (3)            108 BINARY_MODULOk%3            110 LOAD_CONST               5 (1)            112 BINARY_ADDk%3+1            114 BINARY_XORord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)            116 LOAD_FAST                1 (num)            118 LOAD_GLOBAL              1 (len)            120 LOAD_FAST                0 (flag)len(flag)            122 CALL_FUNCTION            1            124 LOAD_FAST                3 (i)            126 BINARY_SUBTRACTlen(flag)-i            128 LOAD_CONST               5 (1)            130 BINARY_SUBTRACTlen(flag)-i-1            132 STORE_SUBSCRnum[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>BINARY_SUBTRACT二元运算减法</p><pre class="language-python" data-language="python"><code class="language-python">num[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>第七段</p><pre class="language-python" data-language="python"><code class="language-python">9         134 LOAD_FAST                2 (k)            136 LOAD_CONST               5 (1)            138 INPLACE_ADDk++            140 STORE_FAST               2 (k)            142 JUMP_ABSOLUTE           30//循环结束</code></pre><p>JUMP_ABSOLUTE绝对跳转，结束循环</p><p>INPLACE_ADD  计算结果可以被操作数引用的到，每一个 二元运算，都对应一个inplace 运算 </p><pre class="language-python" data-language="python"><code class="language-python">k+=1</code></pre><p>第八段</p><pre class="language-python" data-language="python"><code class="language-python">10     &gt;&gt;  144 LOAD_GLOBAL              3 (print)            146 LOAD_FAST                1 (num)            148 CALL_FUNCTION            1 print(num)            150 POP_TOP            152 LOAD_CONST               0 (None)            154 RETURN_VALUE</code></pre><pre class="language-none"><code class="language-none">print(num)</code></pre><h1 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h1><p>python3.9，无法uncompyle6，使用pycdc翻译成字节码</p><pre class="language-python" data-language="python"><code class="language-python">main.pyc (Python 3.9)[Code]    File Name: main.py    Object Name: &lt;module&gt;    Arg Count: 0    Pos Only Arg Count: 0    KW Only Arg Count: 0    Locals: 0    Stack Size: 4    Flags: 0x00000040 (CO_NOFREE)    [Names]        'base64'        'encode'        'enCodeAgain'        'correct'        'flag'        'print'        'input'    [Var Names]    [Free Vars]    [Cell Vars]    [Constants]        0        None        [Code]            File Name: main.py            Object Name: encode            Arg Count: 1            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 4            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'chr'                'base64'                'b64encode'                'encode'            [Var Names]                'message'                's'                'i'                'x'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                32                16                'utf-8' [Disassembly]                0       LOAD_CONST              1: ''                2       STORE_FAST              1: s       s=''                4       LOAD_FAST               0: message                6       GET_ITER                                8       FOR_ITER                32 (to 42) for i in message:                10      STORE_FAST              2: i                   12      LOAD_FAST               2: i                  14      LOAD_CONST              2: 32                16      BINARY_XOR               i^32                18      STORE_FAST              3: xx=i^32                20      LOAD_FAST               3: x                22      LOAD_CONST              3: 16                24      BINARY_ADD              x+16                26      STORE_FAST              3: xx=x+16                28      LOAD_FAST               1: s                30      LOAD_GLOBAL             0: chr                32      LOAD_FAST               3: x                    34      CALL_FUNCTION           1  chr(x)                36      INPLACE_ADD             s+chr(x)                38      STORE_FAST              1: ss=s+chr(x)                40      JUMP_ABSOLUTE           8    循环结束                42      LOAD_GLOBAL             1: base64                44      LOAD_METHOD             2: b64encodebase64.b64                46      LOAD_FAST               1: s                48      LOAD_METHOD             3: encode   LOAD_METHOD是加载类，CALL调用                50      LOAD_CONST              4: 'utf-8'                 52      CALL_METHOD             1                  54      CALL_METHOD             1 base64.b64(s.encode('utf-8'))                56      RETURN_VALUE            return  base64.b64(s.encode('utf-8'))        'encode'        [Code]            File Name: main.py            Object Name: enCodeAgain            Arg Count: 2            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 5            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'str'                'range'                'len'            [Var Names]                'string'                'space'                's'                'i'                'j'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                'utf-8'                0            [Disassembly]                0       LOAD_CONST              1: ''                  2       STORE_FAST              2: ss=''                4       LOAD_GLOBAL             0: str                6       LOAD_FAST               0: string                8       LOAD_CONST              2: 'utf-8'                 10      CALL_FUNCTION           2//参数个数 str(string,'utf-8')                12      STORE_FAST              0: string string=str(string,'utf-8')                14      LOAD_GLOBAL             1: range                 16      LOAD_CONST              3: 0                18      LOAD_FAST               1: space                20      CALL_FUNCTION           2 range(0,space)                22      GET_ITER                //创建迭代器                24      FOR_ITER                50 (to 76)                 26      STORE_FAST              3: ifor i range(0,space):                28      LOAD_GLOBAL             1: range                 30      LOAD_FAST               3: i                32      LOAD_GLOBAL             2: len                34      LOAD_FAST               0: string                36      CALL_FUNCTION           1len(string)                38      LOAD_FAST               1: space                40      CALL_FUNCTION           3                 42      GET_ITER                                44      FOR_ITER                28 (to 74)                46      STORE_FAST              4: j  for j in range(i,len(string),space)                48      LOAD_FAST               4: j                 50      LOAD_GLOBAL             2: len                52      LOAD_FAST               0: string                54      CALL_FUNCTION           1  len(string)                56      COMPARE_OP              0 (&lt;)if(j&lt;len(string))                58      POP_JUMP_IF_FALSE       44跳转                60      LOAD_FAST               2: s                62      LOAD_FAST               0: string                64      LOAD_FAST               4: j                66      BINARY_SUBSCR           string[j]                68      INPLACE_ADD                             70      STORE_FAST              2: s      s+=string[j]                72      JUMP_ABSOLUTE           44第二个循环                74      JUMP_ABSOLUTE           24第一个循环                76      LOAD_FAST               2: s                78      RETURN_VALUE             return s        'enCodeAgain'        'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        ''        'Input flag:'        'utf-8'        2        'correct'        'wrong'    [Disassembly]        0       LOAD_CONST              0: 0        2       LOAD_CONST              1: None        4       IMPORT_NAME             0: base64        6       STORE_NAME              0: base64import base64        8       LOAD_CONST              2: &lt;CODE&gt; encode        10      LOAD_CONST              3: 'encode' //函数        12      MAKE_FUNCTION           0        14      STORE_NAME              1: encode        16      LOAD_CONST              4: &lt;CODE&gt; enCodeAgain        18      LOAD_CONST              5: 'enCodeAgain'        20      MAKE_FUNCTION           0//第二个函数        22      STORE_NAME              2: enCodeAgain        24      LOAD_CONST              6: 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        26      STORE_NAME              3: correctcorrect=VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ=        28      LOAD_CONST              7: ''        30      STORE_NAME              4: flagflag=''        32      LOAD_NAME               5: print        34      LOAD_CONST              8: 'Input flag:'        36      CALL_FUNCTION           1print('Int flag:')        38      POP_TOP                         40      LOAD_NAME               6: input        42      CALL_FUNCTION           0input()        44      STORE_NAME              4: flagflag=input()        46      LOAD_NAME               4: flag        48      LOAD_METHOD             1: encode        50      LOAD_CONST              9: 'utf-8'        52      CALL_METHOD             1        54      STORE_NAME              4: flagflag=flag.encode('utf-8')        56      LOAD_NAME               5: print        58      LOAD_NAME               2: enCodeAgain        60      LOAD_NAME               1: encode        62      LOAD_NAME               4: flag        64      CALL_FUNCTION           1        66      LOAD_CONST              10: 2 其中一个参数        68      CALL_FUNCTION           2//两个参数        70      CALL_FUNCTION           1print(enCodeAgain(encodee(flag),2))        72      POP_TOP                 函数栈顶元素出栈        74      LOAD_NAME               2: enCodeAgain        76      LOAD_NAME               1: encode        78      LOAD_NAME               4: flag        80      CALL_FUNCTION           1        82      LOAD_CONST              10: 2        84      CALL_FUNCTION           2(enCodeAgain(encodee(flag),2))        86      LOAD_NAME               3: correct        88      COMPARE_OP              2 (==)//比较        90      POP_JUMP_IF_FALSE       102跳转        92      LOAD_NAME               5: print        94      LOAD_CONST              11: 'correct'        96      CALL_FUNCTION           1print('correct')        98      POP_TOP                         100     JUMP_FORWARD            8 (to 110)结束        102     LOAD_NAME               5: print        104     LOAD_CONST              12: 'wrong'        106     CALL_FUNCTION           1print('wrong)        108     POP_TOP                         110     LOAD_CONST              1: None        112     RETURN_VALUE            </code></pre><pre class="language-python" data-language="python"><code class="language-python">import base64def encode(message):    s = ''    for i in message:        x = i ^ 32        x += 16        s += chr(x)        return (base64.b64encode(s.encode('utf-8')))def enCodeAgain(string, space):    s = ''    string = str(string, 'utf-8')    for i in range(0, space):        for j in range(i, len(string), space):            if j &lt; len(string):                s += string[j]    return scorrect = 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='flag = ''print('Input flag:')flag = input()flag = flag.encode('utf-8')print(enCodeAgain(encode(flag), 2))if enCodeAgain(encode(flag), 2) == correct:    print(correct)else:    print('wrong')</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VNCTF2022-BabyMaze&quot;&gt;&lt;a href=&quot;#VNCTF2022-BabyMaze&quot; class=&quot;headerlink&quot; title=&quot;VNCTF2022-BabyMaze&quot;&gt;&lt;/a&gt;VNCTF2022-BabyMaze&lt;/h1&gt;&lt;p&gt;pyc相关知</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
</feed>
