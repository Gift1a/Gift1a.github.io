<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-07-13T12:14:02.172Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法刷题</title>
    <link href="https://gift1a.github.io/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <id>https://gift1a.github.io/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</id>
    <published>2022-07-13T12:14:02.000Z</published>
    <updated>2022-07-13T12:14:02.172Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA学习</title>
    <link href="https://gift1a.github.io/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-07-09T15:27:26.000Z</published>
    <updated>2022-07-13T12:32:42.372Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA</p><span id="more"></span><h1 id="IDE"><a class="header-anchor" href="#IDE">¶</a>IDE</h1><p>对于IntelliJ IDEA，首先需要创建项目，然后添加包，最后创建类，然后开始写函数</p><h1 id="JAVA数据类型"><a class="header-anchor" href="#JAVA数据类型">¶</a>JAVA数据类型</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;JAVA&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-08T08:38:10.000Z</published>
    <updated>2022-07-13T12:32:27.063Z</updated>
    
    <content type="html"><![CDATA[<p>数据结构与算法</p><span id="more"></span><h1 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h1><h2 id="基本概念和术语"><a class="header-anchor" href="#基本概念和术语">¶</a>基本概念和术语</h2><h3 id="数据"><a class="header-anchor" href="#数据">¶</a>数据</h3><p>数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</p><p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录</p><p>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位</p><p>数据对象：是性质相同的数据元素的集合，是数据的子集</p><h3 id="结构"><a class="header-anchor" href="#结构">¶</a>结构</h3><p>不同数据元素之间不是独立的，而是存在特定的关系，而这些关系就是结构</p><p><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</strong></p><h2 id="逻辑结构与物理结构"><a class="header-anchor" href="#逻辑结构与物理结构">¶</a>逻辑结构与物理结构</h2><p>逻辑结构是面向问题的，物理结构就是面向计算机的，其基本的目标就是将数据及逻辑关系存储到计算机的内存中</p><h3 id="逻辑结构"><a class="header-anchor" href="#逻辑结构">¶</a>逻辑结构</h3><p>逻辑结构：<strong>是指数据对象数据元素之间的相互关系</strong>，这也是我们今后需要关注的地方</p><h4 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h4><p>使用示意图表示数据的逻辑结构时，要注意两点：</p><ul><li>将每一个数据元素看作一个结点，用圆圈表示</li><li>元素之间的逻辑关系用结点之间的连线表示，如果这个给关系是由方向的，那么用带箭头的连线表示</li></ul><h4 id="集合结构"><a class="header-anchor" href="#集合结构">¶</a>集合结构</h4><p><strong>集合结构：集合结构中的数据元素除了同属于一个集合外</strong>，它们之间没有其他关系，类似于数学中的集合</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png" alt="集合结构"></p><h4 id="线性结构"><a class="header-anchor" href="#线性结构">¶</a>线性结构</h4><p><strong>线性结构：线性结构中的数据元素是一对一的关系</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501980892.png" alt="线性结构"></p><h4 id="树形结构"><a class="header-anchor" href="#树形结构">¶</a>树形结构</h4><p><strong>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502028932.png" alt="树形结构"></p><h4 id="图形结构"><a class="header-anchor" href="#图形结构">¶</a>图形结构</h4><p><strong>图形结构：图形结构的数据元素是多对多的关系</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502086807.png" alt="图形结构"></p><h3 id="物理结构——存储结构"><a class="header-anchor" href="#物理结构——存储结构">¶</a>物理结构——存储结构</h3><p><strong>物理结构：是指数据的逻辑结构在计算机中的存储形式</strong></p><p>数据的存储结构应正确反映数据元素之间的逻辑关系</p><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构">¶</a>顺序存储结构</h4><p><strong>顺序存储结构：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502487332.png" alt="顺序存储结构"></p><h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构">¶</a>链式存储结构</h4><p><strong>链式存储结构：是把数据元素存放在任意的存储单元中，这组存储单元可以是连续的，也可以是不连续的</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502635250.png" alt="链式存储结构"></p><p>此时数据元素的存储关系不能反映其逻辑关系，所以需要一个指针存放数据元素的地址，通过指针可以找到相关联数据元素的地址。相较于顺序存储结构，链式存储结构更为灵活，<strong>也更适合处理需要变化的结构</strong>，比如排队，当队伍中需要添加或者删去成员时，使用顺序存储结构则需要处理大量数据</p><h2 id="抽象数据类型"><a class="header-anchor" href="#抽象数据类型">¶</a>抽象数据类型</h2><h3 id="数据类型"><a class="header-anchor" href="#数据类型">¶</a>数据类型</h3><p><strong>数据类型：是指一组性质形同的值的集合及定义在此集合上的一些操作的总称</strong></p><h3 id="抽象数据类型-v2"><a class="header-anchor" href="#抽象数据类型-v2">¶</a>抽象数据类型</h3><p><strong>抽象数据类型：是指一个数据建模及定义在该模型上的一组操作</strong>，比如整型</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657503293323.png" alt="抽象数据类型标准格式"></p><h1 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h1><p><strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列。并且每条指令表示一个或多个操作</strong></p><p><strong>算法的基本特性：输入、输出、有穷性、确定性、可行性</strong></p><p><strong>算法的基本要求：</strong></p><ul><li>正确性</li><li>可读性：便于阅读、理解和交流</li><li>健壮性：当输入数据不合法时算法能做出相关处理</li><li>时间效率高和存储量低</li></ul><h2 id="算法时间和空间复杂度"><a class="header-anchor" href="#算法时间和空间复杂度">¶</a>算法时间和空间复杂度</h2><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657504108330.png" alt="算法时间复杂度定义"><br>$$<br>O(1)叫做常数阶、O(n)叫做线性阶、O(n^2)叫做平方阶<br>$$</p><h3 id="时间复杂度的计算"><a class="header-anchor" href="#时间复杂度的计算">¶</a>时间复杂度的计算</h3><p>推导大O阶：</p><ul><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常数阶</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//这里代码的执行次数和问题的大小n无关，所以为常数，也就是O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//以上代码会执行n次，所以位O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数阶</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;n)</span><br><span class="line">{</span><br><span class="line">    count=count*<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//程序不再执行的条件是2^(count)&gt;=n，也就是count=log2n，所以这个循环的时间复杂度为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平方阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//因为上述程序为嵌套循环，所以会执行n*n次，所以时间复杂度为O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于下述循环嵌套，时间复杂度计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对于上述程序，我们先计算程序的执行次数，因为外层循环执行次数必定为n，主要看内层循环，内层循环执行次数总和为n+(n-1)+(n-2)+……=(n+1)/2，最终得到n^2/2+n/2</span></span><br><span class="line"><span class="comment">//按照上面的大O推导法，1、没有加法常数不予考虑，2、只保留最高阶也就是n^2/2，3、去除这个项的系数，得到n^2，所以时间复杂度为O(n^2)</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510055411.png" alt="常见的时间复杂度"></p><h3 id="空间复杂度的计算"><a class="header-anchor" href="#空间复杂度的计算">¶</a>空间复杂度的计算</h3><p>算法的空间复杂度通过计算算法所需要的存储空间实现</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510171290.png" alt=""></p><p>主要是数组大小，变量只占一个存储单元</p><h1 id="线性表"><a class="header-anchor" href="#线性表">¶</a>线性表</h1><p>线性表：零个或多个数据元素的有限序列，元素之间是有序的<img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514042881.png" alt="线性表的数学语言定义"></p><p>所以线性表元素的个数n定义为线性表的长度，当n=0时为空表</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514222426.png" alt="位序"></p><p><strong>在较复杂的线性表中，一个数据元素可以由若干个数据项组成</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514307777.png" alt="复杂线性表"></p><h2 id="线性表的抽象数据类型"><a class="header-anchor" href="#线性表的抽象数据类型">¶</a>线性表的抽象数据类型</h2><p>前面说过抽象数据类型分为数据和操作</p><p>在这里线性表的抽象数据类型定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">    DATA</span><br><span class="line">    线性表的数据对象集合为(a1,a2,a3……，an)，每个元素的类型均为DataType。除了第一个元素a1外，其余元素都有且只有一个直接前驱元素，除最后一个元素外，其余元素都有且只有一个直接后继元素。数据元素之间的关系是一对一的关系</span><br><span class="line">    <span class="function">Operation</span></span><br><span class="line"><span class="function">    <span class="title">InitList</span><span class="params">(*L)</span><span class="comment">//初始化操作，建立一个空的线性表</span></span></span><br><span class="line"><span class="function">    <span class="title">ListEmpty</span><span class="params">(*L)</span><span class="comment">//若线性表为空，返回true，否则返回false</span></span></span><br><span class="line"><span class="function">    <span class="title">ClearList</span><span class="params">(*L)</span><span class="comment">//将线性表清空</span></span></span><br><span class="line"><span class="function">    <span class="title">GetElem</span><span class="params">(L,i,*e)</span><span class="comment">//将线性表L中的第i个位置元素值返回给e</span></span></span><br><span class="line"><span class="function">    <span class="title">LocateElem</span><span class="params">(L,e)</span> <span class="comment">//在线性表L中查找和e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则返回0表示失败</span></span></span><br><span class="line"><span class="function">    <span class="title">ListInsert</span><span class="params">(*L,i,e)</span><span class="comment">//在线性表L的第i个位置擦汗如新元素e</span></span></span><br><span class="line"><span class="function">    <span class="title">ListDelete</span><span class="params">(*L,i,*e)</span><span class="comment">//删除线性表L中的第i个未知元素，并用e返回其值</span></span></span><br><span class="line"><span class="function">    <span class="title">ListLength</span><span class="params">(L)</span><span class="comment">//返回线性表L的元素个数</span></span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>以上只是线性表的基础操作，对于复杂的一些操作可以分解为简单的操作，比如求A和B集合的并集这一操作可以分解为遍历B表，将A表中不存在的元素插入到A表中</strong></p></blockquote><h2 id="线性表的顺序存储结构"><a class="header-anchor" href="#线性表的顺序存储结构">¶</a>线性表的顺序存储结构</h2><p><strong>线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素</strong></p><p>描述顺序存储结构需要三个特性：</p><ul><li>存储空间的起始位置：数组data，他的存储位置就是存储空间的存储位置</li><li>线性表的最大存储容量：数组长度MaxSize</li><li>线性表的当前长度：length</li></ul><h3 id="顺序存储结构的插入与删除"><a class="header-anchor" href="#顺序存储结构的插入与删除">¶</a>顺序存储结构的插入与删除</h3><p>这两者其实是比较麻烦的，对于插入数据，插入位置之后的元素都需要后移，删除则为前移。</p><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量</li><li>从最后一个元素开始向前遍历到第i个位置，分别将他们往后移动一个位置</li><li>将要插入的元素填入位置i处</li><li>表长+1</li></ul><p>删除算法也是类似的</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516394208.png" alt="线性表的优缺点"></p><h2 id="线性表的链式存储结构"><a class="header-anchor" href="#线性表的链式存储结构">¶</a>线性表的链式存储结构</h2><p><strong>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素</strong>，由于是任意的，我们还需要存储当前元素的后继元素地址</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516611507.png" alt="单链表的定义"></p><p><strong>一般会在单链表的第一个结点前附设一个头结点，在其数据域存储线性表的长度，然后让头结点的指针指向第一个结点</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516871062.png" alt="头指针与头结点的异同"></p><p>为了更好地理解，贴出下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516922060.png" alt=""></p><h3 id="单链表的读取、插入和删除"><a class="header-anchor" href="#单链表的读取、插入和删除">¶</a>单链表的读取、插入和删除</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//类型</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">}List;<span class="comment">//名称</span></span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">InsertNode</span><span class="params">(List* <span class="built_in">list</span>)</span><span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">{</span><br><span class="line">List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">tmp-&gt;data = i;</span><br><span class="line">tmp-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"><span class="built_in">list</span>-&gt;next = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">List* <span class="title">CreateList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">List* Node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">Node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建空的头结点</span></span><br><span class="line"><span class="keyword">return</span> InsertNode(Node);<span class="comment">//插入结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (Linklist-&gt;next != <span class="literal">NULL</span>)<span class="comment">//第一个是空结点，所以先指向第一个结点</span></span><br><span class="line">{</span><br><span class="line">Linklist = Linklist-&gt;next;<span class="comment">//遍历单向链表</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Linklist-&gt;data);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">DeteleNode</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> goal = <span class="number">3</span>;<span class="comment">//删除结点需要先记录前一个结点的位置</span></span><br><span class="line">List* p = Linklist, * q;<span class="comment">//初始化p用于遍历链表</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next-&gt;data == goal)<span class="comment">//当前节点下一结点的值为3</span></span><br><span class="line">{</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Linklist;<span class="comment">//返回的是头节点</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">List* <span class="title">InsertBytail</span><span class="params">(List* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">List* tmplist = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">{</span><br><span class="line">List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">tmp-&gt;data = i;</span><br><span class="line">tmp-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建新节点</span></span><br><span class="line"><span class="comment">//从尾部插入</span></span><br><span class="line">tmplist-&gt;next = tmp;</span><br><span class="line">tmplist = tmplist-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">List* Linklist;</span><br><span class="line">Linklist= CreateList();</span><br><span class="line"><span class="comment">//PrintList(Linklist);</span></span><br><span class="line">Linklist=DeteleNode(Linklist);</span><br><span class="line">PrintList(Linklist);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>链表创建时可以使用尾插法和头插法，尾插法就是创建的结点从尾部插入，而头插法则反之</p><h2 id="静态链表"><a class="header-anchor" href="#静态链表">¶</a>静态链表</h2><p>即使用结构体数组来替代指针来描述单链表</p><blockquote><p><strong>首先让结构体数组拥有两个成员，data和cur。数据域data原来存放数据元素，也就是我们要处理的元素。而游标cur相当于单链表中的next指针，存放该元素的后继元素在数组中的下标，但是为了方便插入数据，通常需要把数组建立得大一些</strong></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//游标Cursor，为0时表示无指向</span></span><br><span class="line">}Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure><p>同时我们需要对第一个元素和最后一个元素进行特殊元素处理，不存放数据。<strong>我们通常把未被使用得数组元素称为备用链表</strong></p><blockquote><p>数组第一个元素即下标为0的元素cur就存放备用链表(空位置)的第一个结点的下标。而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表的头结点的作用</p></blockquote><h3 id="静态链表的插入和删除操作"><a class="header-anchor" href="#静态链表的插入和删除操作">¶</a>静态链表的插入和删除操作</h3><p>前面可知，动态链表结点的申请和释放分别借用malloc和free函数。<strong>而在静态链表中，操作的是数组</strong>，为了区分哪些数组是被使用过的，我们可以将所有未被使用过的以及已经被删除的分量用游标链成一个备用的链表（使cur指向下一个空位置）</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657620383741.png" alt="静态链表"></p><h4 id="静态链表插入"><a class="header-anchor" href="#静态链表插入">¶</a>静态链表插入</h4><p>首先我们需要在备用链表中找到一个空位置，相当于(malloc)，然后将该位置的元素加入数据链表中此时当前的空位置会被占用，所以list[0]-&gt;cur也需要改变。</p><h4 id="静态链表删除"><a class="header-anchor" href="#静态链表删除">¶</a>静态链表删除</h4><p>和插入一样，都需要对备用链和数据链进行更改</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line">}Component, StaticList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//找到备用链表中的空位置</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur)<span class="comment">//如果备用链表已被使用过</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[i]-&gt;cur;<span class="comment">//因为当前位置被占用，所以从备用链表中解除</span></span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回空位置的下标</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateList</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxsize - <span class="number">1</span>; ++i)<span class="comment">//初始化备用链表，此时空间都没被使用，所以list[0]-&gt;cur为0</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">list</span>[i]-&gt;cur = i + <span class="number">1</span>;<span class="comment">//cur相当于next，指向下一个结点</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//结尾的结点的cur赋值为0</span></span><br><span class="line"><span class="built_in">list</span>[Maxsize - <span class="number">1</span>]-&gt;cur = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从备用链表中获取空结点的位置,从而创建数据链表的头节点</span></span><br><span class="line"><span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">int</span> head = k;<span class="comment">//返回头节点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//申请数据结点</span></span><br><span class="line"><span class="keyword">int</span> s = Malloc(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">list</span>[s]-&gt;data = i;</span><br><span class="line">k = s;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">list</span>[k]-&gt;cur = <span class="number">0</span>;<span class="comment">//数据链表的末尾结尾以0结尾，表示cur指向NULL</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//因为第一个是头结点无数据，所以跳过</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//插入的位置，首先在备用链表中获取空结点的下标</span></span><br><span class="line"><span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">list</span>[k]-&gt;data = <span class="number">10</span>;<span class="comment">//给指定位置的元素赋值，下一步将其从中间插入，同时备用链表也需要改变</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[k]-&gt;cur;<span class="comment">//这样就实现了不移动元素在中间插入数据</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">4</span>]-&gt;cur = k;</span><br><span class="line"><span class="built_in">list</span>[k]-&gt;cur = <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;data == <span class="number">10</span>)<span class="comment">//当前结点的后一个结点数值为10</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//当找到我们刚才插入的结点时，备用链表和数据链表都需要进行做出改变</span></span><br><span class="line"><span class="comment">//首先改变数据链表</span></span><br><span class="line"><span class="built_in">list</span>[head]-&gt;cur = <span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur;<span class="comment">//跳过下一结点</span></span><br><span class="line"><span class="comment">//接下来改变备用链表，将其看作备用链表的结点</span></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line"><span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur = tmp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//后移</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">StaticList <span class="built_in">list</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> head = CreateList(<span class="built_in">list</span>);</span><br><span class="line">InsertNode(<span class="built_in">list</span>);</span><br><span class="line">DeleteNode(<span class="built_in">list</span>, head);</span><br><span class="line">PrintList(<span class="built_in">list</span>, head);</span><br><span class="line">InsertNode(<span class="built_in">list</span>);</span><br><span class="line">PrintList(<span class="built_in">list</span>, head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634024878.png" alt="静态链表的优缺点"></p><h2 id="循环链表"><a class="header-anchor" href="#循环链表">¶</a>循环链表</h2><p>之前提到的单链表都只存储向后的指针，所以没办法找到他的前驱节点。而我们只要将链表改为一个环就可以解决这样的问题，而这样的链表就是循环链表——解决了一个问题（如何从当中的一个结点出发，访问到链表的全部结点）</p><p><strong>将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为但循环链表，简称循环链表</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634585653.png" alt="循环链表和单链表的差异"></p><p>循环链表如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657635089691.png" alt="循环链表"></p><p>在单链表中，我们有了头结点时，可以用O(1)的时间访问第一个结点，但是要访问到最后一个结点则需要O(n)时间，因为所有结点都要访问一遍。</p><p>我们可以改造一下上面的循环链表，不用头指针，而是用<strong>指向终端结点的尾指针来表示循环链表</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636505788.png" alt=""></p><h3 id="两个循环链表的合并"><a class="header-anchor" href="#两个循环链表的合并">¶</a>两个循环链表的合并</h3><p>有了尾结点合并时就会比较简单</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636794584.png" alt="流程图"></p><p>rearA和rearB是两条循环链表的尾指针</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=readA-&gt;next;<span class="comment">//保存A表的头结点</span></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next;<span class="comment">//将B链的第一个结点（不是头结点）赋值给rearA-&gt;next</span></span><br><span class="line">readB-&gt;next=p;</span><br><span class="line"><span class="built_in">free</span>(p)<span class="comment">//释放p</span></span><br></pre></td></tr></tbody></table></figure><h2 id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h2><p>在单向链表中，由于存在next指针，所以我们访问下一节点的时间复杂度为O(1)，而访问前一个结点则需要O(n)，所以设计出了双向链表。</p><p><strong>双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域</strong>，所以在双向链表中的每个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">prior</span>;</span><span class="comment">//直接前驱结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">next</span>;</span><span class="comment">//直接后继结点</span></span><br><span class="line">}DulNode,*DuLinkList;</span><br></pre></td></tr></tbody></table></figure><p>双向链表也可以是循环表</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657677859248.png" alt="双向循环链表"></p><h3 id="双向链表的查找、插入和删除"><a class="header-anchor" href="#双向链表的查找、插入和删除">¶</a>双向链表的查找、插入和删除</h3><p>查找的话只需要往一个方向遍历即可，不需要使用两个指针。</p><p>但是在插入和删除的时候需要同时对两个指针变量作出修改</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678031412.png" alt="插入的流程图"></p><blockquote><p>在编写代码时一定要注意顺序</p></blockquote><p>双向链表是使用空间换取时间的例子。</p><h1 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h1><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong></p><blockquote><p><strong>栈顶——允许插入和删除，栈顶的另一端就是栈底，不含任何元素的叫空栈。栈又被称为后进先出的线性表</strong>，简称LIFO结构</p></blockquote><p><strong>栈的插入操作叫作进栈，也可以叫做压栈、入栈；栈的删除操作叫做出栈</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678420041.png" alt="出栈入栈图"></p><p>相同的元素出栈次序的变化是很多的</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678529526.png" alt="出入栈的例子"></p><h2 id="栈的抽象数据类型"><a class="header-anchor" href="#栈的抽象数据类型">¶</a>栈的抽象数据类型</h2><p>对于栈的插入和删除操作，我们改名为push和pop</p><p><strong>入栈(push)是先移动栈顶指针再压入元素，出栈(pop)是弹出元素再移动栈顶指针</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈</span><br><span class="line">DAta</span><br><span class="line">同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Opreation</span></span><br><span class="line"><span class="function"><span class="title">InitStack</span><span class="params">(*S)</span></span>;<span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line">DestroyStack(*S);<span class="comment">//若栈存在，则销毁他</span></span><br><span class="line">ClearStack(*S);<span class="comment">//将栈清空</span></span><br><span class="line">StackEmpty(S);<span class="comment">//判断栈是否为空</span></span><br><span class="line">GetTop(S,*e);<span class="comment">//若栈不为空，用e返回栈顶元素</span></span><br><span class="line">Push(*S,e);<span class="comment">//入栈</span></span><br><span class="line">Pop(*S,*e);<span class="comment">//出栈</span></span><br><span class="line">StackLength(S);<span class="comment">//返回栈S的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure><p>因为栈是线性表，所以也具有顺序和链式存储方式</p><h2 id="栈的顺序存储及实现"><a class="header-anchor" href="#栈的顺序存储及实现">¶</a>栈的顺序存储及实现</h2><p>栈的顺序存储简称为顺序栈，线性表的顺序存储是用数组表示的，我们将栈底定义在数组下标为0的位置，并且使用top变量来指示栈顶的位置，<strong>当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定为top等于-1</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//用于栈顶指针</span></span><br><span class="line">}Sqstack;</span><br></pre></td></tr></tbody></table></figure><p>出栈入栈的代码也是相对简单的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">}Sqstack;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == MaxSize - <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断是否满栈</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//先移动栈顶指针，再压入</span></span><br><span class="line"><span class="built_in">stack</span>-&gt;top++;</span><br><span class="line"><span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> <span class="keyword">final</span>)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//判断是否为空栈</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span> = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line"><span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="两栈共享空间"><a class="header-anchor" href="#两栈共享空间">¶</a>两栈共享空间</h3><p>在前面的例子中存在很大的一个缺陷，那就是需要事先确定数组存储空间大小，<strong>对于一个栈我们需要设计出合适大小的数组来处理，但是对于两个相同类型的栈，我们却可以做到最大限度地利用其是先开辟地存储空间来进行操作</strong></p><p>我们可以使用一个数组类存储两个栈</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657680434915.png" alt="数组存储两个栈"></p><p>此时我们需要两个栈顶指针top1和top2，<strong>当top+1==top2时表示两个栈都满了</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top1;</span><br><span class="line"><span class="keyword">int</span> top2;</span><br><span class="line">}SqdoubleStack;</span><br></pre></td></tr></tbody></table></figure><p>对于两栈共享空间的push和pop，还需要有一个用于判断是栈1还是栈2的参数stackNumber</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682240174.png" alt="两栈共享空间push操作"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682220519.png" alt="两栈共享空间pop操作"></p><h2 id="栈的链式存储结构"><a class="header-anchor" href="#栈的链式存储结构">¶</a>栈的链式存储结构</h2><p>栈的链式存储结构，简称为<strong>链栈</strong></p><p>对于链栈来说不需要头结点，因为已经有栈顶了</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682407800.png" alt="链栈"></p><p><strong>对于空栈来说链表的原定义头指针指向NULL，那么链栈的空就是top=NULL</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>//栈的结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span><span class="comment">//栈的结点</span></span><br><span class="line">}StackNode, * LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>//栈的链表结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">LinkStackPtr top;<span class="comment">//栈顶</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="链栈的入栈和出栈"><a class="header-anchor" href="#链栈的入栈和出栈">¶</a>链栈的入栈和出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">s-&gt;data = e;<span class="comment">//结点赋值</span></span><br><span class="line">s-&gt;next = S-&gt;top;<span class="comment">//将新结点与原本的栈顶相连</span></span><br><span class="line">S-&gt;top = s;<span class="comment">//栈顶指向新的结点</span></span><br><span class="line">S-&gt;count++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStackPtr p;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">e = S-&gt;top-&gt;data;</span><br><span class="line">p = S-&gt;top;<span class="comment">//将栈顶结点赋值给p，待会free掉</span></span><br><span class="line">S-&gt;top = S-&gt;top-&gt;next;<span class="comment">//使得栈顶指针后移一个结点</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">S-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684222256.png" alt="顺序栈和链栈的对比"></p><h2 id="栈的作用"><a class="header-anchor" href="#栈的作用">¶</a>栈的作用</h2><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684273946.png" alt=""></p><h2 id="栈的应用"><a class="header-anchor" href="#栈的应用">¶</a>栈的应用</h2><h3 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h3><p>递归一个典型的例子就是斐波那契数列（每一项的元素都是前两项元素之和）</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684630710.png" alt="斐波那契数列表达式"></p><p>这里可以使用递归计算，会比较简单</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Fbi(n - <span class="number">1</span>) + Fbi(n - <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Fbi(i));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657688706889.png" alt="斐波那契数列的执行过程"></p><p><strong>递归的定义：间接地调用自己的函数，同时我们需要注意要有递归的出口</strong>，而对于函数的传参和返回值都是使用栈来实现的</p><h3 id="四则运算表达式求值"><a class="header-anchor" href="#四则运算表达式求值">¶</a>四则运算表达式求值</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689038037.png" alt="带括号的四则运算"></p><p>但是光按照括号来判断是不够的，所以采用以下方法</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689312633.png" alt=""></p><p>就是遇到数字就入栈，遇到符号就从栈中取出两个元素（注意先后），做运算后再入栈</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689418201.png" alt="具体过程"></p><p>但是上面的方法需要先将中缀表达式先转为后缀表达式</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689587176.png" alt="中缀表达式先转为后缀表达式过程"></p><h1 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h1><p><strong>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p><p><strong>队列是一种先进先出的线性表，简称FIFO，运行插入的一端称为队尾，允许删除的一端叫做队头</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689730159.png" alt="队列的结构图"></p><h2 id="队列的抽象数据类型"><a class="header-anchor" href="#队列的抽象数据类型">¶</a>队列的抽象数据类型</h2><p>同样是线性表，队列也有类似线性表的各种操作，<strong>不同的就是插入数据只能在队尾插入，删除数据只能在队头进行</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列</span><br><span class="line">Data</span><br><span class="line">同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function"><span class="title">InitQueue</span><span class="params">(*Q)</span></span>;<span class="comment">//初始化操作，建立一个空队列Q</span></span><br><span class="line">DestroyQueue(*Q);<span class="comment">//若队列Q存在，则销毁他</span></span><br><span class="line">ClearQueue(*Q);<span class="comment">//将队列清空</span></span><br><span class="line">QueueEmpty(*Q);<span class="comment">//判断队列是否为空</span></span><br><span class="line">GetHead(Q,*e);<span class="comment">//若队列存在且非空，用e返回队列Q的队头元素</span></span><br><span class="line">EnQueue(*Q,e);<span class="comment">//若队列Q存在，插入新元素e到队列Q中并成为队尾元素</span></span><br><span class="line">DeQueue(*Q,*e);<span class="comment">//删除队列Q中队头元素，用e返回其值</span></span><br><span class="line">QueueLength(Q);<span class="comment">//返回队列Q的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure><h2 id="循环队列"><a class="header-anchor" href="#循环队列">¶</a>循环队列</h2><p>队列作为特殊的线性表也有顺序存储和链式存储</p><h3 id="队列顺序存储的不足"><a class="header-anchor" href="#队列顺序存储的不足">¶</a>队列顺序存储的不足</h3><p>如果以数组下标为0的位置作为队头，那么入队时只需要在队尾追加元素即可，但是出队的话比较复杂，因为队头之后的所有元素都需要前移，时间复杂度为O(n)</p><p>但我们可以不去限制队列的元素必须存储在数组的前n个元素，也就是说<strong>队头不需要一定在下标为0的位置</strong></p><p>为了避免当只有一个元素时队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时队列为空</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691539985.png" alt="队列顺序存储的出队和入队"></p><p>可以看出当出队后再进行入队时发生了数组越界的情况（无法入队），而数组前两个位置还是空的，<strong>这就是假溢出</strong>，这时候就需要循环队列了</p><h3 id="循环队列的定义"><a class="header-anchor" href="#循环队列的定义">¶</a>循环队列的定义</h3><p><strong>队列的头尾相接的顺序存储结构叫做循环队列</strong></p><p>按照上面的例子，当入队a5时，可以将rear指向数组下标为0的位置</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691779653.png" alt="rear指向0下标处"></p><p>这样我们就可以继续入队了</p><p>此时新的问题出现了，空队列时front等于rear，当队列满的时候也是front=rear，为了区分，有两种方法</p><ul><li>设置一个标志量flag，当front==rear，且flag=0时为队列空，当flag=1时为队列满</li><li>可以修改队列满的条件，当数组还剩下一个空闲单元时我们就认为队列满了</li></ul><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710307674.png" alt="条件2"></p><p>下面重点讨论第二种方法</p><p>由于rear可能比fornt大，也可能小，所以不能仅凭二者相差1来判断是否为满队列（因为可能相差整整一圈）</p><p>设队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710665197.png" alt="队列长度计算"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> Data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">//尾指针，若队列不空指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的入队操作，首先判断是否为满队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//尾指针后移，如果为最后则转到数组头部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的出队操作，队头出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    <span class="comment">//队头后移</span></span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="队列的链式存储结构"><a class="header-anchor" href="#队列的链式存储结构">¶</a>队列的链式存储结构</h2><p>队列的链式存储结构其实就是线性表的单链表，只不过他只能尾进头出而已。我们称之为<strong>链队列</strong></p><p>为了操作方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657711606663.png" alt="链队列"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>//结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//队列的链表结构</span></span><br><span class="line">QueuePtr front, rear;<span class="comment">//队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="链队列的入队和出队操作"><a class="header-anchor" href="#链队列的入队和出队操作">¶</a>链队列的入队和出队操作</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化结点</span></span><br><span class="line"><span class="comment">//链接上队列，队尾插入</span></span><br><span class="line">Q-&gt;rear-&gt;next = s;</span><br><span class="line">Q-&gt;rear = s;<span class="comment">//把当前结点设置为队尾结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用变量p暂时存储需要删除的结点</span></span><br><span class="line">p = Q-&gt;front-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next;<span class="comment">//队头指针后移</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">//如果队尾指向第一个数据结点，则删除之后恢复空队列</span></span><br><span class="line">{</span><br><span class="line">Q-&gt;rear = Q-&gt;front;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>——————下划线——————</p><p>刷题巩固一下我的🐖脑</p><h1 id="串"><a class="header-anchor" href="#串">¶</a>串</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据结构与算法&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TLS和main前的初始化</title>
    <link href="https://gift1a.github.io/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://gift1a.github.io/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-06-18T09:08:22.000Z</published>
    <updated>2022-06-18T09:08:22.399Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学基础知识</title>
    <link href="https://gift1a.github.io/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <id>https://gift1a.github.io/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</id>
    <published>2022-05-26T10:53:53.000Z</published>
    <updated>2022-06-04T05:34:24.470Z</updated>
    
    <content type="html"><![CDATA[<p>密码学预备数学知识</p><span id="more"></span><h1 id="数论知识和markdown数学符号"><a class="header-anchor" href="#数论知识和markdown数学符号">¶</a>数论知识和markdown数学符号</h1><ul><li>欧拉函数</li><li>欧拉定理</li><li>模逆</li><li>指数</li><li>合数</li><li>有限域等</li><li>预备pyCrypto和gmpy2知识</li></ul><p>$$<br>x^2+y_3\<br>Z^+\<br>\sqrt{x}\</p><p>\frac{a}{b} \times\frac{b}{c}\</p><p>\sqrt[n]{y}\</p><p>\vec{a}\cdot\vec{b}=0\</p><p>\overline{x}\</p><p>\lim_{n\to+\infty}n or \lim n\</p><p>\int_0^nf(x)dx or \int f(x)dx\</p><p>\sum_{i=1}^n a_i or \sum a_i\</p><p>\begin{bmatrix}<br>6&amp;2&amp;10&amp;3\<br>7&amp;5&amp;4&amp;9\<br>\end{bmatrix}\</p><p>\begin{matrix}<br>1&amp;2&amp;3\<br>4&amp;5&amp;6\<br>7&amp;8&amp;9\<br>\end{matrix}<br>\tag{2}\<br>$$</p><p>$$<br>a\cdot b\<br>c \times d\<br>f \div e\<br>a \approx 5\<br>a\pm5\<br>a\leq b\<br>a\geq d\<br>\forall\<br>\infty\<br>\emptyset\<br>\exists\<br>\nabla\<br>\bot\<br>\angle\<br>\because\<br>\therefore\<br>\alpha(n)\<br>\beta\<br>\chi\<br>\delta\<br>\eta\<br>\gamma\<br>\gamma =\quad \eta\<br>a \ mod \ b<br>$$</p><h1 id="数学基础"><a class="header-anchor" href="#数学基础">¶</a>数学基础</h1><h2 id="整数和同余"><a class="header-anchor" href="#整数和同余">¶</a>整数和同余</h2><ul><li><strong>整除</strong>：设$a,b,m\in Z,\exists m$使得$a=mb$成立，则称非零整数$b$整除$a$，记作$b \mid a$，此时称$b$是$a$的因子，$a$是$b$的倍数。例：$2\mid6,3 \mid 6$等。</li></ul><blockquote><p>除数与被除数</p><p>需要熟知一个容易混淆的概念：被除数$\div$除数=余数……商，因此整除描述了除数整除被除数的情况，比如$6\div3=2……0$，描述了3整除6的情况，要注意除和除以是不同的概念</p></blockquote><p>在上面，假设$m\mid a,m\mid b$说明$m$是$a$的因子，也是$b$的因子，因此称$m$是$a$和$b$的公因子。</p><ul><li><strong>最大公因子</strong>，设$a,b,m\in Z，而且m\mid a,m\mid b,若m是整除a和b的最大整数，那么m称为a和b的最大公因子，记作m=gcd(a,b)$</li></ul><blockquote><p><strong>互素</strong></p><p>​利用最大公因子可以定义一个常用的概念，即<strong>互素</strong>：称整数$a,b$是互素的，当且仅当$gcd(a,b)=1$</p></blockquote><p>求解最大公因子有非常有效的算法——欧几里得算法(辗转相除法)。在介绍欧几里得算法前，先介绍一下余数的概念</p><ul><li><strong>带余除法</strong>：$\forall n \in  Z^+$和$\forall a\in Z$，$\exists q,r\in Z$且$0\leq r&lt;n$使得$a=qn+r$，其中$q=[a/n]$，[]为向下取整。</li></ul><p>可以看到，其中q为商，r为余数，按照上面的公式有$r=a-[a/n]\times n$，在这里用一个更加简洁的符号表示$r$，那就是模运算符号$mod$，记作$r=a \ mod \ n$，这里$n$是模数，该运算称为模$n$运算</p><p>回到求解最大公因子，对于任意整数$a$和$b$可以通过下面的方式计算$gcd(a,b)$，不断使用带余数除法，直至余数为0，此时的除数为最大公因子</p><blockquote><p><strong>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</strong></p></blockquote><p>$$<br>gcd(a,b)=gcd(b,a\ mod\ b)<br>$$</p><p>以上的式子不停迭代直至余数为0</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> r=a%b;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        a=b;</span><br><span class="line">        b=r;</span><br><span class="line">        r=a%b;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> b; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>模$n$同余</strong>：若$a \ mod\ n=b \ mod\ n$那么称整数$a$和$b$是同余的，记作$a \equiv b(mod\ n)$。</li></ul><p>同余运算中，最重要的是模数$n$，比如6和11模5同余，而模三就不同余了。因此考虑一般情况，对于模$n$运算，考察所有整数$Z= \left{0,\pm1,\pm2,\pm3,\cdots \right},\forall\ a\in Z$，根据$a\ mod \ n \in \left{0,1,2,3,\cdots,n-1\right}$，因此<strong>对于任何整数只要进行模$n$运算后，所有整数都被限制到有限的集合中</strong>，那么必然会出现同余的情况，依据此可以定义下面两个概念：</p><ul><li><strong>剩余类集</strong>：模$n$运算的所有余数的集合，记作$Z_n=\left{ 0,1,2,3,\cdots,n-1\right}$</li><li><strong>剩余类</strong>：所有模$n$同余的整数的集合，一般用最小的非负整数作为代表，记作$[0],[1],[2],\cdots,[n-1]$</li></ul><p><img src="/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1653645853317.png" alt="例子"></p><ul><li><strong>模运算</strong>：称二元运算$a\ mod \ n=r$是模$n$运算，$r$是$a$模$n$的值，且$0\leq r &lt;n$，可以证明对于任意两个整数$a$和$b$有下面的结论</li></ul><p><img src="/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1653646093104.png" alt=""></p><p>消去律的成立与否与逆元的存在与否有很大关系，下面是加法逆元和乘法逆元的定义</p><ul><li><strong>加法逆元</strong>：$a,b\in Z_n$，若$(a+b)\ mod\ n=0$，则$a$和$b$互为加法逆元，记$a$的加法逆元为$-a$</li><li><strong>乘法逆元</strong>：$a,b\in Z_n$，若$(a+b)\ mod\ n=1$，则$a$和$b$互为乘法逆元，记$a$的乘法逆元为$a^{-1}$</li></ul><p>由于加法逆元一定存在，故加法消去律一定成立，而当且仅当$gcd(a,n)=1$时，$a$才在模$n$运算中存在逆元，故乘法消去律在该条件下才成立。</p><h2 id="素数及其定理"><a class="header-anchor" href="#素数及其定理">¶</a>素数及其定理</h2><ul><li>素数：正因子只有1和它本身的正整数称为素数，而且规定1不是素数，常记作$\rho$</li><li>合数：合数是指正整数中不是素数的数</li></ul><p>合数有一个非常重要的性质，称之为算术基本定理</p><ul><li><strong>算术基本定理</strong>：任何合数都可以唯一分解为若干个素数的乘积，即对于任何整数$a&gt;1$可以唯一分解为$a=\rho_1<sup>{a_1}\rho_2</sup>{a_2}\cdots \rho_n^{a_n},\forall i\in \left{1,2,\cdots n \right}$有$\rho_i$是素数($\rho_1&lt;\rho_2&lt;\cdots&lt;\rho_n$)，$a_i$是正整数</li><li><strong>费马小定理</strong>：</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;密码学预备数学知识&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>简单密码学入门</title>
    <link href="https://gift1a.github.io/2022/05/23/%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8/"/>
    <id>https://gift1a.github.io/2022/05/23/%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-23T01:14:22.000Z</published>
    <updated>2022-05-26T10:30:03.003Z</updated>
    
    <content type="html"><![CDATA[<p>算法和理解能力太差了，做题感觉自己像脑缠，先从古典密码入手</p><span id="more"></span><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/222691227">https://zhuanlan.zhihu.com/p/222691227</a></p><h1 id="凯撒密码"><a class="header-anchor" href="#凯撒密码">¶</a>凯撒密码</h1><p>凯撒加密就是将明文中的每个字母都按照其在字母表中的顺序向后或向前移动固定数目（循环移动）作为密文，这个固定数目就是key</p><p>下面给出encode和decode的实现（我这里还添加了对数字的Caesar）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//凯撒加密，对象是大小写字母和数字，字母表的位置后移key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caesar_encode</span><span class="params">(<span class="keyword">char</span> raw[], <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(raw); ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (raw[i] &gt;= <span class="string">'A'</span> &amp;&amp; raw[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'A'</span> + key) % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'a'</span> &amp;&amp; raw[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i]= (raw[i] - <span class="string">'a'</span> + key) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'0'</span> &amp;&amp; raw[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'0'</span> + key) % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"加密后的字符串为：%s\n"</span>, raw);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在字母表中，右移n位等于左移26-n位，此时需要左移还原，左移n位就是右移26-n位，因为左移可能小于A或者a，此时还原到z的位置比较麻烦，所以采取右移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caesar_decode</span><span class="params">(<span class="keyword">char</span> raw[], <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(raw); ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (raw[i] &gt;= <span class="string">'A'</span> &amp;&amp; raw[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'A'</span> + <span class="number">26</span> - key) % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'a'</span> &amp;&amp; raw[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'a'</span> + <span class="number">26</span> - key) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'0'</span> &amp;&amp; raw[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'0'</span> + <span class="number">10</span> - key) % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"解密后的字符串为：%s\n"</span>, raw);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> raw[] = <span class="string">"flag123123asdasdasdzxczaqw"</span>;</span><br><span class="line"><span class="comment">/*printf("Please input your raw flag\n");</span></span><br><span class="line"><span class="comment">scanf("%s", raw);*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input your key\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"><span class="keyword">char</span> encode[] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> decode[] = {<span class="number">0</span>};</span><br><span class="line">Caesar_encode(raw, key);</span><br><span class="line">Caesar_decode(raw, key);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="基于密钥的Caesar"><a class="header-anchor" href="#基于密钥的Caesar">¶</a>基于密钥的Caesar</h2><p><img src="/2022/05/23/%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8/1653508089916.png" alt=""></p><p>先找到密钥各个字母在字母表中的偏移，然后以此偏移作为密钥加密原文中的字母</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caesar_key_encode</span><span class="params">(<span class="keyword">char</span>* raw, <span class="keyword">char</span>* key_str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(raw); ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (raw[i] &gt;= <span class="string">'A'</span> &amp;&amp; raw[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'A'</span> + key_str[j] - <span class="string">'a'</span>) % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'a'</span> &amp;&amp; raw[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'a'</span> + key_str[j] - <span class="string">'a'</span>) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密钥凯撒加密后的结果：%s\n"</span>, raw);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="仿射变换"><a class="header-anchor" href="#仿射变换">¶</a>仿射变换</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;算法和理解能力太差了，做题感觉自己像脑缠，先从古典密码入手&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>CTF中32位调用64位代码</title>
    <link href="https://gift1a.github.io/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/"/>
    <id>https://gift1a.github.io/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-05T11:42:31.000Z</published>
    <updated>2022-05-13T11:46:42.089Z</updated>
    
    <content type="html"><![CDATA[<p>CTF中32位程序调用64位代码</p><span id="more"></span><h1 id="参考文章-v2"><a class="header-anchor" href="#参考文章-v2">¶</a>参考文章</h1><p><a href="https://blog.shi1011.cn/ctf/1750">https://blog.shi1011.cn/ctf/1750</a><br><a href="https://www.anquanke.com/post/id/171111">https://www.anquanke.com/post/id/171111</a></p><p><a href="https://www.psbazx.com/2022/04/06/%E5%85%B3%E4%BA%8E32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%88%87%E6%8D%A2/">https://www.psbazx.com/2022/04/06/关于32位与64位程序切换/</a></p><p><a href="https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html">https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html</a></p><h1 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h1><h2 id="CS和IP"><a class="header-anchor" href="#CS和IP">¶</a>CS和IP</h2><p>CS是代码段寄存器，IP是指令指针寄存器</p><blockquote><p>之所以要这样设计是因为8086CPU是16位的，而物理地址是20位的，他内存的寄存器只能表现16位的地址，因此使用ip寄存器来存放偏移地址</p></blockquote><p>我们假设CS的值为M，IP的值为N，那么8086CPU将从内存M*16+N单元开始，读取下一条指令</p><p>工作流程</p><ul><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区</li><li>IP=IP+所读取指令的长度，便于读取下一条指令</li><li>执行指令，重复第一步</li></ul><p>如果我们想修改CS:IP的值，可以使用转移指令，例如JMP指令</p><p>以上是基于16位程序中</p><p>但是32位以上段寄存器不再被用来指向段了，在本例子中CS存储的值用于判断是32位或64位工作模式</p><blockquote><p><strong>64位：CS=0x33；32位：CS=0x23</strong></p></blockquote><h2 id="WOW64"><a class="header-anchor" href="#WOW64">¶</a>WOW64</h2><blockquote><p>WOW64 (Windows-on-Windows 64-bit)是一个Windows操作系统的子系统, 它为现有的32位应用程序提供了32位的模拟，可以使大多数32 位应用程序在无需修改的情况下运行在 Windows 64 位版本上。</p></blockquote><p>在x64系统下的进程有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。32位模式时，CS = 0x23；64位模式时，CS = 0x33</p><blockquote><p><strong>这两种工作模式是可以进行转换的，一般通过retf指令，一条retf指令等效于以下两条汇编指令</strong></p></blockquote><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">ip</span><span class="comment">//当前读取指令的地址</span></span><br><span class="line"><span class="keyword">pop</span> cs<span class="comment">//cs寄存器</span></span><br></pre></td></tr></tbody></table></figure><p>如果此时栈中有0x33，retf会将0x33弹出到CS寄存器，实现32位程序转换到64位代码的过程。<strong>所以retf是识别32位程序调用64位代码的重要标志</strong></p><p>利用好这一点就可以实现64位代码和32位代码来回切换</p><h1 id="解决"><a class="header-anchor" href="#解决">¶</a>解决</h1><h2 id="dump"><a class="header-anchor" href="#dump">¶</a>dump</h2><p>使用idc将64位的代码段dump下来</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"./final"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x4011C0</span>;<span class="comment">//起始地址</span></span><br><span class="line">  end = <span class="number">0x4012A0</span>;<span class="comment">//结束地址</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用ida64打开，选择64-bit mode</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084552451.png" alt=""></p><p>如同修改基址为0x4011C0</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084623510.png" alt=""></p><p>可以看到已经基本恢复了，剩下只需对比着进行代码分析即可</p><h2 id="修改为64位程序"><a class="header-anchor" href="#修改为64位程序">¶</a>修改为64位程序</h2><p>将这里的0x10B改成0x20B，然后使用ida64打开</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084704987.png" alt=""></p><p>基址重新修改为原本程序的基址</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084801377.png" alt="恢复后"></p><h1 id="例子-v3"><a class="header-anchor" href="#例子-v3">¶</a>例子</h1><h2 id="hgame2022-week4-WOW"><a class="header-anchor" href="#hgame2022-week4-WOW">¶</a>hgame2022-week4-WOW</h2><p>在某些函数中ida无法反编译</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652077738159.png" alt=""></p><p>查看此函数的汇编，因为在此之后才无法反编译</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078266535.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078302028.png" alt="汇编"></p><p>因为retf相当于pop ip;pop cs，而ip是下一条指令的地址</p><p>所以这一段代码意思是先将64位工作模式的标志0x33压入栈中，然后通过call和add esp的值改变retf跳转的地址</p><p>然后通过retf时将0x33pop到cs中，换为64位工作模式，所以ida32无法正确反编译</p><p>再来看第二个函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078950121.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652079092143.png" alt="汇编代码"></p><p>这里是一样的，不过这里使用的是mov指令，将0x23mov到esp+4存储的地址中</p><p>通过这一段代码恢复回32位工作模式</p><h2 id="ISCC-擂台题"><a class="header-anchor" href="#ISCC-擂台题">¶</a>ISCC-擂台题</h2><h2 id="考点-v7"><a class="header-anchor" href="#考点-v7">¶</a>考点</h2><p>创建子进程和子线程、TEA、WOW64</p><h2 id="分析-v7"><a class="header-anchor" href="#分析-v7">¶</a>分析</h2><p>当命令行参数为2时进入第一个函数，否则进入第二个</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652267971329.png" alt=""></p><h3 id="第二个函数"><a class="header-anchor" href="#第二个函数">¶</a>第二个函数</h3><p>第二个函数传入的参数是命令行参数的第一个，也就是我们的程序绝对路径</p><p>进入第二个函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268136354.png" alt=""></p><p>这一段就是打开当前程序创建子进程（根据第六个参数判断进程的属性），命令行参数为我们打开程序的路径和" DIO"，然后</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652248950697.png" alt=""></p><p>然后根据调试事件判断时候break，这里当报告退出进程调试事件才会break</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652249119969.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268383536.png" alt="创建的新进程"></p><p>这样创建的子进程具有两个命令行参数，所以进入第一个函数</p><h3 id="第一个函数"><a class="header-anchor" href="#第一个函数">¶</a>第一个函数</h3><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268475082.png" alt="函数列表"></p><h4 id="CreateNewThread函数"><a class="header-anchor" href="#CreateNewThread函数">¶</a>CreateNewThread函数</h4><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268516934.png" alt=""></p><p>创建一个子线程，根据第五个参数dwCreationFlags为0可知是线程创建后立即执行，指定函数为StartAddress</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268675363.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268738053.png" alt="StartAddress函数"></p><p>就是对flag的格式进行判断，并且对最后的几个字符进行异或</p><p>但是此时我们还未输入，按理说会一直卡在while循环，但是单步步过CreateNewThread时都是正常的</p><h4 id="compare-input函数"><a class="header-anchor" href="#compare-input函数">¶</a>compare_input函数</h4><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268936181.png" alt=""></p><p>判断输入前几位是否为ISCC</p><h4 id="encode-and-compare函数"><a class="header-anchor" href="#encode-and-compare函数">¶</a>encode_and_compare函数</h4><p>通过动态调试可以知道前面的while循环是将每八个输入存储为QWORD类型，第二段就是对key，也就是命令行参数的第二个进行加密，然后传入encode()函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269032854.png" alt=""></p><h5 id="encode-函数"><a class="header-anchor" href="#encode-函数">¶</a>encode()函数</h5><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269187607.png" alt=""></p><p>这一段就是开辟空间和初始化直接动调，关键还是对该函数的调用</p><p>注意要先添加命令行参数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269289722.png" alt=""></p><p>开启调试到达该函数，发现了切换为64位工作模式的代码</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269376040.png" alt=""></p><p>将这一段dump下来</p><p>这里调用了920000地址处的函数，所以也要一起dump下来</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269739310.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"./final1"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x920000</span>;<span class="comment">//起始地址</span></span><br><span class="line">  end = <span class="number">0x93006B</span>;<span class="comment">//结束地址</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拖进ida64，可以看出来是tea加密</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269705752.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269865596.png" alt="切换回32位"></p><p>经此全部分析就已经结束了，前十六个字符先转long long型，然后进行tea加密，后5个字符进行异或，tea的密钥直接在调用encode函数处提取即可</p><p>加密代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 tmp0;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 tmp1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag[<span class="number">32</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x25</span>,<span class="number">0xf</span>};</span><br><span class="line"><span class="keyword">unsigned</span> __int64 temp[<span class="number">2</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x425B1CD73C3598F1</span>, <span class="number">0x72C63C6A5ACF14BA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">tmp0 = v11[i];</span><br><span class="line">tmp1 = v11[i + <span class="number">1</span>];</span><br><span class="line">__int64 sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">{</span><br><span class="line">sum += <span class="number">0x9E3779B9</span>;</span><br><span class="line">tmp0 += (sum + tmp1) ^ (a[<span class="number">0</span>] + <span class="number">16</span> * tmp1) ^ (a[<span class="number">1</span>] + (tmp1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">tmp1 += (sum + tmp0) ^ (a[<span class="number">2</span>] + <span class="number">16</span> * tmp0) ^ (a[<span class="number">3</span>] + (tmp0 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">}</span><br><span class="line">v11[i] = tmp0;</span><br><span class="line">v11[i + <span class="number">1</span>] = tmp1;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//0x425B1CD73C3598F1, 0x72C63C6A5ACF14BA</span></span><br></pre></td></tr></tbody></table></figure><p>这里我不知道为啥我拿输入去加密得到的结果和程序的一致，但是解不出来😢</p><p>解不出来的解密代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 tmp0;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 tmp1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag[<span class="number">32</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x25</span>,<span class="number">0xf</span>};</span><br><span class="line"><span class="keyword">unsigned</span> __int64 temp[<span class="number">2</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x425B1CD73C3598F1</span>, <span class="number">0x72C63C6A5ACF14BA</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">tmp0 = v11[<span class="number">0</span>];</span><br><span class="line">tmp1 = v11[<span class="number">1</span>];</span><br><span class="line">__int64 sum = <span class="number">32</span> * <span class="number">0x9E3779B9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp1 -= (sum + tmp0) ^ (a[<span class="number">2</span>] + <span class="number">16</span> * tmp0) ^ (a[<span class="number">3</span>] + (tmp0 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">tmp0 -= (sum + tmp1) ^ (a[<span class="number">0</span>] + <span class="number">16</span> * tmp1) ^ (a[<span class="number">1</span>] + (tmp1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">sum -= <span class="number">0x9E3779B9</span>;</span><br><span class="line">}</span><br><span class="line">v11[<span class="number">0</span>]= tmp0;</span><br><span class="line">v11[<span class="number">1</span>]= tmp1;</span><br></pre></td></tr></tbody></table></figure><p>想动态调试这段汇编好像会出问题，只能单步步过</p><p>不过好像使用WINDBG可以调试</p><h2 id="linux"><a class="header-anchor" href="#linux">¶</a>linux</h2><p>代码分析</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652086069132.png" alt=""></p><p>可以知道这一段代码是在0xDEAD000开辟空间，然后赋值后再SMC解密，然后就出现了无法识别的代码，看汇编动调发现和前面是一样的</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652086040351.png" alt=""></p><p>使用retf实现jmp far</p><p>解决方法同上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CTF中32位程序调用64位代码&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>比赛和复现</title>
    <link href="https://gift1a.github.io/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/"/>
    <id>https://gift1a.github.io/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/</id>
    <published>2022-05-05T08:32:02.000Z</published>
    <updated>2022-06-18T09:07:04.594Z</updated>
    
    <content type="html"><![CDATA[<p>比赛和一些题目复现</p><span id="more"></span><h1 id="Patriotctf2022-Flowing"><a class="header-anchor" href="#Patriotctf2022-Flowing">¶</a>Patriotctf2022-Flowing</h1><p>主程序就这一段，输入一个十六进制数，然后从文件中读取flag，可以采用爆破，可能是因为linux和windows的不同，我自己模拟出来的数据不一样，所以没爆破出来，最后采用了subprocess爆破</p><p><img src="/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/1651739832426.png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">''</span><span class="comment">#绝对正确的前6个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffffffff</span>):<span class="comment">#当前爆破的位置上的字符</span></span><br><span class="line">    real_flag_arr_s=<span class="built_in">str</span>(<span class="built_in">hex</span>(i).strip(<span class="string">'0x'</span>))<span class="comment">#输入到程序中的字符串，hex自带0x所以要去除掉0x</span></span><br><span class="line">    <span class="comment">#上面都是一些初始化</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"./flowing"</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(real_flag_arr_s.encode())</span><br><span class="line">    p.stdin.close()<span class="comment">#停止输入</span></span><br><span class="line">    out = p.stdout.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b"PCTF"</span> <span class="keyword">in</span> out <span class="keyword">or</span> <span class="string">b"pctf"</span> <span class="keyword">in</span> out:</span><br><span class="line">        <span class="built_in">print</span>(out)</span><br><span class="line">        exit()</span><br></pre></td></tr></tbody></table></figure><h1 id="Patriotctf2022-Fishyfish"><a class="header-anchor" href="#Patriotctf2022-Fishyfish">¶</a>Patriotctf2022-Fishyfish</h1><p>得到.s文件，查阅后得知是gcc编译过程中生成的</p><blockquote><p><strong>生成可执行程序过程为成四个步骤： 1、由.c文件到.i文件，这个过程叫预处理。 2、由.i文件到.s文件，这个过程叫编译。 3、由.s文件到.o文件，这个过程叫汇编。 4、由.o文件到可执行文件，这个过程叫链接。</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用以下指令将.s文件生成.o文件</span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line">//使用以下指令将.o文件生成可执行文件</span><br><span class="line">gcc test.o -o test</span><br></pre></td></tr></tbody></table></figure><p>将生成的可执行文件拖入ida中</p><p><img src="/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/1651740964609.png" alt=""></p><p>可以看到这里调用了socket网络通信</p><p><a href="https://zhuanlan.zhihu.com/p/260139078">https://zhuanlan.zhihu.com/p/260139078</a></p><p>先将异或后的数据发送到目标地址中，然后读取数据并写入文件中</p><p>我们可以不使用套接字进行编程，而使用pwntools这个工具，然后模拟socket接收数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启远程端口,网址+端口</span></span><br><span class="line">p=remote(<span class="string">"chal1.pctf.competitivecyber.club"</span>,<span class="number">10015</span>)</span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line">p.send(<span class="string">b"obese dragonfish"</span>)</span><br><span class="line"><span class="comment">#接收指定长度的数据，直到timeout</span></span><br><span class="line">data=p.readn(<span class="number">0x3888</span>)</span><br><span class="line"><span class="comment">#将数据写入文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"fish.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(bin_file)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="Self-Reverse"><a class="header-anchor" href="#Self-Reverse">¶</a>Self-Reverse</h1><h1 id="NCTF2021-狗狗的秘密"><a class="header-anchor" href="#NCTF2021-狗狗的秘密">¶</a>NCTF2021-狗狗的秘密</h1><h2 id="考点：反调试、SMC、进制转换"><a class="header-anchor" href="#考点：反调试、SMC、进制转换">¶</a>考点：反调试、SMC、进制转换</h2><h1 id="NCTF2021-鲨鲨的秘密"><a class="header-anchor" href="#NCTF2021-鲨鲨的秘密">¶</a>NCTF2021-鲨鲨的秘密</h1><h2 id="考点：反调试、CRC32、SMC"><a class="header-anchor" href="#考点：反调试、CRC32、SMC">¶</a>考点：反调试、CRC32、SMC</h2><h1 id="ISCC2022-MYALA"><a class="header-anchor" href="#ISCC2022-MYALA">¶</a>ISCC2022-MYALA</h1><h2 id="考点：维吉尼亚加密、C"><a class="header-anchor" href="#考点：维吉尼亚加密、C">¶</a>考点：维吉尼亚加密、C++</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;比赛和一些题目复现&lt;/p&gt;</summary>
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/categories/Competition/"/>
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>MiniLctf2022</title>
    <link href="https://gift1a.github.io/2022/05/05/MiniLctf2022/"/>
    <id>https://gift1a.github.io/2022/05/05/MiniLctf2022/</id>
    <published>2022-05-05T02:42:32.000Z</published>
    <updated>2022-05-19T09:12:15.256Z</updated>
    
    <content type="html"><![CDATA[<p>题目质量很高，我也是真的菜</p><span id="more"></span><h1 id="题目和WP"><a class="header-anchor" href="#题目和WP">¶</a>题目和WP</h1><p><a href="https://github.com/XDSEC/miniLCTF_2022">https://github.com/XDSEC/miniLCTF_2022</a></p><h1 id="Twin"><a class="header-anchor" href="#Twin">¶</a>Twin</h1><h2 id="考点：TLS-CallBack函数、SMC、XXTEA-XXTEA魔改、反调试、花指令"><a class="header-anchor" href="#考点：TLS-CallBack函数、SMC、XXTEA-XXTEA魔改、反调试、花指令">¶</a>考点：TLS_CallBack函数、SMC、XXTEA+XXTEA魔改、反调试、花指令</h2><h2 id="前置知识-v3"><a class="header-anchor" href="#前置知识-v3">¶</a>前置知识</h2><h3 id="TLS-CALLBACK函数"><a class="header-anchor" href="#TLS-CALLBACK函数">¶</a>TLS_CALLBACK函数</h3><blockquote><p><strong>TLS设计的本意，是为了解决多线程程序中变量同步的问题，是Thread Local Storage的缩写，意为线程本地存储。线程本身有独立于其他线程的栈空间，因此线程中的局部变量不用考虑同步问题。多线程同步问题在于对全局变量的访问，TLS在操作系统的支持下，通过把全局变量打包到一个特殊的节，当每次创建线程时把这个节中的数据当做副本，拷贝到进程空闲的地址空间中。以后线程可以像访问局部变量一样访问该异于其他线程的全局变量的副本，而不用加同步控制。</strong></p></blockquote><p>TLS回调函数常用于反调试</p><p>每当创建或终止进程的线程时会自动调用执行的函数。当然，创建进程的主线程的时候也会自动调用回调函数，且其执行先于EP代码。反调试技术就是利用的TLS回调函数的这一特征。它是各线程独立的数据存储空间，可修改进程的全局/静态数据</p><p>而它可以注册多个TLS_CALLBACK函数</p><p><img src="/2022/05/05/MiniLctf2022/1651974115184.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651974138087.png" alt=""></p><h3 id="进程通信-共享内存CreateFileMapping-MapViewOfFile"><a class="header-anchor" href="#进程通信-共享内存CreateFileMapping-MapViewOfFile">¶</a>进程通信-共享内存CreateFileMapping+MapViewOfFile</h3><p><a href="https://www.cnblogs.com/endenvor/p/9753135.html">https://www.cnblogs.com/endenvor/p/9753135.html</a></p><p>把文件映像到内存，首先必须调用CreateFileMapping()函数，然后再调用MapViewOfFile函数，把文件视映像到进程地址空间上。这样多个子进程都可以访问该内存</p><h2 id="分析-v11"><a class="header-anchor" href="#分析-v11">¶</a>分析</h2><p>这道题所有的字符串都进行了异或加密</p><p>在main函数中逆出来得到的是fake_flag，然后去Export发现了TLS函数</p><p><a href="https://blog.csdn.net/CSNN2019/article/details/113094488">https://blog.csdn.net/CSNN2019/article/details/113094488</a></p><p><img src="/2022/05/05/MiniLctf2022/1651758278192.png" alt=""></p><p>点进去发现里面什么代码都没有，很奇怪，查看汇编</p><p><img src="/2022/05/05/MiniLctf2022/1651758334830.png" alt=""></p><p>这里加了一处花指令导致ida无法正常分析</p><blockquote><p><strong>这段花指令就是将返回地址（call后压入栈的值）加上插入字符串的长度，以跳过这段无用代码</strong></p></blockquote><p>直接改为jmp到原本指令的地址</p><p><img src="/2022/05/05/MiniLctf2022/1651975334021.png" alt=""></p><p>然后F5</p><p><img src="/2022/05/05/MiniLctf2022/1651758540000.png" alt=""></p><p>要注意的是这里面还有一处花指令很坑</p><p><img src="/2022/05/05/MiniLctf2022/1651758596649.png" alt=""></p><p>去除之后，这里就是将我们的函数注册为TLS_CALLBACK函数</p><p><img src="/2022/05/05/MiniLctf2022/1651758699171.png" alt=""></p><h3 id="将文件映射到内存中"><a class="header-anchor" href="#将文件映射到内存中">¶</a>将文件映射到内存中</h3><p><img src="/2022/05/05/MiniLctf2022/1651975828550.png" alt=""></p><p>继续往下，这里的reason是TLS_CALLBACK函数的第二个参数，因为还处于主线程，所以是1，所以不会进入这里的if</p><p><img src="/2022/05/05/MiniLctf2022/1651976154245.png" alt=""></p><p>先在注册的TLS_CALLBACK第二个函数下断点，然后F9</p><p><img src="/2022/05/05/MiniLctf2022/1651976351875.png" alt=""></p><h3 id="Hook掉WriteFile"><a class="header-anchor" href="#Hook掉WriteFile">¶</a>Hook掉WriteFile</h3><p><img src="/2022/05/05/MiniLctf2022/1651976372396.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651976527716.png" alt="Hook函数内部"></p><p>可以看到这里是遍历，然后只要地址等于WriteFile就将final函数的地址赋值过去，实现Hook</p><p><img src="/2022/05/05/MiniLctf2022/1651976683946.png" alt="Hook完成"></p><p>Hook之后ExitProcess</p><p><img src="/2022/05/05/MiniLctf2022/1651976714789.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651976845486.png" alt="结束所有进程和线程"></p><p>所以不会进入到main函数中</p><h3 id="第二次进入TLS-CALLBACK函数"><a class="header-anchor" href="#第二次进入TLS-CALLBACK函数">¶</a>第二次进入TLS_CALLBACK函数</h3><p>此时第二个参数变成了0，进入第二段</p><p>加载资源文件</p><p><img src="/2022/05/05/MiniLctf2022/1651977745611.png" alt=""></p><p>加载EXERES文件，然后xor_0x5F后创建tmp文件</p><blockquote><p>注意这里的WriteFile已经被Hook成我们的函数</p></blockquote><p><img src="/2022/05/05/MiniLctf2022/1651979822133.png" alt=""></p><p>修改值为6，其他正常写入，我们手动去文件修改</p><p><img src="/2022/05/05/MiniLctf2022/1651980030650.png" alt=""></p><p>下面这个函数是将取消Hook，也就是将WriteFile函数恢复</p><p>在Resources Hacker也可以找到资源文件</p><p><img src="/2022/05/05/MiniLctf2022/1651977808202.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651977842463.png" alt="生成tmp文件"></p><p><img src="/2022/05/05/MiniLctf2022/1651976997090.png" alt=""></p><blockquote><p><strong>CreateProcessA创建新进程，这个新进程运行指定的可执行文件tmp文件，也就是创建子进程</strong></p></blockquote><p><a href="https://baike.baidu.com/item/CreateProcess/11050419">https://baike.baidu.com/item/CreateProcess/11050419</a></p><p>这里的3代表的是新进程会被当做被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。</p><p><img src="/2022/05/05/MiniLctf2022/1651990868690.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651979411776.png" alt=""></p><p>此时也可以通过工具查看</p><p><img src="/2022/05/05/MiniLctf2022/1651977305230.png" alt=""></p><h3 id="DEBUG模式"><a class="header-anchor" href="#DEBUG模式">¶</a>DEBUG模式</h3><p><img src="/2022/05/05/MiniLctf2022/1651979468081.png" alt="进入该函数"></p><p>等待调试</p><p><img src="/2022/05/05/MiniLctf2022/1651979593455.png" alt=""></p><h3 id="子进程"><a class="header-anchor" href="#子进程">¶</a>子进程</h3><p>去tmp文件查看</p><p>注册一个异常处理函数</p><p><img src="/2022/05/05/MiniLctf2022/1651980146402.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651980174862.png" alt="异常处理函数"></p><p>当出现地址访问异常时，EIP+2</p><blockquote><p><strong>但是这里要注意因为子进程是DEBUG模式，所以优先让调试器也就是父进程处理</strong></p></blockquote><p>因为子进程是调试状态，所以这里要执行，也就是xxtea的常量进行异或，key[1]改为0x90</p><p><img src="/2022/05/05/MiniLctf2022/1651980332623.png" alt=""></p><h4 id="异常地址"><a class="header-anchor" href="#异常地址">¶</a>异常地址</h4><p><img src="/2022/05/05/MiniLctf2022/1651980405385.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651980416658.png" alt="内存访问出错"></p><p>此时再去父进程看</p><p><img src="/2022/05/05/MiniLctf2022/1651980602332.png" alt=""></p><p>而EAX的值恰好是XXTEA的常量经过处理</p><p><img src="/2022/05/05/MiniLctf2022/1651980653548.png" alt="常量的处理"></p><h4 id="子进程通过文件映射通信"><a class="header-anchor" href="#子进程通过文件映射通信">¶</a>子进程通过文件映射通信</h4><p><img src="/2022/05/05/MiniLctf2022/1651980933549.png" alt=""></p><h4 id="xxtea"><a class="header-anchor" href="#xxtea">¶</a>xxtea</h4><p>最后就是xxtea，不过要注意这里的&gt;&gt;5都改成了&gt;&gt;6,也就是前面WirteFile时候改的数值</p><p><img src="/2022/05/05/MiniLctf2022/1651980951417.png" alt=""></p><p>脚本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA ((((0x9E3779B9 ^0x90909090^ 0x12345678 ^ 0x7b)+12345))^0x1b207)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;6^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(DWORD* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">int</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="comment">//unsigned int enc[155] = { 3532577106, 1472742623, 3642468664, 4193500461, 2398676029, 617653972, 1474514999, 1471783658, 1012864704, 3615627536, 993855884, 438456717, 3358938551, 3906991208, 198959101, 3317190635, 3656923078, 613157871, 2398768861, 97286225, 2336972940, 1471645170, 3233163154, 583597118, 2863776301, 3183067750, 1384330715, 2929694742, 3522431804, 2181488067, 3303062236, 3825712422, 145643141, 2148976293, 2940910035, 506798154, 994590281, 2231904779, 3389770074, 2814269052, 1105937096, 1789727804, 3757028753, 2469686072, 1162286478, 680814033, 2934024098, 2162521262, 4048876895, 2121620700, 4240287315, 2391811140, 3396611602, 3091349617, 3031523010, 2486958601, 3164065171, 1285603712, 798920280, 2337813135, 4186055520, 3523024366, 1077514121, 1436444106, 2731983230, 1507202797, 500756149, 198754565, 2382448647, 880454148, 1970517398, 3217485349, 1161840191, 560498076, 1782600856, 2643721918, 1285196205, 788797746, 1195724574, 4061612551, 103427523, 2502688387, 4147162188, 617564657, 978211984, 1781482121, 2205798970, 3939973102, 3826603515, 659557668, 2582884932, 1561884856, 2217488804, 1189296962, 169145316, 2781742156, 1323893433, 824667876, 408202876, 3759637634, 4094868412, 1508996065, 162419237, 3732146944, 3083560189, 3955940127, 2393776934, 2470191468, 3620861513, 481927014, 2756226070, 3154651143, 1261069441, 2063238535, 2222237213, 101459755, 3159774417, 1721190841, 1078395785, 176506553, 3552913423, 1566142515, 1938949000, 1499289517, 3315102456, 829714860, 3843359394, 952932374, 1283577465, 2045007203, 3957761944, 3767891405, 2917089623, 3296133521, 482297421, 1734231412, 3670478932, 2575334979, 2827842737, 3413631016, 1533519803, 4008428470, 3890643173, 272960248, 317508587, 3299937500, 2440520601, 27470488, 1666674386, 1737927609, 750987808, 2385923471, 2694339191, 562925334, 2206035395 };</span></span><br><span class="line">    DWORD enc[<span class="number">18</span>] = { <span class="number">0x6B7CE328</span>, <span class="number">0x4841D5DD</span>, <span class="number">0x963784DC</span>, <span class="number">0xEF8A3226</span>, <span class="number">0x0776B226</span> };</span><br><span class="line">    <span class="comment">//unsigned int key[4] = {0x12,0x90,0x56,0x78};</span></span><br><span class="line">    <span class="keyword">int</span> key[<span class="number">4</span>] = { <span class="number">0x12</span>,<span class="number">0x90</span>,<span class="number">0x56</span>,<span class="number">0x78</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-5</span>, key);<span class="comment">//长度为多少，解密时第二个参数就改为多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* char s[] = "3e90c91c02e9b40b78b}";</span></span><br><span class="line"><span class="comment">    printf("%d", strlen(s));*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>剩下的一部分也是xxtea，没魔改就不说了</p><h1 id="What-assembly"><a class="header-anchor" href="#What-assembly">¶</a>What assembly</h1><h2 id="考点：WASM逆向"><a class="header-anchor" href="#考点：WASM逆向">¶</a>考点：WASM逆向</h2><p><a href="https://www.52pojie.cn/thread-962068-1-1.html">https://www.52pojie.cn/thread-962068-1-1.html</a></p><p><a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a></p><p><a href="http://www.dwenzhao.cn/profession/netbuild/webassemblyfunc.html">http://www.dwenzhao.cn/profession/netbuild/webassemblyfunc.html</a></p><p>wasm动态调试</p><p>利用python3在与<code>.html</code>、<code>.js</code>、<code>.wasm</code>文件同目录下开启http服务。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8888</span></span><br></pre></td></tr></tbody></table></figure><p>然后在浏览器输入http://127.0.0.1:8888/MiniLctf-2022.html</p><p>下断点动态调试</p><h2 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h2><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wasm<span class="number">2</span><span class="keyword">c</span> flag.wasm -o flag.<span class="keyword">c</span></span><br></pre></td></tr></tbody></table></figure><p>生成flag.c和flag.h</p><p>将之前反编译出来的wasm.c，wasm.h，以及wabt项目内的wasm-rt.h，wasm-rt-impl.c，wasm-rt-impl.h三个文件放到同一个文件夹。</p><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> flag.<span class="keyword">c</span> -o final.o</span><br></pre></td></tr></tbody></table></figure><p>生成.o文件， 因为很多wasm的函数没有具体的实现，我们不需要编译链接生成elf文件</p><p>因为wasm是基于栈的，编译后的C的结构也模拟对栈的操作，所以可以模拟栈进行分析</p><h3 id="基础指令"><a class="header-anchor" href="#基础指令">¶</a>基础指令</h3><p><a href="https://juejin.cn/post/6844904069186715656">https://juejin.cn/post/6844904069186715656</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">load(memory,a2)<span class="comment">//出栈指令</span></span><br><span class="line">    <span class="comment">//将栈顶元素弹出至a1</span></span><br><span class="line">store(memory,a1,a2)<span class="comment">//入栈指令</span></span><br><span class="line">    <span class="comment">//a1一般是栈顶，也就是目标地址，而a2是要入栈的值</span></span><br><span class="line"><span class="comment">//当然上面的指令也是可以指定不同长度的    </span></span><br><span class="line">i32_load8_u<span class="comment">//8位无符号数</span></span><br><span class="line">i32_load8_s<span class="comment">//8位有符号数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//数组索引取值，通过地址+索引</span></span><br><span class="line">    i32_store(&amp;w2c_memory, Stack_Pointer + <span class="number">28LL</span>, <span class="number">0</span>);<span class="comment">// 初始化为索引为0</span></span><br><span class="line">      key_addr = i32_load(&amp;w2c_memory, Stack_Pointer + <span class="number">100LL</span>);</span><br><span class="line">      tmp_key_addr = i32_load(&amp;w2c_memory, Stack_Pointer + <span class="number">28LL</span>) + key_addr;<span class="comment">// 存储key的地址+索引</span></span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><h3 id="分析-v12"><a class="header-anchor" href="#分析-v12">¶</a>分析</h3><p>就一步一步分析</p><p>得出最终的加密过程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROL(a,b) (((a) <span class="meta-string">&lt;&lt; (b)) | ((a) &gt;</span>&gt; (8 - (b))))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qua_rou</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//直接异或即可</span></span><br><span class="line"><span class="comment">//逆着来解密就行了</span></span><br><span class="line">s[b] ^= ROL((s[a] + s[d]) &amp; <span class="number">0xff</span>, <span class="number">4</span>);</span><br><span class="line">s[d] ^= ROL((s[c] + s[b]) &amp; <span class="number">0xff</span>, <span class="number">2</span>);</span><br><span class="line">s[c] ^= ROL((s[b] + s[a]) &amp; <span class="number">0xff</span>, <span class="number">3</span>);</span><br><span class="line">s[a] ^= ROL((s[d] + s[c]) &amp; <span class="number">0xff</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"D33.B4T0"</span>;</span><br><span class="line"><span class="keyword">char</span> table[] = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line"><span class="keyword">char</span> flag[] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> enc[] = { <span class="number">0x05</span>,<span class="number">0x77</span>,<span class="number">0x9c</span>,<span class="number">0x24</span>,<span class="number">0xd9</span>,<span class="number">0x24</span>,<span class="number">0x9e</span>,<span class="number">0x69</span>,<span class="number">0x3f</span>,<span class="number">0xa7</span>,<span class="number">0xac</span>,<span class="number">0x4a</span>,<span class="number">0x10</span>,<span class="number">0xc6</span>,<span class="number">0x8d</span>,<span class="number">0xfb</span>,<span class="number">0xd3</span>,<span class="number">0x52</span>,<span class="number">0x00</span>,<span class="number">0x83</span>,<span class="number">0xb3</span>,<span class="number">0x3f</span>,<span class="number">0x56</span>,<span class="number">0xe9</span>,<span class="number">0x0f</span>,<span class="number">0xd8</span>,<span class="number">0x49</span>,<span class="number">0x78</span>,<span class="number">0xb6</span>,<span class="number">0xa1</span>,<span class="number">0x5c</span>,<span class="number">0x97</span>,<span class="number">0x0b</span>,<span class="number">0x97</span>,<span class="number">0x67</span>,<span class="number">0x79</span>,<span class="number">0xa8</span>,<span class="number">0xfe</span>,<span class="number">0xfe</span>,<span class="number">0x91</span>,<span class="number">0xfb</span>,<span class="number">0x87</span>,<span class="number">0xd2</span>,<span class="number">0x22</span>,<span class="number">0x1c</span>,<span class="number">0x9a</span>,<span class="number">0x1f</span>,<span class="number">0x87</span>,<span class="number">0xed</span>,<span class="number">0x7e</span>,<span class="number">0xad</span>,<span class="number">0xdb</span>,<span class="number">0x8a</span>,<span class="number">0xe6</span>,<span class="number">0x37</span>,<span class="number">0x0f</span>,<span class="number">0x9d</span>,<span class="number">0xe6</span>,<span class="number">0x9e</span>,<span class="number">0x3a</span>,<span class="number">0x7a</span>,<span class="number">0x5c</span>,<span class="number">0x5c</span>,<span class="number">0x48</span>,<span class="number">0x8c</span>,<span class="number">0xde</span>,<span class="number">0x79</span>,<span class="number">0x75</span>,<span class="number">0x6b</span>,<span class="number">0x0b</span>,<span class="number">0x9f</span>,<span class="number">0x17</span>,<span class="number">0x13</span>,<span class="number">0xe7</span>,<span class="number">0x49</span>,<span class="number">0xed</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0xff</span>,<span class="number">0x04</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//key赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">{</span><br><span class="line">s[i] = key[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i+=<span class="number">8</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">{</span><br><span class="line">s[j + <span class="number">8</span>] = flag[i + j];<span class="comment">//每次取出flag的8个字符存储到s中，而前八个是上一轮的加密结果</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">42</span>; ++j)<span class="comment">//进行42轮加密</span></span><br><span class="line">{</span><br><span class="line">qua_rou(s, <span class="number">12</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">qua_rou(s, <span class="number">13</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>);<span class="comment">//根据0-7下标的值对8-15下标的加密（也就是我们的flag）</span></span><br><span class="line">qua_rou(s, <span class="number">14</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(s, <span class="number">15</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">qua_rou(s, <span class="number">15</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">qua_rou(s, <span class="number">12</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">qua_rou(s, <span class="number">13</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(s, <span class="number">14</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> correct = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) </span><br><span class="line">{</span><br><span class="line">correct |= (enc[i * <span class="number">4</span> + j * <span class="number">2</span> + <span class="number">0</span>] != table[s[j] / <span class="number">0x10</span>]);<span class="comment">//加密一次之后，此时s数组长度为16，然后偶数取模</span></span><br><span class="line">correct |= (enc[i * <span class="number">4</span> + j * <span class="number">2</span> + <span class="number">1</span>] != table[s[j] % <span class="number">0x10</span>]);<span class="comment">//奇数取余</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以知道第一轮先把key赋值给s的前八个，将flag的前八个字符赋值给s数组，然后进行42轮的加密</p><p>求解时只需要逆着进行，每次取出密文的16个字符，因为异或过程就只有异或，但是有先后的关系，比如s[12]已经被重新赋值，再次被使用时就会出错，所以要逆着来</p><h3 id="脚本-v6"><a class="header-anchor" href="#脚本-v6">¶</a>脚本</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROL(a,b) (((a) <span class="meta-string">&lt;&lt; (b)) | ((a) &gt;</span>&gt; (8 - (b))))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qua_rou</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//直接异或即可</span></span><br><span class="line"><span class="comment">//逆着来解密就行了</span></span><br><span class="line">s[a] ^= ROL((s[d] + s[c]) &amp; <span class="number">0xff</span>, <span class="number">1</span>);</span><br><span class="line">s[c] ^= ROL((s[b] + s[a]) &amp; <span class="number">0xff</span>, <span class="number">3</span>);</span><br><span class="line">s[d] ^= ROL((s[c] + s[b]) &amp; <span class="number">0xff</span>, <span class="number">2</span>);</span><br><span class="line">s[b] ^= ROL((s[a] + s[d]) &amp; <span class="number">0xff</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"D33.B4T0"</span>;</span><br><span class="line"><span class="keyword">char</span> table[] = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> enc[] = { <span class="number">0x05</span>,<span class="number">0x77</span>,<span class="number">0x9c</span>,<span class="number">0x24</span>,<span class="number">0xd9</span>,<span class="number">0x24</span>,<span class="number">0x9e</span>,<span class="number">0x69</span>,<span class="number">0x3f</span>,<span class="number">0xa7</span>,<span class="number">0xac</span>,<span class="number">0x4a</span>,<span class="number">0x10</span>,<span class="number">0xc6</span>,<span class="number">0x8d</span>,<span class="number">0xfb</span>,<span class="number">0xd3</span>,<span class="number">0x52</span>,<span class="number">0x00</span>,<span class="number">0x83</span>,<span class="number">0xb3</span>,<span class="number">0x3f</span>,<span class="number">0x56</span>,<span class="number">0xe9</span>,<span class="number">0x0f</span>,<span class="number">0xd8</span>,<span class="number">0x49</span>,<span class="number">0x78</span>,<span class="number">0xb6</span>,<span class="number">0xa1</span>,<span class="number">0x5c</span>,<span class="number">0x97</span>,<span class="number">0x0b</span>,<span class="number">0x97</span>,<span class="number">0x67</span>,<span class="number">0x79</span>,<span class="number">0xa8</span>,<span class="number">0xfe</span>,<span class="number">0xfe</span>,<span class="number">0x91</span>,<span class="number">0xfb</span>,<span class="number">0x87</span>,<span class="number">0xd2</span>,<span class="number">0x22</span>,<span class="number">0x1c</span>,<span class="number">0x9a</span>,<span class="number">0x1f</span>,<span class="number">0x87</span>,<span class="number">0xed</span>,<span class="number">0x7e</span>,<span class="number">0xad</span>,<span class="number">0xdb</span>,<span class="number">0x8a</span>,<span class="number">0xe6</span>,<span class="number">0x37</span>,<span class="number">0x0f</span>,<span class="number">0x9d</span>,<span class="number">0xe6</span>,<span class="number">0x9e</span>,<span class="number">0x3a</span>,<span class="number">0x7a</span>,<span class="number">0x5c</span>,<span class="number">0x5c</span>,<span class="number">0x48</span>,<span class="number">0x8c</span>,<span class="number">0xde</span>,<span class="number">0x79</span>,<span class="number">0x75</span>,<span class="number">0x6b</span>,<span class="number">0x0b</span>,<span class="number">0x9f</span>,<span class="number">0x17</span>,<span class="number">0x13</span>,<span class="number">0xe7</span>,<span class="number">0x49</span>,<span class="number">0xed</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0xff</span>,<span class="number">0x04</span> };</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">17</span>] = { <span class="number">0</span> };</span><br><span class="line">buf[<span class="number">16</span>] = <span class="number">0</span>;</span><br><span class="line">memmove(buf, enc + i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">42</span>; ++j)</span><br><span class="line">{</span><br><span class="line">qua_rou(buf, <span class="number">14</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">qua_rou(buf, <span class="number">13</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(buf, <span class="number">12</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">qua_rou(buf, <span class="number">15</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">qua_rou(buf, <span class="number">15</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">qua_rou(buf, <span class="number">14</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(buf, <span class="number">13</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">qua_rou(buf, <span class="number">12</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, buf+<span class="number">8</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="NotRC4"><a class="header-anchor" href="#NotRC4">¶</a>NotRC4</h1><h2 id="考点：RISV架构"><a class="header-anchor" href="#考点：RISV架构">¶</a>考点：RISV架构</h2><p>使用readelf可以知道是RISV架构</p><p><img src="/2022/05/05/MiniLctf2022/1651987423786.png" alt=""></p><h2 id="过程-v2"><a class="header-anchor" href="#过程-v2">¶</a>过程</h2><p>ida无法反编译，jeb可以反编译但是效果不太好，最好的还是Ghidra</p><p>就是一个VM题</p><p>分析完大概就是这样</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">final</span>[<span class="number">4</span>] = {</span><br><span class="line"><span class="number">0x4BC21DBB95EF82CA</span>, <span class="number">0xF57BECAE71B547BE</span>, <span class="number">0x80A1BDAB15E7F6CD</span>, <span class="number">0xA3C793D7E1776385</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> opcode[<span class="number">23</span>] = {</span><br><span class="line"><span class="number">0xF3</span>, <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0xE1</span>, <span class="number">0xF4</span>, <span class="number">0xE2</span>, <span class="number">0xF2</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0xF5</span>, <span class="number">0xF3</span>, <span class="number">0x02</span>, <span class="number">0xF4</span>, <span class="number">0xE1</span>, <span class="number">0xF4</span>, <span class="number">0xE2</span>,</span><br><span class="line"><span class="number">0xF2</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xFF</span>, <span class="number">0x00</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//F1对应的指令</span></span><br><span class="line"><span class="comment">//compare,long型的判断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F2</span></span><br><span class="line"><span class="comment">//循环的操作，和0x0B作比较，作为循环的次数，而4是指回到前四个指令的位置，实现循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F3，取出输入然后加上yyds和dbt!(小端序)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F4加密操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//F5,存储</span></span><br><span class="line"><span class="keyword">int</span> key[<span class="number">2</span>] = { <span class="number">0x64627421</span>, <span class="number">0x79796473</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp1 = <span class="keyword">final</span>[i] + key[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp2 = <span class="keyword">final</span>[i + <span class="number">1</span>] + key[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x0C</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp1 = ((tmp1 ^ tmp2) &gt;&gt; (-(<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>) | ((tmp1 ^ tmp2) &lt;&lt; ((<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>) + key[<span class="number">0</span>];</span><br><span class="line">tmp2 = ((tmp1 ^ tmp2) &gt;&gt; (-(<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>) | ((tmp1 ^ tmp2) &lt;&lt; ((<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>) + key[<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[i] = tmp1;</span><br><span class="line"><span class="keyword">final</span>[i + <span class="number">1</span>] = tmp2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>脚本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp1 = <span class="keyword">final</span>[i];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp2 = <span class="keyword">final</span>[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x0C</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp2 = ((((tmp2 - key[<span class="number">1</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &lt;&lt; ((-(<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>)) | (((tmp2 - key[<span class="number">1</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &gt;&gt; (((<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>))) ^ tmp1;</span><br><span class="line">tmp1 = ((((tmp1 - key[<span class="number">0</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &lt;&lt; ((-(<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>)) | (((tmp1 - key[<span class="number">0</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &gt;&gt; (((<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>))) ^ tmp2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[i] = tmp1 - key[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">final</span>[i+<span class="number">1</span>] = tmp2 - key[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">3</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">4</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">5</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">6</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">3</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">4</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">5</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">6</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">7</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目质量很高，我也是真的菜&lt;/p&gt;</summary>
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/categories/Competition/"/>
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>Frida-Hook</title>
    <link href="https://gift1a.github.io/2022/05/01/Frida-Hook/"/>
    <id>https://gift1a.github.io/2022/05/01/Frida-Hook/</id>
    <published>2022-04-30T21:18:23.000Z</published>
    <updated>2022-05-05T06:01:43.455Z</updated>
    
    <content type="html"><![CDATA[<p>Frida-Hook</p><span id="more"></span><h1 id="0x00-示例"><a class="header-anchor" href="#0x00-示例">¶</a>0x00-示例</h1><h2 id="0x00-配置环境"><a class="header-anchor" href="#0x00-配置环境">¶</a>0x00-配置环境</h2><h3 id="Frida安装"><a class="header-anchor" href="#Frida安装">¶</a>Frida安装</h3><p>直接pip install  frida-tools、pip install frida即可</p><h3 id="Frida-server"><a class="header-anchor" href="#Frida-server">¶</a>Frida-server</h3><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro<span class="selector-class">.product</span><span class="selector-class">.cpu</span>.abi</span><br></pre></td></tr></tbody></table></figure><p>查看CPU信息</p><p>选择对应手机版本的即可</p><p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><h3 id="配置手机端"><a class="header-anchor" href="#配置手机端">¶</a>配置手机端</h3><p><img src="/2022/05/01/Frida-Hook/1651354655163.png" alt=""></p><p>先将frida-server文件存至手机文件夹data/local/tmp中</p><p>然后授权</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">adb</span> forward tcp:<span class="number">27042</span> tcp:<span class="number">27042</span></span><br></pre></td></tr></tbody></table></figure><p>端口转发</p><h2 id="0x01-代码审计"><a class="header-anchor" href="#0x01-代码审计">¶</a>0x01-代码审计</h2><p>这是Namahonctf的一道Mobile题</p><p><img src="/2022/05/01/Frida-Hook/1651356220172.png" alt=""></p><p>从这里可以看出这里只需要点击的次数为0x5F5E0FF即可获得flag，所以采用自动化工具更为方便</p><h2 id="0x02-编写脚本"><a class="header-anchor" href="#0x02-编写脚本">¶</a>0x02-编写脚本</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> click = Java.use(<span class="string">"com.example.clickme.MainActivity"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> run = click.$new();</span><br><span class="line">    <span class="keyword">var</span> returnvalue = run.getFlag();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Flag: "</span> + returnvalue);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><p>先让frida-server处于开启状态</p><p><img src="/2022/05/01/Frida-Hook/1651355616556.png" alt=""></p><p>在手机中打开程序，通过以下命令查找进程</p><p><img src="/2022/05/01/Frida-Hook/1651354746522.png" alt=""></p><p>开启</p><p><img src="/2022/05/01/Frida-Hook/1651355383018.png" alt=""></p><p>-U 连接USB设备<br>-l 加载JavaScript脚本文件<br>-f表示包名</p><p>–no–pause表示没有暂停</p><h1 id="0x03-Frida简介"><a class="header-anchor" href="#0x03-Frida简介">¶</a>0x03-Frida简介</h1><p>在反编译时我们难以知道某个函数在被调用时所传入的参数和他返回的值，这样增加了我们逆向的复杂性</p><p>而使用HOOK可以让我们知道被传入的参数和返回值</p><blockquote><p><strong>Hook的原理简单来说就是用一个新的函数替代掉原来的函数，在这个新的函数中你想做什么都可以</strong></p></blockquote><p>而Frida就是一个很常用的Hook工具（python+js接口），只需要编写一段Javascript代码就能对指定的函数进行Hook</p><p><a href="https://www.anquanke.com/post/id/197670#h2-5">https://www.anquanke.com/post/id/197670#h2-5</a></p><p>Frida还可以用来<strong>访问进程的内存、应用程序运行时覆盖功能、从导入的类调用函数、动态Hook跟踪、拦截函数等</strong></p><p><strong>Frida基础语法</strong></p><p><a href="https://www.anquanke.com/post/id/195215">https://www.anquanke.com/post/id/195215</a></p><p><a href="https://blog.csdn.net/LoopherBear/article/details/107085949">https://blog.csdn.net/LoopherBear/article/details/107085949</a></p><p><a href="https://zyzling.gitee.io/2020/05/12/Frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%AE%80%E5%8D%95%E8%84%9A%E6%9C%AC%EF%BC%88%E6%8A%84%E7%9A%84%EF%BC%89">https://zyzling.gitee.io/2020/05/12/Frida学习笔记/#简单脚本（抄的）</a></p><p><a href="https://blog.csdn.net/u012717638/article/details/110118697">https://blog.csdn.net/u012717638/article/details/110118697</a></p><p><strong>示例</strong></p><p><a href="https://xz.aliyun.com/t/8211">https://xz.aliyun.com/t/8211</a></p><p><strong>Frida Hook so</strong></p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/115582853">https://blog.csdn.net/weixin_39190897/article/details/115582853</a></p><p><a href="https://blog.csdn.net/weixin_38819889/article/details/122535920">https://blog.csdn.net/weixin_38819889/article/details/122535920</a></p><h2 id="Javascript编写"><a class="header-anchor" href="#Javascript编写">¶</a>Javascript编写</h2><p>以上面的代码为例</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java.perform开始执行JavaScript脚本</span></span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="comment">//Java.use指定要使用的类，click变量</span></span><br><span class="line">    <span class="keyword">var</span> click = Java.use(<span class="string">"com.example.clickme.MainActivity"</span>);</span><br><span class="line"><span class="comment">//new一个对象创建类，该类和click（也就是mainactivity）一致</span></span><br><span class="line">    <span class="keyword">var</span> run = click.$new();</span><br><span class="line">    <span class="keyword">var</span> returnvalue = run.getFlag();</span><br><span class="line"><span class="comment">//调用类中的方法，打印getFlag的返回值，也就是flag</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Flag: "</span> + returnvalue);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><h3 id="console"><a class="header-anchor" href="#console">¶</a>console</h3><p>打印内存中的值</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定so文件</span></span><br><span class="line"><span class="keyword">var</span> libc = Module.findBaseAddress(<span class="string">'libc.so'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hexdump(libc, {</span><br><span class="line">  <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">64</span>,</span><br><span class="line">  <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">ansi</span>: <span class="literal">true</span></span><br><span class="line">}));</span><br></pre></td></tr></tbody></table></figure><h2 id="python-js"><a class="header-anchor" href="#python-js">¶</a>python+js</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"[*] {0}"</span>.<span class="built_in">format</span>(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"><span class="comment">#js代码</span></span><br><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function () {</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity');</span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function (v) {</span></span><br><span class="line"><span class="string">        send("Hook Start...");</span></span><br><span class="line"><span class="string">        this.onClick(v);</span></span><br><span class="line"><span class="string">        this.n.value = 0;</span></span><br><span class="line"><span class="string">        this.m.value = 2;</span></span><br><span class="line"><span class="string">        this.cnt.value = 999;</span></span><br><span class="line"><span class="string">        send("Success!")</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">});</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#附加到usb设备，attach后面是进程名</span></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">'com.example.seccon2015.rock_paper_scissors'</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Frida-Hook&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>安卓逆向-修改smali代码并打包</title>
    <link href="https://gift1a.github.io/2022/04/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E4%BF%AE%E6%94%B9smali%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%89%93%E5%8C%85/"/>
    <id>https://gift1a.github.io/2022/04/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E4%BF%AE%E6%94%B9smali%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%89%93%E5%8C%85/</id>
    <published>2022-04-30T00:43:46.000Z</published>
    <updated>2022-05-05T11:41:42.759Z</updated>
    
    <content type="html"><![CDATA[<p>修改smali代码并打包</p><span id="more"></span><p>安卓逆向-打包-重签名<br><a href="https://blog.csdn.net/syxsyfsyh/article/details/89056820">https://blog.csdn.net/syxsyfsyh/article/details/89056820</a><br><a href="https://www.jianshu.com/p/792a08d5452c">https://www.jianshu.com/p/792a08d5452c</a><br><a href="https://www.cnblogs.com/shuaiwu1108/p/13534044.html">https://www.cnblogs.com/shuaiwu1108/p/13534044.html</a><br>签名验证与反调试<br><a href="https://blog.csdn.net/weixin_39190897/article/details/121024165">https://blog.csdn.net/weixin_39190897/article/details/121024165</a></p><p>dex转smali<br><a href="https://www.jianshu.com/p/9bf9467c7c7e">https://www.jianshu.com/p/9bf9467c7c7e</a><br><a href="https://bitbucket.org/JesusFreke/smali/downloads/">https://bitbucket.org/JesusFreke/smali/downloads/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;修改smali代码并打包&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF-FATE-Reverse</title>
    <link href="https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/"/>
    <id>https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/</id>
    <published>2022-04-23T12:40:54.000Z</published>
    <updated>2022-04-24T07:53:15.696Z</updated>
    
    <content type="html"><![CDATA[<p>DASCTF-FATE-Reverse</p><span id="more"></span> <h1 id="0x00-Crackme"><a class="header-anchor" href="#0x00-Crackme">¶</a>0x00-Crackme</h1><h2 id="考点-v8"><a class="header-anchor" href="#考点-v8">¶</a>考点</h2><p>MFC逆向、反调试、Wincrypt</p><h2 id="分析-v8"><a class="header-anchor" href="#分析-v8">¶</a>分析</h2><p>看exe文件的图标是MFC，于是去网上搜了一下MFC逆向，发现了这篇文章</p><p><a href="https://blog.csdn.net/Sanky0u/article/details/81568483">https://blog.csdn.net/Sanky0u/article/details/81568483</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650718980990.png" alt=""></p><p>1000和1001对应两个输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719074057.png" alt=""></p><p>能定位到输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719123440.png" alt=""></p><p>对函数交叉引用发现找不到，因为这里使用的是this指针调用（可能）</p><blockquote><p><strong>MFC主函数是WinMain</strong></p></blockquote><p>然后动调半天看晕了</p><p>字符串搜索回显的字符串Wrong，直接明文存储</p><p>如果下次有机会出这样的题一定把回显字符串加密（</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719281899.png" alt=""></p><p>流程分析</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719629400.png" alt=""></p><p>这里都是一些API函数，就不过多介绍了</p><h3 id="key加密"><a class="header-anchor" href="#key加密">¶</a>key加密</h3><p>关键的是</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719692346.png" alt=""></p><p>不同的值对应了不同的加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719799678.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719826383.png" alt=""></p><p>所以就是将我们输入的key分为两个长度为四的字符串，然后分别进行MD5和SHA1加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719927941.png" alt="最终的加密"></p><h3 id="flag加密"><a class="header-anchor" href="#flag加密">¶</a>flag加密</h3><p>先把整段key进行md5加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720029530.png" alt=""></p><p>然后将加密后的key传入最终的加密函数中，生成MD5的哈希值，传入生成Key</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720157885.png" alt=""></p><p>看到这个参数，查了一下</p><p><a href="https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN">https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN</a></p><p>发现对应AES-128，也就是生成AES-128的密钥</p><p>然后调用CryptEncrypt函数加密</p><h3 id="反调试-ZwSetInformationThread"><a class="header-anchor" href="#反调试-ZwSetInformationThread">¶</a>反调试-ZwSetInformationThread</h3><p>我们需要动态调试提取数据，但是在刚才的位置设置断点会发现输入后直接结束，应该是有反调试</p><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/">https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/</a></p><p>对比各种反调试和去IMPORT找导入函数，最终确定是ZwSetInformationThread</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720722604.png" alt=""></p><p>反反调试在该文中也有介绍，就不再多说了</p><p>绕过后就可以提取数据进行解密了</p><h3 id="得到key"><a class="header-anchor" href="#得到key">¶</a>得到key</h3><p>MD5</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650761698008.png" alt=""></p><p>SHA1</p><p><a href="https://crackstation.net/">https://crackstation.net/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762007404.png" alt=""></p><h3 id="解密flag"><a class="header-anchor" href="#解密flag">¶</a>解密flag</h3><p>这里直接提取数据拿去AES解密有问题（提取出来调用CryptDecrypt也不行），还是FallW1nd师傅强，想到直接模拟生成哈希值的过程，然后最后调用CryptDecrypt即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762204848.png" alt=""></p><p>EXP如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HCRYPTKEY phKey; <span class="comment">// [esp+Ch] [ebp-10h] BYREF</span></span><br><span class="line">    HCRYPTPROV phProv; <span class="comment">// [esp+10h] [ebp-Ch] BYREF</span></span><br><span class="line">    HCRYPTHASH phHash; <span class="comment">// [esp+14h] [ebp-8h] BYREF</span></span><br><span class="line">    BOOL retValue;</span><br><span class="line"></span><br><span class="line">    BYTE flag_data[<span class="number">0x104</span>] = { <span class="number">0x5B</span>, <span class="number">0x9C</span>, <span class="number">0xEE</span>, <span class="number">0xB2</span>, <span class="number">0x3B</span>, <span class="number">0xB7</span>, <span class="number">0xD7</span>, <span class="number">0x34</span>, <span class="number">0xF3</span>, <span class="number">0x1B</span>, <span class="number">0x75</span>, <span class="number">0x14</span>, <span class="number">0xC6</span>, <span class="number">0xB2</span>, <span class="number">0x1F</span>, <span class="number">0xE8</span>, <span class="number">0xDE</span>, <span class="number">0x33</span>, <span class="number">0x44</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x1B</span>, <span class="number">0x47</span>, <span class="number">0x6A</span>, <span class="number">0xD4</span>, <span class="number">0x37</span>, <span class="number">0x51</span>, <span class="number">0x88</span>, <span class="number">0xFC</span>, <span class="number">0x67</span>, <span class="number">0xE6</span>, <span class="number">0x60</span>, <span class="number">0xDA</span>, <span class="number">0x0D</span>, <span class="number">0x58</span>, <span class="number">0x07</span>, <span class="number">0x81</span>, <span class="number">0x43</span>, <span class="number">0x53</span>, <span class="number">0xEA</span>, <span class="number">0x7B</span>, <span class="number">0x52</span>, <span class="number">0x85</span>, <span class="number">0x6C</span>, <span class="number">0x86</span>, <span class="number">0x65</span>, <span class="number">0xAF</span>, <span class="number">0xB4</span> };</span><br><span class="line">    BYTE keyBuf[] = { <span class="number">0x5c</span>,<span class="number">0x53</span>,<span class="number">0xa4</span>,<span class="number">0xa4</span>,<span class="number">0x1d</span>,<span class="number">0x52</span>,<span class="number">0x43</span>,<span class="number">0x7a</span>,<span class="number">0x9f</span>,<span class="number">0xa1</span>,<span class="number">0xe9</span>,<span class="number">0xc2</span>,<span class="number">0x6c</span>,<span class="number">0xa5</span>,<span class="number">0x90</span>,<span class="number">0x90</span> };</span><br><span class="line">    DWORD dwDataLen = <span class="number">0x10</span>;</span><br><span class="line">    DWORD dwBufLen = <span class="number">0x104</span>;</span><br><span class="line">    DWORD dwDataLen_2;</span><br><span class="line">    DWORD* pdwDataLen = &amp;dwDataLen_2;</span><br><span class="line">    *pdwDataLen = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    phProv = <span class="number">0</span>;</span><br><span class="line">    phHash = <span class="number">0</span>;</span><br><span class="line">    phKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retValue = CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x18</span>u, <span class="number">0xF0000000</span>);</span><br><span class="line">    <span class="keyword">if</span> (retValue)</span><br><span class="line">    {</span><br><span class="line">        retValue = CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash);</span><br><span class="line">        <span class="keyword">if</span> (retValue)</span><br><span class="line">        {</span><br><span class="line">            retValue = CryptHashData(phHash, keyBuf, dwDataLen, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (retValue)</span><br><span class="line">            {</span><br><span class="line">                retValue = CryptDeriveKey(phProv, <span class="number">0x660E</span>u, phHash, <span class="number">1u</span>, &amp;phKey);</span><br><span class="line">                <span class="keyword">if</span> (retValue)</span><br><span class="line">                    retValue = CryptDecrypt(phKey, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, flag_data, pdwDataLen);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phKey)</span><br><span class="line">        CryptDestroyKey(phKey);</span><br><span class="line">    <span class="keyword">if</span> (phHash)</span><br><span class="line">        CryptDestroyHash(phHash);</span><br><span class="line">    <span class="keyword">if</span> (phProv)</span><br><span class="line">        CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h3><p>还有这种调用加密，有兴趣可以去看看-<a href="http://ctf.hsc2019.site/challenges#DRIVER-58">http://ctf.hsc2019.site/challenges#DRIVER-58</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762364038.png" alt=""></p><h1 id="0x01-FakePica"><a class="header-anchor" href="#0x01-FakePica">¶</a>0x01-FakePica</h1><h2 id="考点-v9"><a class="header-anchor" href="#考点-v9">¶</a>考点</h2><p>安卓加壳、AES</p><h2 id="分析-v9"><a class="header-anchor" href="#分析-v9">¶</a>分析</h2><p>hgame-week3-re也有脱壳，这里把工具链接贴一下</p><p><a href="https://github.com/CodingGay/BlackDex">https://github.com/CodingGay/BlackDex</a></p><p>具体分析加壳与脱壳直接看我之前写的文章</p><p><a href="https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=%E6%A2%86">https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=梆</a></p><h3 id="加密分析"><a class="header-anchor" href="#加密分析">¶</a>加密分析</h3><p>找到Mainactivity</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762932688.png" alt=""></p><p>数据提取</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content[] = {<span class="number">-114</span>, <span class="number">95</span>, <span class="number">-37</span>, <span class="number">127</span>, <span class="number">-110</span>, <span class="number">113</span>, <span class="number">41</span>, <span class="number">74</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">19</span>, <span class="number">124</span>, <span class="number">-57</span>, <span class="number">-88</span>, <span class="number">39</span>, <span class="number">-116</span>, <span class="number">-16</span>, <span class="number">-75</span>, <span class="number">-3</span>, <span class="number">-45</span>, <span class="number">-73</span>, <span class="number">-6</span>, <span class="number">-104</span>, <span class="number">-6</span>, <span class="number">-78</span>, <span class="number">121</span>, <span class="number">110</span>, <span class="number">74</span>, <span class="number">-90</span>, <span class="number">-47</span>, <span class="number">-28</span>, <span class="number">-28</span>};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content1[] = {<span class="number">-40</span>, <span class="number">26</span>, <span class="number">95</span>, <span class="number">-49</span>, <span class="number">-40</span>, <span class="number">-123</span>, <span class="number">72</span>, <span class="number">-90</span>, <span class="number">-100</span>, <span class="number">-41</span>, <span class="number">122</span>, <span class="number">-4</span>, <span class="number">25</span>, <span class="number">-101</span>, <span class="number">-58</span>, <span class="number">116</span>};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, content1[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解密直接去在线网站即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763024950.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763086950.png" alt="get flag"></p><h1 id="0x02-奇怪的交易"><a class="header-anchor" href="#0x02-奇怪的交易">¶</a>0x02-奇怪的交易</h1><h2 id="考点-v10"><a class="header-anchor" href="#考点-v10">¶</a>考点</h2><p>ELF-python打包、算法</p><h2 id="分析-v10"><a class="header-anchor" href="#分析-v10">¶</a>分析</h2><p>还好加了Lu1u师傅，刚好看到</p><p><a href="https://lu1u.xyz/2022/03/28/RE_Challenge/">https://lu1u.xyz/2022/03/28/RE_Challenge/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763204421.png" alt=""></p><blockquote><p><strong>objcopy --dump-section pydata=pydata.dump 1</strong></p><p><strong>sudo snap install pyinstxtractor</strong></p><p><strong>pyinstxtractor pydata.dump</strong></p></blockquote><p>得到pyc文件，修补好文件头发现uncompyle6不了（因为是3.10的），寄，只能嗯读python字节码</p><h3 id="翻译字节码"><a class="header-anchor" href="#翻译字节码">¶</a>翻译字节码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cup <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">pub_key=[<span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,<span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">pp=[<span class="number">0</span>]</span><br><span class="line">dd=[<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>]</span><br><span class="line">oo=[<span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">        <span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,</span><br><span class="line">        <span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">    flag=<span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    m=libnum.s2n(flag)<span class="comment">#字符串转为数字</span></span><br><span class="line">    c=<span class="built_in">str</span>(<span class="built_in">pow</span>(m,pub_key[<span class="number">1</span>],pub_key[<span class="number">0</span>]))<span class="comment">#简单算法并且进行转为字符串</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">        kk=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> c[<span class="built_in">slice</span>(i,i+<span class="number">4</span>)]:</span><br><span class="line">            kk=(kk&lt;&lt;<span class="number">8</span>)+<span class="built_in">ord</span>(ii)</span><br><span class="line">            pp.append(kk)</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">            ww=<span class="built_in">len</span>(pp)</span><br><span class="line">            res=encrypt(ww,pp,dd)</span><br><span class="line">    <span class="keyword">if</span> pp==oo:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are right!!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"gg"</span>)</span><br><span class="line">        quit()</span><br></pre></td></tr></tbody></table></figure><p>翻译出来大概是这样的</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785245624.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785253078.png" alt=""></p><p>这里要关注跳转的条件是not还是true</p><blockquote><p><em><em>encrypt函数是cup库里面的一个函数，当时我忽略了from cup import</em>，导致一直识别不出来encrypt函数是什么</em>*</p></blockquote><p>过程差不多都可以读出来，那个for循环就是将每四个字符转为一个int，由于不会python，很多都是自己写代码试出来的（,剩下的蹲wp了</p><blockquote><p>整个过程就是先进行RSA加密，然后调用encrypt函数加密</p></blockquote><h4 id="tip"><a class="header-anchor" href="#tip">¶</a>tip</h4><p>看了https://blog.t0hka.top/index.php/archives/36/才知道可以使用在线工具</p><p><a href="https://tool.lu/pyc/%EF%BC%8C%E6%95%88%E6%9E%9C%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E4%BF%AE%E5%A4%8D%E4%B8%80%E4%B8%8B">https://tool.lu/pyc/，效果差不多，不过还是需要自己修复一下</a></p><h3 id="pyinstaller加密"><a class="header-anchor" href="#pyinstaller加密">¶</a>pyinstaller加密</h3><p><a href="https://bbs.pediy.com/thread-271253.htm">https://bbs.pediy.com/thread-271253.htm</a></p><p>我们可以在解包的时候发现两个文件，一个是加密的密钥，一个是加密的过程</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785638921.png" alt=""></p><p>接下来只需要对PYZ文件解包（同样使用pyinxtxtractor），得到加密后的cup库即可</p><p>解密脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> tinyaes</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从crypt_key.pyc获取key，也可自行反编译获取</span></span><br><span class="line">key = <span class="built_in">bytes</span>(<span class="string">'0000000000000tea'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">'cup.pyc.encrypted'</span>, <span class="string">'rb'</span>)  <span class="comment"># 打开加密文件</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">'cup.pyc'</span>, <span class="string">'wb'</span>)  <span class="comment"># 输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按加密块大小进行读取</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line"></span><br><span class="line">cipher = tinyaes.AES(key, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补pyc头(最后自己补也行)</span></span><br><span class="line">outf.write(<span class="string">b'\x6f\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入解密数据</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line"></span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>反编译得到cup库的内容</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MX</span>(<span class="params">z, y, total, key, p, e</span>):</span></span><br><span class="line">    temp1 = (z.value &gt;&gt; <span class="number">5</span> ^ y.value &lt;&lt; <span class="number">2</span>) + (y.value &gt;&gt; <span class="number">3</span> ^ z.value &lt;&lt; <span class="number">4</span>)</span><br><span class="line">    temp2 = (total.value ^ y.value) + (key[p &amp; <span class="number">3</span> ^ e.value] ^ z.value)</span><br><span class="line">    <span class="keyword">return</span> c_uint32(temp1 ^ temp2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">ᘗ, ᘖ, ᘘ</span>):</span></span><br><span class="line">    ᘜ = <span class="number">0x9E3779B9L</span></span><br><span class="line">    ᘛ = <span class="number">6</span> + <span class="number">52</span> // ᘗ</span><br><span class="line">    total = c_uint32(<span class="number">0</span>)</span><br><span class="line">    ᘔ = c_uint32(ᘖ[ᘗ - <span class="number">1</span>])</span><br><span class="line">    ᘕ = c_uint32(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ᘛ &gt; <span class="number">0</span>:</span><br><span class="line">        total.value += ᘜ</span><br><span class="line">        ᘕ.value = total.value &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        ᘚ = c_uint32(ᘖ[<span class="number">0</span>])</span><br><span class="line">        ᘖ[ᘗ - <span class="number">1</span>] = c_uint32(ᘖ[ᘗ - <span class="number">1</span>] + MX(ᘔ, ᘚ, total, ᘘ, ᘗ - <span class="number">1</span>, ᘕ).value).value</span><br><span class="line">        ᘔ.value = ᘖ[ᘗ - <span class="number">1</span>]</span><br><span class="line">        ᘛ -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ᘛ &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ᘖ</span><br></pre></td></tr></tbody></table></figure><p>可以看出是xxtea加密</p><h2 id="解密-v2"><a class="header-anchor" href="#解密-v2">¶</a>解密</h2><p>得到rsa的密文c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">uint32_t</span>* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">uint32_t</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> enc[<span class="number">155</span>] = { <span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = { (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-155</span>, key);<span class="comment">//长度为多少，解密时第二个参数就改为多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">155</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, (((enc[i]) &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0xff</span>));</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解RSA，怪我不是密码🤠,直接贴t0hka师傅的脚本了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_hack</span>(<span class="params">e, n</span>):</span></span><br><span class="line">    <span class="comment"># firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git !</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span> <span class="keyword">and</span> (e * d - <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            discr = s * s - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> (discr &gt;= <span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t != -<span class="number">1</span> <span class="keyword">and</span> (s + t) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">    <span class="number">0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25</span>,</span><br><span class="line">    <span class="number">0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68B</span>]</span><br><span class="line">    <span class="comment"># 0-&gt;n,1-&gt;e</span></span><br><span class="line"></span><br><span class="line">    n = pub_key[<span class="number">0</span>]</span><br><span class="line">    e = pub_key[<span class="number">1</span>]</span><br><span class="line">    c = <span class="number">10610336534759505889607399322387179316771488492347274741918862678692508953185876570981227584004676580623553664818853686933004290078153620168054665086468417541382824708104480882577200529822968531743002301934310349005341104696887943182074473298650903541494918266823037984054778903666406545980557074219162536057146090758158128189406073809226361445046225524917089434897957301396534515964547462425719205819342172669899546965221084098690893672595962129879041507903210851706793788311452973769358455761907303633956322972510500253009083922781934406731633755418753858930476576720874219359466503538931371444470303193503733920039</span></span><br><span class="line">    d = wiener_hack(e, n)</span><br><span class="line">    m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m)) <span class="comment">#  flag{You_Need_Some_Tea} </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;DASCTF-FATE-Reverse&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>安卓动调</title>
    <link href="https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/"/>
    <id>https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/</id>
    <published>2022-04-23T00:53:44.000Z</published>
    <updated>2022-04-27T01:02:14.296Z</updated>
    
    <content type="html"><![CDATA[<p>安卓动态调试</p><span id="more"></span> <h1 id="0x00-IDA调试so文件"><a class="header-anchor" href="#0x00-IDA调试so文件">¶</a>0x00-IDA调试so文件</h1><h2 id="参考文章-v7"><a class="header-anchor" href="#参考文章-v7">¶</a>参考文章</h2><p><a href="https://bbs.pediy.com/thread-262524.htm">https://bbs.pediy.com/thread-262524.htm</a></p><h2 id="实操"><a class="header-anchor" href="#实操">¶</a>实操</h2><blockquote><p><strong>注意：手机要先ROOT，调试的so文件根据系统版本来选择</strong></p></blockquote><p>我的是arm64，所以选择这个</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937243317.png" alt=""></p><h3 id="打开手机的USB调试功能"><a class="header-anchor" href="#打开手机的USB调试功能">¶</a>打开手机的USB调试功能</h3><p>首先打开开发者选项，然后进入开发者选项打开USB调试</p><h3 id="adb连接手机"><a class="header-anchor" href="#adb连接手机">¶</a>adb连接手机</h3><blockquote><p>adb devices</p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866742532.png" alt=""></p><h3 id="adb进入手机"><a class="header-anchor" href="#adb进入手机">¶</a>adb进入手机</h3><blockquote><p>adb shell</p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866794822.png" alt=""></p><h3 id="查看手机ro-debuggable"><a class="header-anchor" href="#查看手机ro-debuggable">¶</a>查看手机ro.debuggable</h3><p>ro.debuggable是rom级别的调试，如果ro.debuggable的值是1说明你的手机已经打开了调试功能，如果为0的话需要安装的安卓app已经打开了android:debuggable属性方可调试，通常正式发布出来的apk默认android:debuggable属性都是关闭的</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866865200.png" alt=""></p><blockquote><p><strong>值为0，所以需要去让安装的app开启android:debuggable属性</strong></p></blockquote><h3 id="开启被调试APK的debuggable属性"><a class="header-anchor" href="#开启被调试APK的debuggable属性">¶</a>开启被调试APK的debuggable属性</h3><p>使用APK Editor Studio查看android:debuggable属性，没有的话就需要自行添加</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867048124.png" alt=""></p><p>这里我已经修改好了</p><h3 id="重新签名打包"><a class="header-anchor" href="#重新签名打包">¶</a>重新签名打包</h3><p>因为修改之后签名需要更新</p><p>在APK Editor Studio中按下Ctrl+Alt+S重新打包</p><h3 id="安装APK文件到手机中"><a class="header-anchor" href="#安装APK文件到手机中">¶</a>安装APK文件到手机中</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867221276.png" alt=""></p><p>此时手机中会弹出安装提示，确认即可安装</p><p>也可以使用adb安装</p><p><a href="https://blog.csdn.net/qq_43203586/article/details/104881919">https://blog.csdn.net/qq_43203586/article/details/104881919</a></p><h3 id="上传ida的远程工具"><a class="header-anchor" href="#上传ida的远程工具">¶</a>上传ida的远程工具</h3><p>在ida的dbgsrv目录下，将android_server64传入手机目录中</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867343056.png" alt=""></p><blockquote><p><strong>使用命令：adb push android_server64 /data/local/tmp</strong></p></blockquote><p>使用chmod提升权限</p><p>此时在该目录下我们可以找到该文件</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867613473.png" alt=""></p><h3 id="启动android-server64"><a class="header-anchor" href="#启动android-server64">¶</a>启动android_server64</h3><p>在data/local/tmp目录下直接运行</p><h3 id="启动adb端口转发"><a class="header-anchor" href="#启动adb端口转发">¶</a>启动adb端口转发</h3><blockquote><p><strong>adb forward tcp:23946 tcp:23946</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868122288.png" alt=""></p><h3 id="以调试模式启动APK"><a class="header-anchor" href="#以调试模式启动APK">¶</a>以调试模式启动APK</h3><p>启动前我们先获取Mainactivity</p><blockquote><p><strong>adb shell am start -D -n 包名路径/.Activity</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868216815.png" alt=""></p><p>以调试模式启动APK</p><blockquote><p><strong>adb shell am start -D -n com.j.hiddendata/.MainActivity</strong></p></blockquote><p>此时真机已经进入Waiting For Debugger界面了</p><h3 id="ida下断点"><a class="header-anchor" href="#ida下断点">¶</a>ida下断点</h3><p>在我们要调试的地方设置断点</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937076837.png" alt=""></p><h3 id="ida进行动态调试"><a class="header-anchor" href="#ida进行动态调试">¶</a>ida进行动态调试</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868333739.png" alt=""></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868368483.png" alt=""></p><p>attach上我们的程序</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868402833.png" alt=""></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868433623.png" alt=""></p><p>此时已经停下，F9一下，让其处于运行状态</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868487721.png" alt=""></p><h3 id="启动monitor并使用jdb连接端口"><a class="header-anchor" href="#启动monitor并使用jdb连接端口">¶</a>启动monitor并使用jdb连接端口</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868567690.png" alt=""></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868595091.png" alt=""></p><p>端口号为8600，接下来使用jdb连接</p><blockquote><p><strong>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8600</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868659975.png" alt=""></p><p>此时真机的等待调试窗口关闭</p><p>ida中提示已经加载，会问你包中的so文件是否和你的一致，选择same即可，接下来就是等待时间</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937277662.png" alt=""></p><p>然后就可以调试了</p><h1 id="0x01-JEB调试"><a class="header-anchor" href="#0x01-JEB调试">¶</a>0x01-JEB调试</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓动态调试&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ida符号恢复</title>
    <link href="https://gift1a.github.io/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/"/>
    <id>https://gift1a.github.io/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/</id>
    <published>2022-04-22T09:04:39.000Z</published>
    <updated>2022-04-24T01:39:17.064Z</updated>
    
    <content type="html"><![CDATA[<p>ida符号恢复</p><span id="more"></span><h1 id="0x00-前言"><a class="header-anchor" href="#0x00-前言">¶</a>0x00-前言</h1><p>有时候我们在ida中反编译时遇到很多以地址命名的函数，而这些函数实际上是系统函数，当符号表被去除时，函数就会以函数地址命名，但是去除的只是函数的名称，我们可以通过其他方法还原，所以我们可以通过.sig文件来恢复符号，当然还有其他方法</p><h1 id="0x01-恢复符号"><a class="header-anchor" href="#0x01-恢复符号">¶</a>0x01-恢复符号</h1><h2 id="Finger"><a class="header-anchor" href="#Finger">¶</a>Finger</h2><p>符号识别神器</p><p><a href="https://github.com/aliyunav/Finger">https://github.com/aliyunav/Finger</a></p><p>按照里面的介绍安装即可</p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650621943386.png" alt="恢复前"></p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650622196897.png" alt="恢复后"></p><p>只能说太强了</p><h2 id="使用lscan和flair"><a class="header-anchor" href="#使用lscan和flair">¶</a>使用lscan和flair</h2><h3 id="lscan"><a class="header-anchor" href="#lscan">¶</a>lscan</h3><p>lscan可以扫描sig文件，找到与二进制文件最相似的库</p><p><a href="https://github.com/maroueneboubakri/lscan">https://github.com/maroueneboubakri/lscan</a></p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> ./lscan.<span class="keyword">py</span> -S .<span class="keyword">sig</span>的目录 -<span class="keyword">f</span> 要扫描的二进制文件</span><br></pre></td></tr></tbody></table></figure><p>这里我使用的是python2</p><p>也可以自己下载sig文件</p><p><a href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a></p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650623466335.png" alt=""></p><h2 id="flair"><a class="header-anchor" href="#flair">¶</a>flair</h2><p>ida加载sig文件的工具</p><p>使用方法看下面的博客吧，我自己试的时候没找到对应的</p><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103788796">https://blog.csdn.net/Breeze_CAT/article/details/103788796</a></p><h1 id="0x02-去除符号"><a class="header-anchor" href="#0x02-去除符号">¶</a>0x02-去除符号</h1><p><a href="https://cloud.tencent.com/developer/article/1839671">https://cloud.tencent.com/developer/article/1839671</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ida符号恢复&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Mips架构逆向初探</title>
    <link href="https://gift1a.github.io/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://gift1a.github.io/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-22T05:06:13.000Z</published>
    <updated>2022-04-24T01:54:46.742Z</updated>
    
    <content type="html"><![CDATA[<p>Mips架构逆向初探</p><span id="more"></span><h1 id="0x00-Mips指令架构"><a class="header-anchor" href="#0x00-Mips指令架构">¶</a>0x00-Mips指令架构</h1><blockquote><p>MIPS架构（英语：MIPS architecture，为Microprocessor without interlocked piped stages architecture的缩写，亦为Millions of Instructions Per Second的双关语），是一种采取精简指令集（RISC）的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。最早的MIPS架构是32位，最新的版本已经变成64位。</p></blockquote><blockquote><p><strong>使用linux下的readelf命令可以了解到文件相关信息</strong></p></blockquote><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650604608575.png" alt=""></p><h1 id="0x01-环境安装"><a class="header-anchor" href="#0x01-环境安装">¶</a>0x01-环境安装</h1><p>由于程序是MIPS指令架构的，而通常我们使用的电脑是x86架构的，无法直接运行该程序，这时可以借助Qemu模拟器来运行程序。QEMU是运行在用户层的开源全虚拟化解决方案，可以在Intel机器上虚拟出完整的操作系统。QEMU主要有两种运作方式</p><ul><li>User Mode:即使用者模式，能单独运行那些为不同处理编译的Linux程序</li><li>System Mode:即系统模式，能够模拟整个操作系统，包括中央处理器及其他周边设备</li></ul><p>由于BabyMips程序是通过静态链接生成的，为了方便，在User Mode下使用QEMU来运行该程序</p><p>使用下面的命令来安装QEMU</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu<span class="operator">-</span><span class="keyword">user</span><span class="operator">-</span><span class="keyword">static</span></span><br><span class="line">sudo apt install qemu<span class="operator">-</span><span class="keyword">user</span></span><br></pre></td></tr></tbody></table></figure><p>安装qemu对应下的mips64库</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libc<span class="number">6</span>-mips<span class="number">64</span>-cross</span><br></pre></td></tr></tbody></table></figure><h1 id="0x01-DDCTF2018-BabyMips"><a class="header-anchor" href="#0x01-DDCTF2018-BabyMips">¶</a>0x01-DDCTF2018-BabyMips</h1><h2 id="静态分析"><a class="header-anchor" href="#静态分析">¶</a>静态分析</h2><p>readelf读取文件信息-Mips32-小端序</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606053687.png" alt=""></p><p>运行试试</p><p>出现错误</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606188738.png" alt=""></p><blockquote><p><strong>先使用Ghidra查看反编译代码，也可以使用ida7.5即以上版本反编译，也可以使用jeb-mips</strong></p></blockquote><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606391321.png" alt="ghidra"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606413794.png" alt="ida7.7"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606537986.png" alt="jeb"></p><p>可以看到先让我们输入，然后进入函数进行判断，所以我们需要知道函数进行了什么加密操作</p><p>进入函数后发现分析出错了，在最后跳转时跳转到了垃圾数据的位置，所以我们试一下动态调试</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606639388.png" alt=""></p><h2 id="动态调试"><a class="header-anchor" href="#动态调试">¶</a>动态调试</h2><p>ida+QEMU调试</p><p>首先在ida中选择Remote GDB Debugger</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606835259.png" alt=""></p><p>然后Debugger设置好</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607126949.png" alt=""></p><p>连接</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">qemu</span>-mipsel -g <span class="number">23946</span> Baby_Mips</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>-g后面跟着端口号+文件名</strong></p></blockquote><p>端口的另一边可以选择IDA也可以选择GDB，这里我选择DIA</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607359256.png" alt=""></p><p>在IDA中启动调试</p><p>成功断下</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607396583.png" alt=""></p><p>接下来定位到刚才出错的地址，下个断点</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607460822.png" alt=""></p><p>放开程序</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607488259.png" alt="等待我们输入"></p><p>输入完成后，提示出错</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607545161.png" alt="报错"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650608745243.png" alt=""></p><p>F8也会出现异常</p><p>查找<code>lwc1</code>指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到<code>$f29</code>和<code>$t1</code>寄存器的内容</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650609292804.png" alt="大佬的思路"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650609507747.png" alt=""></p><p>也就是说E8本来是8位，也就是两个字节，但是mips指令为4字节，所以跳转的时候出错了</p><p>使用idc进行Patch</p><p>注意idc不支持+=操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> addr=<span class="number">0x4001F0</span>;</span><br><span class="line">    <span class="keyword">auto</span> addr1=<span class="number">0x403234</span>;</span><br><span class="line">    <span class="keyword">for</span>(;addr&lt;=addr1;addr=<span class="number">4</span>+addr)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(Byte(addr)==<span class="number">0xeb</span> &amp;&amp; Byte(addr+<span class="number">1</span>)==<span class="number">0x02</span>)</span><br><span class="line">        {</span><br><span class="line">            PatchByte(addr,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">1</span>,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">2</span>,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">3</span>,<span class="number">0x00</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//printf("finished");</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>保存之后重新拖进jeb反编译</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650611442753.png" alt=""></p><h2 id="脚本-v7"><a class="header-anchor" href="#脚本-v7">¶</a>脚本</h2><p>十六个方程组，使用z3求解</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = [BitVec(<span class="string">'a%d'</span> %i, <span class="number">32</span>) <span class="keyword">for</span> i in range(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">0xffffc20e</span>*a[<span class="number">0</span>]<span class="number">-0xbd52</span>*a[<span class="number">1</span>]+<span class="number">0x7f57</span>*a[<span class="number">2</span>]+<span class="number">0x96cd</span>*a[<span class="number">3</span>]<span class="number">-0xac7f</span>*a[<span class="number">4</span>] +<span class="number">0x5d80</span>*a[<span class="number">5</span>]+<span class="number">0xb25e</span>*a[<span class="number">6</span>]+<span class="number">0x2447</span>*a[<span class="number">7</span>]+<span class="number">0xba8a</span>*a[<span class="number">8</span>]+<span class="number">0xbb41</span>*a[<span class="number">9</span>]+<span class="number">0xa3a8</span>*a[<span class="number">10</span>]+<span class="number">0xcb12</span>*a[<span class="number">11</span>]<span class="number">-0x6958</span>*a[<span class="number">12</span>]+<span class="number">0x5821</span>*a[<span class="number">13</span>]+<span class="number">0x77ed</span>*a[<span class="number">14</span>]+<span class="number">0xf7ff</span>*a[<span class="number">15</span>] == <span class="number">0x162f0ca</span> )</span><br><span class="line">s.add(<span class="number">0xeb44</span>*a[<span class="number">0</span>]<span class="number">-0x0f99</span>*a[<span class="number">1</span>] - <span class="number">0x40e7</span>*a[<span class="number">2</span>] +<span class="number">0xdf2e</span>*a[<span class="number">3</span>] <span class="number">-0x4b2e</span>*a[<span class="number">4</span>] <span class="number">-0x96b5</span>*a[<span class="number">5</span>] +<span class="number">0x9d66</span>*a[<span class="number">6</span>] <span class="number">-0xafa8</span>*a[<span class="number">7</span>] <span class="number">-0x6e26</span>*a[<span class="number">8</span>] <span class="number">-0xe655</span>*a[<span class="number">9</span>]- <span class="number">0x9a6e</span>*a[<span class="number">10</span>] +<span class="number">0x57ba</span>*a[<span class="number">11</span>] <span class="number">-0x227c</span>*a[<span class="number">12</span>] +<span class="number">0xbdd1</span>*a[<span class="number">13</span>] +<span class="number">0xb437</span>*a[<span class="number">14</span>] +<span class="number">0x5d3f</span>*a[<span class="number">15</span>]== <span class="number">0xffec2e48</span>)</span><br><span class="line">s.add(<span class="number">0xe6f1</span>*a[<span class="number">0</span>] +<span class="number">0xa4b2</span>*a[<span class="number">1</span>] <span class="number">-0xfe74</span>*a[<span class="number">2</span>] <span class="number">-0x0f07</span>*a[<span class="number">3</span>] <span class="number">-0x5d22</span>*a[<span class="number">4</span>] <span class="number">-0xb845</span>*a[<span class="number">5</span>] <span class="number">-0x9954</span>*a[<span class="number">6</span>] +<span class="number">0x93ac</span>*a[<span class="number">7</span>] <span class="number">-0x51e4</span>*a[<span class="number">8</span>] <span class="number">-0x4b11</span>*a[<span class="number">9</span>] +<span class="number">0xdc93</span>*a[<span class="number">10</span>] +<span class="number">0x13f8</span>*a[<span class="number">11</span>] +<span class="number">0x246c</span>*a[<span class="number">12</span>] +<span class="number">0xf121</span>*a[<span class="number">13</span>] +<span class="number">0xf09f</span>*a[<span class="number">14</span>] +<span class="number">0x0dfa</span>*a[<span class="number">15</span>] == <span class="number">0xd3c060</span>)</span><br><span class="line">s.add(<span class="number">0xffff7085</span>*a[<span class="number">0</span>] <span class="number">-0x6623</span>*a[<span class="number">1</span>] +<span class="number">0x0686</span>*a[<span class="number">2</span>] +<span class="number">0x4b2d</span>*a[<span class="number">3</span>] +<span class="number">0x68df</span>*a[<span class="number">4</span>] +<span class="number">0x9be7</span>*a[<span class="number">5</span>] +<span class="number">0x21b4</span>*a[<span class="number">6</span>] +<span class="number">0xe25a</span>*a[<span class="number">7</span>] <span class="number">-0xc807</span>*a[<span class="number">8</span>] +<span class="number">0xf695</span>*a[<span class="number">9</span>] <span class="number">-0x5421</span>*a[<span class="number">10</span>] <span class="number">-0x2469</span>*a[<span class="number">11</span>] +<span class="number">0x9f29</span>*a[<span class="number">12</span>] <span class="number">-0xe311</span>*a[<span class="number">13</span>] +<span class="number">0x78f2</span>*a[<span class="number">14</span>] <span class="number">-0x6bda</span>*a[<span class="number">15</span>] == <span class="number">0x8bf576</span>)</span><br><span class="line">s.add(<span class="number">0xffff07b8</span>*a[<span class="number">0</span>] <span class="number">-0xd048</span>*a[<span class="number">1</span>] <span class="number">-0x85f1</span>*a[<span class="number">2</span>] +<span class="number">0xee84</span>*a[<span class="number">3</span>] <span class="number">-0x37d1</span>*a[<span class="number">4</span>] +<span class="number">0xb74a</span>*a[<span class="number">5</span>] +<span class="number">0xcfe2</span>*a[<span class="number">6</span>]+ <span class="number">0x8f1e</span>*a[<span class="number">7</span>] <span class="number">-0xf211</span>*a[<span class="number">8</span>] <span class="number">-0x83bf</span>*a[<span class="number">9</span>] <span class="number">-0x1249</span>*a[<span class="number">10</span>] +<span class="number">0x7ea7</span>*a[<span class="number">11</span>] <span class="number">-0x4294</span>*a[<span class="number">12</span>] <span class="number">-0xb661</span>*a[<span class="number">13</span>] <span class="number">-0x8a73</span>*a[<span class="number">14</span>] <span class="number">-0x5e5c</span>*a[<span class="number">15</span>] == <span class="number">0xff4ea5b3</span>)</span><br><span class="line">s.add(<span class="number">0xffffd6b5</span>*a[<span class="number">0</span>] <span class="number">-0x2b5f</span>*a[<span class="number">1</span>]+ <span class="number">0xc981</span>*a[<span class="number">2</span>] <span class="number">-0x60c3</span>*a[<span class="number">3</span>] +<span class="number">0xf8f2</span>*a[<span class="number">4</span>]+ <span class="number">0xded7</span>*a[<span class="number">5</span>]- <span class="number">0xf6fb</span>*a[<span class="number">6</span>] +<span class="number">0x1083</span>*a[<span class="number">7</span>]- <span class="number">0xdc96</span>*a[<span class="number">8</span>]- <span class="number">0x587e</span>*a[<span class="number">9</span>] <span class="number">-0xb4f5</span>*a[<span class="number">10</span>] +<span class="number">0xf57a</span>*a[<span class="number">11</span>] +<span class="number">0x57d0</span>*a[<span class="number">12</span>] +<span class="number">0xe814</span>*a[<span class="number">13</span>] +<span class="number">0x6169</span>*a[<span class="number">14</span>] +<span class="number">0xf285</span>*a[<span class="number">15</span>] == <span class="number">0x9dd61e</span>)</span><br><span class="line">s.add(<span class="number">0xcd89</span>*a[<span class="number">0</span>] <span class="number">-0xd43d</span>*a[<span class="number">1</span>] +<span class="number">0xf037</span>*a[<span class="number">2</span>] +<span class="number">0x83a8</span>*a[<span class="number">3</span>] <span class="number">-0xa305</span>*a[<span class="number">4</span>] <span class="number">-0xadef</span>*a[<span class="number">5</span>] +<span class="number">0xcaaa</span>*a[<span class="number">6</span>] <span class="number">-0xf145</span>*a[<span class="number">7</span>]- <span class="number">0x6073</span>*a[<span class="number">8</span>]- <span class="number">0x2777</span>*a[<span class="number">9</span>] +<span class="number">0x794f</span>*a[<span class="number">10</span>] +<span class="number">0xf00e</span>*a[<span class="number">11</span>] <span class="number">-0xe7d5</span>*a[<span class="number">12</span>] +<span class="number">0x2654</span>*a[<span class="number">13</span>] <span class="number">-0xbed0</span>*a[<span class="number">14</span>] <span class="number">-0xb8af</span>*a[<span class="number">15</span>] == <span class="number">0xff6baab3</span>)</span><br><span class="line">s.add(<span class="number">0xffff6108</span>*a[<span class="number">0</span>] <span class="number">-0x6766</span>*a[<span class="number">1</span>] +<span class="number">0xd58e</span>*a[<span class="number">2</span>] <span class="number">-0x5ca3</span>*a[<span class="number">3</span>] +<span class="number">0x2718</span>*a[<span class="number">4</span>] +<span class="number">0x1e2b</span>*a[<span class="number">5</span>] <span class="number">-0xf49e</span>*a[<span class="number">6</span>] +<span class="number">0xcf78</span>*a[<span class="number">7</span>] +<span class="number">0x7c09</span>*a[<span class="number">8</span>] <span class="number">-0x13b7</span>*a[<span class="number">9</span>] <span class="number">-0xbeee</span>*a[<span class="number">10</span>]- <span class="number">0xe450</span>*a[<span class="number">11</span>] +<span class="number">0x4da3</span>*a[<span class="number">12</span>] <span class="number">-0x8880</span>*a[<span class="number">13</span>] <span class="number">-0x5691</span>*a[<span class="number">14</span>] +<span class="number">0x8bd8</span>*a[<span class="number">15</span>] == <span class="number">0xff818f06</span>)</span><br><span class="line">s.add(<span class="number">0xffffa564</span>*a[<span class="number">0</span>] <span class="number">-0xa95a</span>*a[<span class="number">1</span>] <span class="number">-0xe643</span>*a[<span class="number">2</span>] +<span class="number">0x0d38</span>*a[<span class="number">3</span>] <span class="number">-0x097a</span>*a[<span class="number">4</span>] <span class="number">-0xeb22</span>*a[<span class="number">5</span>] +<span class="number">0xcac3</span>*a[<span class="number">6</span>] <span class="number">-0x4ed1</span>*a[<span class="number">7</span>] <span class="number">-0x7c8a</span>*a[<span class="number">8</span>] +<span class="number">0xf107</span>*a[<span class="number">9</span>] +<span class="number">0xa59e</span>*a[<span class="number">10</span>]- <span class="number">0x1213</span>*a[<span class="number">11</span>] +<span class="number">0xb2b5</span>*a[<span class="number">12</span>] <span class="number">-0x7213</span>*a[<span class="number">13</span>] <span class="number">-0x2b83</span>*a[<span class="number">14</span>] <span class="number">-0xa155</span>*a[<span class="number">15</span>] == <span class="number">0xff8d50e7</span>)</span><br><span class="line">s.add(<span class="number">0xffff6c45</span>*a[<span class="number">0</span>] <span class="number">-0x2752</span>*a[<span class="number">1</span>] <span class="number">-0xbdc3</span>*a[<span class="number">2</span>] <span class="number">-0xf495</span>*a[<span class="number">3</span>] <span class="number">-0x7121</span>*a[<span class="number">4</span>] +<span class="number">0x9c41</span>*a[<span class="number">5</span>] <span class="number">-0x9465</span>*a[<span class="number">6</span>]- <span class="number">0x6ce3</span>*a[<span class="number">7</span>] <span class="number">-0x4f28</span>*a[<span class="number">8</span>] <span class="number">-0x8350</span>*a[<span class="number">9</span>] <span class="number">-0x176e</span>*a[<span class="number">10</span>] +<span class="number">0x7814</span>*a[<span class="number">11</span>] <span class="number">-0x739a</span>*a[<span class="number">12</span>] +<span class="number">0x5494</span>*a[<span class="number">13</span>] +<span class="number">0x142d</span>*a[<span class="number">14</span>] +<span class="number">0xca55</span>*a[<span class="number">15</span>] == <span class="number">0xff3f9826</span>)</span><br><span class="line">s.add(<span class="number">0xcf01</span>*a[<span class="number">0</span>] +<span class="number">0xf378</span>*a[<span class="number">1</span>] +<span class="number">0x1064</span>*a[<span class="number">2</span>] <span class="number">-0xd9a7</span>*a[<span class="number">3</span>] <span class="number">-0x077d</span>*a[<span class="number">4</span>]+ <span class="number">0x6dab</span>*a[<span class="number">5</span>] <span class="number">-0xaf1f</span>*a[<span class="number">6</span>]- <span class="number">0x3db7</span>*a[<span class="number">7</span>] +<span class="number">0x3554</span>*a[<span class="number">8</span>] <span class="number">-0xcb8e</span>*a[<span class="number">9</span>] <span class="number">-0x9815</span>*a[<span class="number">10</span>]+ <span class="number">0xf30b</span>*a[<span class="number">11</span>] +<span class="number">0x9c5e</span>*a[<span class="number">12</span>] <span class="number">-0x5d07</span>*a[<span class="number">13</span>] <span class="number">-0x4c31</span>*a[<span class="number">14</span>] +<span class="number">0xeae0</span>*a[<span class="number">15</span>] == <span class="number">0x213fed</span>)</span><br><span class="line">s.add(<span class="number">0x8bd4</span>*a[<span class="number">0</span>] <span class="number">-0x6d81</span>*a[<span class="number">1</span>] <span class="number">-0xe772</span>*a[<span class="number">2</span>] +<span class="number">0xb6f1</span>*a[<span class="number">3</span>] +<span class="number">0x9b57</span>*a[<span class="number">4</span>] <span class="number">-0x597d</span>*a[<span class="number">5</span>] +<span class="number">0x15d1</span>*a[<span class="number">6</span>]- <span class="number">0xa55e</span>*a[<span class="number">7</span>]+ <span class="number">0xfd13</span>*a[<span class="number">8</span>]+ <span class="number">0x17b4</span>*a[<span class="number">9</span>] +<span class="number">0xec78</span>*a[<span class="number">10</span>] <span class="number">-0xd51a</span>*a[<span class="number">11</span>] +<span class="number">0x56ad</span>*a[<span class="number">12</span>] <span class="number">-0xc319</span>*a[<span class="number">13</span>] +<span class="number">0x9f8e</span>*a[<span class="number">14</span>] +<span class="number">0xfa17</span>*a[<span class="number">15</span>] == <span class="number">0xa9f0dc</span>)</span><br><span class="line">s.add(<span class="number">0xffffb798</span>*a[<span class="number">0</span>] <span class="number">-0x8bef</span>*a[<span class="number">1</span>] +<span class="number">0x109d</span>*a[<span class="number">2</span>]- <span class="number">0xf9d4</span>*a[<span class="number">3</span>] +<span class="number">0x4ecf</span>*a[<span class="number">4</span>] +<span class="number">0xa896</span>*a[<span class="number">5</span>] +<span class="number">0x773b</span>*a[<span class="number">6</span>] +<span class="number">0x6e8a</span>*a[<span class="number">7</span>] <span class="number">-0x737c</span>*a[<span class="number">8</span>]+ <span class="number">0x4979</span>*a[<span class="number">9</span>] +<span class="number">0xc685</span>*a[<span class="number">10</span>] <span class="number">-0x96ae</span>*a[<span class="number">11</span>] +<span class="number">0x0bbd</span>*a[<span class="number">12</span>] +<span class="number">0x8280</span>*a[<span class="number">13</span>] +<span class="number">0xe3a9</span>*a[<span class="number">14</span>] <span class="number">-0x730c</span>*a[<span class="number">15</span>] == <span class="number">0xbdeb20</span>)</span><br><span class="line">s.add(<span class="number">0x0b20</span>*a[<span class="number">0</span>] +<span class="number">0x9b9c</span>*a[<span class="number">1</span>] +<span class="number">0xb4aa</span>*a[<span class="number">2</span>]+ <span class="number">0x6176</span>*a[<span class="number">3</span>] +<span class="number">0x9670</span>*a[<span class="number">4</span>] +<span class="number">0x7c9d</span>*a[<span class="number">5</span>] <span class="number">-0x5402</span>*a[<span class="number">6</span>] <span class="number">-0x8cd2</span>*a[<span class="number">7</span>] +<span class="number">0xac82</span>*a[<span class="number">8</span>] +<span class="number">0xa2f5</span>*a[<span class="number">9</span>] <span class="number">-0x8efd</span>*a[<span class="number">10</span>] <span class="number">-0x65f1</span>*a[<span class="number">11</span>] <span class="number">-0x94b9</span>*a[<span class="number">12</span>] +<span class="number">0x8cb8</span>*a[<span class="number">13</span>] +<span class="number">0x1cb5</span>*a[<span class="number">14</span>] +<span class="number">0x4aa1</span>*a[<span class="number">15</span>] == <span class="number">0x9c7cf5</span>)</span><br><span class="line">s.add(<span class="number">0x57fd</span>*a[<span class="number">0</span>] +<span class="number">0x3d83</span>*a[<span class="number">1</span>] +<span class="number">0xf745</span>*a[<span class="number">2</span>] +<span class="number">0xa5c4</span>*a[<span class="number">3</span>] <span class="number">-0x65fa</span>*a[<span class="number">4</span>] <span class="number">-0x58e9</span>*a[<span class="number">5</span>] +<span class="number">0xbebe</span>*a[<span class="number">6</span>] +<span class="number">0x1820</span>*a[<span class="number">7</span>] <span class="number">-0xd7b9</span>*a[<span class="number">8</span>] <span class="number">-0xb21f</span>*a[<span class="number">9</span>] <span class="number">-0x76a0</span>*a[<span class="number">10</span>] +<span class="number">0xc60d</span>*a[<span class="number">11</span>] +<span class="number">0x168f</span>*a[<span class="number">12</span>] +<span class="number">0x2a96</span>*a[<span class="number">13</span>] +<span class="number">0x31d6</span>*a[<span class="number">14</span>] <span class="number">-0x4b88</span>*a[<span class="number">15</span>] == <span class="number">0xd08e2</span>)</span><br><span class="line">s.add(<span class="number">0xffff1bae</span>*a[<span class="number">0</span>] <span class="number">-0xc7d4</span>*a[<span class="number">1</span>] <span class="number">-0x1554</span>*a[<span class="number">2</span>] +<span class="number">0x7eea</span>*a[<span class="number">3</span>] <span class="number">-0x684d</span>*a[<span class="number">4</span>] +<span class="number">0x6adb</span>*a[<span class="number">5</span>] +<span class="number">0x8534</span>*a[<span class="number">6</span>] <span class="number">-0x3a36</span>*a[<span class="number">7</span>] +<span class="number">0x29f0</span>*a[<span class="number">8</span>] +<span class="number">0xd3f2</span>*a[<span class="number">9</span>] <span class="number">-0x23e5</span>*a[<span class="number">10</span>] <span class="number">-0x6540</span>*a[<span class="number">11</span>] +<span class="number">0xbcd3</span>*a[<span class="number">12</span>] <span class="number">-0xef9b</span>*a[<span class="number">13</span>] +<span class="number">0xefdb</span>*a[<span class="number">14</span>] <span class="number">-0x774e</span>*a[<span class="number">15</span>] == <span class="number">0x178803</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item in a:</span><br><span class="line">    s.add(item &gt; <span class="number">0</span>, item &lt; <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">16</span>):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    print(<span class="string">''.join(map(chr, flag)))</span></span><br></pre></td></tr></tbody></table></figure><p>注意负数要换成十六进制</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650613838317.png" alt=""></p><h1 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h1><p><a href="https://blog.csdn.net/m0_46362499/article/details/107629918">https://blog.csdn.net/m0_46362499/article/details/107629918</a></p><p><a href="https://cloud.tencent.com/developer/article/1123681">https://cloud.tencent.com/developer/article/1123681</a></p><p><a href="https://cq674350529.github.io/2018/05/07/Solve-baby-mips-with-angr/">https://cq674350529.github.io/2018/05/07/Solve-baby-mips-with-angr/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mips架构逆向初探&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>CRC算法</title>
    <link href="https://gift1a.github.io/2022/04/21/CRC%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/04/21/CRC%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-21T08:32:35.000Z</published>
    <updated>2022-06-01T11:37:22.096Z</updated>
    
    <content type="html"><![CDATA[<p>CRC校验算法</p><span id="more"></span> <p><a href="https://www.52pojie.cn/thread-783879-1-1.html">https://www.52pojie.cn/thread-783879-1-1.html</a></p><h1 id="0x00-CRC校验原理"><a class="header-anchor" href="#0x00-CRC校验原理">¶</a>0x00-CRC校验原理</h1><p>CRC校验即循环冗余判断，是基于数据计算一组的校验码，用于核对数据传输过程中是否被更改或传输错误。首先看两个概念，后续会用到</p><ul><li><p>模2除法：也叫模2运算，就是结果除2后取余数。 数据传输过程中是否被更改或传输错误。首先看两个概念，后续会用到</p></li><li><p>多项式与二进制：二进制可以表示成多项式的形式，比如二进制1101可以表示为：<br>$$<br>x<sup>3+x</sup>2+x^0<br>$$<br>1011表示为：<br>$$<br>x<sup>3+x</sup>1+x^0<br>$$</p></li></ul><p>CRC校验本质上是选取一个合适的除数，要进行校验的数据是除数，然后做模2除法，得到的余数就是CRC校验值</p><p>最终传输的数据是我们的数据加上CRC校验值，而CRC的数据存储在数据的末尾，添加的位数根据除数来判断</p><blockquote><p><strong>余数位必须比除数少一位，如果不够前面加0补齐</strong></p></blockquote><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/20170622115737528.png" alt="计算过程"></p><h2 id="CRC生成多项式"><a class="header-anchor" href="#CRC生成多项式">¶</a>CRC生成多项式</h2><p>通常我们把选出的除数称为生成多项式，对于我们来说，直接拿来使用即可</p><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/1651021828457.png" alt="标准CRC生成多项式"></p><p>因为生成多项式的最高位肯定为1，所以在简记式中可以去掉，所以位宽等于多项式对应的二进制的位数-1，CRC8本来是9位，但是省去最高位1，得到八位，所以CRC校验值为8位</p><h1 id="0x01-计算过程"><a class="header-anchor" href="#0x01-计算过程">¶</a>0x01-计算过程</h1><h2 id="根据CRC原理实现校验"><a class="header-anchor" href="#根据CRC原理实现校验">¶</a>根据CRC原理实现校验</h2><p>这里我们以CRC16为例，即选取生成多项式为0x8005</p><ol><li>在数据末尾添加十六位CRC校验值0</li><li>如果最高位为1，数据左移后异或生成的多项式</li><li>如果数据最高位为0，直接左移</li><li>这样得到的低十六位就是我们的CRC校验值</li></ol><p>这样就完成了一个字节的校验</p><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/1651022682175.png" alt="工程中常用CRC校验过程"></p><p>CRC校验有很多种类型，这上面介绍了不同的计算类型</p><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/1651022865226.png" alt=""></p><h2 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h2><p>以CRC16为例</p><p>因为一个字符是8位，所以CRC16本身会左移8位，所以在开始前 需要先左移8位，这样得到的才会是十六位数据</p><h1 id="0x01-CRC检验过程改进"><a class="header-anchor" href="#0x01-CRC检验过程改进">¶</a>0x01-CRC检验过程改进</h1><p>CRC查表法</p><p>由于每一个字节都需要进行8次的判断、移位和异或操作。如果使用查表法</p><p>因为加密的是一个字符，最多就256个，也就是8位，所以使用查表法效率较高</p><p>下面是生成CRC-8表的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//每个字符传进来进行CRC8计算</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">crc_high_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &gt; <span class="number">0</span>; --i)   <span class="comment">/* 下面这段计算过程与计算一个字节crc一样 */</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)</span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (crc);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_crc_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (i % <span class="number">16</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        j = i &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%.2x, "</span>, crc_high_first(j));  <span class="comment">/*依次计算每个字节的crc校验值*/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    create_crc_table();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>CRC8查表法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> crc_table[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x62</span>,<span class="number">0x53</span>,<span class="number">0xc4</span>,<span class="number">0xf5</span>,<span class="number">0xa6</span>,<span class="number">0x97</span>,<span class="number">0xb9</span>,<span class="number">0x88</span>,<span class="number">0xdb</span>,<span class="number">0xea</span>,<span class="number">0x7d</span>,<span class="number">0x4c</span>,<span class="number">0x1f</span>,<span class="number">0x2e</span>,<span class="number">0x43</span>,<span class="number">0x72</span>,<span class="number">0x21</span>,<span class="number">0x10</span>,<span class="number">0x87</span>,<span class="number">0xb6</span>,<span class="number">0xe5</span>,<span class="number">0xd4</span>,<span class="number">0xfa</span>,<span class="number">0xcb</span>,<span class="number">0x98</span>,<span class="number">0xa9</span>,<span class="number">0x3e</span>,<span class="number">0x0f</span>,<span class="number">0x5c</span>,<span class="number">0x6d</span>,<span class="number">0x86</span>,<span class="number">0xb7</span>,<span class="number">0xe4</span>,<span class="number">0xd5</span>,<span class="number">0x42</span>,<span class="number">0x73</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x3f</span>,<span class="number">0x0e</span>,<span class="number">0x5d</span>,<span class="number">0x6c</span>,<span class="number">0xfb</span>,<span class="number">0xca</span>,<span class="number">0x99</span>,<span class="number">0xa8</span>,<span class="number">0xc5</span>,<span class="number">0xf4</span>,<span class="number">0xa7</span>,<span class="number">0x96</span>,<span class="number">0x01</span>,<span class="number">0x30</span>,<span class="number">0x63</span>,<span class="number">0x52</span>,<span class="number">0x7c</span>,<span class="number">0x4d</span>,<span class="number">0x1e</span>,<span class="number">0x2f</span>,<span class="number">0xb8</span>,<span class="number">0x89</span>,<span class="number">0xda</span>,<span class="number">0xeb</span>,<span class="number">0x3d</span>,<span class="number">0x0c</span>,<span class="number">0x5f</span>,<span class="number">0x6e</span>,<span class="number">0xf9</span>,<span class="number">0xc8</span>,<span class="number">0x9b</span>,<span class="number">0xaa</span>,<span class="number">0x84</span>,<span class="number">0xb5</span>,<span class="number">0xe6</span>,<span class="number">0xd7</span>,<span class="number">0x40</span>,<span class="number">0x71</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x7e</span>,<span class="number">0x4f</span>,<span class="number">0x1c</span>,<span class="number">0x2d</span>,<span class="number">0xba</span>,<span class="number">0x8b</span>,<span class="number">0xd8</span>,<span class="number">0xe9</span>,<span class="number">0xc7</span>,<span class="number">0xf6</span>,<span class="number">0xa5</span>,<span class="number">0x94</span>,<span class="number">0x03</span>,<span class="number">0x32</span>,<span class="number">0x61</span>,<span class="number">0x50</span>,<span class="number">0xbb</span>,<span class="number">0x8a</span>,<span class="number">0xd9</span>,<span class="number">0xe8</span>,<span class="number">0x7f</span>,<span class="number">0x4e</span>,<span class="number">0x1d</span>,<span class="number">0x2c</span>,<span class="number">0x02</span>,<span class="number">0x33</span>,<span class="number">0x60</span>,<span class="number">0x51</span>,<span class="number">0xc6</span>,<span class="number">0xf7</span>,<span class="number">0xa4</span>,<span class="number">0x95</span>,<span class="number">0xf8</span>,<span class="number">0xc9</span>,<span class="number">0x9a</span>,<span class="number">0xab</span>,<span class="number">0x3c</span>,<span class="number">0x0d</span>,<span class="number">0x5e</span>,<span class="number">0x6f</span>,<span class="number">0x41</span>,<span class="number">0x70</span>,<span class="number">0x23</span>,<span class="number">0x12</span>,<span class="number">0x85</span>,<span class="number">0xb4</span>,<span class="number">0xe7</span>,<span class="number">0xd6</span>,<span class="number">0x7a</span>,<span class="number">0x4b</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0xbe</span>,<span class="number">0x8f</span>,<span class="number">0xdc</span>,<span class="number">0xed</span>,<span class="number">0xc3</span>,<span class="number">0xf2</span>,<span class="number">0xa1</span>,<span class="number">0x90</span>,<span class="number">0x07</span>,<span class="number">0x36</span>,<span class="number">0x65</span>,<span class="number">0x54</span>,<span class="number">0x39</span>,<span class="number">0x08</span>,<span class="number">0x5b</span>,<span class="number">0x6a</span>,<span class="number">0xfd</span>,<span class="number">0xcc</span>,<span class="number">0x9f</span>,<span class="number">0xae</span>,<span class="number">0x80</span>,<span class="number">0xb1</span>,<span class="number">0xe2</span>,<span class="number">0xd3</span>,<span class="number">0x44</span>,<span class="number">0x75</span>,<span class="number">0x26</span>,<span class="number">0x17</span>,<span class="number">0xfc</span>,<span class="number">0xcd</span>,<span class="number">0x9e</span>,<span class="number">0xaf</span>,<span class="number">0x38</span>,<span class="number">0x09</span>,<span class="number">0x5a</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x74</span>,<span class="number">0x27</span>,<span class="number">0x16</span>,<span class="number">0x81</span>,<span class="number">0xb0</span>,<span class="number">0xe3</span>,<span class="number">0xd2</span>,<span class="number">0xbf</span>,<span class="number">0x8e</span>,<span class="number">0xdd</span>,<span class="number">0xec</span>,<span class="number">0x7b</span>,<span class="number">0x4a</span>,<span class="number">0x19</span>,<span class="number">0x28</span>,<span class="number">0x06</span>,<span class="number">0x37</span>,<span class="number">0x64</span>,<span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0xf3</span>,<span class="number">0xa0</span>,<span class="number">0x91</span>,<span class="number">0x47</span>,<span class="number">0x76</span>,<span class="number">0x25</span>,<span class="number">0x14</span>,<span class="number">0x83</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xd0</span>,<span class="number">0xfe</span>,<span class="number">0xcf</span>,<span class="number">0x9c</span>,<span class="number">0xad</span>,<span class="number">0x3a</span>,<span class="number">0x0b</span>,<span class="number">0x58</span>,<span class="number">0x69</span>,<span class="number">0x04</span>,<span class="number">0x35</span>,<span class="number">0x66</span>,<span class="number">0x57</span>,<span class="number">0xc0</span>,<span class="number">0xf1</span>,<span class="number">0xa2</span>,<span class="number">0x93</span>,<span class="number">0xbd</span>,<span class="number">0x8c</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x79</span>,<span class="number">0x48</span>,<span class="number">0x1b</span>,<span class="number">0x2a</span>,<span class="number">0xc1</span>,<span class="number">0xf0</span>,<span class="number">0xa3</span>,<span class="number">0x92</span>,<span class="number">0x05</span>,<span class="number">0x34</span>,<span class="number">0x67</span>,<span class="number">0x56</span>,<span class="number">0x78</span>,<span class="number">0x49</span>,<span class="number">0x1a</span>,<span class="number">0x2b</span>,<span class="number">0xbc</span>,<span class="number">0x8d</span>,<span class="number">0xde</span>,<span class="number">0xef</span>,<span class="number">0x82</span>,<span class="number">0xb3</span>,<span class="number">0xe0</span>,<span class="number">0xd1</span>,<span class="number">0x46</span>,<span class="number">0x77</span>,<span class="number">0x24</span>,<span class="number">0x15</span>,<span class="number">0x3b</span>,<span class="number">0x0a</span>,<span class="number">0x59</span>,<span class="number">0x68</span>,<span class="number">0xff</span>,<span class="number">0xce</span>,<span class="number">0x9d</span>,<span class="number">0xac</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//每个字符传进来进行CRC8计算</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">crc_high_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &gt; <span class="number">0</span>; --i)   <span class="comment">/* 下面这段计算过程与计算一个字节crc一样 */</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)</span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (crc);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_crc_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (i % <span class="number">16</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        j = i &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%.2x, "</span>, crc_high_first(j));  <span class="comment">/*依次计算每个字节的crc校验值*/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_crc_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key = <span class="number">0x31</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, crc_table[crc ^ <span class="number">0x31</span>]);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crc_8_encode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc=<span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key = <span class="number">0x31</span>;</span><br><span class="line">    crc ^= key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)</span><br><span class="line">        {</span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            crc &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x"</span>, crc);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//create_crc_table();</span></span><br><span class="line">    find_crc_table();</span><br><span class="line">    crc_8_encode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>CRC16和CRC32也同理</p><p>只是初始时移动的位数改变</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CRC校验算法&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-18T06:51:41.000Z</published>
    <updated>2022-04-20T05:25:59.456Z</updated>
    
    <content type="html"><![CDATA[<p>Buuctf刷题记录</p><span id="more"></span> <h1 id="红帽杯-XX"><a class="header-anchor" href="#红帽杯-XX">¶</a>红帽杯-XX</h1><h2 id="考点"><a class="header-anchor" href="#考点">¶</a>考点</h2><p>xxtea、异或、换位</p><h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2><p>整个过程就是取前四个输入作为密钥，先进行XXTEA加密，然后位置互换混淆，最后进行异或加密</p><h3 id="取密钥"><a class="header-anchor" href="#取密钥">¶</a>取密钥</h3><p>这里判断取出前四位，判断是否为数组内的元素，因为如果不是的话，最后V11=V14退出程序</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329798015.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329952441.png" alt="v6元素"></p><p>取出地址中存储的字符，保证其不为0，下面那个循环是将取出的key末尾填充0</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330081892.png" alt=""></p><p>我们的key是int型，这里传参时强制转为char型</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330189857.png" alt=""></p><p>函数内部起始段是将我们传入的key转为int型，转换大小端序，因为原本是flag，转为int之后就变成了galf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330259305.png" alt=""></p><p>然后xxtea加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330294507.png" alt=""></p><h3 id="打乱位置"><a class="header-anchor" href="#打乱位置">¶</a>打乱位置</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330367612.png" alt=""></p><h3 id="异或"><a class="header-anchor" href="#异或">¶</a>异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330508850.png" alt="index初始值"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330454278.png" alt=""></p><p>这段的逻辑就是只要是3的倍数就取出来异或，index从1开始，所以0、1、2下标的字符都不会被加密，3、4、5进行一次加密，异或的值为下标为0的enc_flag，6、7、8则两次，异或的值为下标为0、1的加密后的字符，依次往后，直到21、22、23，此时异或前六位加密字符</p><h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2><p>xxtea</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">uint32_t</span>* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">uint32_t</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> enc[<span class="number">6</span>] = { <span class="number">0x40CEA5BC</span>,<span class="number">0xE7B2B2F4</span>,<span class="number">0x129D12A9</span>,<span class="number">0x5BC810AE</span>,<span class="number">0x1D06D73D</span>,<span class="number">0xDCF870DC</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = { (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x67616c66</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-6</span>, key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>,((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">3</span>]);</span><br><span class="line">    }<span class="comment">//强制转为char然后依次取出，这样就不会逆序了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>异或和位置互换</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">24</span>] = {</span><br><span class="line"><span class="number">0xCE</span>, <span class="number">0xBC</span>, <span class="number">0x40</span>, <span class="number">0x6B</span>, <span class="number">0x7C</span>, <span class="number">0x3A</span>, <span class="number">0x95</span>, <span class="number">0xC0</span>, <span class="number">0xEF</span>, <span class="number">0x9B</span>, <span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0xF7</span>, <span class="number">0x02</span>, <span class="number">0x35</span>,</span><br><span class="line"><span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x02</span>, <span class="number">0xC8</span>, <span class="number">0xE7</span>, <span class="number">0x56</span>, <span class="number">0x56</span>, <span class="number">0xFA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//因为最后的加密数据和前面的有关系，所以要从前往后</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">6</span> - count; j &gt;= <span class="number">0</span>; --j)<span class="comment">//并且分为了多轮，除去前三个不需要异或，剩下7组，又是小于8，所以从下标为6开始</span></span><br><span class="line">{</span><br><span class="line">data[i] ^= data[j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> encode_flag2[<span class="number">24</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//交换还原</span></span><br><span class="line">encode_flag2[<span class="number">2</span>]= *data;</span><br><span class="line">*encode_flag2= data[<span class="number">1</span>];</span><br><span class="line">encode_flag2[<span class="number">3</span>]= data[<span class="number">2</span>];</span><br><span class="line">encode_flag2[<span class="number">1</span>]= data[<span class="number">3</span>];</span><br><span class="line">encode_flag2[<span class="number">6</span>]= data[<span class="number">4</span>];</span><br><span class="line">encode_flag2[<span class="number">4</span>]= data[<span class="number">5</span>];</span><br><span class="line">encode_flag2[<span class="number">7</span>]= data[<span class="number">6</span>];</span><br><span class="line">encode_flag2[<span class="number">5</span>]= data[<span class="number">7</span>];</span><br><span class="line">encode_flag2[<span class="number">10</span>]= data[<span class="number">8</span>];</span><br><span class="line">encode_flag2[<span class="number">8</span>]= data[<span class="number">9</span>];</span><br><span class="line">encode_flag2[<span class="number">11</span>]= data[<span class="number">10</span>];</span><br><span class="line">encode_flag2[<span class="number">9</span>]= data[<span class="number">11</span>];</span><br><span class="line">encode_flag2[<span class="number">14</span>]= data[<span class="number">12</span>];</span><br><span class="line">encode_flag2[<span class="number">12</span>]= data[<span class="number">13</span>];</span><br><span class="line">encode_flag2[<span class="number">15</span>]= data[<span class="number">14</span>];</span><br><span class="line">encode_flag2[<span class="number">13</span>]= data[<span class="number">15</span>];</span><br><span class="line">encode_flag2[<span class="number">18</span>]= data[<span class="number">16</span>];</span><br><span class="line">encode_flag2[<span class="number">16</span>]= data[<span class="number">17</span>];</span><br><span class="line">encode_flag2[<span class="number">19</span>]= data[<span class="number">18</span>];</span><br><span class="line">encode_flag2[<span class="number">17</span>]= data[<span class="number">19</span>];</span><br><span class="line">encode_flag2[<span class="number">22</span>]= data[<span class="number">20</span>];</span><br><span class="line">encode_flag2[<span class="number">20</span>]=data[<span class="number">21</span>] ;</span><br><span class="line">encode_flag2[<span class="number">23</span>]= data[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%X,"</span>, encode_flag2[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="安洵杯-2019-crackMe"><a class="header-anchor" href="#安洵杯-2019-crackMe">¶</a>[安洵杯 2019]crackMe</h1><h2 id="考点-v2"><a class="header-anchor" href="#考点-v2">¶</a>考点</h2><p>SM4、Base64变表加密、换位</p><h2 id="分析-v2"><a class="header-anchor" href="#分析-v2">¶</a>分析</h2><p>这里我和别人不一样，我运行不了程序，所以没办法动调，只能X查看交叉引用</p><p>进去定位到主加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333197817.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333231195.png" alt=""></p><h3 id="初始化密钥"><a class="header-anchor" href="#初始化密钥">¶</a>初始化密钥</h3><p>对key查看交叉引用，可以进入这里，看一下对赋值后的字符串处理</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333257430.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333345804.png" alt=""></p><p>通过FindCrypt可以知道是SM4加密，所以这一段就是初始化密钥了</p><h3 id="SM4加密"><a class="header-anchor" href="#SM4加密">¶</a>SM4加密</h3><p>回到encode函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333436418.png" alt=""></p><p>可以发现最后将加密后的字符串给到了final</p><h3 id="Base64加密"><a class="header-anchor" href="#Base64加密">¶</a>Base64加密</h3><p>对final查看交叉引用，发现对其进行了加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333588664.png" alt=""></p><p>这里解释一下一些东西</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333635363.png" alt=""></p><blockquote><p><strong>我们base64就是将三个字符也就是24位转为4个6位，做索引，这里使用移位直接将三个字符成为一个int型，也就是每个左移8位，而待会取出的时候右移六位即可取出，实现了8位与6位的转换，比较有意思</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333792600.png" alt=""></p><p>在红框函数中将传入的6位索引进行+24，也就是(index+24)%64，我们可以将base64表整体左移，就相当于index+24了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333896782.png" alt=""></p><p>再对base64表查看交叉引用，发现了将大小写转换</p><h3 id="换位"><a class="header-anchor" href="#换位">¶</a>换位</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333519884.png" alt=""></p><p>可以看到这里将最后用来对比的字符串每两个字符进行互换</p><h2 id="脚本-v2"><a class="header-anchor" href="#脚本-v2">¶</a>脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> base64_table[] = <span class="string">"yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx"</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_encode</span><span class="params">(<span class="keyword">char</span> code[], <span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> code_len = <span class="built_in">strlen</span>(code);</span><br><span class="line"><span class="keyword">int</span> str_len ;</span><br><span class="line"><span class="keyword">if</span> (code_len%<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">str_len = (code_len / <span class="number">3</span> + <span class="number">1</span> ) * <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str_len = (code_len / <span class="number">3</span>) * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, i_ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; code_len; i += <span class="number">3</span>, i_ += <span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">str[i_] = base64_table[code[i]&gt;&gt; <span class="number">2</span>];</span><br><span class="line">str[i_ + <span class="number">1</span>] = base64_table[((code[i] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>) | ((code[i + <span class="number">1</span>] &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">str[i_ + <span class="number">2</span>] = base64_table[((code[i+<span class="number">1</span>] &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">2</span>) | ((code[i + <span class="number">2</span>] &amp; <span class="number">0xc0</span>) &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">str[i_ + <span class="number">3</span>] = base64_table[(code[i + <span class="number">2</span>] &amp; <span class="number">0x3f</span>)];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (code_len % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">str[i_<span class="number">-1</span>] = <span class="string">'='</span>;</span><br><span class="line">str[i_ - <span class="number">2</span>] = <span class="string">'='</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (code_len % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">str[i_<span class="number">-1</span>] = <span class="string">'='</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> b64_table[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (c == b64_table[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> str_len;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_decode</span><span class="params">(<span class="keyword">char</span> code[], <span class="keyword">char</span> str[], <span class="keyword">char</span> b64_table[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> memstr[<span class="number">200</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="built_in">memcpy</span>(memstr, code, <span class="built_in">strlen</span>(code));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(code);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">"=="</span>))</span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">"="</span>))</span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, i_ = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span>, i_ += <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; <span class="number">2</span>) | (findIndex(memstr[i + <span class="number">1</span>], b64_table) &amp; <span class="number">0x30</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">str[i_+<span class="number">1</span>]= (findIndex(memstr[i+<span class="number">1</span>], b64_table)&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">4</span> | (findIndex(memstr[i + <span class="number">2</span>], b64_table) &amp; <span class="number">0x3c</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">str[i_ + <span class="number">2</span>] = (findIndex(memstr[i + <span class="number">2</span>], b64_table) &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span> | (findIndex(memstr[i + <span class="number">3</span>], b64_table));</span><br><span class="line">}</span><br><span class="line">str[str_len] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> code[<span class="number">100</span>] = <span class="string">"1UTAOIkpyOSWGv/mOYFY4R=="</span>;</span><br><span class="line"><span class="keyword">char</span> decode[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">char</span> encode[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//两位交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(code); i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">char</span> v2 = code[i];</span><br><span class="line">code[i] = code[i + <span class="number">1</span>];</span><br><span class="line">code[i + <span class="number">1</span>] = v2;                         <span class="comment">// 每两个之间进行交换</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*base64_encode(code, encode); </span></span><br><span class="line"><span class="comment">printf("%s\n", encode);*/</span></span><br><span class="line">base64_decode(code, decode,base64_table);</span><br><span class="line"><span class="keyword">if</span> (decode == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X"</span>, decode[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得到59D095290DF2400614F48D276906874E</p><p>SM4解密</p><p><a href="https://the-x.cn/cryptography/Sm4.aspx">https://the-x.cn/cryptography/Sm4.aspx</a></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650334038696.png" alt=""></p><h1 id="SWPU2019-ReverseMe"><a class="header-anchor" href="#SWPU2019-ReverseMe">¶</a>[SWPU2019]ReverseMe</h1><h2 id="考点-v3"><a class="header-anchor" href="#考点-v3">¶</a>考点</h2><p>异或、ZUC算法</p><h2 id="分析-v3"><a class="header-anchor" href="#分析-v3">¶</a>分析</h2><p>先异或SWPU_2019_CTF，再异或ZUC算法生成的数据</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350768675.png" alt="异或"></p><p>ZUC算法生成异或的值</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350800049.png" alt=""></p><p>unsigned int 的异或，通过动调也可以知道</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350725823.png" alt="xor"></p><h2 id="脚本-v3"><a class="header-anchor" href="#脚本-v3">¶</a>脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">8</span>] = {</span><br><span class="line"><span class="number">0xCA3E0C86</span>, <span class="number">0x19AED798</span>, <span class="number">0xA66B77E2</span>, <span class="number">0xB077A16A</span>, <span class="number">0x05379169</span>, <span class="number">0x307BF97A</span>, <span class="number">0x104B5A43</span>, <span class="number">0x28D47D86</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">final</span>[<span class="number">8</span>] = {</span><br><span class="line"><span class="number">0xF80F37B3</span>, <span class="number">0x5DAEBCBC</span>, <span class="number">0x864D5ABA</span>, <span class="number">0xD3629744</span>, <span class="number">0x1624BA4F</span>, <span class="number">0x1A729F0B</span>, <span class="number">0x266D6865</span>, <span class="number">0x67C86BBA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> k[] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span>[i] ^= data[i];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">0</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">1</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">2</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">3</span>];</span><br><span class="line">}</span><br><span class="line">k[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"SWPU_2019_CTF"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">{</span><br><span class="line">k[i] ^= key[i % <span class="number">13</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, k[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="MRCTF2020-EasyCpp"><a class="header-anchor" href="#MRCTF2020-EasyCpp">¶</a>[MRCTF2020]EasyCpp</h1><h2 id="考点-v4"><a class="header-anchor" href="#考点-v4">¶</a>考点</h2><p>异或、替换，素因数分解</p><h2 id="分析-v4"><a class="header-anchor" href="#分析-v4">¶</a>分析</h2><p>一些关键的都已经标识出来了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331362066.png" alt=""></p><h3 id="读取输入"><a class="header-anchor" href="#读取输入">¶</a>读取输入</h3><p>读取9次key，并且拼接起来</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331630377.png" alt=""></p><h3 id="异或-v2"><a class="header-anchor" href="#异或-v2">¶</a>异或</h3><p>这里面是和1异或</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331969448.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331929652.png" alt=""></p><h3 id="素因数分解"><a class="header-anchor" href="#素因数分解">¶</a>素因数分解</h3><p>这里只要能整除i，就重新进入递归，参数为整除i后的数，如果i遍历完不符合，结束循环，然后拼接上空格</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332066496.png" alt=""></p><h3 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332316391.png" alt=""></p><p>将数字换成字母，空格换为=</p><h3 id="比较"><a class="header-anchor" href="#比较">¶</a>比较</h3><p>红框数组存储的是最后比较的字符串</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332398066.png" alt=""></p><h2 id="脚本-v4"><a class="header-anchor" href="#脚本-v4">¶</a>脚本</h2><p>这里我直接手动替换算出来的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">293</span> * <span class="number">8</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">1223</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">11</span> * <span class="number">7</span> * <span class="number">5</span> * <span class="number">5</span> * <span class="number">3</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">2477</span>) ^ <span class="number">1</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">125</span> * <span class="number">27</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">3</span> * <span class="number">3011</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">13</span> * <span class="number">7</span> * <span class="number">27</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">353</span> * <span class="number">5</span> * <span class="number">2</span>) ^ <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>md5即可</p><h1 id="SCTF2019-Creakme"><a class="header-anchor" href="#SCTF2019-Creakme">¶</a>SCTF2019-Creakme</h1><h2 id="考点-v5"><a class="header-anchor" href="#考点-v5">¶</a>考点</h2><p>AES-CBC加密、Base64加密、反调试、SMC</p><h2 id="分析-v5"><a class="header-anchor" href="#分析-v5">¶</a>分析</h2><h3 id="反调试、SMC"><a class="header-anchor" href="#反调试、SMC">¶</a>反调试、SMC</h3><p>一看到这种遍历段名称的操作，熟悉SMC自解密的应该知道这是敏感的操作，也就是解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335524731.png" alt=""></p><p>对于这种在输入开始前的反调试，采用attach to process</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335425994.png" alt="反调试"></p><p>可以看到如果不是调试状态，就将数据强制转为函数指针</p><p>这里已经解密完并执行完程序了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335630803.png" alt=""></p><p>对其交叉引用可以看到</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335692377.png" alt=""></p><h3 id="AES-CBC、Base64加密"><a class="header-anchor" href="#AES-CBC、Base64加密">¶</a>AES-CBC、Base64加密</h3><p>动调发现这就是加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336067526.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336317921.png" alt="AES-CBC"></p><p>可以知道该函数就是初始化密钥</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336575248.png" alt=""></p><p>从这里的明文异或结合CBC可以知道是CBC模式</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337171206.png" alt="明文异或"></p><p>key和iv分别为sycloversyclover、sctfsctfsctfsctf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336622490.png" alt="iv"></p><p>这里很多this指针，但是我们还是可以通过一些特征以及FindCrypt发现这是AES中的key的初始化</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336696808.png" alt=""></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336732282.png" alt="轮常量异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336808010.png" alt="S表替换"></p><p>AES-CBC加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337454010.png" alt="明文与iv向量的异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337280514.png" alt="内部加密"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336891802.png" alt="base64"></p><p>进入该函数中，明显是base64加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336933402.png" alt=""></p><p>找到码表，发现没有被改过</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336989928.png" alt=""></p><h3 id="比较-v2"><a class="header-anchor" href="#比较-v2">¶</a>比较</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337016203.png" alt=""></p><h2 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h2><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337028435.png" alt=""></p><h1 id="SCTF2019-babyre"><a class="header-anchor" href="#SCTF2019-babyre">¶</a>SCTF2019-babyre</h1><h2 id="考点-v6"><a class="header-anchor" href="#考点-v6">¶</a>考点</h2><p>base64解密、Maze、移位与异或、花指令</p><h2 id="分析-v6"><a class="header-anchor" href="#分析-v6">¶</a>分析</h2><p>花指令就不说了，全部都是一样的，去除即可</p><p>迷宫也没啥说的，注意这里是三维迷宫 <strong>ddwwxxssxaxwwaasasyywwdd</strong></p><h3 id="base64解密"><a class="header-anchor" href="#base64解密">¶</a>base64解密</h3><p>可以看到这里先将我们的输入去table找索引，然后&amp;0x3F取出最后的六位，按位与上v5左移6，这样就得到了8位的字符，加上=4的判断，类似于base64的解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650339409043.png" alt=""></p><p>直接将最后的字符串加密即可<strong>c2N0Zl85MTAy</strong></p><h3 id="换位异或"><a class="header-anchor" href="#换位异或">¶</a>换位异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340193709.png" alt=""></p><p>加密流程：每四个输入存入int型的变量，然后进行xor_enc加密，将前四个字符加密后存放到第四个字符的后一个字符，依次往后。</p><blockquote><p><strong>之所以要这样进行移位是因为如果强制转为int型，由于小端序，存储的时候是12345678，这样int取出的时候就变成了4321</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340446709.png" alt="xor_enc"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340461185.png" alt=""></p><p>xor_enc加密流程：将第二第三第四个字符进行异或，分为四个字节去table找到对应的值，然后重新组合成int型，再经过一系列左移右移异或操作并返回，再将返回值与第一个字符异或，这样就得到了一个加密后的结果，这里要一直等到index&lt;=29，也就是前四个字符不会加密</p><p>我们可以看到这里v10只有26，那么26、27、28、29下标的v10就赋值给了v11、v12、v13、v14</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340936262.png" alt=""></p><p>取出最后四个int型存储的十六个字节，存储到enc_flag数组，然后比较</p><blockquote><p><strong>假设int a=0x12345678,那么HIBYTE(a)=0x12,BYTE2(a)=0x34,BYTE1(a)=0x56</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340991543.png" alt=""></p><p>这样我们就知道了最后的四个int型的元素，往前推，29是怎么来的呢，是flag[25]<sup>enc(flag[26],flag[27],flag[28])得到的，所以flag[29]</sup>enc(flag[26],flag[27],flag[28])即可得到flag[25]，前面的元素同理</p><h2 id="脚本-v5"><a class="header-anchor" href="#脚本-v5">¶</a>脚本</h2><p>因为涉及了ida的左右移位操作，而ida目录下defs.h有定义，所以可以直接引用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v3[<span class="number">273</span>] = {</span><br><span class="line">    <span class="number">0x000000D6</span>, <span class="number">0x00000090</span>, <span class="number">0x000000E9</span>, <span class="number">0x000000FE</span>, <span class="number">0x000000CC</span>, <span class="number">0x000000E1</span>, <span class="number">0x0000003D</span>, <span class="number">0x000000B7</span>,</span><br><span class="line">    <span class="number">0x00000016</span>, <span class="number">0x000000B6</span>, <span class="number">0x00000014</span>, <span class="number">0x000000C2</span>, <span class="number">0x00000028</span>, <span class="number">0x000000FB</span>, <span class="number">0x0000002C</span>, <span class="number">0x00000005</span>,</span><br><span class="line">    <span class="number">0x0000002B</span>, <span class="number">0x00000067</span>, <span class="number">0x0000009A</span>, <span class="number">0x00000076</span>, <span class="number">0x0000002A</span>, <span class="number">0x000000BE</span>, <span class="number">0x00000004</span>, <span class="number">0x000000C3</span>,</span><br><span class="line">    <span class="number">0x000000AA</span>, <span class="number">0x00000044</span>, <span class="number">0x00000013</span>, <span class="number">0x00000026</span>, <span class="number">0x00000049</span>, <span class="number">0x00000086</span>, <span class="number">0x00000006</span>, <span class="number">0x00000099</span>,</span><br><span class="line">    <span class="number">0x0000009C</span>, <span class="number">0x00000042</span>, <span class="number">0x00000050</span>, <span class="number">0x000000F4</span>, <span class="number">0x00000091</span>, <span class="number">0x000000EF</span>, <span class="number">0x00000098</span>, <span class="number">0x0000007A</span>,</span><br><span class="line">    <span class="number">0x00000033</span>, <span class="number">0x00000054</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000043</span>, <span class="number">0x000000ED</span>, <span class="number">0x000000CF</span>, <span class="number">0x000000AC</span>, <span class="number">0x00000062</span>,</span><br><span class="line">    <span class="number">0x000000E4</span>, <span class="number">0x000000B3</span>, <span class="number">0x0000001C</span>, <span class="number">0x000000A9</span>, <span class="number">0x000000C9</span>, <span class="number">0x00000008</span>, <span class="number">0x000000E8</span>, <span class="number">0x00000095</span>,</span><br><span class="line">    <span class="number">0x00000080</span>, <span class="number">0x000000DF</span>, <span class="number">0x00000094</span>, <span class="number">0x000000FA</span>, <span class="number">0x00000075</span>, <span class="number">0x0000008F</span>, <span class="number">0x0000003F</span>, <span class="number">0x000000A6</span>,</span><br><span class="line">    <span class="number">0x00000047</span>, <span class="number">0x00000007</span>, <span class="number">0x000000A7</span>, <span class="number">0x000000FC</span>, <span class="number">0x000000F3</span>, <span class="number">0x00000073</span>, <span class="number">0x00000017</span>, <span class="number">0x000000BA</span>,</span><br><span class="line">    <span class="number">0x00000083</span>, <span class="number">0x00000059</span>, <span class="number">0x0000003C</span>, <span class="number">0x00000019</span>, <span class="number">0x000000E6</span>, <span class="number">0x00000085</span>, <span class="number">0x0000004F</span>, <span class="number">0x000000A8</span>,</span><br><span class="line">    <span class="number">0x00000068</span>, <span class="number">0x0000006B</span>, <span class="number">0x00000081</span>, <span class="number">0x000000B2</span>, <span class="number">0x00000071</span>, <span class="number">0x00000064</span>, <span class="number">0x000000DA</span>, <span class="number">0x0000008B</span>,</span><br><span class="line">    <span class="number">0x000000F8</span>, <span class="number">0x000000EB</span>, <span class="number">0x0000000F</span>, <span class="number">0x0000004B</span>, <span class="number">0x00000070</span>, <span class="number">0x00000056</span>, <span class="number">0x0000009D</span>, <span class="number">0x00000035</span>,</span><br><span class="line">    <span class="number">0x0000001E</span>, <span class="number">0x00000024</span>, <span class="number">0x0000000E</span>, <span class="number">0x0000005E</span>, <span class="number">0x00000063</span>, <span class="number">0x00000058</span>, <span class="number">0x000000D1</span>, <span class="number">0x000000A2</span>,</span><br><span class="line">    <span class="number">0x00000025</span>, <span class="number">0x00000022</span>, <span class="number">0x0000007C</span>, <span class="number">0x0000003B</span>, <span class="number">0x00000001</span>, <span class="number">0x00000021</span>, <span class="number">0x00000078</span>, <span class="number">0x00000087</span>,</span><br><span class="line">    <span class="number">0x000000D4</span>, <span class="number">0x00000000</span>, <span class="number">0x00000046</span>, <span class="number">0x00000057</span>, <span class="number">0x0000009F</span>, <span class="number">0x000000D3</span>, <span class="number">0x00000027</span>, <span class="number">0x00000052</span>,</span><br><span class="line">    <span class="number">0x0000004C</span>, <span class="number">0x00000036</span>, <span class="number">0x00000002</span>, <span class="number">0x000000E7</span>, <span class="number">0x000000A0</span>, <span class="number">0x000000C4</span>, <span class="number">0x000000C8</span>, <span class="number">0x0000009E</span>,</span><br><span class="line">    <span class="number">0x000000EA</span>, <span class="number">0x000000BF</span>, <span class="number">0x0000008A</span>, <span class="number">0x000000D2</span>, <span class="number">0x00000040</span>, <span class="number">0x000000C7</span>, <span class="number">0x00000038</span>, <span class="number">0x000000B5</span>,</span><br><span class="line">    <span class="number">0x000000A3</span>, <span class="number">0x000000F7</span>, <span class="number">0x000000F2</span>, <span class="number">0x000000CE</span>, <span class="number">0x000000F9</span>, <span class="number">0x00000061</span>, <span class="number">0x00000015</span>, <span class="number">0x000000A1</span>,</span><br><span class="line">    <span class="number">0x000000E0</span>, <span class="number">0x000000AE</span>, <span class="number">0x0000005D</span>, <span class="number">0x000000A4</span>, <span class="number">0x0000009B</span>, <span class="number">0x00000034</span>, <span class="number">0x0000001A</span>, <span class="number">0x00000055</span>,</span><br><span class="line">    <span class="number">0x000000AD</span>, <span class="number">0x00000093</span>, <span class="number">0x00000032</span>, <span class="number">0x00000030</span>, <span class="number">0x000000F5</span>, <span class="number">0x0000008C</span>, <span class="number">0x000000B1</span>, <span class="number">0x000000E3</span>,</span><br><span class="line">    <span class="number">0x0000001D</span>, <span class="number">0x000000F6</span>, <span class="number">0x000000E2</span>, <span class="number">0x0000002E</span>, <span class="number">0x00000082</span>, <span class="number">0x00000066</span>, <span class="number">0x000000CA</span>, <span class="number">0x00000060</span>,</span><br><span class="line">    <span class="number">0x000000C0</span>, <span class="number">0x00000029</span>, <span class="number">0x00000023</span>, <span class="number">0x000000AB</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000053</span>, <span class="number">0x0000004E</span>, <span class="number">0x0000006F</span>,</span><br><span class="line">    <span class="number">0x000000D5</span>, <span class="number">0x000000DB</span>, <span class="number">0x00000037</span>, <span class="number">0x00000045</span>, <span class="number">0x000000DE</span>, <span class="number">0x000000FD</span>, <span class="number">0x0000008E</span>, <span class="number">0x0000002F</span>,</span><br><span class="line">    <span class="number">0x00000003</span>, <span class="number">0x000000FF</span>, <span class="number">0x0000006A</span>, <span class="number">0x00000072</span>, <span class="number">0x0000006D</span>, <span class="number">0x0000006C</span>, <span class="number">0x0000005B</span>, <span class="number">0x00000051</span>,</span><br><span class="line">    <span class="number">0x0000008D</span>, <span class="number">0x0000001B</span>, <span class="number">0x000000AF</span>, <span class="number">0x00000092</span>, <span class="number">0x000000BB</span>, <span class="number">0x000000DD</span>, <span class="number">0x000000BC</span>, <span class="number">0x0000007F</span>,</span><br><span class="line">    <span class="number">0x00000011</span>, <span class="number">0x000000D9</span>, <span class="number">0x0000005C</span>, <span class="number">0x00000041</span>, <span class="number">0x0000001F</span>, <span class="number">0x00000010</span>, <span class="number">0x0000005A</span>, <span class="number">0x000000D8</span>,</span><br><span class="line">    <span class="number">0x0000000A</span>, <span class="number">0x000000C1</span>, <span class="number">0x00000031</span>, <span class="number">0x00000088</span>, <span class="number">0x000000A5</span>, <span class="number">0x000000CD</span>, <span class="number">0x0000007B</span>, <span class="number">0x000000BD</span>,</span><br><span class="line">    <span class="number">0x0000002D</span>, <span class="number">0x00000074</span>, <span class="number">0x000000D0</span>, <span class="number">0x00000012</span>, <span class="number">0x000000B8</span>, <span class="number">0x000000E5</span>, <span class="number">0x000000B4</span>, <span class="number">0x000000B0</span>,</span><br><span class="line">    <span class="number">0x00000089</span>, <span class="number">0x00000069</span>, <span class="number">0x00000097</span>, <span class="number">0x0000004A</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000096</span>, <span class="number">0x00000077</span>, <span class="number">0x0000007E</span>,</span><br><span class="line">    <span class="number">0x00000065</span>, <span class="number">0x000000B9</span>, <span class="number">0x000000F1</span>, <span class="number">0x00000009</span>, <span class="number">0x000000C5</span>, <span class="number">0x0000006E</span>, <span class="number">0x000000C6</span>, <span class="number">0x00000084</span>,</span><br><span class="line">    <span class="number">0x00000018</span>, <span class="number">0x000000F0</span>, <span class="number">0x0000007D</span>, <span class="number">0x000000EC</span>, <span class="number">0x0000003A</span>, <span class="number">0x000000DC</span>, <span class="number">0x0000004D</span>, <span class="number">0x00000020</span>,</span><br><span class="line">    <span class="number">0x00000079</span>, <span class="number">0x000000EE</span>, <span class="number">0x0000005F</span>, <span class="number">0x0000003E</span>, <span class="number">0x000000D7</span>, <span class="number">0x000000CB</span>, <span class="number">0x00000039</span>, <span class="number">0x00000048</span>,</span><br><span class="line">    <span class="number">0x000000C6</span>, <span class="number">0x000000BA</span>, <span class="number">0x000000B1</span>, <span class="number">0x000000A3</span>, <span class="number">0x00000050</span>, <span class="number">0x00000033</span>, <span class="number">0x000000AA</span>, <span class="number">0x00000056</span>,</span><br><span class="line">    <span class="number">0x00000097</span>, <span class="number">0x00000091</span>, <span class="number">0x0000007D</span>, <span class="number">0x00000067</span>, <span class="number">0x000000DC</span>, <span class="number">0x00000022</span>, <span class="number">0x00000070</span>, <span class="number">0x000000B2</span>,</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> xor_final)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> v2 = (v3[BYTE2(xor_final)] &lt;&lt; <span class="number">16</span>) | v3[(<span class="keyword">unsigned</span> __int8)xor_final] | (v3[BYTE1(xor_final)] &lt;&lt; <span class="number">8</span>) | (v3[HIBYTE(xor_final)] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> __ROL4__(v2, <span class="number">12</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(__ROL4__(v2, <span class="number">8</span>) ^ __ROR4__(v2, <span class="number">2</span>)) ^ __ROR4__(v2, <span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> v10[<span class="number">30</span>] = { <span class="number">0</span> };</span><br><span class="line">    v10[<span class="number">26</span>] = <span class="number">0xBE040680</span>;</span><br><span class="line">    v10[<span class="number">27</span>] = <span class="number">0xC5AF7647</span>;</span><br><span class="line">    v10[<span class="number">28</span>] = <span class="number">0x9FCC401F</span>;</span><br><span class="line">    v10[<span class="number">29</span>] = <span class="number">0xD8BF92EF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    {</span><br><span class="line">        v10[i] = v10[i + <span class="number">4</span>] ^ encode(v10[i + <span class="number">1</span>]^v10[i + <span class="number">2</span>]^v10[i + <span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>,((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">0</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">1</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">2</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650342054912.png" alt=""></p><p>这样子就不会存在int型读取时小端序的问题</p><h1 id=""><a class="header-anchor" href="#">¶</a></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Buuctf刷题记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Detours学习</title>
    <link href="https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T07:26:14.000Z</published>
    <updated>2022-04-24T01:37:54.871Z</updated>
    
    <content type="html"><![CDATA[<p>Detourd学习</p><span id="more"></span> <h1 id="0x00-参考"><a class="header-anchor" href="#0x00-参考">¶</a>0x00-参考</h1><p><a href="https://blog.csdn.net/jyl_sh/article/details/120855998">https://blog.csdn.net/jyl_sh/article/details/120855998</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100565010">https://blog.csdn.net/z971130192/article/details/100565010</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100565398">https://blog.csdn.net/z971130192/article/details/100565398</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100671576">https://blog.csdn.net/z971130192/article/details/100671576</a></p>]]></content>
    
    
    <summary type="html">Detours</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>API钩取技术</title>
    <link href="https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/"/>
    <id>https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-15T06:28:13.000Z</published>
    <updated>2022-04-20T01:21:38.511Z</updated>
    
    
    <summary type="html">API钩取技术</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用汇编语言编写注入代码</title>
    <link href="https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/"/>
    <id>https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/</id>
    <published>2022-04-14T08:03:09.000Z</published>
    <updated>2022-04-20T05:39:42.656Z</updated>
    
    <content type="html"><![CDATA[<p>代码注入-汇编</p><span id="more"></span> <h1 id="0x00-设置"><a class="header-anchor" href="#0x00-设置">¶</a>0x00-设置</h1><p>修改EIP</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925411946.png" alt=""></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925229842.png" alt=""></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925283278.png" alt="关闭自动填充nop"></p><h1 id="0x01-修改汇编"><a class="header-anchor" href="#0x01-修改汇编">¶</a>0x01-修改汇编</h1><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926048838.png" alt=""></p><p>输入字符串，Ctrl+E修改，注意字符串以0结尾，最后要加上00</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926227498.png" alt=""></p><p>可以发现得到的是汇编代码，OD会自动识别</p><p>只需要选中字符串按下Ctrl+A即可转为字符串</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926333629.png" alt=""></p><p>同理修改好www.reversecore.com字符串</p><h2 id="提取汇编"><a class="header-anchor" href="#提取汇编">¶</a>提取汇编</h2><p>接下来将插入的asm的机器码进行复制（在内存窗口中复制对应长度的十六进制数据），并修改格式</p><p>得到</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = {</span><br><span class="line"><span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-代码实现-v2"><a class="header-anchor" href="#0x02-代码实现-v2">¶</a>0x02-代码实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE shellcode[] = {</span><br><span class="line"> <span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Thread_Param</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">FARPROC pFunc[<span class="number">2</span>];<span class="comment">//Loadlibrary,GetProcAddress</span></span><br><span class="line">}Thread_Param, * pThread_Param;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Asm_Inject</span><span class="params">(DWORD PID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">Thread_Param param[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID pRemoteBuf[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取kernel32.dll的句柄</span></span><br><span class="line">hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"><span class="comment">//将需要使用的函数存储</span></span><br><span class="line">param-&gt;pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">param-&gt;pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启进程</span></span><br><span class="line"><span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟空间并写入</span></span><br><span class="line"><span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Thread_Param), MEM_COMMIT, PAGE_READWRITE)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAlloc Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">0</span>], (LPVOID)&amp;param, <span class="keyword">sizeof</span>(Thread_Param), <span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcess Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们的shellcode写入</span></span><br><span class="line"><span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT, PAGE_READWRITE)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAlloc Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">1</span>], (LPVOID)&amp;shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcess Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>], pRemoteBuf[<span class="number">0</span>], <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Asm_Inject((DWORD)atol(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上和代码注入没区别，主要是我们将字符串也包含在了注入的代码里面，所以在线程函数中不再需要使用字符数组存储</p><h1 id="0x03-分析"><a class="header-anchor" href="#0x03-分析">¶</a>0x03-分析</h1><p>在OD中打开并注入，让其停在新线程</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650001855752.png" alt=""></p><p>先提升堆栈，然后将函数的参数存入ESI中，也就是线程函数对应的THREAD_PARAM结构体，因为里面只有两个函数指针，所以大小为0x8</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002105819.png" alt="ESI的值"></p><p>我们执行完移动到esi这一步，去内存中查看ESI存储的值</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002164069.png" alt=""></p><p>将其转为地址，注释中会告知我们其对应的API函数</p><p>接下来的四个PUSH+call可以知道是调用函数，LoadLibraryA只需要一个参数</p><p>前面三个PUSH是将函数名称压入栈，而最后一个是将当前的ESP的值压入栈，而当前ESP的值正好是存储字符串的地址，这样就实现了给LoadLibraryA传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002382351.png" alt=""></p><p>需要注意这里是小端序</p><p>接下来的四个PUSH和前面是一样的，关键是最后一个PUSH</p><blockquote><p><strong>因为返回值一般存储在EAX，并且函数调用时入栈顺序是从右往左依次入栈</strong></p></blockquote><p>这里的EAX存储的值就是user32.dll的句柄，也就是地址，在eax寄存器中OD也自动标明了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002603450.png" alt=""></p><p>最后获取到MessageBoxA的地址</p><p>MessageBoxA的传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002654110.png" alt=""></p><p>这一段本来是字符串，但是OD给我们识别成了代码</p><p>执行完之后</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002721021.png" alt=""></p><p>可以看到我们的MessageBoxA的参数都在栈中了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002770898.png" alt="调用MessageBoxA"></p><p>最后就是清空eax和恢复堆栈了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码注入-汇编&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
</feed>
