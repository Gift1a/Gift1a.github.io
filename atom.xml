<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-03-14T12:17:23.941Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PE-滴水逆向-手动实现</title>
    <link href="https://gift1a.github.io/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-11T12:03:07.000Z</published>
    <updated>2022-03-14T12:17:23.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代码节空白节区添加代码"><a href="#代码节空白节区添加代码" class="headerlink" title="代码节空白节区添加代码"></a>代码节空白节区添加代码</h1><p>这里我们在notepad++增加MessageBoxA函数，保证先调用我们的函数再运行notepad++</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在代码区先加入对函数的调用，再将原来的OEP修改为我们插入代码在内存中的位置</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p> ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。 所以我们要先关闭</p><p><a href="https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr">https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr</a></p><p>在标准PE头属性中的第一个值改为1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647081337731.png"></p><p>这样PE文件加载到内存中就不会随机化了</p><h2 id="提取关键数据"><a href="#提取关键数据" class="headerlink" title="提取关键数据"></a>提取关键数据</h2><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>DWORD AddressOfEntryPoint-10E5DBh</p><p>DWORD ImageBase-400000h</p><h3 id="节表信息"><a href="#节表信息" class="headerlink" title="节表信息"></a>节表信息</h3><p>MIsc.DWORD VirtualSize-17C51Eh</p><p>DWORD VirtualAddress-1000h</p><p>DWORD PointerToRawData-400h</p><p>DWORD SizeOfRawData-17C600h</p><h2 id="判断能否添加"><a href="#判断能否添加" class="headerlink" title="判断能否添加"></a>判断能否添加</h2><p>如果SizeOfRawData-MIsc.DWORD VirtualSize&gt;=0x12，即可添加，这里是可以的</p><h2 id="找到在文件中代码结束的位置"><a href="#找到在文件中代码结束的位置" class="headerlink" title="找到在文件中代码结束的位置"></a>找到在文件中代码结束的位置</h2><p>先找到在文件中的偏移PointerToRawData，再找到数据段大小MIsc.DWORD VirtualSize，两者相加就是真实数据段的结束位置</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082425978.png"></p><h2 id="添加硬编码"><a href="#添加硬编码" class="headerlink" title="添加硬编码"></a>添加硬编码</h2><p>MessageBoxA需要四个参数</p><p>call指令长度为5</p><p>jmp指令长度为5</p><blockquote><p>真正要跳转的地址=E8/E9指令的下一条指令在内存中的地址+X（X就是E8后边跟着的四个字节）</p></blockquote><p>所以我们需要添加的硬编码为6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082868490.png"></p><h2 id="计算E8和E9的后四个字节"><a href="#计算E8和E9的后四个字节" class="headerlink" title="计算E8和E9的后四个字节"></a>计算E8和E9的后四个字节</h2><p>先找到E8对应的真实地址，也就是MessageBoxA的地址，在od里面command-&gt;输入bp MessageBoxA-&gt;状态栏b-&gt;找到MessageBoxA的地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083046046.png"></p><h3 id="E8后四字节计算"><a href="#E8后四字节计算" class="headerlink" title="E8后四字节计算"></a>E8后四字节计算</h3><p>真实地址为MessageBoxA的地址</p><p>X为MessageBoxA地址-VirtualAddress+ImageBase+8+5+Misc.VirtualSize</p><p>76BA5865</p><h3 id="E9后四字节计算"><a href="#E9后四字节计算" class="headerlink" title="E9后四字节计算"></a>E9后四字节计算</h3><p>真实地址为原来的OEP</p><p>X为ImageBase+AddressOfEntryPoint-VirtualAddress+ImageBase+8+5+5+Misc.VirtualSize</p><p>为FFF910AB</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083638028.png"></p><h2 id="修改AddressOfPoint"><a href="#修改AddressOfPoint" class="headerlink" title="修改AddressOfPoint"></a>修改AddressOfPoint</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083743309.png"></p><p>让他先执行我们的代码，也就是修改其为插入硬编码的地址</p><p>VirtualAddress+Misc.VirtualSize=17D51Eh</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>先执行MessageBoxA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084038464.png"></p><p>再运行程序</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084072618.png"></p><h1 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h1><h2 id="大小判断"><a href="#大小判断" class="headerlink" title="大小判断"></a>大小判断</h2><p>首先我们需要知道能否新增节SizeofHeaders-最后一个节表 的位置，如果大于或等于两个节表的大小（因为节表最后必须有长度为一个节表的00填充），则可以插入</p><h2 id="修改节表数量"><a href="#修改节表数量" class="headerlink" title="修改节表数量"></a>修改节表数量</h2><p>标准PE头-&gt;WORD NumberOfSections，+1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647140787003.png"></p><h2 id="添加节表信息"><a href="#添加节表信息" class="headerlink" title="添加节表信息"></a>添加节表信息</h2><p>这里直接复制.text段的信息，因为其可读可写可执行，后续可以不用再去修改节表属性</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141001170.png"></p><h2 id="确定插入的大小"><a href="#确定插入的大小" class="headerlink" title="确定插入的大小"></a>确定插入的大小</h2><p>根据情况自行选择，这里假设我们插入0x1000字节</p><h2 id="修改内存对齐后的大小"><a href="#修改内存对齐后的大小" class="headerlink" title="修改内存对齐后的大小"></a>修改内存对齐后的大小</h2><p>SizeOfImage+插入的大小（按照内存对齐）</p><h2 id="修正节表信息"><a href="#修正节表信息" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>先看关键数据</p><p>DWORD VirtualAddress</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD PointerToRawData</p><p>这里为了方便将Misc.DWORD VirtualSize和DWORD SizeOfRawData都改为0x1000，注意如果插入的是其他字节数，需要计算按照文件和内存对齐来调整</p><h3 id="计算VirtualAddress"><a href="#计算VirtualAddress" class="headerlink" title="计算VirtualAddress"></a>计算VirtualAddress</h3><p>前面一个节表的VirtualAddress+Max(Misc.DWORD VirtualSize,SizeOfRawData)-按内存对齐后的</p><p>这里SizeOfRawData大于前者，按内存对齐后是15000h，加上该节表的VirtualAddress就是我们插入节表在内存中的偏移地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141493979.png"></p><h3 id="计算PointerToRawData"><a href="#计算PointerToRawData" class="headerlink" title="计算PointerToRawData"></a>计算PointerToRawData</h3><p>和前面类似SizeOfRawData（文件对齐）+PointerToRawData</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141658195.png"></p><h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141708469.png"></p><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p>在PointerToRawData插入0x1000字节</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141776493.png"></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>在PE解析工具可以看到插入的节表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141801656.png"></p><h1 id="新增节-节表信息后不够位置"><a href="#新增节-节表信息后不够位置" class="headerlink" title="新增节-节表信息后不够位置"></a>新增节-节表信息后不够位置</h1><p>我们直到DOS和NT头之前有一段垃圾数据，当节表末尾没位置插入80个字节，我们需要将NT头和节表信息前移，这样就可以空出一段无用字节，长度为垃圾数据长度</p><blockquote><p>注意要修改LONG AddressOfNewExeHeader-NT头的位置</p></blockquote><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142922682.png"></p><p>直接复制到垃圾数据的起始地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142986819.png"></p><p>这就是空出来的节表，后续操作和前面新增节一样，就不赘述了</p><h1 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h1><p>当前面两种做法都不能满足，我们采取扩大节的办法，可以在任意节区末尾添加，但是如果不是在最后一个节添加，后面的节表偏移都要修改，所以我们扩大最后一个节</p><p>需要修改的数据</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD SizeOfImage</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>将最后一个节的SizeOfRawData和VirtualSize改成N，N = 节内存对齐后的大小 + 要扩大的大小</li><li>修改 SizeOfImage大小=SizeOfImage大小+要扩大的大小</li><li>分配一块新的空间，大小为：节内存对齐增加的大小+要扩大的大小</li></ol><h2 id="修正节表信息-1"><a href="#修正节表信息-1" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>这里我们假设扩大0x1000个字节</p><p>要改为Max(DWORD VirtualSize,DWORD SizeOfRawData)内存对齐的大小+我们扩大的大小=16000h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147742819.png"></p><h2 id="修正SizeOfImage"><a href="#修正SizeOfImage" class="headerlink" title="修正SizeOfImage"></a>修正SizeOfImage</h2><p>直接加上0x1000即可</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>节内存对齐增加的大小=N-DWORD SizeOfRawData，即C00</p><p>在节区尾部增加即可，有时候最后一个节区尾部之后还有别的程序，那么就需要计算最后一个节区的结束地址</p><p>求和得到2B6C00h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147968238.png"></p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647148042480.png"></p><h1 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h1><h2 id="修改节表个数"><a href="#修改节表个数" class="headerlink" title="修改节表个数"></a>修改节表个数</h2><p>合并之后节数量-1，这里改为7</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149630089.png"></p><h2 id="修改节表信息"><a href="#修改节表信息" class="headerlink" title="修改节表信息"></a>修改节表信息</h2><p>要将节进行合并，就需要修改节表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149670756.png"></p><h3 id="DWORD-SizeOfRawData和DWORD-VirtualSize"><a href="#DWORD-SizeOfRawData和DWORD-VirtualSize" class="headerlink" title="DWORD SizeOfRawData和DWORD VirtualSize"></a>DWORD SizeOfRawData和DWORD VirtualSize</h3><p>将这两个值改为该节的Max(SizeOfRawData,VirtualSize)+下一个节的Max(SizeOfRawData,VirtualSize)</p><p>最后保存即可</p><p>那么剩下的节表信息没用了，我们可以再次新增节</p><h2 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150089815.png"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150123108.png"></p><h1 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h1><p>移动前，我们需要先开辟节区，先将后面三个表指向的数据复制到新的节区中，再复制那三个表的信息过去，最后将数据目录指向导出表开始的地方</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647219750918.png" alt="移动前"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647220007029.png" alt="移动后"></p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>在数据目录找到导入表的RVA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228628138.png"></p><p>根据节的RVA和大小确定在哪个表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228686574.png"></p><p>计算FOA=Export .RVA-rdata.RVA+rdata. PointerToRawData</p><p>计算得到F2270，跳转，根据Export.Size确定大小</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228914109.png"></p><h2 id="新增节-1"><a href="#新增节-1" class="headerlink" title="新增节"></a>新增节</h2><p>前面说过，就不细🔒了</p><h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2><p>前面四个是DWORD函数地址，DWORD函数名称表，WORD函数序号-这里比较少，就一个函数</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229009740.png"></p><p>这两个分别是dll名字和函数名称</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229076116.png"></p><p>直接复制剩下的导出表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229244730.png"></p><h2 id="修改RVA"><a href="#修改RVA" class="headerlink" title="修改RVA"></a>修改RVA</h2><p>这里我已经改好了，因为该节的RVA-PointOfRawData=1600，所以修改的时候将FOA+1600h=RVA</p><p>要修改的有</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229408065.png"></p><h2 id="数据目录修改"><a href="#数据目录修改" class="headerlink" title="数据目录修改"></a>数据目录修改</h2><p>将Export.RVA指向我们复制导出表的初始位置</p><h1 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h1><p>新增节-&gt;复制数据-&gt;数据目录修改重定位表位置</p><h2 id="修改ImageBase"><a href="#修改ImageBase" class="headerlink" title="修改ImageBase"></a>修改ImageBase</h2><p>我们修改ImageBase时，重定位表也需要修改，其他不用改，因为其他节表信息映射到内存中时，都是按照ImageBase进行的</p><p>而重定位表是按照VirtualAddress+小表进行修复的，所以ImageBase修改了，重定位表的VirtualAddress也需要修改</p><p>假如ImageBase+1000，重定位表的VirtualAddress也需要+1000</p><h1 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h1><p>每个DLL对应一个导入表，DLL存放着我们的函数</p><p>导入表后面还有一堆数据，我们不能直接添加，所以要新开辟节区，然后复制原来的导入表之后再在末尾添加导入表</p><h2 id="新增节区"><a href="#新增节区" class="headerlink" title="新增节区"></a>新增节区</h2><h2 id="复制导入表信息"><a href="#复制导入表信息" class="headerlink" title="复制导入表信息"></a>复制导入表信息</h2><p> 拷贝原来的导入表到新节中 </p><h2 id="新增导入表"><a href="#新增导入表" class="headerlink" title="新增导入表"></a>新增导入表</h2><h2 id="新增INT表和IAT表"><a href="#新增INT表和IAT表" class="headerlink" title="新增INT表和IAT表"></a>新增INT表和IAT表</h2><p>至少八字节</p><h2 id="修改Name"><a href="#修改Name" class="headerlink" title="修改Name"></a>修改Name</h2><p> 存储要注入的dll的名称 ，并且将DLL名称的RVA赋值给新增导入表的Name</p><h2 id="创建struct-IMAGE-IMPORT-BY-NAME"><a href="#创建struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="创建struct _IMAGE_IMPORT_BY_NAME"></a>创建struct _IMAGE_IMPORT_BY_NAME</h2><p>将函数名称赋值给结构体的第二个变量</p><h2 id="修改INT和IAT指向的地址"><a href="#修改INT和IAT指向的地址" class="headerlink" title="修改INT和IAT指向的地址"></a>修改INT和IAT指向的地址</h2><p>将IMAGE_IMPORT_BY_NAME的RVA赋值给INT和IAT的第一项，因为INT和IAT都指向_IMAGE_IMPORT_BY_NAME</p><h2 id="修改数据目录"><a href="#修改数据目录" class="headerlink" title="修改数据目录"></a>修改数据目录</h2><p>指向我们的新增位置， 修改IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;代码节空白节区添加代码&quot;&gt;&lt;a href=&quot;#代码节空白节区添加代码&quot; class=&quot;headerlink&quot; title=&quot;代码节空白节区添加代码&quot;&gt;&lt;/a&gt;代码节空白节区添加代码&lt;/h1&gt;&lt;p&gt;这里我们在notepad++增加MessageBoxA函数，保证先调</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>PE解析代码实现</title>
    <link href="https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-03-11T05:19:10.000Z</published>
    <updated>2022-03-11T05:19:10.420Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>PE文件结构</title>
    <link href="https://gift1a.github.io/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://gift1a.github.io/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-03T06:13:58.000Z</published>
    <updated>2022-03-15T07:36:08.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>主要有exe、dll、sys文件，这些都是可执行文件</p><p>exe由多个exe文件组成，dll之类的</p><h1 id="PE文件头解析"><a href="#PE文件头解析" class="headerlink" title="PE文件头解析"></a>PE文件头解析</h1><p>在内存中和硬盘中数据几乎是一样的，但是存在差异，且程序开始的位置不同，所以可以知道存储信息的位置是可以改变的</p><p>根据不同的功能分了不同的节，也就是程序不同的块，这样做1、可以节省硬盘空间，在内存中占用空间大于硬盘占用空间（节之间的间隔较小）</p><p>2、节省内存，当程序需要多开的时候，只需要将可读可写的数据段重新复制一份即可，不需要对只读的数据进行复制</p><h2 id="硬盘（文件）对齐和内存对齐"><a href="#硬盘（文件）对齐和内存对齐" class="headerlink" title="硬盘（文件）对齐和内存对齐"></a>硬盘（文件）对齐和内存对齐</h2><p>目的都是为了提升读写的速度</p><p>老的编译器，硬盘对齐是200h个字节<strong>（当不够200h字节，会自动填充）</strong>，内存对齐是1000h个字节，所以PE结构执行（<strong>操作系统运行exe文件</strong>）时会发生拉伸的过程，即在内存中占用空间大于硬盘占用空间</p><p>新的编译器在硬盘和内存都采用1000h，这是因为编译器发展，这样内存和硬盘对齐一样，运行时可以减少运算，这样虽然牺牲了空间，但是缩短了时间</p><h2 id="PE磁盘文件与内存映像结构图"><a href="#PE磁盘文件与内存映像结构图" class="headerlink" title="PE磁盘文件与内存映像结构图"></a>PE磁盘文件与内存映像结构图</h2><p>块表（节表）概括节的基本信息（起始和终止位置，节的大小），DOS头和PE头对当前exe文件做的概要性描述（拉伸完后的大小，堆栈大小），节表存储信息</p><p> <img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/19100019-8692ac67434949cb9ec42764cab75468-1646313270630.jpg"> </p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>DOS长度确定</p><p>解析exe文件时，先解析前两个字节，并通过DOS头找到exe文件真正开始的地方</p><p>第一个WORD MZSignature（e_magic）-MZ标记</p><p>最后一个LONG AddressOfNewExeHeader（e_lfanew）-指向了PE文件的真正开始地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646292642401.png"></p><p>这里的0108表示从文件开始的地方计算0108个字节就是PE结构开始的地方</p><h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>DOS头和NT头中间是一段空间，可以自由发挥，多与少不确定，我们可以在这一段写入shellcode（ <strong>利用软件漏洞而执行的代码</strong> ），在程序中调用。有地址我们就可以访问和执行</p><p>PE的标记-DWORD Signature-四个字节</p><h3 id="标准PE头-20字节"><a href="#标准PE头-20字节" class="headerlink" title="标准PE头-20字节"></a>标准PE头-20字节</h3><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646295409969.png"></p><p>关键信息</p><p>enum IMAGE_MACHINE Machine-程序运行的CPU型号：0x0 任何处理器 /0x14C 386及后续处理器</p><p>WORD NumberOfSections-文件中存在的节的数量，如果需要新增或者合并节，就要修改这个值</p><p>time_t TimeDateStamp-文件创建时间，编译器填写</p><p><strong>WORD SizeOfOptionalHeader</strong>-可选PE头的大小，32位PE文件默认E0h、64位PE文件默认为F0h  大小可以自定义.</p><p>struct FILE_CHARACTERISTICS Characteristics-每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 </p><p>这里的102拆成二进制</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296388161.png"></p><p>勾中即为1</p><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296662617.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296680675.png"></p><p>关键信息</p><p>enum OPTIONAL_MAGIC Magic-说明文件类型：10B 32位下的PE文件、20B 64位下的PE文件</p><p>DWORD SectionAlignment-内存对齐</p><p>DWORD FileAlignment-文件对齐</p><p>DWORD SizeOfCode-所有代码节的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfInitializedData-已初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfUninitializedData-未初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p><em><strong>DWORD AddressOfEntryPoint-程序入口</strong></em></p><p>DWORD BaseOfCode-代码开始的基址，编译器填的，不会被使用</p><p>DWORD BaseOfData-数据开始的基址，编译器填的，不会被使用</p><p>！！<em><strong>DWORD ImageBase-内存镜像基址</strong></em>（不从0开始是因为需要内存保护）</p><p><em><strong>把文件拖入OD时会断在ImageBase+AddressOfEntryPoint这个地址，也就是OEP</strong></em></p><blockquote><p>程序入口可以修改-加壳</p><p>加壳之后入口点EP（RVA）和OEP（RAW）都会改变，但是内存镜像基址不变</p></blockquote><blockquote><p>内核重载：（有一些软件会通过hook技术，检测是否调用函数）相当于PEloader（加载）-把硬盘文件拷贝到内存中进而执行exe文件，但是在拷贝过程中还会有一个文件的缓冲区，这个缓冲区也是在内存中的。装载到内存时是以ImageBase为起点的</p></blockquote><p>DWORD SizeOfImage-内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍，也就是PE文件在内存中被拉伸后的大小</p><p>DWORD SizeOfHeaders-所有头+节表按照文件对齐后的大小，否则加载会出错</p><p>DWORD CheckSum-校验和，一些系统文件有要求，用来判断文件是否被修改</p><p>DWORD SizeOfStackReserve-初始化时保留的堆栈大小</p><p>DWORD SizeOfStackCommit-初始化时实际提交的大小</p><p>DWORD SizeOfHeapReserve-初始化时保留的堆的大小</p><p>DWORD SizeOfHeapCommit-初始化时实际提交的大小</p><p>DWORD NumberOfRvaAndSizes-目录项数目</p><h1 id="节表-每个节有28字节的信息"><a href="#节表-每个节有28字节的信息" class="headerlink" title="节表-每个节有28字节的信息"></a>节表-每个节有28字节的信息</h1><p>节表定位-DOS+PE+OPTIONPE</p><p>描述每个节的信息</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306378425.png"></p><p>节的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306828500.png"></p><p>BYTE Name[8]是八个字节，不够补’\0’，在内存是0，所以不能使用char*，而要用char [9]，且可以随便改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306924262.png"></p><p>第二个成员是union Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确（可能被别的软件加工过），但是不会妨碍运行，<strong>里面的成员DWORD VirtualSize-存放PE文件放入内存时的数据宽度，他的值可能大于文件对齐后的数据宽度（SizeofRawData），这是因为未初始化的变量不会被存入文件中</strong></p><p>第三个成员-DWORD VirtualAddress-节区在内存中的相对偏移（拉伸-内存对齐后的），加上ImageBase才是在内存中的真正地址（跟文件中无关）</p><p>第四个成员-DWORD SizeOfRawData-节在文件中对齐后的尺寸</p><p>第五个成员-DWORD PointerToRawData-节区在文件中的偏移,所以.text是从400h开始的（跟内存中无关）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646309678678.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646308057578.png"></p><p>第二个和第四个是在调试时使用的，编译完这四个默认为0</p><p>struct SECTION_CHARACTERISTICS Characteristics-节的属性</p><p>最后一个成员struct SECTION_CHARACTERISTICS Characteristics-里面有32位，但不是每一位都用</p><pre class="language-c" data-language="c"><code class="language-c">--&gt; 标志(属性块) 常用特征值对照表：&lt;--[值:00000020h](*包含可执行代码)[值:00000040h](*该块包含已初始化的数据)[值:00000080h](*该块包含未初始化的数据)[值:00000200h][Section contains comments or some other type of information.][值:00000800h][Section contents will not become part of image.][值:00001000h][Section contents comdat.][值:00004000h][Reset speculative exceptions handling bits in the TLB entries for this section.][值:00008000h][Section content can be accessed relative to GP.][值:00500000h][Default alignment if no others are specified.][值:01000000h][Section contains extended relocations.][值:02000000h][Section can be discarded.][值:04000000h][Section is not cachable.][值:08000000h][Section is not pageable.][值:10000000h](*该块为共享块).[值:20000000h](*该块可执行)[值:40000000h](*该块可读)[值:80000000h](*该块可写)</code></pre><h1 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h1><p>拉伸完之后还需要进行一些准备步骤</p><p>先把文件对齐后的数据拷贝到内存中，根据SizeofHeades，直接copy，因为头和节表是不会变化的，但是节表后面不一定是节区，这是因为文件对齐和内存对齐不同</p><p>循环赋值节的内容，复制到内存的地方由节表信息里面的VirtualAddress决定，PointerToRawData决定了文件复制到内存的起始位置</p><p>复制数据的大小根据SizeofRawData（Misc也可以，但是如果MIsc存在大量未初始化数据，会变得很大，可能将下一节的信息也copy到内存中）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646548848907.png"></p><h2 id="根据内存数据存储的位置查找在文件中的位置"><a href="#根据内存数据存储的位置查找在文件中的位置" class="headerlink" title="根据内存数据存储的位置查找在文件中的位置"></a>根据内存数据存储的位置查找在文件中的位置</h2><p>假设内存开始位置是500000，数据在内存存储位置是501234</p><p>1、确定节</p><p>先确定偏移501234-500000</p><p>根据节的不同偏移（VirtualAddress）</p><p>1234&gt;VirtualAddress</p><p>1234&lt;VirtualAddress+Misc.VirtualSize</p><p>2、计算距离节初始位置的长度</p><p>1234-1000=234h</p><p>3、在文件中寻找</p><p>因为在文件中和在内存中距离节初始位置的长度相同，所以地址为400+234h</p><h1 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h1><p>MessageBoxA-四个参数，执行后会出现弹窗-一般exe都有这个函数-user32.dll里面</p><p>让程序执行我们的代码，需要先找到OEP，修改为call我们函数的地址，然后再jmp回到原程序的OEP</p><p>call=E8+四个字节，jmp=E9+四个字节</p><p>但是这四个字节不是直接的地址，需要进行计算</p><blockquote><p>真正要跳转的地址=E8这条指令的下一行地址（当前指令地址+5，因为call长度是5）+X（X就是E8后边跟着的四个字节）</p></blockquote><p>push=0x6A</p><p>所以我们要加的程序硬编码 = 6A 00  6A 00  6A 00  6A 00  E8 00 00 00 00 E9 00 00 00 00</p><p>我们加入的代码必须加在拉伸后的文件中，也就是内存中的，因为我们计算的地址是拉伸后的地址</p><h2 id="添加代码过程-文件注入"><a href="#添加代码过程-文件注入" class="headerlink" title="添加代码过程-文件注入"></a>添加代码过程-文件注入</h2><p>1、先看代码空白区能不能填充那十八个字节——（SizeofRawData-VirtualSize）</p><p>2、找到添加的地方，假设我们开始是从1000h开始的，而SizeofRawData是1a0000，所以两者相加就是当前节结束的地址，而在1b0000之前为0的部分是代码块的空白部分</p><p>3、开始填充我们的那十八个字节</p><p>4、算地址，要计算内存对齐的地址，而不是文件对齐的，因为我们需要的是运行时的地址（内存对齐和文件对齐不同）</p><p>先找到MessageBoxA在内存中的地址，在OD里面使用命令bp MessageBoxA，按状态栏的B可以找到内存的地址</p><p>5、填充，注意小端序，E8跟着计算后的地址，E9跟着计算后的OEP（ImageBase+EntryPoint）</p><p>6、将原本的EntryOfPoint改为我们填充数据在内存中的地址</p><h1 id="任意代码节空白区添加代码"><a href="#任意代码节空白区添加代码" class="headerlink" title="任意代码节空白区添加代码"></a>任意代码节空白区添加代码</h1><p>从内存转为硬盘文件计算大小-最后一个节的初始位置+最后一个节的大小</p><h1 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h1><p>新增之后，修改NumberOfSections，节表信息，节表后面必须跟着一定长度的00数据（空白区），所以要计算增加之后SizeofHeaders会不会大于PointerOfRawData，并且在新增节最后加上一个节表信息长度的00</p><p>计算内存偏移VirtualAddress（RVA）时，根据上一个节区的VirtualAddress+（SizofRawData/VirtualSize[谁大加谁]）按照内存对齐后的数</p><p>如果编译器在节表中加入一些数据，而我们不能修改，节表又不能断，只能将NT头前移（加入数据之前的），这样再去添加新的节表信息，就不会占用编译器加入的数据</p><p>当DOS到NT头大小不够开辟一个节表的信息，只能扩充最后一个节</p><h1 id="扩大节-合并节-数据目录"><a href="#扩大节-合并节-数据目录" class="headerlink" title="扩大节-合并节-数据目录"></a>扩大节-合并节-数据目录</h1><p>扩大节：在内存中进行扩大，然后再还原回文件中，还原的时候要修改参数</p><p>1、拉伸到内存</p><p>2、分配新空间N=SizeofImage+Ex</p><p>3、将最后一个节的SizeOfRawdata和VirtualSize改为N</p><p>4、修改SizeofImage</p><p>合并节：合并之后节表有空间进行添加节区</p><p>VirtualSize=SizeofImage-VIrtualAddress</p><blockquote><p>数据目录-里面存储各种表的信息</p></blockquote><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646564515662.png"></p><p>下面介绍几种比较重要的</p><h1 id="DLL-动态链接库和静态链接库"><a href="#DLL-动态链接库和静态链接库" class="headerlink" title="DLL-动态链接库和静态链接库"></a>DLL-动态链接库和静态链接库</h1><p>使用的时候都需要include</p><p>程序编译的过程为将.h和.cpp等文件进行预编译，然后进行编译，再进行汇编，最后链接上（.a/.lib/.so/.dll）成为可执行文件</p><p>静态库、动态库区别来自【链接阶段】如何处理库（处理方式不同来区分），链接成可执行程序。分别称为静态链接方式、动态链接方式</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>使用的时候需要include和#pragma comment(lib,”xxx.lib”)</p><p>因为头文件只包含函数声明，函数实现在lib文件中</p><p>即在链接阶段，将源文件用到的库函数与汇编生成的文件.o等合并（即函数被包含在exe文件中）生成可执行文件</p><p>好处：方便程序移植，因为可执行程序与库函数再无关系，放入任何环境当中都可以执行</p><p>缺点：可执行文件太大（因为包含了库函数），每次库文件升级都需要重新编译源文件，每个可执行程序都会合并库函数，存在很大的重复性，占用空间大</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>两个程序应用一个库，目标文件在内存中只有一份，供所有程序使用，但是可移植性太差，如果两台电脑运行环境不同，动态库存放位置不同，可能会导致程序运行失败</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>1、将dll，lib文件添加到调用文件中</p><p>2、将#pragma comment(lib,”xxx.lib”)添加到调用文件中</p><p>3、加入函数的声明</p><p>extern “C” _declspec(dllimport) _stdcall int Plus(int x,int y);</p><p>导出则为dllexport，dll导出和导入的方式必须一致，即导出的时候使用了_stdcall，导入的时候也应该是__stdcall</p><p>这样的话如果需要修改函数，只需要在dll文件修改即可，程序不用编译</p><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>1、定义函数指针</p><p>typedef int (__stdcall *lpPlus)(int,int);</p><p>2、声明函数指针变量</p><p>lpPlus myPlus</p><p>3、动态加载dll到内存中</p><p>HINSTANCE hModule=LoadLibrary(“DllDemo.dll”);</p><p>4、获取函数地址</p><p>myPlus=(lpPlus)GetProcAddress(hModule,”_Plus@8”);(__stdcall为了区分会自动加符号)，如果导入的时候没加stdcall就不需要加符号，即myPlus=(lpPlus)GetProcAddress(hModule,”Plus”);</p><p>5、调用函数</p><p>int a=myPlus(1,2);</p><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>Handle是代表系统内核的对象，如文件句柄、线程句柄、进程句柄</p><p>HMODULE代表应用程序载入的模块-在内存中拉伸的起始位置</p><p>HINSTANCE在win32是和前一个一样的 win16遗留</p><p>HWND是窗口句柄</p><blockquote><p>上面的都是无符号整数，四个字节</p></blockquote><p>这样做是为了方便区分，操作系统给的</p><h3 id="def文件导出"><a href="#def文件导出" class="headerlink" title="def文件导出"></a>def文件导出</h3><p>为了隐藏函数的名字</p><p>和前面的类似，先创建动态链接库，头文件只需要函数声明</p><p>创建def文件后，在def文件中写入</p><blockquote><p>EXPORTS</p><p>(函数名)                编号</p><p>Plus                    @12——导出序号是12</p><p>在编号后面+NONAME 可以隐藏函数名</p></blockquote><h2 id="dll导出函数的方式"><a href="#dll导出函数的方式" class="headerlink" title="dll导出函数的方式"></a>dll导出函数的方式</h2><p>extern表示是个全局函数，可以供各个其他的函数调用</p><p>声明导出：_declspec(dllexport)</p><p>def文件导出</p><p>dll函数调用</p><p>隐式链接</p><p>包含头文件，载入lib库</p><p>显式链接</p><p>LoadLibary，GetProAddress</p><h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><p>作用：记载我们写的dll或者exe导出的函数</p><h2 id="导出表重要成员"><a href="#导出表重要成员" class="headerlink" title="导出表重要成员"></a>导出表重要成员</h2><p>1、指向导出表文件名的字符串-DWORD Name</p><p>2、导出函数的起始序号-DWORD Base</p><p>3、导出函数地址表RVA-DWORD AddressOfFunctions</p><p>4、函数名称地址表RVA-DWORD AddressOfNames</p><p>5、函数序号地址表RVA-DWORD AddressOfNameOrdinals</p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>1、找出导出表RVA的偏移</p><p>首先我们要在数据目录的导出表信息的第一项，也就是导出表地址的RVA偏移是多少</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621065982.png"></p><p>可以看出c000h是RVA偏移，大小是164个字节</p><h3 id="判断属于哪一个节"><a href="#判断属于哪一个节" class="headerlink" title="判断属于哪一个节"></a>判断属于哪一个节</h3><p>根据节区的VIrtualAddress判断</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621026524.png"></p><p>所以可以知道在.edata节</p><h3 id="算出FOA位置"><a href="#算出FOA位置" class="headerlink" title="算出FOA位置"></a>算出FOA位置</h3><p>我们知道是在.rdata节的，可以算出FOA</p><p>FOA=RVA-节区的VA（VirtualAddress）+节.PointerOfRawData</p><p>计算发现为8200h</p><h3 id="通过FOA找到导出表位置"><a href="#通过FOA找到导出表位置" class="headerlink" title="通过FOA找到导出表位置"></a>通过FOA找到导出表位置</h3><p>找到后根据前面的导出表大小可以知道导出表的范围</p><p>跳转过去即可</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621157564.png"></p><h2 id="导出表的存储方式"><a href="#导出表的存储方式" class="headerlink" title="导出表的存储方式"></a>导出表的存储方式</h2><p>一个导出表大小为0x28个字节，也就是两行半</p><p>分段讲解</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621661598.png"></p><p>前面十二个字节没用，就不讲了</p><h3 id="Dword-Name"><a href="#Dword-Name" class="headerlink" title="Dword Name"></a>Dword Name</h3><p>绿框的4个字节存储的是dll名称的RVA，想查看的话，可以计算FOA，和前面一样的，得到8250地址存储的是我们的dll名称，以00结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621843130.png"></p><h3 id="Dword-Base"><a href="#Dword-Base" class="headerlink" title="Dword Base"></a>Dword Base</h3><p>导出函数的起始序号</p><p> DLL导出的函数如果给序号了，那么就从这个序号开始</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622459296.png"></p><h3 id="Dword-NumberOfFunctions-所有的导出函数的个数"><a href="#Dword-NumberOfFunctions-所有的导出函数的个数" class="headerlink" title="Dword NumberOfFunctions-所有的导出函数的个数"></a>Dword NumberOfFunctions-所有的导出函数的个数</h3><p>前四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622410901.png"></p><h3 id="DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数"><a href="#DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数" class="headerlink" title="DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数"></a>DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数</h3><p>可以将两个不同的名字指向相同的地址</p><p>有一些是无名函数不会在里面</p><p>后四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622415877.png"></p><p>下面就是子表了，三个子表都是RVA，要转为FOA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622483098.png"></p><p>分别是函数地址表0x8228，函数名称表0x8238，函数序号表0x8248</p><blockquote><p>先去找函数名称表，根据名称的下标再去序号表找对应，然后再去函数地址表找</p></blockquote><h4 id="函数地址表-AddressOfFunctions"><a href="#函数地址表-AddressOfFunctions" class="headerlink" title="函数地址表-AddressOfFunctions"></a>函数地址表-AddressOfFunctions</h4><p>函数地址表指向一个偏移，这个偏移存放了所有导出函数的地址，每个地址占四个字节，存放的是RVA地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622927186.png"></p><p>ImageBase+函数偏移就是函数在内存中的实际地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646623978690.png"></p><p>可以看到这就是函数</p><p> 还需要注意的就是，如果你按照序号导出1 3 4 5这4个函数，在导入表中我们的函数地址表中的地址会有5个，原因就是：中断的序号会给我们用0填充，２虽然没有，但是也会给我们导出. </p><h4 id="函数名称表-AddressOfNames"><a href="#函数名称表-AddressOfNames" class="headerlink" title="函数名称表-AddressOfNames"></a>函数名称表-AddressOfNames</h4><p>函数名称表也是存储名称的RVA，四个字节存储一个，RVA的个数由以函数名称导出函数个数来决定（DWORD  NumberOfNames）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625166524.png"></p><p>转为FOA就是0x805e，0x8071,0x8082,0x8093</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625255683.png"></p><p>排序的时候是按照字母顺序排列的，而不是按照导出时函数的顺序进行排序的</p><p>例如:</p><p>　　EXPORT</p><p>　　　　SUB</p><p>　　　　ADD</p><p>　　　　MUL</p><p>导出三个函数，那么第一项就为 ADD，因为按照字母排序，A在前边，后面依次类推，所以我们上面看到的函数名称 ACquireSRW 这个函数名称，并不是第一个导出的函数.</p><h4 id="函数序号表-AddressOfNumberOrdinals－存储的是RVA"><a href="#函数序号表-AddressOfNumberOrdinals－存储的是RVA" class="headerlink" title="函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ"></a>函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ</h4><p>给名称用的中转表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625803927.png"></p><p>和函数名称表大小相同</p><h4 id="按名称导出"><a href="#按名称导出" class="headerlink" title="按名称导出"></a>按名称导出</h4><p>得到函数名称后去AddressOfNames中的函数名称对比，得到索引后根据索引取出AddressOfNameOrdinals存储的值，以此为索引去函数地址表找到函数的地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647329750554.png" alt="按名称导出过程"></p><p>函数数量计算方式=最大序号-最小序号+1，（连续的算得准）不连续的话在函数地址表会留有多余的地址，但是多余的地址没有被使用</p><h4 id="按序号导出"><a href="#按序号导出" class="headerlink" title="按序号导出"></a>按序号导出</h4><blockquote><p>当使用序号导出的时候不需要使用序号表，直接将序号-Base作为索引去函数地址表找即可</p></blockquote><h4 id="导出的过程"><a href="#导出的过程" class="headerlink" title="导出的过程"></a>导出的过程</h4><p>系统和我们前面说的不一样</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724098510.png" alt="1"></p><p>根据函数地址表找，如果索引在序号表中，说明是按名字导出的，再去名称表找对应，索引和序号表中的相同</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724264502.png"></p><p>这里的100a索引是3，在序号表中没有，所以不是按照序号导出的，序号可算，为索引+Base=005</p><h1 id="重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable"><a href="#重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable" class="headerlink" title="重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable"></a>重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable</h1><h2 id="程序的加载过程"><a href="#程序的加载过程" class="headerlink" title="程序的加载过程"></a>程序的加载过程</h2><p>系统加载的dll一般在高空间运行，一般是71**************</p><p>先像贴图一样把dll贴在内存中，最后指向exe文件的入口点，exe开始运行</p><p>我们自己写的dll的imageBase都是1000000，所以当多个dll同时使用，会存在地址已经被占用的问题，所以dl只能往后放，但是：</p><p>编译器生成的地址=ImageBase+RVA，这个地址在程序编译完成后，已经写入文件了。但是如果当程序加载时没有按照原来的ImageBase载入，但是此时程序还是会按照前面生成的地址进行使用</p><p>所以一般exe不存在重定位表，而dll一般都有，用于记录需要修改的地方</p><h2 id="重定位表解析"><a href="#重定位表解析" class="headerlink" title="重定位表解析"></a>重定位表解析</h2><p>重定位表是分块，根据RVA计算得到FOA，跳转过去发现有几个重定位表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727831045.png"></p><p>这两个数据分别存储RVA和大小</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727910599.png"></p><p>下面的数据中，每两个字节代表这一段有多少个数据需要修复，一般是绝对地址需要修改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646728080337.png"></p><p>只需要基础地址加上小表的值就可以定位到需要修改的地方，而不用四个字节来存储地址，节省了空间，而这个基础地址就是前面记录的RVA</p><p>而基础地址可以不同，所以才需要分块操作</p><p>可以发现每一块的间隔是1000h，也就是内存对齐的大小</p><p>一个页是1000h，所以只需要1000个十六进制的地址就可以记录完一页的每个位置，对应十进制的4096个</p><p>2^12=4096，所以只需要十二个二进制位就可以表示完所有可能，两个字节有十六位，所以最后找地址的时候，只用取低十二位，高四位有别的用处-如果高四位的值是3就说明这个地方需要修改</p><h3 id="判断块数"><a href="#判断块数" class="headerlink" title="判断块数"></a>判断块数</h3><p>下一块的开始地址都可以通过RVA+SizeOfBlock来得到</p><p>直到遇到全为零的块</p><p>计算需要修改的数据个数：(SizeOfBlock-8)/2，因为前面两个数据是8个字节，剩下的两个字节为1组</p><h1 id="移动导出表-重定位表"><a href="#移动导出表-重定位表" class="headerlink" title="移动导出表-重定位表"></a>移动导出表-重定位表</h1><p>表的数据也在节区中，加密代码时，表的信息也会被加密，这样程序无法初始化，所以要先增节，再移动表，学会移动各种表是对程序加密和破解的基础</p><h2 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h2><p>比较繁琐，因为要移动多张表</p><h3 id="在DLL文件中新增节"><a href="#在DLL文件中新增节" class="headerlink" title="在DLL文件中新增节"></a>在DLL文件中新增节</h3><p>先计算大小</p><p>并且返回新增节的FOA，因为后面的数据还要从新增节的开头开始</p><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>需要复制的数据类型和长度</p><h4 id="复制AddressOfFunctions"><a href="#复制AddressOfFunctions" class="headerlink" title="复制AddressOfFunctions"></a>复制AddressOfFunctions</h4><p>长度：4×NumberOfFunctions</p><h4 id="复制AddressOfNameOrdinals"><a href="#复制AddressOfNameOrdinals" class="headerlink" title="复制AddressOfNameOrdinals"></a>复制AddressOfNameOrdinals</h4><p>长度：2×NumberOfNames</p><h4 id="复制AddressOfNames"><a href="#复制AddressOfNames" class="headerlink" title="复制AddressOfNames"></a>复制AddressOfNames</h4><p>长度：4×NumberOfNames</p><h4 id="复制所有函数名"><a href="#复制所有函数名" class="headerlink" title="复制所有函数名"></a>复制所有函数名</h4><p>长度不确定，复制时直接修复AddressOfName（因为名字的地址也改变了），每复制完一个名字，都需要计算下一个复制的地方</p><h4 id="复制导出表的整体结构"><a href="#复制导出表的整体结构" class="headerlink" title="复制导出表的整体结构"></a>复制导出表的整体结构</h4><h3 id="修复地址"><a href="#修复地址" class="headerlink" title="修复地址"></a>修复地址</h3><p>AddressOfName</p><p>目录项指向新的导出表的位置</p><p>函数地址表、序号表、名称表都需要修复</p><h3 id="将目录项中的RVA修正"><a href="#将目录项中的RVA修正" class="headerlink" title="将目录项中的RVA修正"></a>将目录项中的RVA修正</h3><p>指向我们新的导出表的位置</p><h2 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h2><p>直接复制过去，修改RVA即可</p><p>加载程序：（当前面已经有DLL被加载）</p><p>1、将新的DLL复制到新的位置</p><p>2、修复重定位表，修改每一个重定位表的偏移</p><h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>作用：从其他第三方程序导入API，以供本程序调用</p><p>在exe运行的时候加载器会遍历导入表，将导入表中所有dll加载到进程中，被加载的DLL的DLLMain就会被调用</p><p>通过导入表可以知道程序使用了哪些函数</p><p> 导入表，是为了提供的要导入的dll的函数的地址，只不过由于dll地址不固定，所以每次都会重新修正 </p><h2 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h2><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><pre class="language-c" data-language="c"><code class="language-c">DWORD OriginalFirstThunk;</code></pre><p>指向导入名称表（INT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   FirstThunk;</code></pre><p>指向导入地址表（IAT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   Name;</code></pre><p>指向导入映像文件的名字</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788456499.png"></p><p>计算后跳转过去，注意要算的是FOA，但是这里RVA和FOA一样 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788490238.png"></p><p>其中IAT与INT都指向 IMAGE_THUNK_DATA32（虽然二者的地址不同）</p><p>INT-以全0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788999608.png">          函数名数组(对应IMAGE_THUNK_DATA32结构体数组,每一个结构体就是一个联合体-4字节) </p><pre class="language-c" data-language="c"><code class="language-c">typedef struct  _IMAGE_THUNK_DATA32{union{//联合体，实际是4字节DWORD ForwarderString;DWORD Function;//导入函数的地址,在加载到内存之后,这里才起作用DWORD Ordinal;//假如是序号导入的,会用到这里DWORD AddressOfData;//假如是函数名导入,会用到这里,它指向另外一个结构体PIMAGE_IMPORT_BY_NAME}u1;}IMAGE_THUNK_DATA32;//如果是函数名导入的,AddressOfData会指向下面这个结构体typedef struct _IMAGE_IMPORT_BY_NAME{WORD  Hint;//序号CHAR Name[1];//不定长,字符串}</code></pre><h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><p>在可选PE头最后的十六个数组的导入表结构，这里存放的是RVA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646998855451.png"></p><p>跳转过去发现存储的是struct IMAGE_IMPORT_DESCRIPTOR ImportDescriptor[0]，这里存放的是真正的导入表结构</p><p>有多少个DLL，对应的结构体数组就有几个</p><p>关键的数据有下面三个，也要注意这里的TimeDateStamp-时间戳</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999149540.png"></p><h3 id="INT表"><a href="#INT表" class="headerlink" title="INT表"></a>INT表</h3><p><em><strong>ULONG OriginalFirstThunk-RVA</strong></em>，存放的是IMAGE_THUNK_DATA这个结构体数组，四字节数，以0结尾</p><p>跳转过去</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999423139.png"></p><p> 但是之前学导出表有了解到，导出函数可以以名字导出，亦可以序号导出。所以为了方便区分，就将这INT表的每个值做了细微调整。</p><blockquote><p> 如果这个4字节数的最高位（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。 </p></blockquote><p>根据INT存储的RVA进行跳转</p><h4 id="struct-IMAGE-IMPORT-BY-NAME"><a href="#struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="struct _IMAGE_IMPORT_BY_NAME"></a>struct _IMAGE_IMPORT_BY_NAME</h4><p>1、WORD Hint，可能为0，编译器决定，如果不为0，则是函数在导出表中的索引</p><p>2、BYTE Name[1]，函数名称，以0结尾</p><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>DLL的名字，以0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999638790.png"></p><h3 id="ULONG-FirstThunk"><a href="#ULONG-FirstThunk" class="headerlink" title="ULONG FirstThunk"></a>ULONG FirstThunk</h3><p>根据RVA跳转，发现存储的值和INT的一样，这个存储的是IAT，当文件加载后，会发现IAT会改变</p><h4 id="IAT表-导入地址表"><a href="#IAT表-导入地址表" class="headerlink" title="IAT表-导入地址表"></a>IAT表-导入地址表</h4><p> 记录程序正在使用哪些库中的哪些函数 </p><p>分为两个过程，在文件中存储的是存放函数的地址，在内存中存放函数</p><p>在文件运行前类似于call [地址]</p><p>在文件运行时类似于call [上面地址存放的值]</p><h4 id="IAT表存在的原因"><a href="#IAT表存在的原因" class="headerlink" title="IAT表存在的原因"></a>IAT表存在的原因</h4><p> 一般程序在调用自身函数的时候，自身函数地址RAV是固定的；但是当程序在调用dll里的函数的时候，由于dll的地址会发生重定位，导致dll里的函数地址每次都会发生变化。 </p><p>为了准确调用dll函数的地址，构造了IAT表来存储程序运行时，即DLL文件重定位之后的dll函数的位置</p><h2 id="导入表加载过程"><a href="#导入表加载过程" class="headerlink" title="导入表加载过程"></a>导入表加载过程</h2><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAzMjg0Ni5wbmc-1647000237348.png" alt="PE文件加载前"></p><p>加载过程</p><p>先找ＤＬＬ，再确定使用的函数</p><h3 id="寻找DLL"><a href="#寻找DLL" class="headerlink" title="寻找DLL"></a>寻找DLL</h3><p>先根据导入表的NAME找到DLL名称和DLL的INT和IAT表，开始的时候INT和IAT数据相同，但是存储位置不同</p><h3 id="查INT表"><a href="#查INT表" class="headerlink" title="查ＩＮＴ表"></a>查ＩＮＴ表</h3><p>因为导出的时候可以按序号导出也可以按函数名称导出，所以为了区分，ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ最高位为１时，表示其存储的是序号，而剩下的３１位表示序号，否则ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ存储的是函数名称的ＲＶＡ</p><h3 id="修改IAT"><a href="#修改IAT" class="headerlink" title="修改ＩＡＴ"></a>修改ＩＡＴ</h3><p>使用ＧＥＴＰｒｏＡｄｄｒ（ｍｏｄｕｌｅ，）</p><p>将前面查找到的函数地址填充进ＩＡＴ表中</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAyNTEwMy5wbmc.png" alt="PE文件加载后"> </p><p>可以看到IAT表变成了函数的地址</p><p> IAT表会存储dll的函数的地址，方便调用该函数时，直接取IAT表这个地址内的值，作为函数地址，去CALL。</p><h1 id="绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR"><a href="#绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR" class="headerlink" title="绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR"></a>绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR</h1><p>可选NT头里的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647001593786.png"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 有些windows程序，如notepad，为了提高加载速度，会直接把DLL中的函数地址写入到IAT表，省去了加载时的计算。 </p><h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p> 第一，当DLL没有占住ImageBase时，IAT中的地址就是错的；第二，当链接的DLL被修改了，那IAT里写的地址也是错的。遇到这两种情形之一，加载时就必须修复IAT了。 </p><p>对于第二种情形，DLL是否被修改，是根据比较DLL的时间戳和绑定导入表中的记录的DLL时间戳来判断的，如果不一致，说明DLL被修改了。</p><p>加载程序时，操作系统根据导入表中的时间戳来判断程序是否使用了绑定导入。当时间戳为0，表示不使用绑定导入表；当时间戳为0xFFFFFFFF，说明该程序使用绑定导入。</p><h2 id="绑定导入表结构"><a href="#绑定导入表结构" class="headerlink" title="绑定导入表结构"></a>绑定导入表结构</h2><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    NumberOfModuleForwarderRefs;// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></pre><p> TimeDateStamp 是时间戳，用于和DLL中的时间戳比较，判断DLL是否已经发生变化； </p><p> OffsetModuleName 是当前模块名距离第一个 _IMAGE_BOUND_IMPORT_DESCRIPTOR 的偏移。</p><p>  NumberOfModuleForwarderRefs 是该模块依赖的模块数量； </p><h3 id="依赖模块结构"><a href="#依赖模块结构" class="headerlink" title="依赖模块结构"></a>依赖模块结构</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_FORWARDER_REF {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    Reserved;} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;</code></pre><p> 除了第三个属性保留，其他与 _IMAGE_BOUND_IMPORT_DESCRIPTOR 相同。 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647049008006.png" alt="绑定导入表"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PE文件&quot;&gt;&lt;a href=&quot;#PE文件&quot; class=&quot;headerlink&quot; title=&quot;PE文件&quot;&gt;&lt;/a&gt;PE文件&lt;/h1&gt;&lt;p&gt;主要有exe、dll、sys文件，这些都是可执行文件&lt;/p&gt;
&lt;p&gt;exe由多个exe文件组成，dll之类的&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>hgame2022-WOW-patch数据段</title>
    <link href="https://gift1a.github.io/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/"/>
    <id>https://gift1a.github.io/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/</id>
    <published>2022-02-22T11:57:59.000Z</published>
    <updated>2022-03-11T05:10:53.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531507324.png"></p><p>可以看到上面这一段是输入并且把加密后的输入赋值给Buf2，在这之后已经结束了判断，所以下面红色框的代码应该是解密代码，只需要把Buf在栈中进行修改为final字符串即可</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531624170.png"></p><p>这里点过去发现并没有数据，这可能是一些数据没有反编译出来，但是在图中蓝色部分可以看到地址是ebp-54</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531725452.png">计算一下，在堆栈窗口按g进行跳转</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531744867.png"></p><p>跳转之后</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531761124.png"></p><p>然后右键Edit，或者按快捷键F2，然后进行修改，注意大小端序的问题，这里使用lazyida选择DWORD导出来就很方便，再次右键，应用修改</p><p>然后运行即可，就可以在input看到flag了</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531871154.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1</summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>hgame-misc</title>
    <link href="https://gift1a.github.io/2022/02/19/hgame-misc/"/>
    <id>https://gift1a.github.io/2022/02/19/hgame-misc/</id>
    <published>2022-02-18T19:05:16.000Z</published>
    <updated>2022-03-11T05:11:08.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总算是结束了，下面就记录一下misc遇到的一些题目</p><h1 id="这个压缩包有点麻烦"><a href="#这个压缩包有点麻烦" class="headerlink" title="这个压缩包有点麻烦"></a>这个压缩包有点麻烦</h1><h2 id="相关知识-压缩包"><a href="#相关知识-压缩包" class="headerlink" title="相关知识-压缩包"></a>相关知识-压缩包</h2><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p><img src="/2022/02/19/hgame-misc/1645212044252.png"></p><p>可以看到在zip给出了密码的提示，六位纯数字，Advanced Archive Password Recovery爆破</p><p><img src="/2022/02/19/hgame-misc/1645212152522.png"></p><p><img src="/2022/02/19/hgame-misc/1645212207157.png"></p><p>根据提示，给出的应该是字典，我们同样在爆破软件中选择字典</p><p><img src="/2022/02/19/hgame-misc/1645212320305.png"></p><p>继续下一步</p><p><img src="/2022/02/19/hgame-misc/1645212429206.png"></p><p>他让我们重新储存，把readme文件选择以存储的方式压缩发现</p><p><img src="/2022/02/19/hgame-misc/1645212573216.png"></p><p>这两个的CRC32的值是一样的，但是我们知道CRC32的值只有一个，所以使用明文攻击，这里4.5没跑出来，4.0跑出来了</p><p>在jpg文件尾部发现了zip，另存一下，是伪加密</p><p><img src="/2022/02/19/hgame-misc/1645213950846.png"></p><p>修复后得到flag</p><p><img src="/2022/02/19/hgame-misc/1645214098403.png"></p><h1 id="你上当了-我的很大"><a href="#你上当了-我的很大" class="headerlink" title="你上当了 我的很大"></a>你上当了 我的很大</h1><h2 id="相关知识-二维码"><a href="#相关知识-二维码" class="headerlink" title="相关知识-二维码"></a>相关知识-二维码</h2><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p>解压之后得到很多的视频，但都是重复的，有用的就几个，主要记录一下各种二维码的样子，以免之后认不出来</p><p><a href="https://barcode.tec-it.com/zh/CodablockF">https://barcode.tec-it.com/zh/CodablockF</a></p><p>这个网站可以生成不同的二维码，便于识别</p><p><a href="https://products.aspose.app/barcode/recognize#">https://products.aspose.app/barcode/recognize#</a></p><p>这个网站识别比较全</p><p><img src="/2022/02/19/hgame-misc/1645213399267.png"></p><p><img src="/2022/02/19/hgame-misc/1645213453036.png"></p><p><img src="/2022/02/19/hgame-misc/1645213467874.png"></p><h1 id="谁不喜欢猫猫呢"><a href="#谁不喜欢猫猫呢" class="headerlink" title="谁不喜欢猫猫呢"></a>谁不喜欢猫猫呢</h1><p><a href="https://blog.csdn.net/mochu7777777/article/details/122631962-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E8%84%9A%E6%9C%AC%E4%B8%8D%E4%BC%9A%E5%86%99">https://blog.csdn.net/mochu7777777/article/details/122631962-可以看看，脚本不会写</a></p><h1 id="摆烂"><a href="#摆烂" class="headerlink" title="摆烂"></a>摆烂</h1><h2 id="相关知识-盲水印、APng、零宽隐写"><a href="#相关知识-盲水印、APng、零宽隐写" class="headerlink" title="相关知识-盲水印、APng、零宽隐写"></a>相关知识-盲水印、APng、零宽隐写</h2><h2 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h2><p>foremost分离压缩包得到png文件，也可以复制文件信息之后另存为，将png拖进010发现奇怪的地方</p><p><img src="/2022/02/19/hgame-misc/1645214249445.png"></p><p>正常的png文件是没有fdAT数据段的 APng-<a href="https://www.jianshu.com/p/5333bcc20ba7">https://www.jianshu.com/p/5333bcc20ba7</a></p><p>查阅资料发现是Apng，这里介绍一个分解Apng的网址</p><p><a href="https://ezgif.com/split">https://ezgif.com/split</a></p><p>得到两张一模一样的图片，这时候就想到了盲水印</p><p><img src="/2022/02/19/hgame-misc/1645214469303.png"></p><p>得到带有密码的图片</p><p><img src="/2022/02/19/hgame-misc/1645214585213.png"></p><p>得到密钥解压压缩包，拼接二维码，扫码得到</p><p><img src="/2022/02/19/hgame-misc/1645214612749.png"></p><p>发现很多问号，应该就是零宽了，这里我手机扫码后的信息再拿去解密-<a href="https://330k.github.io/misc_tools/unicode_steganography.html">https://330k.github.io/misc_tools/unicode_steganography.html</a></p><p><img src="/2022/02/19/hgame-misc/1645214720413.png"></p><h1 id="At0m的给你们的-迟到的-情人节礼物"><a href="#At0m的给你们的-迟到的-情人节礼物" class="headerlink" title="At0m的给你们的(迟到的)情人节礼物"></a>At0m的给你们的(迟到的)情人节礼物</h1><h2 id="相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具"><a href="#相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具" class="headerlink" title="相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具"></a>相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具</h2><h2 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h2><p>一般数据流隐写都采取winrar，所以要关注rar文件</p><p>这里解压之后时候NTFS工具得到</p><p><img src="/2022/02/19/hgame-misc/1645214827597.png"></p><p>四个方向对应四进制，解码的到 6557225 </p><p>还有一个avi文件，一般是MSU StegoVideo工具</p><p>下载好之后选择好avi文件，并且指定写入的文本 ，输入密码即可</p><p>hgame{Q1ng_R3n_J1e_Da_Sh4_CTF}                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;总算是结束了，下面就记录一下misc遇到的一些题目&lt;/p&gt;
&lt;h1 id=&quot;这个压缩包有点麻烦&quot;&gt;&lt;a href=&quot;#这个压缩包有点麻烦&quot; </summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>pyc加花指令</title>
    <link href="https://gift1a.github.io/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <id>https://gift1a.github.io/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/</id>
    <published>2022-02-14T12:10:12.000Z</published>
    <updated>2022-03-11T05:12:19.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VNCTF2022-BabyMaze"><a href="#VNCTF2022-BabyMaze" class="headerlink" title="VNCTF2022-BabyMaze"></a>VNCTF2022-BabyMaze</h1><p>pyc相关知识-<a href="https://zhuanlan.zhihu.com/p/145811103">https://zhuanlan.zhihu.com/p/145811103</a></p><p>使用uncompyle6发现无法反编译，应该是添加了花指令</p><p>先查看字节码</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import marshal, disf = open("D:\\new\\AD\\game\\vnctf2022\\re\\BabyMaze.pyc", "rb").read()code = marshal.loads(f[16:]) #这边从16位开始取因为是python3 python2从8位开始取dis.dis(code)</code></pre><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848858641.png"></p><p>发现这一段就是花指令</p><p>去python的包里面搜索opcode.h，找到对应的字节码</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848986760.png"></p><p>转为十六进制后去010editor修改，去掉即可</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849226023.png"></p><p>但是发现还是不行，这是因为</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849421077.png"></p><p>pyc文件有co_code，所以修改长度之后要修改它</p><p>先打印出来长度，然后计算后修改</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849766935.png"></p><p>2030-6=7E8</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849849453.png"></p><p>重新uncompyle6</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849958666.png"></p><p>反编译成功，接下来就是maze图，打印出来之后手打</p><h1 id="Pyc字节码阅读-unctf2021-pytrade"><a href="#Pyc字节码阅读-unctf2021-pytrade" class="headerlink" title="Pyc字节码阅读-unctf2021-pytrade"></a>Pyc字节码阅读-unctf2021-pytrade</h1><p>得到两个txt文件，一个是py的字节码，一个是输出</p><p>对字节码进行分析</p><p><a href="https://www.jianshu.com/p/557cfe36f0f0">https://www.jianshu.com/p/557cfe36f0f0</a></p><p><a href="https://bbs.pediy.com/thread-246683.htm">https://bbs.pediy.com/thread-246683.htm</a></p><p><a href="https://docs.python.org/zh-cn/3/library/dis.html">https://docs.python.org/zh-cn/3/library/dis.html</a>  这是python3的</p><pre class="language-python" data-language="python"><code class="language-python">0 LOAD_CONST               1 ('XXXXXX')       //This is flag,try to figure it out ! Don't forget to fill it in flag{} !             2 STORE_FAST               0 (flag)</code></pre><p>LOAD_CONST加载const变量，比如数值、字符串等，一般用于传给函数参数</p><p>STORE_FAST 一般用于保存值到局部变量</p><p>这句话意思是</p><pre class="language-none"><code class="language-none">flag='XXXXXXXX'</code></pre><p>第二段</p><pre class="language-python" data-language="python"><code class="language-python">4 LOAD_CONST               2 (0) const变量，一般用于传给函数的参数             6 BUILD_LIST               1  创建列表             8 LOAD_CONST               3 (18)   const变量  num=[0]*18            10 BINARY_MULTIPLY                12 STORE_FAST               1 (num) 保存值到局部变量中</code></pre><p>BINARY_MULTIPLY 是二元运算，即将栈顶的前两个元素取出进行计算，结果压回栈中 </p><p>BUILD_LIST 创建列表</p><pre class="language-none"><code class="language-none">num=[0]*18</code></pre><p>第三段</p><pre class="language-python" data-language="python"><code class="language-python">14 LOAD_CONST               2 (0)             16 STORE_FAST               2 (k)</code></pre><pre class="language-python" data-language="python"><code class="language-python">k=0</code></pre><p>第四段</p><pre class="language-python" data-language="python"><code class="language-python">18 LOAD_GLOBAL              0 (range) 加载全局变量             20 LOAD_GLOBAL              1 (len)              22 LOAD_FAST                0 (flag)              24 CALL_FUNCTION            1调用一个函数，在此之前要先赋值 len(flag)             26 CALL_FUNCTION            1  range(len(flag))             28 GET_ITER取迭代器        &gt;&gt;   30 FOR_ITER               112 (to 144)  一直到144都是for循环             32 STORE_FAST               3 (i) </code></pre><p> LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。当和函数搭配时，要注意有CALL_FUNCTION</p><p>LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。这里调用完len之后，要使用其传值，这里传入flag</p><p>前半段意思是</p><pre class="language-python" data-language="python"><code class="language-python">range(len(flag))</code></pre><p>GET_ITER创建迭代器，一般是for循环</p><p>FOR_ITER(to 144)表示迭代器一直到144</p><p>STORE_FAST 创建局部变量，这里作为for循环的索引</p><pre class="language-python" data-language="python"><code class="language-python">for i in range(len(flag)):</code></pre><p>第五段</p><pre class="language-python" data-language="python"><code class="language-python">7          34 LOAD_GLOBAL              2 (ord)             36 LOAD_FAST                0 (flag)            38 LOAD_FAST                3 (i)            40 BINARY_SUBSCR索引运算            42 CALL_FUNCTION            1ord(flag[i])            44 LOAD_FAST                3 (i)            46 BINARY_ADD+i            48 LOAD_FAST                2 (k)            50 LOAD_CONST               4 (3)            52 BINARY_MODULO//取模运算 k%3            54 LOAD_CONST               5 (1)             56 BINARY_ADD(k%3)+1            58 BINARY_XOR(ord(flag[i])+i)^(k%3+1)            60 LOAD_FAST                1 (num)            62 LOAD_FAST                3 (i)            64 STORE_SUBSCR num[i]</code></pre><p>BINARY_SUBSCR下标 访问操作</p><p>BINARY_ADD也是二元运算，相加</p><p>BINARY_MODULO，二元运算取模</p><p>BINARY_XOR二元运算异或</p><p>STORE_SUBSCR下标访问操作</p><pre class="language-python" data-language="python"><code class="language-python">num[i]= (ord(flag[i]) + i) ^ (k % 3 + 1)</code></pre><p>第六段</p><pre class="language-python" data-language="python"><code class="language-python">8          66 LOAD_GLOBAL              2 (ord)             68 LOAD_FAST                0 (flag)             70 LOAD_GLOBAL              1 (len)             72 LOAD_FAST                0 (flag)             74 CALL_FUNCTION            1len(flag)             76 LOAD_FAST                3 (i)len(flag)-i             78 BINARY_SUBTRACT             80 LOAD_CONST               5 (1)             82 BINARY_SUBTRACT减法len(flag)-i-1             84 BINARY_SUBSCR索引运算flag[len(flag)-i-1]             86 CALL_FUNCTION            1ord(flag[len(flag)-i-1])             88 LOAD_GLOBAL              1 (len)             90 LOAD_FAST                0 (flag)             92 CALL_FUNCTION            1len(flag)             94 BINARY_ADDord(flag[len(flag)-i-1])+len(flag)-i-1             96 LOAD_FAST                3 (i)             98 BINARY_SUBTRACT            100 LOAD_CONST               5 (1)            102 BINARY_SUBTRACT            104 LOAD_FAST                2 (k)            106 LOAD_CONST               4 (3)            108 BINARY_MODULOk%3            110 LOAD_CONST               5 (1)            112 BINARY_ADDk%3+1            114 BINARY_XORord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)            116 LOAD_FAST                1 (num)            118 LOAD_GLOBAL              1 (len)            120 LOAD_FAST                0 (flag)len(flag)            122 CALL_FUNCTION            1            124 LOAD_FAST                3 (i)            126 BINARY_SUBTRACTlen(flag)-i            128 LOAD_CONST               5 (1)            130 BINARY_SUBTRACTlen(flag)-i-1            132 STORE_SUBSCRnum[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>BINARY_SUBTRACT二元运算减法</p><pre class="language-python" data-language="python"><code class="language-python">num[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>第七段</p><pre class="language-python" data-language="python"><code class="language-python">9         134 LOAD_FAST                2 (k)            136 LOAD_CONST               5 (1)            138 INPLACE_ADDk++            140 STORE_FAST               2 (k)            142 JUMP_ABSOLUTE           30//循环结束</code></pre><p>JUMP_ABSOLUTE绝对跳转，结束循环</p><p>INPLACE_ADD  计算结果可以被操作数引用的到，每一个 二元运算，都对应一个inplace 运算 </p><pre class="language-python" data-language="python"><code class="language-python">k+=1</code></pre><p>第八段</p><pre class="language-python" data-language="python"><code class="language-python">10     &gt;&gt;  144 LOAD_GLOBAL              3 (print)            146 LOAD_FAST                1 (num)            148 CALL_FUNCTION            1 print(num)            150 POP_TOP            152 LOAD_CONST               0 (None)            154 RETURN_VALUE</code></pre><pre class="language-none"><code class="language-none">print(num)</code></pre><h1 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h1><p>python3.9，无法uncompyle6，使用pycdc翻译成字节码</p><pre class="language-python" data-language="python"><code class="language-python">main.pyc (Python 3.9)[Code]    File Name: main.py    Object Name: &lt;module&gt;    Arg Count: 0    Pos Only Arg Count: 0    KW Only Arg Count: 0    Locals: 0    Stack Size: 4    Flags: 0x00000040 (CO_NOFREE)    [Names]        'base64'        'encode'        'enCodeAgain'        'correct'        'flag'        'print'        'input'    [Var Names]    [Free Vars]    [Cell Vars]    [Constants]        0        None        [Code]            File Name: main.py            Object Name: encode            Arg Count: 1            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 4            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'chr'                'base64'                'b64encode'                'encode'            [Var Names]                'message'                's'                'i'                'x'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                32                16                'utf-8' [Disassembly]                0       LOAD_CONST              1: ''                2       STORE_FAST              1: s       s=''                4       LOAD_FAST               0: message                6       GET_ITER                                8       FOR_ITER                32 (to 42) for i in message:                10      STORE_FAST              2: i                   12      LOAD_FAST               2: i                  14      LOAD_CONST              2: 32                16      BINARY_XOR               i^32                18      STORE_FAST              3: xx=i^32                20      LOAD_FAST               3: x                22      LOAD_CONST              3: 16                24      BINARY_ADD              x+16                26      STORE_FAST              3: xx=x+16                28      LOAD_FAST               1: s                30      LOAD_GLOBAL             0: chr                32      LOAD_FAST               3: x                    34      CALL_FUNCTION           1  chr(x)                36      INPLACE_ADD             s+chr(x)                38      STORE_FAST              1: ss=s+chr(x)                40      JUMP_ABSOLUTE           8    循环结束                42      LOAD_GLOBAL             1: base64                44      LOAD_METHOD             2: b64encodebase64.b64                46      LOAD_FAST               1: s                48      LOAD_METHOD             3: encode   LOAD_METHOD是加载类，CALL调用                50      LOAD_CONST              4: 'utf-8'                 52      CALL_METHOD             1                  54      CALL_METHOD             1 base64.b64(s.encode('utf-8'))                56      RETURN_VALUE            return  base64.b64(s.encode('utf-8'))        'encode'        [Code]            File Name: main.py            Object Name: enCodeAgain            Arg Count: 2            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 5            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'str'                'range'                'len'            [Var Names]                'string'                'space'                's'                'i'                'j'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                'utf-8'                0            [Disassembly]                0       LOAD_CONST              1: ''                  2       STORE_FAST              2: ss=''                4       LOAD_GLOBAL             0: str                6       LOAD_FAST               0: string                8       LOAD_CONST              2: 'utf-8'                 10      CALL_FUNCTION           2//参数个数 str(string,'utf-8')                12      STORE_FAST              0: string string=str(string,'utf-8')                14      LOAD_GLOBAL             1: range                 16      LOAD_CONST              3: 0                18      LOAD_FAST               1: space                20      CALL_FUNCTION           2 range(0,space)                22      GET_ITER                //创建迭代器                24      FOR_ITER                50 (to 76)                 26      STORE_FAST              3: ifor i range(0,space):                28      LOAD_GLOBAL             1: range                 30      LOAD_FAST               3: i                32      LOAD_GLOBAL             2: len                34      LOAD_FAST               0: string                36      CALL_FUNCTION           1len(string)                38      LOAD_FAST               1: space                40      CALL_FUNCTION           3                 42      GET_ITER                                44      FOR_ITER                28 (to 74)                46      STORE_FAST              4: j  for j in range(i,len(string),space)                48      LOAD_FAST               4: j                 50      LOAD_GLOBAL             2: len                52      LOAD_FAST               0: string                54      CALL_FUNCTION           1  len(string)                56      COMPARE_OP              0 (&lt;)if(j&lt;len(string))                58      POP_JUMP_IF_FALSE       44跳转                60      LOAD_FAST               2: s                62      LOAD_FAST               0: string                64      LOAD_FAST               4: j                66      BINARY_SUBSCR           string[j]                68      INPLACE_ADD                             70      STORE_FAST              2: s      s+=string[j]                72      JUMP_ABSOLUTE           44第二个循环                74      JUMP_ABSOLUTE           24第一个循环                76      LOAD_FAST               2: s                78      RETURN_VALUE             return s        'enCodeAgain'        'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        ''        'Input flag:'        'utf-8'        2        'correct'        'wrong'    [Disassembly]        0       LOAD_CONST              0: 0        2       LOAD_CONST              1: None        4       IMPORT_NAME             0: base64        6       STORE_NAME              0: base64import base64        8       LOAD_CONST              2: &lt;CODE&gt; encode        10      LOAD_CONST              3: 'encode' //函数        12      MAKE_FUNCTION           0        14      STORE_NAME              1: encode        16      LOAD_CONST              4: &lt;CODE&gt; enCodeAgain        18      LOAD_CONST              5: 'enCodeAgain'        20      MAKE_FUNCTION           0//第二个函数        22      STORE_NAME              2: enCodeAgain        24      LOAD_CONST              6: 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        26      STORE_NAME              3: correctcorrect=VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ=        28      LOAD_CONST              7: ''        30      STORE_NAME              4: flagflag=''        32      LOAD_NAME               5: print        34      LOAD_CONST              8: 'Input flag:'        36      CALL_FUNCTION           1print('Int flag:')        38      POP_TOP                         40      LOAD_NAME               6: input        42      CALL_FUNCTION           0input()        44      STORE_NAME              4: flagflag=input()        46      LOAD_NAME               4: flag        48      LOAD_METHOD             1: encode        50      LOAD_CONST              9: 'utf-8'        52      CALL_METHOD             1        54      STORE_NAME              4: flagflag=flag.encode('utf-8')        56      LOAD_NAME               5: print        58      LOAD_NAME               2: enCodeAgain        60      LOAD_NAME               1: encode        62      LOAD_NAME               4: flag        64      CALL_FUNCTION           1        66      LOAD_CONST              10: 2 其中一个参数        68      CALL_FUNCTION           2//两个参数        70      CALL_FUNCTION           1print(enCodeAgain(encodee(flag),2))        72      POP_TOP                 函数栈顶元素出栈        74      LOAD_NAME               2: enCodeAgain        76      LOAD_NAME               1: encode        78      LOAD_NAME               4: flag        80      CALL_FUNCTION           1        82      LOAD_CONST              10: 2        84      CALL_FUNCTION           2(enCodeAgain(encodee(flag),2))        86      LOAD_NAME               3: correct        88      COMPARE_OP              2 (==)//比较        90      POP_JUMP_IF_FALSE       102跳转        92      LOAD_NAME               5: print        94      LOAD_CONST              11: 'correct'        96      CALL_FUNCTION           1print('correct')        98      POP_TOP                         100     JUMP_FORWARD            8 (to 110)结束        102     LOAD_NAME               5: print        104     LOAD_CONST              12: 'wrong'        106     CALL_FUNCTION           1print('wrong)        108     POP_TOP                         110     LOAD_CONST              1: None        112     RETURN_VALUE            </code></pre><pre class="language-python" data-language="python"><code class="language-python">import base64def encode(message):    s = ''    for i in message:        x = i ^ 32        x += 16        s += chr(x)        return (base64.b64encode(s.encode('utf-8')))def enCodeAgain(string, space):    s = ''    string = str(string, 'utf-8')    for i in range(0, space):        for j in range(i, len(string), space):            if j &lt; len(string):                s += string[j]    return scorrect = 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='flag = ''print('Input flag:')flag = input()flag = flag.encode('utf-8')print(enCodeAgain(encode(flag), 2))if enCodeAgain(encode(flag), 2) == correct:    print(correct)else:    print('wrong')</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VNCTF2022-BabyMaze&quot;&gt;&lt;a href=&quot;#VNCTF2022-BabyMaze&quot; class=&quot;headerlink&quot; title=&quot;VNCTF2022-BabyMaze&quot;&gt;&lt;/a&gt;VNCTF2022-BabyMaze&lt;/h1&gt;&lt;p&gt;pyc相关知</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>hgame2022-week3-re</title>
    <link href="https://gift1a.github.io/2022/02/13/hgame2022-week3-re/"/>
    <id>https://gift1a.github.io/2022/02/13/hgame2022-week3-re/</id>
    <published>2022-02-13T15:49:18.000Z</published>
    <updated>2022-03-11T05:10:40.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是总结和反思吧</p><h1 id="hardened"><a href="#hardened" class="headerlink" title="hardened"></a>hardened</h1><h2 id="考点：加壳、AES-CBC、Base64魔改"><a href="#考点：加壳、AES-CBC、Base64魔改" class="headerlink" title="考点：加壳、AES-CBC、Base64魔改"></a>考点：加壳、AES-CBC、Base64魔改</h2><h2 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h2><p>首先可以先试试用jeb打开</p><p><img src="/2022/02/13/hgame2022-week3-re/1644828115040.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644828621422.png"></p><p>没有找到mainactivitity，且有application，应该是加了壳，去lib找一下so文件，进行识别</p><pre class="language-none"><code class="language-none">markNameMap.put("libchaosvmp.so", "娜迦");markNameMap.put("libddog.so", "娜迦");markNameMap.put("libfdog.so", "娜迦");markNameMap.put("libedog.so", "娜迦企业版");markNameMap.put("libexec.so", "爱加密");markNameMap.put("libexecmain.so", "爱加密");markNameMap.put("ijiami.dat", "爱加密");markNameMap.put("ijiami.ajm", "爱加密企业版");markNameMap.put("libsecexe.so", "梆梆免费版");markNameMap.put("libsecmain.so", "梆梆免费版");markNameMap.put("libSecShell.so", "梆梆免费版");markNameMap.put("libDexHelper.so", "梆梆企业版");markNameMap.put("libDexHelper-x86.so", "梆梆企业版");markNameMap.put("libprotectClass.so", "360");markNameMap.put("libjiagu.so", "360");markNameMap.put("libjiagu_art.so", "360");markNameMap.put("libjiagu_x86.so", "360");markNameMap.put("libegis.so", "通付盾");markNameMap.put("libNSaferOnly.so", "通付盾");markNameMap.put("libnqshield.so", "网秦");markNameMap.put("libbaiduprotect.so", "百度");markNameMap.put("aliprotect.dat", "阿里聚安全");markNameMap.put("libsgmain.so", "阿里聚安全");markNameMap.put("libsgsecuritybody.so", "阿里聚安全");markNameMap.put("libmobisec.so", "阿里聚安全");markNameMap.put("libtup.so", "腾讯");markNameMap.put("libexec.so", "腾讯");markNameMap.put("libshell.so", "腾讯");markNameMap.put("mix.dex", "腾讯");markNameMap.put("lib/armeabi/mix.dex", "腾讯");markNameMap.put("lib/armeabi/mixz.dex", "腾讯");markNameMap.put("libtosprotection.armeabi.so", "腾讯御安全");markNameMap.put("libtosprotection.armeabi-v7a.so", "腾讯御安全");markNameMap.put("libtosprotection.x86.so", "腾讯御安全");markNameMap.put("libnesec.so", "网易易盾");markNameMap.put("libAPKProtect.so", "APKProtect");markNameMap.put("libkwscmm.so", "几维安全");markNameMap.put("libkwscr.so", "几维安全");markNameMap.put("libkwslinker.so", "几维安全");markNameMap.put("libx3g.so", "顶像科技");markNameMap.put("libapssec.so", "盛大");markNameMap.put("librsprotect.so", "瑞星");</code></pre><p>这个程序是被梆梆加固加固过的</p><p>使用工具脱壳-</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829142036.png"></p><p>安装到手机或者模拟器上面</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829295135.png"></p><p>找到目录再移动到共享文件夹就可以了</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829809855.png"></p><p>选中后打开共享文件夹，打开安卓文件夹</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829839920.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644829849310.png"></p><p>移动到此</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829879528.png"></p><p>再打开电脑文件夹就可以找到了</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829901534.png"></p><p>把dex依次拖入jeb，发现540702有关键信息</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830177982.png"></p><p>第二段是关键比较</p><p>查看前一个方框中引用的类</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830302545.png"></p><p>是用来调用so的，改为zip文件把enc.so文件拖进ida进行分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830479144.png"></p><p>找到关键的函数，可以看出是aes-cbc模式，查看AES函数调用的关键参数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830690500.png"></p><p>找到key和iv，对一些关键数据查看交叉引用</p><p>发现其他加密函数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830877369.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644830924673.png"></p><p>base64，再看看有没有魔改，对表查看交叉引用</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830970190.png"></p><p>发现对key和iv，以及base64表都进行了异或操作，写脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char key[32] = {0x7A, 0x65, 0x63, 0x64, 0x6F, 0x71, 0x6F, 0x7E, 0x7F, 0x62, 0x7D, 0x71, 0x7C, 0x6F, 0x7B, 0x75,0x69, 0x6F, 0x76, 0x7F, 0x62, 0x6F, 0x69, 0x7F, 0x65, 0x6F, 0x64, 0x7F, 0x6F, 0x74, 0x75, 0x73};char iv[16] = {0x06, 0x10, 0x0A, 0x20, 0x19, 0x16, 0x11, 0x1B,0x20, 0x12, 0x1A, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E};char base64_table[63] = {0x79, 0x78, 0x7B, 0x7A, 0x7D, 0x7C, 0x7F, 0x7E, 0x71, 0x70, 0x08, 0x0B, 0x0A, 0x0D, 0x0C, 0x0F,0x0E, 0x01, 0x00, 0x03, 0x02, 0x05, 0x04, 0x07, 0x06, 0x19, 0x18, 0x1B, 0x1A, 0x1D, 0x1C, 0x1F,0x1E, 0x11, 0x10, 0x13, 0x28, 0x2B, 0x2A, 0x2D, 0x2C, 0x2F, 0x2E, 0x21, 0x20, 0x23, 0x22, 0x25,0x24, 0x27, 0x26, 0x39, 0x38, 0x3B, 0x3A, 0x3D, 0x3C, 0x3F, 0x3E, 0x31, 0x30, 0x33, 0x62};for (int i = 0; i &lt; 32; ++i){key[i] ^= 0x30;printf("%c", key[i]);}printf("\n");for (int i = 0; i &lt; 16; ++i){iv[i] ^= 0x7f;printf("%c", iv[i]);}printf("\n");for (int i = 0; i &lt; 63; ++i){base64_table[i] ^= 0x49;printf("%c", base64_table[i]);}return 0;}</code></pre><p><img src="/2022/02/13/hgame2022-week3-re/1644831095464.png"></p><p>找在线网站解密-<a href="https://www.iculture.cc/demo/cyberchef/">https://www.iculture.cc/demo/cyberchef/</a></p><p><img src="/2022/02/13/hgame2022-week3-re/1644831134385.png"></p><h1 id="Answer’s-Windows"><a href="#Answer’s-Windows" class="headerlink" title="Answer’s Windows"></a>Answer’s Windows</h1><h2 id="考点：QT逆向、Base64魔改"><a href="#考点：QT逆向、Base64魔改" class="headerlink" title="考点：QT逆向、Base64魔改"></a>考点：QT逆向、Base64魔改</h2><h2 id="做题过程-1"><a href="#做题过程-1" class="headerlink" title="做题过程"></a>做题过程</h2><p><img src="/2022/02/13/hgame2022-week3-re/1644826230792.png"></p><p>根据字符串的搜索功能，快速定位到关键函数，可以看到进行了字符串比较，所以往上找到对字符串进行操作的函数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644826372187.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644826396198.png"></p><p>从这些关键特征可以猜测是base64，但是根据最后的字符串，可知道应该是对base64表进行了修改</p><p>查看交叉引用</p><p><img src="/2022/02/13/hgame2022-week3-re/1644826515161.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644826528911.png"></p><p>这时候可以绕过反调试进行动调，得到base64表</p><p><img src="/2022/02/13/hgame2022-week3-re/1644827711098.png"></p><p>然后写脚本即可</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = {  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,  0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34,  0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,  0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,  0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,  0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C,  0x5D, 0x5E, 0x5F, 0x60, 0x61};void base64_encode(char raw[], char encode[]){int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){encode[i_] = base64_table[raw[i] &gt;&gt; 2];encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1]) &gt;&gt; 4)];encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] ) &gt;&gt; 6)];encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];}if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}return;}int Findindex(char c){for (int i = 0; i &lt; strlen(base64_table); ++i){if (c == base64_table[i])return i;}}void base64_decode(char* encode, char* decode){int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;int i = 0, i_ = 0;for (; i &lt; encode_len; i_ += 4, i += 3){decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);decode[i + 2] = ((Findindex(encode[i_ + 2]) &amp; 0x3) &lt;&lt; 6) | ((Findindex(encode[i_ + 3])));}decode[decode_len] = 0;return;}int main(){char raw[] = ";'&gt;B&lt;76\\=82@-8.@=T\"@-7ZU:8*F=X2J&lt;G&gt;@=W^@-8.@9D2T:49U@1aa";char encode[100] = { 0 };char decode[100] = { 0 };/*base64_encode(raw, encode);printf("%s", encode);*/base64_decode(raw, decode);printf("%s", decode);}</code></pre><h1 id="creakme3"><a href="#creakme3" class="headerlink" title="creakme3"></a>creakme3</h1><h2 id="考点：猴子排序"><a href="#考点：猴子排序" class="headerlink" title="考点：猴子排序"></a>考点：猴子排序</h2><h2 id="做题过程-2"><a href="#做题过程-2" class="headerlink" title="做题过程"></a>做题过程</h2><p>开始用7.0无法反编译，使用7.5就行</p><p><img src="/2022/02/13/hgame2022-week3-re/1644827237787.png"></p><p>因为要满足for的第二个条件，所以就是进行排序，rand这一步是为了限制数组内的值小于88，而第二个条件是以偶数下标作为索引，前一个要大于后一个，所以使用结构体数组</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;struct data{int asc;int num;};struct data a[89]={{48,20093},{48,26557},{48,31304},{48,33442},{48,37694},{49,39960},{50,23295},{50,27863},{50,42698},{50,48505},{50,52925},{51,12874},{51,12946},{51,14597},{51,17041},{51,23262},{51,28319},{51,42282},{51,48693},{51,52067},{53,32571},{56,14612},{56,45741},{57,14554},{57,20048},{57,27138},{57,45327},{66,30949},{95,32502},{95,35235},{95,36541},{95,38371},{97,29658},{100,21388},{100,25403},{100,40604},{100,46987},{100,51302},{101,12974},{101,30329},{102,10983},{102,19818},{102,22280},{102,26128},{102,41560},{102,47116},{102,51333},{103,28938},{103,31988},{104,16246},{104,28715},{104,41966},{104,44368},{104,47815},{105,16420},{105,35362},{105,49237},{106,11090},{106,50823},{107,24320},{107,50199},{108,24962},{109,30171},{110,15457},{110,18838},{110,24001},{111,11638},{111,32023},{111,43291},{112,39661},{114,17872},{114,33895},{114,43869},{115,20611},{115,25122},{115,36243},{115,37434},{115,38686},{115,46266},{115,51077},{116,13656},{116,34493},{116,38712},{117,14096},{117,38777},{119,12095},{119,17629},{123,30945},{125,40770}};int main(){for (int i = 0; i &lt; 89; ++i){for (int j = i + 1; j &lt; 89; ++j){if (a[i].num &gt;= a[j].num){struct data tmp = a[i];a[i] = a[j];a[j] = tmp;}}}for (int i = 0; i &lt; 89; ++i){printf("%c", a[i].asc);}return 0;}</code></pre><h1 id="fishman"><a href="#fishman" class="headerlink" title="fishman"></a>fishman</h1><h2 id="考点：pyd逆向、Blowfish分组加密算法"><a href="#考点：pyd逆向、Blowfish分组加密算法" class="headerlink" title="考点：pyd逆向、Blowfish分组加密算法"></a>考点：pyd逆向、Blowfish分组加密算法</h2><h2 id="做题过程-3"><a href="#做题过程-3" class="headerlink" title="做题过程"></a>做题过程</h2><p>附件给了一个pyd文件，pyd文件是python的动态库，拖进ida分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644835618562.png"></p><p>使用Findcrypt插件查看发现是Blowfish加密算法</p><p>Blowfish-<a href="https://www.cnblogs.com/iBinary/p/14883752.html">https://www.cnblogs.com/iBinary/p/14883752.html</a></p><p><img src="/2022/02/13/hgame2022-week3-re/1644835958154.png"></p><p>加密后的数据</p><p>可以动调得到S盒和P盒的数据再写脚本，也可以不用，在string发现一个类似key的字符串</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836282247.png"></p><h3 id="pyd动调"><a href="#pyd动调" class="headerlink" title="pyd动调"></a>pyd动调</h3><p><img src="/2022/02/13/hgame2022-week3-re/1644836332456.png"></p><p>这是里面的一些函数，init初始化，check检查字符串</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836466799.png"></p><p>cp后面是python的版本，这里是3.9，把pyd文件修改名称为fishman.pyd，放入D:\python3.9\Lib\site-packages\</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import fishmanimport osprint(os.getpid())flag=input("input your flag here:")fishman.init()print(fishman.check(flag))</code></pre><p><img src="/2022/02/13/hgame2022-week3-re/1644836396140.png"></p><p>下好断点开启调试</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836650927.png"></p><p>这是线程，去ida，attach to process</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836705113.png"></p><p>注意要先在ida下好断点</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836779973.png"></p><p>停在了dll文件，要F9继续运行</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836830306.png"></p><p>这里处于Running状态，回去python程序，F8单步步过</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836868323.png"></p><p>回到ida分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836914886.png"></p><p>停在了这里，这时候已经完成对S盒和P盒的初始化，找到后提取出来即可</p><p>贴一下大佬的脚本</p><p>blowfish.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include"blowfish_head.h"#include&lt;stdio.h&gt;//变换后的P盒unsigned long pbx[18] ={0x6af74079, 0xc87db4da, 0x064b77a4, 0x33a56687, 0x73924432, 0x3a78e859, 0xa0f9451e, 0x6e99ea5f, 0xcb62f79c,0xec009d50, 0x46b85709, 0x3b2bfdf6, 0xd0a0f937, 0x67c4c3e1, 0x80d02257, 0x4162d4de, 0x814dce61, 0x227bde9b};//变换后的S盒unsigned long sbx[4][256] ={{ 0x857e5597, 0x326dad20, 0x2d507f8e, 0x2b80ba2c, 0xd711e661, 0x4b7e9667, 0x7a4b2509, 0x5117c0a3, 0x537791d2,0xbda0ec99, 0x9f5d600, 0x97d7453e, 0x6c3dede1, 0xefbec2ec, 0x31f20650, 0x86ea7ee1, 0x4a380c4e, 0x688500c0,0xc939e94b, 0xee64fe1f, 0xdae4a7bd, 0xafdfe274, 0xef95a497, 0xca5e8fc8, 0xa16220a, 0x9c85d82f, 0x3f411e1f,0x199cd133, 0x52ecbaa8, 0x68886557, 0xf8d4ca71, 0x729c0def, 0x5d6d4eb4, 0x550b9697, 0x77a9b569, 0xae8aacd5,0xa48c80d0, 0xb171f834, 0xd6828c5f, 0xf5219b37, 0x260e8a36, 0x9a8fbeba, 0xdf6ca01, 0x5f5ee56f, 0xc2e21a2f,0x87d75493, 0x87ef74ef, 0xfe01a2da, 0x8326e260, 0x7b3f0f, 0xc21ab19, 0x589f28be, 0x9ff0636, 0x2ac6affc, 0xb8e547d,0x91fa13e2, 0xde9a211f, 0x70b95314, 0x5879cad1, 0x8d38aa78, 0xffae559e, 0x132d25af, 0x4244c5f1, 0x7831cb8d,0x5625d8a2, 0xa99878b6, 0x44dfa664, 0x5b4e43c7, 0xfde79c18, 0xa8f89efb, 0x96a65669, 0xfa7ec977, 0x6438138b,0x63098e28, 0x7048ba4b, 0xc6f0e94, 0xabc7ae87, 0xdce4560, 0x2ee85291, 0xa7e24dd8, 0xdf0b5970, 0x3d8fcbe5,0x55b43ae4, 0x9eceee50, 0x6542e890, 0x4f70b16b, 0x778b58dc, 0xf3f830e4, 0x1b9d5867, 0x7076b41c, 0x6b8386de,0x8b148ce, 0x31c2fb7d, 0x42fe87c5, 0x108eb334, 0x7c40206, 0x2f783c90, 0xe593491f, 0x2b4ace07, 0xeba73a3c,0x44fa6586, 0x56ed2871, 0xd9b3ed4f, 0xb04d3c81, 0x93c1656c, 0xc8044fcb, 0x127ff622, 0x159d9dcf, 0x2fc79936,0x8549ee27, 0x262156cb, 0x721d3364, 0xf5a6f15e, 0x7fe8b137, 0x6cb075da, 0xfaa54cf4, 0x634519ec, 0xde79d57d,0x8b728797, 0x4b994f3e, 0x242eb5e6, 0x274f5cec, 0xc0f072e0, 0xb6928b6f, 0x8922972b, 0x2207de1e, 0xc0236ffa,0xc9dca5e5, 0x8d1286f, 0x90729fa3, 0x6a6ed134, 0x4369fae7, 0xf9ae5610, 0x13398b9e, 0xfdd59299, 0x21a3a98b,0xae6a4a80, 0x6b6e89a6, 0xce85be83, 0xda4c3800, 0x867af755, 0x26b3fb41, 0x96141cce, 0xf176999a, 0x1d844757,0xe27ce11f, 0x18638c21, 0x960ccbf2, 0xe4ccbbae, 0xaa0fab55, 0xf093bd6f, 0x4cb18fad, 0xf27853df, 0x5d5d925b,0xc389a234, 0xa9e9b90b, 0x6f06d9e4, 0xf0389646, 0xc75f5884, 0x9961dd6b, 0x44b1dc6a, 0x7ef092, 0xa4ca52a6,0x5342115d, 0x31d445bb, 0x6cb0b744, 0xd1abcf6, 0x95c6f259, 0xdf719b5d, 0xea51c785, 0xc7303253, 0x1e6a034e,0xf60989f1, 0x93f55b8d, 0xde786239, 0x9d01dfc5, 0xa4cd54ba, 0xfa60804a, 0x3da55ae7, 0x64d673a, 0x5ee1a39c,0x6daa769a, 0xec57802a, 0x7acdc0b0, 0xcdfedc6d, 0x72cb1321, 0x42d07041, 0xa45aa294, 0xdbf5b287, 0xca681d73,0x8d302710, 0x2b1ad68d, 0xc1c6521d, 0x4f40a81c, 0xf4762cb1, 0x8962117f, 0xe33e8bc2, 0xffa7db53, 0xd617f8af,0xd8b1563b, 0x1ed7d3b4, 0x9f998ca6, 0x1c32a736, 0x3513f35f, 0x7a4da8a8, 0x93f43a38, 0x6bf2eac7, 0xfe3041fd,0x8853f184, 0x81c00f3e, 0xc601a409, 0x1ceba826, 0x94bc26cd, 0xd07aaf4e, 0x46884d2, 0x5d4ec036, 0xe5587bf2,0xa3482f3f, 0xdbecc4b2, 0xe5a8e81e, 0x1287e1a3, 0x6e4ef861, 0xb4560ada, 0x5f18f3d5, 0xd9299202, 0xbab5cc00,0x18464f47, 0x58877430, 0xb4335a0a, 0x7a6e33e, 0xe62e23b4, 0x648e0251, 0xdd94b375, 0x719a409f, 0x5d45064d,0x243af927, 0xfbd3ab12, 0xdc74bb88, 0x21a563a8, 0x37b0a314, 0x5da98b1f, 0xfc4d4869, 0xbf0c7320, 0xebf308d3,0x714a3f9a, 0x6606297c, 0x28ff2689, 0xa6779947, 0xfb556d94, 0xb6413de2, 0x21519c0f, 0xb1052485, 0x69c2624b,0xde9cc548, 0xce36df75, 0x5dbfa8a7 },{ 0xaee3df14, 0x399d3136, 0x1c0b3ea1, 0xf8416210, 0x719b0d88, 0x908ce2e5, 0x623e46a2, 0xef7772ec, 0xdbc4da3a,0xe88f6e2e, 0x7fb80562, 0x1a33bfa7, 0xb972b27c, 0xfccb67ab, 0xb53bc933, 0xad99167e, 0x1831a7f0, 0x295e3c91,0x6afb6529, 0xb1d2c1eb, 0x38702ff1, 0xfb03fc16, 0xf85c29e8, 0x154bbcbf, 0xfc10c6d8, 0x1a07656, 0x9ec55090,0x52201a4a, 0x9b0ee83f, 0xe08b560a, 0xaff5a8bc, 0x35c5d6d7, 0x8d1f52f, 0x7b2becf0, 0xaf01ac97, 0x3b8700c9,0xfe56cea4, 0x1c4b14f6, 0xef86351c, 0x27a382c9, 0x28f51829, 0xcdeeee51, 0x3d73d792, 0x152c4a00, 0x7122ccea,0xbe459436, 0x624f6a81, 0xba728d6f, 0xdf7f103d, 0x7faf6a84, 0xd91174e1, 0xef9ca2f5, 0xa0675400, 0x9e0129,0x276f61d4, 0xf6e0bbb, 0x2f5e103d, 0x3d24363f, 0x36f1d769, 0xddabaa4d, 0xbd209d7b, 0x38898cda, 0x59aa0a47,0x3dc28a3b, 0x9374f915, 0x7164635e, 0xa09379f0, 0x462da24e, 0x7a6cd48d, 0xde20ce, 0xeac2f361, 0x9796cbc3,0x2cc87742, 0x2220d2f5, 0xab17e0c2, 0x16cb3b75, 0x5dc0d229, 0x7d14b8c8, 0x86ad060c, 0xfc1ac21c, 0xa25f8e37,0x23e553f1, 0xcfca2eb5, 0xda61f278, 0x7a6d0c2c, 0x10f72c33, 0xb9e7da31, 0xf0271ef1, 0xf6d8d0da, 0xccb9fb54,0x9c16adcc, 0x9c793e5d, 0x308dbae0, 0x8152f53d, 0xb8b02ea8, 0xbb7a73ef, 0x5b52b6e7, 0xda7691a1, 0x6f15166f,0x1bcf2abf, 0xed9eb801, 0xcc07f0d1, 0x30fd146a, 0xed552ed1, 0xfe280048, 0xca519936, 0xc6bb62d3, 0x78eb0ca9,0xde25bf1e, 0x377099d1, 0x9e3d9a2a, 0x58d4fdc5, 0x9ef6d4ba, 0x4c4b801c, 0x8d5c098c, 0x84cad315, 0x43b323ca,0xaff0262, 0x2b3be91f, 0xfd49761b, 0x93671206, 0x2460dd5e, 0x1328fc3, 0xa87f6e1a, 0xceebf4dc, 0x21f7d1d6,0x8dafb785, 0x1f058aa4, 0xf636282e, 0xf5d5c6a2, 0xdcb85ea1, 0xea4ce0f2, 0xb37fcdaa, 0xadb4cd12, 0xa51b34b3,0xb2aa712e, 0xa15f5bd, 0x617f127c, 0x7a5dbd16, 0x8aee5420, 0x4d0af701, 0xb2e113d9, 0xb4d09dcb, 0xd258e319,0x704ec155, 0x533c80be, 0x400c952d, 0xc0dd74a1, 0xa9e5599f, 0xada9e64, 0xa775ef10, 0x35abb495, 0x238b1eb3,0x5c8ea9e9, 0xd63ac5e, 0xecb22c6f, 0x836879b, 0xdb4958b0, 0x26606a34, 0x33fa456d, 0x91dc9940, 0xccbd103, 0x644cf9a7,0x80165230, 0xb0e45576, 0x4d28c64d, 0x8d9841cc, 0x3d42c9d1, 0x6fce26aa, 0xe5bd6421, 0xd0e1eb58, 0xfd61f403,0xdeff165, 0xd5a1bfb1, 0xb3323bbe, 0xdb641c02, 0xbfca7536, 0xb8f5820f, 0xda30db7b, 0xd76a9581, 0x61b8a87f,0x5d8410c2, 0x4b2df093, 0xc96447e9, 0xc4ba2487, 0xb24afc5a, 0x797db008, 0xc362253a, 0xc6bbe115, 0x1cc0ed71,0xabe73320, 0xc4364688, 0x5adef1c2, 0x59af22fb, 0xa9aca101, 0x4b5bac9b, 0xb121e519, 0xd8fcf69e, 0x2f0f0f89,0xef615692, 0xd9fac700, 0x6729f5e, 0x15b5965f, 0x83a0e48a, 0xd80cd549, 0xc85443c6, 0xdb051d9e, 0x8646780f,0x7e1bcd54, 0x7746aafa, 0xbc85c57a, 0x42430bc6, 0x36ab5fb6, 0x92e892ed, 0x87b8897f, 0xefcf526c, 0x6b10f264,0xe72e284, 0x6fe2966, 0x42f18a1f, 0xdff79c2a, 0x77fbe8e7, 0x942c9858, 0x637710f, 0xad12b3b8, 0xcf786ed1, 0xd7cda884,0x2cb1dcf1, 0x94f76ac0, 0xf7c4ebbe, 0x6d5591de, 0x6524ea76, 0x200d037e, 0xeb51ac71, 0x8b37601, 0xc9ac832,0x7721b2a4, 0xca23beee, 0x328c7019, 0xd27fd8c8, 0xc5be7325, 0xe9244524, 0x5b1ea918, 0x74c75201, 0x37621445,0xae75bef7, 0x174937dc, 0xf71c7cef, 0xf41d6ed3, 0x94c2d289, 0x7d68c2f0, 0xbddfcee6, 0x51d86ee8, 0x97379f95,0x4275b8c2, 0xf9b3122c },{ 0x6dbfa6dd, 0x6808c4be, 0x65fb06bd, 0xfde21a89, 0xf4c126b7, 0x438a1cc0, 0x850a843, 0x377114b2, 0x259c0fd,0x5881f166, 0x6e9fa190, 0x899a312e, 0x8001b123, 0x56d91bd5, 0x31b9a6db, 0x5a4f1940, 0x98140dee, 0x73ad8506,0x6649c267, 0x6fd7daa8, 0x682bb9e5, 0x7f9061dc, 0x27732a88, 0xa2755af7, 0x54b1b2ec, 0xc171fe6d, 0x33a31667,0x9afc41e2, 0x396678d5, 0x83cb861, 0xfc473f10, 0x575a023e, 0xfe11cafc, 0xe8ea4057, 0x1289aaa7, 0xa38ef05a,0x502c3f4a, 0xcb0928e9, 0x8d521829, 0x24c29091, 0xc07fbd37, 0x30cad78f, 0xcd8dba45, 0xc8ccbce8, 0xfdaee556,0x2a1fc86f, 0x8206edd4, 0x14c2ec89, 0xf0050d48, 0x31f5c320, 0xa5626fd9, 0x19ca606d, 0x65f46320, 0x43e58985,0xe3f777da, 0x4b9fa89e, 0xf3532d19, 0x1e63ee86, 0xa4c0f1b1, 0x56e691ed, 0xc79b5aa3, 0x1d005b01, 0x7ff86805,0xed4f0ce3, 0x167128ab, 0x96702d6b, 0x6f2cb666, 0x40d6b43d, 0x7f2e27f9, 0x25813783, 0xf06f47fe, 0xa1eb246e,0xe11c9c3f, 0x165237ab, 0xa9719981, 0xe0c072ef, 0xbc1430c8, 0x319018e0, 0x65323013, 0xa6337184, 0xe1c06cf0,0x2c99ecdc, 0xd682f79f, 0x2ebde8d2, 0xbdeca5a8, 0xb85ab458, 0xabc0be15, 0x5ed69b9d, 0x28bf53d3, 0x791d867b,0x86e6a98a, 0xba722e1c, 0x2311281a, 0xc8cce88d, 0x6c2d3743, 0xf868a752, 0xe0b86a8a, 0x70058bb9, 0xba926231,0x86a5a32c, 0x3e907ed6, 0x6f03f61e, 0xa87fbe48, 0xa09e8eaa, 0xdd78f5b, 0x622c29eb, 0x26cce112, 0x57215e0f,0xf9d9b37d, 0xc195133e, 0x703bd721, 0x27f1319b, 0xdccf0b77, 0xb73b7af4, 0xc9f75f9e, 0xf5c62fcb, 0x7293703,0xeed8b98f, 0x4a9bf102, 0x7349d5c7, 0xda6f8b23, 0x34529af2, 0x968579a9, 0x986d4e5f, 0x8d1903a2, 0x8960df2e,0x4dccb15c, 0x6a87f919, 0x8bc8e948, 0x82c8274c, 0x52f8bb80, 0xb3b5512c, 0x6b51a116, 0x16abf8e9, 0x99e48bf6,0xea03be4e, 0xa0766e91, 0x75e2c7e, 0x237be6a5, 0x8c1bd482, 0x473541f5, 0xc4af608b, 0xed686762, 0x1bf0cfc1,0x4844f0ca, 0x6a9a1980, 0x9d01dbf5, 0x10660435, 0x72fb5e04, 0xbf3de5a3, 0x21fbb319, 0xd303ed2f, 0xa30d610a,0x76ff38bb, 0x87136fca, 0xa4d11a77, 0xe6c197fd, 0x4e6bc1d1, 0xf2a87aa9, 0xcc795622, 0xb82be2b4, 0x77487ed2,0x2e7719ad, 0x142854f3, 0xe501258d, 0xb8556c95, 0x4e1a1309, 0x3d74b894, 0xfc1b626d, 0xcff955ec, 0x33bdc46f,0xed6091ef, 0x645f4f02, 0x7707e28a, 0x556f385a, 0xf8758408, 0xb06b762e, 0xa698d074, 0x46147980, 0x22668afc,0xdc1f5fa9, 0x245dc1d5, 0x32c87ded, 0xcfa4f49d, 0x734187b5, 0x700bc670, 0x97beeab3, 0x70f6ad54, 0xf0d6535d,0x76e34811, 0xb734677, 0x7ddbb9d3, 0x2bd695ab, 0xdb2daa29, 0x35c9f605, 0xfc4be706, 0x6e44a54b, 0xa96c5fbe,0x51e51ba6, 0xc4ebe8c7, 0xe103a24a, 0x842b0bac, 0xdfac2d6d, 0x1aed355d, 0xbdeafbde, 0x32338f9d, 0xaa634582,0xe152c83a, 0x84be8504, 0x46291ed, 0x7b863e96, 0xdb6776f8, 0x20f815f2, 0xa82af75d, 0xab76c0f5, 0xd550efa2,0xfd0330f1, 0x22e1fab0, 0x5f4407a3, 0x9b8e9e11, 0xeb1cadde, 0x3d104b1f, 0xc3054713, 0x982eb7fb, 0x543314da,0x13ae6d5d, 0x56594d93, 0x7af9ddb3, 0x5dbd0b3c, 0xeca553d0, 0x5f892e42, 0xdc466104, 0xf3b8fe09, 0xea63cc0e,0xe8187fa1, 0xf587d222, 0x762e3246, 0xe3134afd, 0xc8a909a3, 0x2a1b8843, 0xbcf88b37, 0x106d829d, 0xbc6cb72b,0xba700358, 0x4419c67b, 0x298e5b99, 0x53633710, 0xb4676dfb, 0x5003bfdd, 0x4b1f3fd6, 0xbff5676e, 0xfe221749,0x22769dec, 0xfa874d3f, 0xe3ab93a1, 0x7e7eac49 },{ 0xda47873d, 0xb4067196, 0x35629fff, 0x5f9ba741, 0xfc3b885c, 0x7db96275, 0x4be65d7c, 0xaac5aaff, 0xc48e069f,0xa2b51d88, 0x68efc326, 0x5dc94059, 0xf8fa7b3d, 0xc3e21cc2, 0xa619a16f, 0x46dec824, 0x399fea6, 0x8fc7db62,0x184569be, 0xc5f04731, 0x90c0dea5, 0xc180bf5f, 0xfccbd6c9, 0x49d7a598, 0x96425151, 0xe53c49fb, 0x15713840,0xcea6a8a0, 0x5c360e6b, 0x8278ef53, 0xa45ce852, 0xaf1fa60d, 0xd1d357d4, 0xcac8c677, 0x1258a65b, 0x561cc841,0xe73da602, 0x907e2447, 0xe62e297f, 0x107a743, 0xb0d19719, 0x84bb247a, 0xf8077268, 0xd5f63d60, 0xd9a141de,0x3486e6a4, 0xbe1052bf, 0x5be4fa46, 0xe792c9c8, 0xb9fbf3b0, 0xcfd36c94, 0x726aa896, 0x683cd337, 0x392a533a,0x223657a2, 0xf83da285, 0x16c1a03f, 0x68bdbcf5, 0xada3c5ab, 0x124148a8, 0xe7d2a95c, 0xd11922ac, 0x4c6899fd,0x7d8edf38, 0x118e9247, 0x15c6f2f0, 0x9056dd9f, 0x33520052, 0x7204913c, 0x3171d62d, 0x25d9ff0b, 0x8b629a57,0xc3ea9218, 0x699e2abf, 0xa9ff8e0f, 0x14dd1c3e, 0xee95bbe7, 0xa2e277c9, 0xd3966991, 0xce4fb1c6, 0x62f9c9,0x24bee229, 0xc677cc3e, 0x2163ca36, 0xbf6dd3f1, 0x7ae4222f, 0x4322f038, 0x692542df, 0x6692aca0, 0xf6d4946f,0x89154cfd, 0x9f6a7dbc, 0x104ea9f0, 0x89e3289, 0x87c95990, 0xf945a420, 0xb6a20072, 0x5b630e87, 0x848636c0,0xa48bb210, 0x4d5494bb, 0x7b7fb94f, 0xc48841b7, 0x422a2e4, 0x6d915a09, 0xcdabb5a5, 0xa36a9dd3, 0x2b321655,0xe7bd69cf, 0x8c5a8dd8, 0x74615473, 0x8c143ade, 0x6cb1ce59, 0x4396f842, 0xfccbf901, 0xf39018b0, 0x576ba9f5,0x97aeb15d, 0x6f7df74, 0x30f10bb9, 0x214789d7, 0xdf5edc71, 0xcdd4d413, 0x4e26b481, 0xa96771c4, 0xfbbf9600,0x61b03c10, 0xb41ec41b, 0x50e85e2c, 0x9ae79ae9, 0x1bffa793, 0x18402dde, 0x3a896084, 0x604aca05, 0xf0370269,0x83f6b326, 0xfb64099a, 0xabf943bf, 0xe9aa8b99, 0x54ec3adb, 0xa56b3a46, 0x71c05f89, 0x4a7f1444, 0xdf991094,0x8f5efd28, 0x9ad00ad5, 0x3cbee3c, 0xf5898fc4, 0x692ba57, 0x1928304a, 0x2978de0f, 0x64f85786, 0x62b4f525,0xda78ad05, 0xb3da431b, 0xdde89dde, 0xcc7da3d9, 0xbde46885, 0xd26c42cf, 0xa7850e7c, 0xff3b73d, 0xd60665a5,0x825b2d8c, 0xbce1ba7, 0x12be55de, 0x7cf29faa, 0x71a29eca, 0xbd067b1a, 0x2e33857, 0xf0c7e782, 0x9ac9f181,0x61d9b196, 0x288412eb, 0x756010ba, 0x20f99e06, 0x67e6cb96, 0xd1efb6, 0x1a4dfffb, 0x9d097c31, 0x6890b138,0xa162f385, 0x5038a02a, 0xdcca2edc, 0xd68af382, 0xed5c9bb, 0xe88cf6c4, 0x4c031e98, 0xca08127b, 0xc67a831f,0x306fb3f6, 0x9d7315c5, 0x2c72ae76, 0xdd3b3ecc, 0x2ab71490, 0x6e79ef13, 0xe6aa6316, 0x3729bfbc, 0xa13c9bea,0xa4fa53c, 0xdbafeec6, 0x57a11cc2, 0x8f1be1ba, 0x542a4d3b, 0x8f9c90c4, 0xa2b3ad9f, 0x8951b50, 0xda0641dd,0xd7cdf19b, 0xebe79e9b, 0x7d6ae548, 0x2ae7eb6f, 0x3ebefb7f, 0xb9cf555d, 0x22b46357, 0x963e79b5, 0x81729e6f,0xa0657b30, 0x297d0ea1, 0x2d722676, 0xd7c263c7, 0x8fd31545, 0x74b4d545, 0xc9ddb768, 0xd7af1a95, 0x3b41452d,0xeaa84874, 0x3094af86, 0xc71461f6, 0x8cd49c9b, 0x9d6f96b1, 0x9b45bb4c, 0x58742714, 0x29b19a6a, 0xa85bddc6,0xb1e0cf54, 0xb55e81d4, 0xcb219b85, 0xcea74b66, 0xd28a041e, 0xe28c4803, 0x490de006, 0x19bb91b1, 0x14d67500,0x80243406, 0x1ed8b3e, 0xef5636b3, 0x956f13bd, 0x9ae34304, 0xaea37a2c, 0xc90fe0b9, 0x2301fb8f, 0x55716d77,0xc50297f7, 0x3cabc6a4, 0xa0764bb0, 0xcf38a2a2 } };/*P盒和S盒根据密钥进行变换因为我们直接替换成变换后的P盒和S盒，所以不需要调用*/void getkey(char *keytext){int i = -1, j = 0;unsigned long key[18];while (keytext[++i]);while (i&lt;72) keytext[i++] = 0;memcpy(key, keytext, 72);for (i = 0; i&lt;18; i++) pbx[i] ^= key[i];key[0] = key[1] = 0;for (i = 0; i&lt;18; i += 2){blowfish_encrypt(key, key);memcpy(&amp;pbx[i], key, 8);}for (i = 0; i&lt;4; i++){for (j = 0; j&lt;256; j += 2){blowfish_encrypt(key, key);memcpy(&amp;sbx[i][j], key, 8);}}}void blowfish_encrypt(void *protext, void *ciptext){int i = 0;unsigned long x[2], temp;memcpy(x, protext, 8);for (i = 0; i&lt;16; i++){x[0] ^= pbx[i];x[1] ^= f(x[0]);temp = x[1];x[1] = x[0];x[0] = temp;}temp = x[1];x[1] = x[0];x[0] = temp;x[0] ^= pbx[17];x[1] ^= pbx[16];memcpy(ciptext, x, 8);printf("0x%x,0x%x\n", x[0], x[1]);}void blowfish_decrypt(void *protext, void *ciptext){int i = 0;unsigned long x[2], temp;memcpy(x, ciptext, 8);for (i = 17; i &gt;= 2; i--){x[0] ^= pbx[i];x[1] ^= f(x[0]);temp = x[1];x[1] = x[0];x[0] = temp;}temp = x[1];x[1] = x[0];x[0] = temp;x[0] ^= pbx[0];x[1] ^= pbx[1];memcpy(protext, x, 8);printf("0x%x,0x%x\n", x[0], x[1]);}unsigned long f(unsigned long x){unsigned long a, b, c, d;a = (x &amp; 0xff000000) &gt;&gt; 24;b = (x &amp; 0x00ff0000) &gt;&gt; 16;c = (x &amp; 0x0000ff00) &gt;&gt; 8;d = (x &amp; 0x000000ff) &gt;&gt; 0;return(((sbx[0][a] + sbx[1][b]) ^ sbx[2][c]) + sbx[3][d]);}int main(){char data[] = "abcdefgh";char cipher[]={ 0xBF, 0x4E, 0x6F, 0x54, 0x7B, 0x93, 0xED, 0xB4 };//0x6d616768,0x30447b65//0x7E, 0xA0, 0xD2, 0x82, 0xDD, 0xEF, 0xD3, 0x13-&gt;0x7530795f,0x3465725f//0x0F, 0xAE, 0x09, 0x22, 0x61, 0xDF, 0x4E, 0x59-&gt;0x5f563131,0x336b3131//0x2C, 0x78, 0x33, 0xB9, 0x32, 0xE5, 0x07, 0x1C-&gt;0x7456395f,0x7d6e6f68//blowfish_encrypt(data, cipher);blowfish_decrypt(data, cipher);}</code></pre><p>将多组数据分别代入进行运算，再转为字符串即可，注意小端序</p><p>blowfish_head.h</p><pre class="language-c" data-language="c"><code class="language-c">#ifndef BLOWFISHH#define BLOWFISHH#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void blowfish_encrypt(void*, void*);void blowfish_decrypt(void*, void*);void getkey(char*);unsigned long f(unsigned long);#endif#pragma once</code></pre><h3 id="另一个脚本"><a href="#另一个脚本" class="headerlink" title="另一个脚本"></a>另一个脚本</h3><pre class="language-c" data-language="c"><code class="language-c">#include "BlowFish.h"#include &lt;string.h&gt;#include &lt;stdio.h&gt;// using namespace std;int BlowFishInit(BLOWFISH_CTX* blowCtx, unsigned char* key, unsigned intkeylen){//设置传入的CTX中的SBOX值for (int Row = 0; Row &lt; 4; Row++){for (int Col = 0; Col &lt; 256; Col++){blowCtx-&gt;sbox[Row][Col] = ORIG_S[Row][Col];}}/*设置pbox1.循环18轮2.每轮都设置ctx.pbox值与data ^3.data = *(DWORD*)key[0] key[1].....*/int KeyIndex = 0;for (int index = 0; index &lt; N + 2; index++){unsigned int data = 0;//填充data 将key的字符设置到data当中for (int k = 0; k &lt; 4; k++){//通过移位设置每个字符data = (data &lt;&lt; 8) | key[KeyIndex];KeyIndex++;//如果超出了key长度 那么key要从开始if (KeyIndex &gt;= keylen)KeyIndex = 0;}//否则不满足blowCtx-&gt;pbox[index] = ORIG_P[index] ^ data;}//对一个64位0 进行加密。加密结果的输出设置到pbox[i]与pbox[i+1]中unsigned int Data1 = 0;unsigned int Data2 = 0;for (int i = 0; i &lt; N + 2; i += 2){BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);blowCtx-&gt;pbox[i] = Data1;blowCtx-&gt;pbox[i + 1] = Data2;}//初始化Sboxfor (int i = 0; i &lt; 4; i++){for (int j = 0; j &lt; 256; j += 2){BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);blowCtx-&gt;sbox[i][j] = Data1;blowCtx-&gt;sbox[i][j + 1] = Data2;}}return 1;}//unsigned int F(PBLOWFISH_CTX blowCtx, unsigned int Data)//{//// unsigned int a, b, c, d;// /*// 利用位运算 取出下标值// *///// a = (Data &gt;&gt; 24) &amp; 0xFF;// b = (Data &gt;&gt; 16) &amp; 0xFF;// c = (Data &gt;&gt; 8) &amp; 0xFf;// d = Data &amp; 0xFF;////// int TempValue = blowCtx-&gt;sbox[0][a] + blowCtx-&gt;sbox[1][b];// TempValue = TempValue ^ blowCtx-&gt;sbox[2][c];// TempValue = TempValue + blowCtx-&gt;sbox[3][d];// //公式 ((a+b)^c)+d// return TempValue;//}static unsigned long F(BLOWFISH_CTX* ctx, unsigned long x) {unsigned short a, b, c, d;unsigned long y;/* d = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;c = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;b = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;a = (unsigned short)(x &amp; 0xFF);//都可以使用*/a = (x &gt;&gt; 24) &amp; 0xFF;b = (x &gt;&gt; 16) &amp; 0xFF;c = (x &gt;&gt; 8) &amp; 0xFf;d = x &amp; 0xFF;y = ctx-&gt;sbox[0][a] + ctx-&gt;sbox[1][b];y = y ^ ctx-&gt;sbox[2][c];y = y + ctx-&gt;sbox[3][d];return y;}void BlowFish_Encry(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right){unsigned long Xl;unsigned long Xr;unsigned long temp;short i;//加密部分首先将其分为left跟right两组。 每一组分别32位Xl = *left;Xr = *right;for (i = 0; i &lt; N; ++i) {Xl = Xl ^ blowCtx-&gt;pbox[i];Xr = F(blowCtx, Xl) ^ Xr;temp = Xl;Xl = Xr; //交换左右的值。 l = R r= l 继续下一轮循环。总共16轮Xr = temp;}temp = Xl;Xl = Xr; //16轮完毕之后交换变量Xr = temp;Xr = Xr ^ blowCtx-&gt;pbox[N]; //最后进行一次疑或Xl = Xl ^ blowCtx-&gt;pbox[N + 1];*left = Xl;*right = Xr;}void BlowFish_Decrypt(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right){unsigned int Xl = *left;unsigned int Xr = *right;//倒着循环for (int i = N + 1; i &gt; 1; --i){Xl = Xl ^ blowCtx-&gt;pbox[i];Xr = Xr ^ F(blowCtx, Xl);//继续左右交换unsigned int temp = Xl;Xl = Xr;Xr = temp;}//最后一轮继续交换unsigned int temp = Xl;Xl = Xr;Xr = temp;//返还原Xr = Xr ^ blowCtx-&gt;pbox[1];Xl = Xl ^ blowCtx-&gt;pbox[0];//设置变量返回*left = Xl;*right = Xr;}// int main()// {// unsigned int L = 1, R = 2;// BLOWFISH_CTX ctx;// BlowFishInit(&amp;ctx,(unsigned char*)"IBinary",strlen("IBinary"));// BlowFish_Encry(&amp;ctx, &amp;L, &amp;R);// BlowFish_Decrypt(&amp;ctx, &amp;L, &amp;R);// }void main(void) {// unsigned int L = 1, R = 2;unsigned int L1 = 0x546F4EBF, R1 = 0x0B4ED937B;BLOWFISH_CTX ctx;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L1, &amp;R1);printf("%x %x\n", L1, R1);unsigned int L2 = 0x82D2A07E, R2 = 0x13D3EFDD;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L2, &amp;R2);printf("%x %x\n", L2, R2);unsigned int L3 = 0x2209AE0F, R3 = 0x594EDF61;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L3, &amp;R3);printf("%x %x\n", L3, R3);unsigned int L4 = 0x0B933782C, R4 = 0x1C07E532;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L4, &amp;R4);printf("%x %x\n", L4, R4);}</code></pre><p>BlowFish.h</p><pre class="language-c" data-language="c"><code class="language-c">#pragma once#pragma once/*使用BlowFish进行加解密*///定义全局旧的pbox sbox 都是根据小数来的。#define N 16static const unsigned long ORIG_P[16 + 2] = {0x243F6A88L, 0x85A308D3L, 0x13198A2EL, 0x03707344L,0xA4093822L, 0x299F31D0L, 0x082EFA98L, 0xEC4E6C89L,0x452821E6L, 0x38D01377L, 0xBE5466CFL, 0x34E90C6CL,0xC0AC29B7L, 0xC97C50DDL, 0x3F84D5B5L, 0xB5470917L,0x9216D5D9L, 0x8979FB1BL};static const unsigned long ORIG_S[4][256] = {{ 0xD1310BA6L, 0x98DFB5ACL, 0x2FFD72DBL, 0xD01ADFB7L,0xB8E1AFEDL, 0x6A267E96L, 0xBA7C9045L, 0xF12C7F99L,0x24A19947L, 0xB3916CF7L, 0x0801F2E2L, 0x858EFC16L,0x636920D8L, 0x71574E69L, 0xA458FEA3L, 0xF4933D7EL,0x0D95748FL, 0x728EB658L, 0x718BCD58L, 0x82154AEEL,0x7B54A41DL, 0xC25A59B5L, 0x9C30D539L, 0x2AF26013L,0xC5D1B023L, 0x286085F0L, 0xCA417918L, 0xB8DB38EFL,0x8E79DCB0L, 0x603A180EL, 0x6C9E0E8BL, 0xB01E8A3EL,0xD71577C1L, 0xBD314B27L, 0x78AF2FDAL, 0x55605C60L,0xE65525F3L, 0xAA55AB94L, 0x57489862L, 0x63E81440L,0x55CA396AL, 0x2AAB10B6L, 0xB4CC5C34L, 0x1141E8CEL,0xA15486AFL, 0x7C72E993L, 0xB3EE1411L, 0x636FBC2AL,0x2BA9C55DL, 0x741831F6L, 0xCE5C3E16L, 0x9B87931EL,0xAFD6BA33L, 0x6C24CF5CL, 0x7A325381L, 0x28958677L,0x3B8F4898L, 0x6B4BB9AFL, 0xC4BFE81BL, 0x66282193L,0x61D809CCL, 0xFB21A991L, 0x487CAC60L, 0x5DEC8032L,0xEF845D5DL, 0xE98575B1L, 0xDC262302L, 0xEB651B88L,0x23893E81L, 0xD396ACC5L, 0x0F6D6FF3L, 0x83F44239L,0x2E0B4482L, 0xA4842004L, 0x69C8F04AL, 0x9E1F9B5EL,0x21C66842L, 0xF6E96C9AL, 0x670C9C61L, 0xABD388F0L,0x6A51A0D2L, 0xD8542F68L, 0x960FA728L, 0xAB5133A3L,0x6EEF0B6CL, 0x137A3BE4L, 0xBA3BF050L, 0x7EFB2A98L,0xA1F1651DL, 0x39AF0176L, 0x66CA593EL, 0x82430E88L,0x8CEE8619L, 0x456F9FB4L, 0x7D84A5C3L, 0x3B8B5EBEL,0xE06F75D8L, 0x85C12073L, 0x401A449FL, 0x56C16AA6L,0x4ED3AA62L, 0x363F7706L, 0x1BFEDF72L, 0x429B023DL,0x37D0D724L, 0xD00A1248L, 0xDB0FEAD3L, 0x49F1C09BL,0x075372C9L, 0x80991B7BL, 0x25D479D8L, 0xF6E8DEF7L,0xE3FE501AL, 0xB6794C3BL, 0x976CE0BDL, 0x04C006BAL,0xC1A94FB6L, 0x409F60C4L, 0x5E5C9EC2L, 0x196A2463L,0x68FB6FAFL, 0x3E6C53B5L, 0x1339B2EBL, 0x3B52EC6FL,0x6DFC511FL, 0x9B30952CL, 0xCC814544L, 0xAF5EBD09L,0xBEE3D004L, 0xDE334AFDL, 0x660F2807L, 0x192E4BB3L,0xC0CBA857L, 0x45C8740FL, 0xD20B5F39L, 0xB9D3FBDBL,0x5579C0BDL, 0x1A60320AL, 0xD6A100C6L, 0x402C7279L,0x679F25FEL, 0xFB1FA3CCL, 0x8EA5E9F8L, 0xDB3222F8L,0x3C7516DFL, 0xFD616B15L, 0x2F501EC8L, 0xAD0552ABL,0x323DB5FAL, 0xFD238760L, 0x53317B48L, 0x3E00DF82L,0x9E5C57BBL, 0xCA6F8CA0L, 0x1A87562EL, 0xDF1769DBL,0xD542A8F6L, 0x287EFFC3L, 0xAC6732C6L, 0x8C4F5573L,0x695B27B0L, 0xBBCA58C8L, 0xE1FFA35DL, 0xB8F011A0L,0x10FA3D98L, 0xFD2183B8L, 0x4AFCB56CL, 0x2DD1D35BL,0x9A53E479L, 0xB6F84565L, 0xD28E49BCL, 0x4BFB9790L,0xE1DDF2DAL, 0xA4CB7E33L, 0x62FB1341L, 0xCEE4C6E8L,0xEF20CADAL, 0x36774C01L, 0xD07E9EFEL, 0x2BF11FB4L,0x95DBDA4DL, 0xAE909198L, 0xEAAD8E71L, 0x6B93D5A0L,0xD08ED1D0L, 0xAFC725E0L, 0x8E3C5B2FL, 0x8E7594B7L,0x8FF6E2FBL, 0xF2122B64L, 0x8888B812L, 0x900DF01CL,0x4FAD5EA0L, 0x688FC31CL, 0xD1CFF191L, 0xB3A8C1ADL,0x2F2F2218L, 0xBE0E1777L, 0xEA752DFEL, 0x8B021FA1L,0xE5A0CC0FL, 0xB56F74E8L, 0x18ACF3D6L, 0xCE89E299L,0xB4A84FE0L, 0xFD13E0B7L, 0x7CC43B81L, 0xD2ADA8D9L,0x165FA266L, 0x80957705L, 0x93CC7314L, 0x211A1477L,0xE6AD2065L, 0x77B5FA86L, 0xC75442F5L, 0xFB9D35CFL,0xEBCDAF0CL, 0x7B3E89A0L, 0xD6411BD3L, 0xAE1E7E49L,0x00250E2DL, 0x2071B35EL, 0x226800BBL, 0x57B8E0AFL,0x2464369BL, 0xF009B91EL, 0x5563911DL, 0x59DFA6AAL,0x78C14389L, 0xD95A537FL, 0x207D5BA2L, 0x02E5B9C5L,0x83260376L, 0x6295CFA9L, 0x11C81968L, 0x4E734A41L,0xB3472DCAL, 0x7B14A94AL, 0x1B510052L, 0x9A532915L,0xD60F573FL, 0xBC9BC6E4L, 0x2B60A476L, 0x81E67400L,0x08BA6FB5L, 0x571BE91FL, 0xF296EC6BL, 0x2A0DD915L,0xB6636521L, 0xE7B9F9B6L, 0xFF34052EL, 0xC5855664L,0x53B02D5DL, 0xA99F8FA1L, 0x08BA4799L, 0x6E85076AL },{ 0x4B7A70E9L, 0xB5B32944L, 0xDB75092EL, 0xC4192623L,0xAD6EA6B0L, 0x49A7DF7DL, 0x9CEE60B8L, 0x8FEDB266L,0xECAA8C71L, 0x699A17FFL, 0x5664526CL, 0xC2B19EE1L,0x193602A5L, 0x75094C29L, 0xA0591340L, 0xE4183A3EL,0x3F54989AL, 0x5B429D65L, 0x6B8FE4D6L, 0x99F73FD6L,0xA1D29C07L, 0xEFE830F5L, 0x4D2D38E6L, 0xF0255DC1L,0x4CDD2086L, 0x8470EB26L, 0x6382E9C6L, 0x021ECC5EL,0x09686B3FL, 0x3EBAEFC9L, 0x3C971814L, 0x6B6A70A1L,0x687F3584L, 0x52A0E286L, 0xB79C5305L, 0xAA500737L,0x3E07841CL, 0x7FDEAE5CL, 0x8E7D44ECL, 0x5716F2B8L,0xB03ADA37L, 0xF0500C0DL, 0xF01C1F04L, 0x0200B3FFL,0xAE0CF51AL, 0x3CB574B2L, 0x25837A58L, 0xDC0921BDL,0xD19113F9L, 0x7CA92FF6L, 0x94324773L, 0x22F54701L,0x3AE5E581L, 0x37C2DADCL, 0xC8B57634L, 0x9AF3DDA7L,0xA9446146L, 0x0FD0030EL, 0xECC8C73EL, 0xA4751E41L,0xE238CD99L, 0x3BEA0E2FL, 0x3280BBA1L, 0x183EB331L,0x4E548B38L, 0x4F6DB908L, 0x6F420D03L, 0xF60A04BFL,0x2CB81290L, 0x24977C79L, 0x5679B072L, 0xBCAF89AFL,0xDE9A771FL, 0xD9930810L, 0xB38BAE12L, 0xDCCF3F2EL,0x5512721FL, 0x2E6B7124L, 0x501ADDE6L, 0x9F84CD87L,0x7A584718L, 0x7408DA17L, 0xBC9F9ABCL, 0xE94B7D8CL,0xEC7AEC3AL, 0xDB851DFAL, 0x63094366L, 0xC464C3D2L,0xEF1C1847L, 0x3215D908L, 0xDD433B37L, 0x24C2BA16L,0x12A14D43L, 0x2A65C451L, 0x50940002L, 0x133AE4DDL,0x71DFF89EL, 0x10314E55L, 0x81AC77D6L, 0x5F11199BL,0x043556F1L, 0xD7A3C76BL, 0x3C11183BL, 0x5924A509L,0xF28FE6EDL, 0x97F1FBFAL, 0x9EBABF2CL, 0x1E153C6EL,0x86E34570L, 0xEAE96FB1L, 0x860E5E0AL, 0x5A3E2AB3L,0x771FE71CL, 0x4E3D06FAL, 0x2965DCB9L, 0x99E71D0FL,0x803E89D6L, 0x5266C825L, 0x2E4CC978L, 0x9C10B36AL,0xC6150EBAL, 0x94E2EA78L, 0xA5FC3C53L, 0x1E0A2DF4L,0xF2F74EA7L, 0x361D2B3DL, 0x1939260FL, 0x19C27960L,0x5223A708L, 0xF71312B6L, 0xEBADFE6EL, 0xEAC31F66L,0xE3BC4595L, 0xA67BC883L, 0xB17F37D1L, 0x018CFF28L,0xC332DDEFL, 0xBE6C5AA5L, 0x65582185L, 0x68AB9802L,0xEECEA50FL, 0xDB2F953BL, 0x2AEF7DADL, 0x5B6E2F84L,0x1521B628L, 0x29076170L, 0xECDD4775L, 0x619F1510L,0x13CCA830L, 0xEB61BD96L, 0x0334FE1EL, 0xAA0363CFL,0xB5735C90L, 0x4C70A239L, 0xD59E9E0BL, 0xCBAADE14L,0xEECC86BCL, 0x60622CA7L, 0x9CAB5CABL, 0xB2F3846EL,0x648B1EAFL, 0x19BDF0CAL, 0xA02369B9L, 0x655ABB50L,0x40685A32L, 0x3C2AB4B3L, 0x319EE9D5L, 0xC021B8F7L,0x9B540B19L, 0x875FA099L, 0x95F7997EL, 0x623D7DA8L,0xF837889AL, 0x97E32D77L, 0x11ED935FL, 0x16681281L,0x0E358829L, 0xC7E61FD6L, 0x96DEDFA1L, 0x7858BA99L,0x57F584A5L, 0x1B227263L, 0x9B83C3FFL, 0x1AC24696L,0xCDB30AEBL, 0x532E3054L, 0x8FD948E4L, 0x6DBC3128L,0x58EBF2EFL, 0x34C6FFEAL, 0xFE28ED61L, 0xEE7C3C73L,0x5D4A14D9L, 0xE864B7E3L, 0x42105D14L, 0x203E13E0L,0x45EEE2B6L, 0xA3AAABEAL, 0xDB6C4F15L, 0xFACB4FD0L,0xC742F442L, 0xEF6ABBB5L, 0x654F3B1DL, 0x41CD2105L,0xD81E799EL, 0x86854DC7L, 0xE44B476AL, 0x3D816250L,0xCF62A1F2L, 0x5B8D2646L, 0xFC8883A0L, 0xC1C7B6A3L,0x7F1524C3L, 0x69CB7492L, 0x47848A0BL, 0x5692B285L,0x095BBF00L, 0xAD19489DL, 0x1462B174L, 0x23820E00L,0x58428D2AL, 0x0C55F5EAL, 0x1DADF43EL, 0x233F7061L,0x3372F092L, 0x8D937E41L, 0xD65FECF1L, 0x6C223BDBL,0x7CDE3759L, 0xCBEE7460L, 0x4085F2A7L, 0xCE77326EL,0xA6078084L, 0x19F8509EL, 0xE8EFD855L, 0x61D99735L,0xA969A7AAL, 0xC50C06C2L, 0x5A04ABFCL, 0x800BCADCL,0x9E447A2EL, 0xC3453484L, 0xFDD56705L, 0x0E1E9EC9L,0xDB73DBD3L, 0x105588CDL, 0x675FDA79L, 0xE3674340L,0xC5C43465L, 0x713E38D8L, 0x3D28F89EL, 0xF16DFF20L,0x153E21E7L, 0x8FB03D4AL, 0xE6E39F2BL, 0xDB83ADF7L },{ 0xE93D5A68L, 0x948140F7L, 0xF64C261CL, 0x94692934L,0x411520F7L, 0x7602D4F7L, 0xBCF46B2EL, 0xD4A20068L,0xD4082471L, 0x3320F46AL, 0x43B7D4B7L, 0x500061AFL,0x1E39F62EL, 0x97244546L, 0x14214F74L, 0xBF8B8840L,0x4D95FC1DL, 0x96B591AFL, 0x70F4DDD3L, 0x66A02F45L,0xBFBC09ECL, 0x03BD9785L, 0x7FAC6DD0L, 0x31CB8504L,0x96EB27B3L, 0x55FD3941L, 0xDA2547E6L, 0xABCA0A9AL,0x28507825L, 0x530429F4L, 0x0A2C86DAL, 0xE9B66DFBL,0x68DC1462L, 0xD7486900L, 0x680EC0A4L, 0x27A18DEEL,0x4F3FFEA2L, 0xE887AD8CL, 0xB58CE006L, 0x7AF4D6B6L,0xAACE1E7CL, 0xD3375FECL, 0xCE78A399L, 0x406B2A42L,0x20FE9E35L, 0xD9F385B9L, 0xEE39D7ABL, 0x3B124E8BL,0x1DC9FAF7L, 0x4B6D1856L, 0x26A36631L, 0xEAE397B2L,0x3A6EFA74L, 0xDD5B4332L, 0x6841E7F7L, 0xCA7820FBL,0xFB0AF54EL, 0xD8FEB397L, 0x454056ACL, 0xBA489527L,0x55533A3AL, 0x20838D87L, 0xFE6BA9B7L, 0xD096954BL,0x55A867BCL, 0xA1159A58L, 0xCCA92963L, 0x99E1DB33L,0xA62A4A56L, 0x3F3125F9L, 0x5EF47E1CL, 0x9029317CL,0xFDF8E802L, 0x04272F70L, 0x80BB155CL, 0x05282CE3L,0x95C11548L, 0xE4C66D22L, 0x48C1133FL, 0xC70F86DCL,0x07F9C9EEL, 0x41041F0FL, 0x404779A4L, 0x5D886E17L,0x325F51EBL, 0xD59BC0D1L, 0xF2BCC18FL, 0x41113564L,0x257B7834L, 0x602A9C60L, 0xDFF8E8A3L, 0x1F636C1BL,0x0E12B4C2L, 0x02E1329EL, 0xAF664FD1L, 0xCAD18115L,0x6B2395E0L, 0x333E92E1L, 0x3B240B62L, 0xEEBEB922L,0x85B2A20EL, 0xE6BA0D99L, 0xDE720C8CL, 0x2DA2F728L,0xD0127845L, 0x95B794FDL, 0x647D0862L, 0xE7CCF5F0L,0x5449A36FL, 0x877D48FAL, 0xC39DFD27L, 0xF33E8D1EL,0x0A476341L, 0x992EFF74L, 0x3A6F6EABL, 0xF4F8FD37L,0xA812DC60L, 0xA1EBDDF8L, 0x991BE14CL, 0xDB6E6B0DL,0xC67B5510L, 0x6D672C37L, 0x2765D43BL, 0xDCD0E804L,0xF1290DC7L, 0xCC00FFA3L, 0xB5390F92L, 0x690FED0BL,0x667B9FFBL, 0xCEDB7D9CL, 0xA091CF0BL, 0xD9155EA3L,0xBB132F88L, 0x515BAD24L, 0x7B9479BFL, 0x763BD6EBL,0x37392EB3L, 0xCC115979L, 0x8026E297L, 0xF42E312DL,0x6842ADA7L, 0xC66A2B3BL, 0x12754CCCL, 0x782EF11CL,0x6A124237L, 0xB79251E7L, 0x06A1BBE6L, 0x4BFB6350L,0x1A6B1018L, 0x11CAEDFAL, 0x3D25BDD8L, 0xE2E1C3C9L,0x44421659L, 0x0A121386L, 0xD90CEC6EL, 0xD5ABEA2AL,0x64AF674EL, 0xDA86A85FL, 0xBEBFE988L, 0x64E4C3FEL,0x9DBC8057L, 0xF0F7C086L, 0x60787BF8L, 0x6003604DL,0xD1FD8346L, 0xF6381FB0L, 0x7745AE04L, 0xD736FCCCL,0x83426B33L, 0xF01EAB71L, 0xB0804187L, 0x3C005E5FL,0x77A057BEL, 0xBDE8AE24L, 0x55464299L, 0xBF582E61L,0x4E58F48FL, 0xF2DDFDA2L, 0xF474EF38L, 0x8789BDC2L,0x5366F9C3L, 0xC8B38E74L, 0xB475F255L, 0x46FCD9B9L,0x7AEB2661L, 0x8B1DDF84L, 0x846A0E79L, 0x915F95E2L,0x466E598EL, 0x20B45770L, 0x8CD55591L, 0xC902DE4CL,0xB90BACE1L, 0xBB8205D0L, 0x11A86248L, 0x7574A99EL,0xB77F19B6L, 0xE0A9DC09L, 0x662D09A1L, 0xC4324633L,0xE85A1F02L, 0x09F0BE8CL, 0x4A99A025L, 0x1D6EFE10L,0x1AB93D1DL, 0x0BA5A4DFL, 0xA186F20FL, 0x2868F169L,0xDCB7DA83L, 0x573906FEL, 0xA1E2CE9BL, 0x4FCD7F52L,0x50115E01L, 0xA70683FAL, 0xA002B5C4L, 0x0DE6D027L,0x9AF88C27L, 0x773F8641L, 0xC3604C06L, 0x61A806B5L,0xF0177A28L, 0xC0F586E0L, 0x006058AAL, 0x30DC7D62L,0x11E69ED7L, 0x2338EA63L, 0x53C2DD94L, 0xC2C21634L,0xBBCBEE56L, 0x90BCB6DEL, 0xEBFC7DA1L, 0xCE591D76L,0x6F05E409L, 0x4B7C0188L, 0x39720A3DL, 0x7C927C24L,0x86E3725FL, 0x724D9DB9L, 0x1AC15BB4L, 0xD39EB8FCL,0xED545578L, 0x08FCA5B5L, 0xD83D7CD3L, 0x4DAD0FC4L,0x1E50EF5EL, 0xB161E6F8L, 0xA28514D9L, 0x6C51133CL,0x6FD5C7E7L, 0x56E14EC4L, 0x362ABFCEL, 0xDDC6C837L,0xD79A3234L, 0x92638212L, 0x670EFA8EL, 0x406000E0L },{ 0x3A39CE37L, 0xD3FAF5CFL, 0xABC27737L, 0x5AC52D1BL,0x5CB0679EL, 0x4FA33742L, 0xD3822740L, 0x99BC9BBEL,0xD5118E9DL, 0xBF0F7315L, 0xD62D1C7EL, 0xC700C47BL,0xB78C1B6BL, 0x21A19045L, 0xB26EB1BEL, 0x6A366EB4L,0x5748AB2FL, 0xBC946E79L, 0xC6A376D2L, 0x6549C2C8L,0x530FF8EEL, 0x468DDE7DL, 0xD5730A1DL, 0x4CD04DC6L,0x2939BBDBL, 0xA9BA4650L, 0xAC9526E8L, 0xBE5EE304L,0xA1FAD5F0L, 0x6A2D519AL, 0x63EF8CE2L, 0x9A86EE22L,0xC089C2B8L, 0x43242EF6L, 0xA51E03AAL, 0x9CF2D0A4L,0x83C061BAL, 0x9BE96A4DL, 0x8FE51550L, 0xBA645BD6L,0x2826A2F9L, 0xA73A3AE1L, 0x4BA99586L, 0xEF5562E9L,0xC72FEFD3L, 0xF752F7DAL, 0x3F046F69L, 0x77FA0A59L,0x80E4A915L, 0x87B08601L, 0x9B09E6ADL, 0x3B3EE593L,0xE990FD5AL, 0x9E34D797L, 0x2CF0B7D9L, 0x022B8B51L,0x96D5AC3AL, 0x017DA67DL, 0xD1CF3ED6L, 0x7C7D2D28L,0x1F9F25CFL, 0xADF2B89BL, 0x5AD6B472L, 0x5A88F54CL,0xE029AC71L, 0xE019A5E6L, 0x47B0ACFDL, 0xED93FA9BL,0xE8D3C48DL, 0x283B57CCL, 0xF8D56629L, 0x79132E28L,0x785F0191L, 0xED756055L, 0xF7960E44L, 0xE3D35E8CL,0x15056DD4L, 0x88F46DBAL, 0x03A16125L, 0x0564F0BDL,0xC3EB9E15L, 0x3C9057A2L, 0x97271AECL, 0xA93A072AL,0x1B3F6D9BL, 0x1E6321F5L, 0xF59C66FBL, 0x26DCF319L,0x7533D928L, 0xB155FDF5L, 0x03563482L, 0x8ABA3CBBL,0x28517711L, 0xC20AD9F8L, 0xABCC5167L, 0xCCAD925FL,0x4DE81751L, 0x3830DC8EL, 0x379D5862L, 0x9320F991L,0xEA7A90C2L, 0xFB3E7BCEL, 0x5121CE64L, 0x774FBE32L,0xA8B6E37EL, 0xC3293D46L, 0x48DE5369L, 0x6413E680L,0xA2AE0810L, 0xDD6DB224L, 0x69852DFDL, 0x09072166L,0xB39A460AL, 0x6445C0DDL, 0x586CDECFL, 0x1C20C8AEL,0x5BBEF7DDL, 0x1B588D40L, 0xCCD2017FL, 0x6BB4E3BBL,0xDDA26A7EL, 0x3A59FF45L, 0x3E350A44L, 0xBCB4CDD5L,0x72EACEA8L, 0xFA6484BBL, 0x8D6612AEL, 0xBF3C6F47L,0xD29BE463L, 0x542F5D9EL, 0xAEC2771BL, 0xF64E6370L,0x740E0D8DL, 0xE75B1357L, 0xF8721671L, 0xAF537D5DL,0x4040CB08L, 0x4EB4E2CCL, 0x34D2466AL, 0x0115AF84L,0xE1B00428L, 0x95983A1DL, 0x06B89FB4L, 0xCE6EA048L,0x6F3F3B82L, 0x3520AB82L, 0x011A1D4BL, 0x277227F8L,0x611560B1L, 0xE7933FDCL, 0xBB3A792BL, 0x344525BDL,0xA08839E1L, 0x51CE794BL, 0x2F32C9B7L, 0xA01FBAC9L,0xE01CC87EL, 0xBCC7D1F6L, 0xCF0111C3L, 0xA1E8AAC7L,0x1A908749L, 0xD44FBD9AL, 0xD0DADECBL, 0xD50ADA38L,0x0339C32AL, 0xC6913667L, 0x8DF9317CL, 0xE0B12B4FL,0xF79E59B7L, 0x43F5BB3AL, 0xF2D519FFL, 0x27D9459CL,0xBF97222CL, 0x15E6FC2AL, 0x0F91FC71L, 0x9B941525L,0xFAE59361L, 0xCEB69CEBL, 0xC2A86459L, 0x12BAA8D1L,0xB6C1075EL, 0xE3056A0CL, 0x10D25065L, 0xCB03A442L,0xE0EC6E0EL, 0x1698DB3BL, 0x4C98A0BEL, 0x3278E964L,0x9F1F9532L, 0xE0D392DFL, 0xD3A0342BL, 0x8971F21EL,0x1B0A7441L, 0x4BA3348CL, 0xC5BE7120L, 0xC37632D8L,0xDF359F8DL, 0x9B992F2EL, 0xE60B6F47L, 0x0FE3F11DL,0xE54CDA54L, 0x1EDAD891L, 0xCE6279CFL, 0xCD3E7E6FL,0x1618B166L, 0xFD2C1D05L, 0x848FD2C5L, 0xF6FB2299L,0xF523F357L, 0xA6327623L, 0x93A83531L, 0x56CCCD02L,0xACF08162L, 0x5A75EBB5L, 0x6E163697L, 0x88D273CCL,0xDE966292L, 0x81B949D0L, 0x4C50901BL, 0x71C65614L,0xE6C6C7BDL, 0x327A140AL, 0x45E1D006L, 0xC3F27B9AL,0xC9AA53FDL, 0x62A80F00L, 0xBB25BFE2L, 0x35BDD2F6L,0x71126905L, 0xB2040222L, 0xB6CBCF7CL, 0xCD769C2BL,0x53113EC0L, 0x1640E3D3L, 0x38ABBD60L, 0x2547ADF0L,0xBA38209CL, 0xF746CE76L, 0x77AFA1C5L, 0x20756060L,0x85CBFE4EL, 0x8AE88DD8L, 0x7AAAF9B0L, 0x4CF9AA7EL,0x1948C25CL, 0x02FB8A8CL, 0x01C36AE4L, 0xD6EBE1F9L,0x90D4F869L, 0xA65CDEA0L, 0x3F09252DL, 0xC208E69FL,0xB74E6132L, 0xCE77E25BL, 0x578FDFE3L, 0x3AC372E6L }};#define N 16//定义初始化需要用到的加密结构typedef struct _BLOWFISH_CTX{//定义初始化的pbox 以及 sbox 在程序中进行初始化unsigned int pbox[N + 2]; //总共18unsigned int sbox[4][256];}BLOWFISH_CTX, * PBLOWFISH_CTX;/*初始化函数 此函数功能如下1.接受key 与 keylen参数（当然keylen）可以自己计算2.初始化sbox 将全局的sbox的内容复制到CTX中的sbox中3.初始化pbox pbox的初始化方法如下1.迭代18论。然后每一轮都设置CTX的pbox2.CTX.pbox需要使用全局pbox ^ data3.data是一个四字节整数。其中存储的就是key的四个字节。key = "12345678abc"每一轮中 data = "1234"data = "5678"data = "abc1" //注意这里当超出keylen的时候。 data获取的key要从0开始。。。。*/int BlowFishInit(BLOWFISH_CTX* blowCtx, unsigned char* key, unsigned int keylen);/*F函数F函数是将一个32位数分别进行拆分。 拆分为四组。 每一组都作为sbox的索引值然后进行下列运算(（s1[a] + s2[b]) ^ s3[c]) + s4[d]在编程中sbox是数组是从零开始。 所以s1 对应s[0] s2对应s[1]在编程中总结下公式：temap = s[0][a] + s[1][b]teamp = temp ^ s[2][c]'temp = temp + s[3][d]简单的记住就是 ((a+b) ^ c)+d;当然每个都对应下标为 0 1 2 3 s[0][a] s[1][b] s[2][c] s[3][d]最后返回结果值 return temp*/static unsigned long F(BLOWFISH_CTX* ctx, unsigned long x);//signed int F(PBLOWFISH_CTX blowCtx,unsigned int Data);/*加密函数：首次用在初始化中是对一个64位0进行加密。一次加密八个字节核心思想为 加密左边与右边数据左边数据直接 ^ PBOX右边数据 = 右边数据 ^ f(左边数据）然后进行交换。以上是16轮的交换剩下一轮则是左边 = 左边^PBOX[N+1]右边 = 右边^pbox[N]最后设置相关数值*/void BlowFish_Encry(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right);/*跟加密一样。只不过结果相反步骤如下：首先遍历从最后一轮开始逐次递减最后一轮数据 右边= 右边^PBOX[1] 左边数据 = 左边数据 ^pbox[0]*/void BlowFish_Decrypt(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;算是总结和反思吧&lt;/p&gt;
&lt;h1 id=&quot;hardened&quot;&gt;&lt;a href=&quot;#hardened&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>AES</title>
    <link href="https://gift1a.github.io/2022/02/08/AES/"/>
    <id>https://gift1a.github.io/2022/02/08/AES/</id>
    <published>2022-02-08T04:10:56.000Z</published>
    <updated>2022-03-11T05:09:29.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>AES属于分组加密算法，即加解密都是使用同一密钥，但是是分为几组进行加密</p><p>明文长度固定为128位的倍数</p><p>密钥长度可以是128、192、256位</p><h1 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h1><p><img src="/2022/02/08/AES/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"></p><h2 id="初始变换"><a href="#初始变换" class="headerlink" title="初始变换"></a>初始变换</h2><p>这里以16字节为例子</p><p>明文放入矩阵中</p><p><img src="/2022/02/08/AES/1644303811694.png"></p><p>子密钥放入矩阵，这里有省略号是因为后面会根据子密钥进行密钥扩展，初始变换取得是密钥扩展后的第0轮密钥</p><p><img src="/2022/02/08/AES/1644303864629.png"></p><p>明文矩阵和子密钥矩阵进行异或</p><p>对应位置进行逐字节异或</p><p><img src="/2022/02/08/AES/1644304005507.png"></p><h2 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h2><p>AES算法会生成一个Sbox盒用于字节代换</p><p>代换方法：假如某个字节是D4，那么找到D4的位置，xy坐标结合就是代换后的结果，这里为19</p><p><img src="/2022/02/08/AES/1644304381876.png"></p><h2 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h2><p><img src="/2022/02/08/AES/1644304702612.png"></p><h2 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h2><p>将输入的4×4矩阵<strong>左乘</strong>一个给定的4×4矩阵</p><p>这里的+和×和矩阵里面的运算不同，待会介绍</p><p>给定的正矩阵</p><p><img src="/2022/02/08/AES/1644304934448.png"></p><p>过程</p><p><img src="/2022/02/08/AES/1644305201031.png"></p><h3 id="列混合计算"><a href="#列混合计算" class="headerlink" title="列混合计算"></a>列混合计算</h3><p>基于有限域的二维运算</p><h4 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h4><p><img src="/2022/02/08/AES/1644308359054.png"></p><p>要得到第一个数的结果，要先将第一个矩阵的第一行与第二个矩阵的第一列进行乘法，最后相加</p><p>而在列混合中，加法被替换成了异或</p><p>乘法也被修改了</p><p><img src="/2022/02/08/AES/1644308799475.png"></p><p>这里以第一个数为例</p><p>02×d4+03×bf+01×5d+01×30，这里的+是异或</p><p>02×d4过程</p><p>00000010×11010100，因为d4首位是1，所以结果为10101000^00011011,得到10110011</p><p>同理的到第一个数为04</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>每一列进行进行异或操作</p><p><img src="/2022/02/08/AES/1644306385450.png"></p><h2 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h2><p>通过子密钥生成十轮需要的密钥</p><h3 id="i不是4的倍数"><a href="#i不是4的倍数" class="headerlink" title="i不是4的倍数"></a>i不是4的倍数</h3><p>第i列计算公式：</p><p>W[i]=W[i-4]^W[i-1]</p><p><img src="/2022/02/08/AES/1644307284515.png"></p><h3 id="i是4的倍数"><a href="#i是4的倍数" class="headerlink" title="i是4的倍数"></a>i是4的倍数</h3><p>W[i]=W[i-4]^T(W[i-1])</p><p>T函数包括三部分：字循环、字节代换、轮常量异或</p><h4 id="字循环"><a href="#字循环" class="headerlink" title="字循环"></a>字循环</h4><p>将一列中的四个字节循环左移一个字节，即输入[b0,b1,b2,b3]变换成[b1,b2,b3,b0],然后放在一列中</p><p><img src="/2022/02/08/AES/1644307546072.png"></p><h4 id="字节代换-1"><a href="#字节代换-1" class="headerlink" title="字节代换"></a>字节代换</h4><p>对字循环的结果使用S盒进行字节代换</p><p><img src="/2022/02/08/AES/1644307740839.png"></p><h4 id="轮常量异或"><a href="#轮常量异或" class="headerlink" title="轮常量异或"></a>轮常量异或</h4><p>将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。</p><p>轮常量是给定的，因为要生成十个轮密钥，所以有十个轮常量</p><p><img src="/2022/02/08/AES/1644307898552.png"></p><p>过程</p><p><img src="/2022/02/08/AES/1644308032666.png"></p><p>最后，将得到的结果和W[i-4]异或即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h1&gt;&lt;p&gt;AES属于分组加密算法，即加解密都是使用同一密钥，但是是分为几组进行加密&lt;/p&gt;
&lt;p&gt;明文长度固定为128位的倍数&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Tea、XTea、XXTea原理和实现</title>
    <link href="https://gift1a.github.io/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-02-07T06:39:10.000Z</published>
    <updated>2022-03-11T05:12:53.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h1><p>1、特征量（一般是0x9e3779b9，它是黄金分割数和232的乘积），可以替换成其他的值，但是可能会出现问题</p><p>2、主要加密部分进行异或和移位操作（一般都存在&lt;&lt;4、&gt;&gt;5）</p><p>3、key为128bit</p><h1 id="Tea"><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h1><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p>数组的奇数下标元素从右侧传入后进行了移位异或和相加操作，最后偶数下标加上上面操作完的值，所以可以把等式右边看成一个常数，这样写逆向脚本好理解</p><p>结束第一步之后，奇数下标元素的偶数下标元素进行置换，再对奇数下标进行相同的加密</p><p>第三步就是sum+=Delta</p><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/OIP-C.jfif"> </p><h2 id="加密代码"><a href="#加密代码" class="headerlink" title="加密代码"></a>加密代码</h2><pre class="language-c" data-language="c"><code class="language-c">int main(){unsigned int Data[8] = { 0 };unsigned int key[4] = { 0 };unsigned int tmp[2] = { 0 };unsigned int sum = 0;unsigned int delta = 0x9e3779b9;for (int i = 0; i &lt; 8; i += 2){tmp[0] = Data[i];tmp[1] = Data[i + 1];        sum=0;for (int i = 0; i &lt; 32; ++i){sum += delta;tmp[0] += ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);tmp[1] += ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);}Data[i] = tmp[i];Data[i + 1] = tmp[i + 1];}return 0;}</code></pre><h3 id="解密代码"><a href="#解密代码" class="headerlink" title="解密代码"></a>解密代码</h3><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include &lt;stdio.h&gt;int main(){unsigned int Data[8] = { 0 };unsigned int key[4] = { 0 };unsigned int tmp[2] = { 0 };unsigned int sum = 0;unsigned int delta = 0x9e3779b9;for (int i = 0; i &lt; 8; i += 2){tmp[0] = Data[i];tmp[1] = Data[i + 1];sum = delta*32;for (int i = 0; i &lt; 32; ++i){tmp[1] -= ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);tmp[0] -= ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);sum -= delta;}Data[i] = tmp[i];Data[i + 1] = tmp[i + 1];}return 0;}</code></pre><p>解密的时候主要是要找到Key和密文，并且可能会有大小端序的问题</p><h1 id="XTea"><a href="#XTea" class="headerlink" title="XTea"></a>XTea</h1><p>Xtea是Tea的升级版，添加了一些移位和异或操作</p><h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/20190112131633-3a396138-1629-1.png"> </p><p>因为加密过程实际上没发生太多变化，就不贴加密和解密的代码了</p><h1 id="XXTea"><a href="#XXTea" class="headerlink" title="XXTea"></a>XXTea</h1><h2 id="加密流程-2"><a href="#加密流程-2" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/921830_48K7JHRW383FZWR.jpg"> </p><h2 id="加解密代码"><a href="#加解密代码" class="headerlink" title="加解密代码"></a>加解密代码</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9            //固定的一个常量#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组{                                                      //n为数组的长度    uint32_t y, z, sum;                                //无符号整型         unsigned p, rounds, e;                                if (n &gt; 1)            /* Coding Part */       {        rounds = 6 + 52/n;               //固定的得出轮数        sum = 0;                                z = v[n-1];                             do        {            sum += DELTA;                //每次进行叠加            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算            for (p=0; p&lt;n-1; p++)                   {                y = v[p+1];                v[p] += MX;                      z = v[p];                             }            y = v[0];            z = v[n-1] += MX;        }        while (--rounds);    }    else if (n &lt; -1)      /* Decoding Part */    {        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        y = v[0];        do        {            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            {                z = v[p-1];                y = v[p] -= MX;            }            z = v[n-1];            y = v[0] -= MX;            sum -= DELTA;        }        while (--rounds);    }} int main(){    uint32_t v[2]= {1,2};    uint32_t const k[4]= {2,2,3,4};    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密    // v为要加密的数据是两个32位无符号整数  // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位    printf("加密前原始数据：%u %u\n",v[0],v[1]);    btea(v, n, k);    printf("加密后的数据：%u %u\n",v[0],v[1]);    btea(v, -n, k);    printf("解密后的数据：%u %u\n",v[0],v[1]);    return 0;}</code></pre><p>还没实现过，看着流程图不知道怎么入手</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;共同点&quot;&gt;&lt;a href=&quot;#共同点&quot; class=&quot;headerlink&quot; title=&quot;共同点&quot;&gt;&lt;/a&gt;共同点&lt;/h1&gt;&lt;p&gt;1、特征量（一般是0x9e3779b9，它是黄金分割数和232的乘积），可以替换成其他的值，但是可能会出现问题&lt;/p&gt;
&lt;p&gt;2、主</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>RC4原理和实现</title>
    <link href="https://gift1a.github.io/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://gift1a.github.io/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-02-06T14:23:15.000Z</published>
    <updated>2022-03-11T05:12:26.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>RC4属于对称密码算法中的流密码加密算法</p><p>密钥长度可变，面向字节操作</p><p>以一个足够大的S表为基础，对表进行非线性变换，产生密钥流</p><p>两次交换过程是为了增加随机性</p><h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><h2 id="初始化S表"><a href="#初始化S表" class="headerlink" title="初始化S表"></a>初始化S表</h2><p>1、对S表进行先行填充，一般为256字节，且为unsigned类型</p><p>2、用种子密钥填充另一个256字节的K表</p><p>如果种子密钥长度不为256，将循环使用种子密钥对K表进行填充</p><p>3、用 K表对S表进行初始置换</p><h3 id="样例展示"><a href="#样例展示" class="headerlink" title="样例展示"></a>样例展示</h3><p>这里我们假设S表和K表都是7个字节的，密钥为345，填充结果如下</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168199163.png"></p><p>使用K表对S表进行置换</p><pre class="language-c" data-language="c"><code class="language-c">int j = 0;for (int i = 0; i &lt; 7; ++i){j = (j + S[i] + K[i]) % 7;Swap(S[i], S[j]);}</code></pre><p>得到被置换后的S表</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168394862.png"></p><h2 id="生成密钥流"><a href="#生成密钥流" class="headerlink" title="生成密钥流"></a>生成密钥流</h2><p>作用：为每个待价密的字节生成一个伪随机数，用来异或</p><p>注：S表完成初始化之后，种子密钥将不会再被使用</p><p>使用置换后的S表生成密钥流</p><pre class="language-c" data-language="c"><code class="language-c">int i, j = 0;for (int k = 0; k &lt; strlen(raw); ++k){i = (i + 1) % 7;j = (j + S[i]) % 7;Swap(S[i], S[j]);int t = (S[i] + S[j]) % 7;K[k] = S[t];}</code></pre><h1 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h1><p>密钥流和明文进行异或得到密文</p><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>加密部分的j是用来打乱的，实现伪随机</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;void Rc4_init(unsigned char* S, unsigned char*K,unsigned char* key, unsigned long len){unsigned char  tmp = 0;for (int i = 0; i &lt; 256; ++i){S[i] = i;K[i] = key[i % len];}int j = 0;for (int i = 0; i &lt; 256; ++i){j = (j + S[i] + K[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;}return;}void Rc4_encrypt(unsigned char* S, unsigned  char* flag,int len){int i = 0, j = 0,t = 0 ;unsigned char key_liu[len] = { 0 };unsigned char tmp = 0;for (unsigned long k = 0; k &lt; len; ++k){i = (i + 1) % 256;j = (j + S[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;t = (S[i] + S[j]) % 256;key_liu[k] = S[t];}for (int i = 0; i &lt; len; ++i){flag[i] ^= key_liu[i];}}int main(){unsigned char S[256] = { 0 };unsigned char K[256] = { 0 };char flag[512] = { 0xB6, 0x94, 0xFA, 0x8F, 0x3D, 0x5F, 0xB2, 0xE0,0xEA, 0x0F, 0xD2, 0x66, 0x98, 0x6C, 0x9D, 0xE7,0x1B, 0x08, 0x40, 0x71, 0xC5, 0xBE, 0x6F, 0x6D,0x7C, 0x7B, 0x09, 0x8D, 0xA8, 0xBD, 0xF3, 0xF6};char key[] = "w0wy0ugot1t";unsigned long Len = strlen(flag);Rc4_init(S, K,(unsigned char*)key, strlen(key));Rc4_encrypt(S, (unsigned char*)flag, Len);printf("%s", flag);return 0;}</code></pre><p>可以不保存密钥流，直接进行异或，逆向的时候我们可以动调得到密钥流，再与密文进行异或就可以得到明文了</p><pre class="language-c" data-language="c"><code class="language-c">void Rc4_encrypt(unsigned char* S, unsigned  char* flag,char*flag1){int len = strlen(flag1);int i = 0, j = 0,t = 0 ;unsigned char tmp = 0;for (unsigned long k = 0; k &lt; len; ++k){i = (i + 1) % 256;j = (j + S[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;t = (S[i] + S[j]) % 256;flag[k] ^= S[t];}}</code></pre><p>分别看一下加密过程的逆向代码</p><p>直接异或，动调根据存储的寄存器进行提取</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, char *a3){  unsigned int v3; // eax  unsigned __int8 v4; // ST2B_1  __int64 result; // rax  unsigned int v6; // [rsp+30h] [rbp-10h]  unsigned int i; // [rsp+34h] [rbp-Ch]  int v8; // [rsp+38h] [rbp-8h]  signed int v9; // [rsp+3Ch] [rbp-4h]  unsigned __int8 *v10; // [rsp+50h] [rbp+10h]  unsigned __int8 *v11; // [rsp+58h] [rbp+18h]  v10 = a1;  v11 = a2;  v6 = strlen(a3);  v9 = 0;  v8 = 0;  for ( i = 0; ; ++i )  {    result = v6;    if ( v6 &lt;= i )      break;    v9 = (unsigned __int8)(((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24) + v9 + 1) - ((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24);    v3 = (unsigned int)((v8 + v10[v9]) &gt;&gt; 31) &gt;&gt; 24;    v8 = (unsigned __int8)(v3 + v8 + v10[v9]) - v3;    v4 = v10[v9];    v10[v9] = v10[v8];    v10[v8] = v4;    v11[i] ^= v10[(unsigned __int8)(v10[v9] + v10[v8])];  }  return result;}</code></pre><p>先保存再异或</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3){  void *v3; // rsp  char *v4; // rax  signed __int64 i; // rdx  unsigned int v6; // eax  __int64 result; // rax  __int64 v8; // [rsp+0h] [rbp-30h]  __int64 *v9; // [rsp+8h] [rbp-28h]  __int64 v10; // [rsp+10h] [rbp-20h]  int v11; // [rsp+1Ch] [rbp-14h]  unsigned int k; // [rsp+20h] [rbp-10h]  unsigned int j; // [rsp+24h] [rbp-Ch]  unsigned int v14; // [rsp+28h] [rbp-8h]  unsigned int v15; // [rsp+2Ch] [rbp-4h]  unsigned __int8 *v16; // [rsp+58h] [rbp+28h]  v16 = a2;  v15 = 0;  v14 = 0;  v11 = 0;  v10 = a3 - 1i64;  v3 = alloca(16 * ((unsigned __int64)(a3 + 15i64) &gt;&gt; 4));  v9 = &amp;v8;  LOBYTE(v8) = 0;  v4 = (char *)&amp;v8 + 1;  for ( i = a3 - 2i64; i != -1; --i )    *v4++ = 0;  HIBYTE(v8) = 0;  for ( j = 0; a3 &gt; j; ++j )  {    v15 = (unsigned __int8)(((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24) + v15 + 1)        - ((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24);    v6 = (unsigned int)((signed int)(v14 + a1[v15]) &gt;&gt; 31) &gt;&gt; 24;    v14 = (unsigned __int8)(v6 + v14 + a1[v15]) - v6;    HIBYTE(v8) = a1[v15];    a1[v15] = a1[v14];    a1[v14] = HIBYTE(v8);    v11 = (unsigned __int8)(a1[v15] + a1[v14]);    *((_BYTE *)v9 + j) = a1[v11];  }  for ( k = 0; ; ++k )  {    result = k;    if ( (signed int)k &gt;= a3 )      break;    v16[k] ^= *((_BYTE *)v9 + (signed int)k);  }  return result;}</code></pre><p>可以看到密钥流存储在v9，动调之后可以直接提取</p><p>Vs2022生成的exe文件反编译</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall sub_140015E30(__int64 a1, __int64 a2, char *a3){  __int64 result; // rax  __int64 v4; // kr00_8  unsigned __int8 v5; // dl  char v6; // STA4_1  int v7; // edx  unsigned int v8; // [rsp+24h] [rbp+4h]  int v9; // [rsp+44h] [rbp+24h]  int v10; // [rsp+64h] [rbp+44h]  unsigned int i; // [rsp+C4h] [rbp+A4h]  __int64 v12; // [rsp+1C0h] [rbp+1A0h]  __int64 v13; // [rsp+1C8h] [rbp+1A8h]  const char *Str; // [rsp+1D0h] [rbp+1B0h]  Str = a3;  v13 = a2;  v12 = a1;  sub_140011361(&amp;unk_14002200E);  v8 = j_strlen(Str);  v9 = 0;  v10 = 0;  for ( i = 0; ; ++i )  {    result = v8;    if ( i &gt;= v8 )      break;    v4 = v9 + 1;    v9 = (BYTE4(v4) + v9 + 1) - BYTE4(v4);    v5 = (*(v12 + v9) + v10) &gt;&gt; 31;    v10 = (v5 + *(v12 + v9) + v10) - v5;    v6 = *(v12 + v9);    *(v12 + v9) = *(v12 + v10);    *(v12 + v10) = v6;    v7 = (*(v12 + v10) + *(v12 + v9)) &gt;&gt; 31;    *(v13 + i) ^= *(v12 + (v7 + *(v12 + v10) + *(v12 + v9)) - v7);  }  return result;}</code></pre><p>看着跟别的不一样</p><h1 id="题目——BUU-GUET-CTF2019-encrypt"><a href="#题目——BUU-GUET-CTF2019-encrypt" class="headerlink" title="题目——BUU-[GUET-CTF2019]encrypt"></a>题目——BUU-[GUET-CTF2019]encrypt</h1><p>拖进ida，对一些变量和函数名进行识别和改名</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644325364867.png"></p><p>点进加密函数进行查看</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339350075.png"></p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339358773.png"></p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339366532.png"></p><p>整体就是先RC4，然后将加密后的三个字符变为四个字符</p><p>逆向过来先将四个字符转为三个字符，然后直接将转换后的结果和密钥流进行异或得到明文</p><p>密钥流可以通过动调得到</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339479964.png"></p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char raw[52]={0x5a,    0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C,    0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C,    0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76,    0x5A, 0x45, 0x3D};char decode[39]={0};for(int i=0;i&lt;52;++i){raw[i]-=61;}for(int i=0,i_=0;i&lt;52;i+=4,i_+=3){decode[i_]=((raw[i])&lt;&lt;2)|((raw[i+1])&gt;&gt;4);decode[i_+1]=((raw[i+1]&amp;0xf)&lt;&lt;4)|((raw[i+2]&amp;0x3c)&gt;&gt;2);decode[i_+2]=((raw[i+2]&amp;0xF)&lt;&lt;6)|(raw[i+3]);}char v[90]={0x10,0x59,0x9C,0x92,0x06,0x22,0xCF,0xA5,0x72,0x1E,0x45,0x6A,0x06,0xCB,0x08,0xC3,0xE4,0x49,0x5A,0x63,0x0C,0xDF,0xF6,0x5F,0x08,0x28,0xBD,0xE2,0x10,0x15,0x1F,0x6E,0xAA,0x5A,0xCA,0xEC,0x80,0xAF,0x9B,0x16,0xBB,0x3D,0x13,0x2F,0x6A,0xA4,0xC7,0x2E,0xBC,0x4B,0x60,0x9A,0xAF,0xE9,0xCE,0xDA,0x67,0x39,0xBA,0x3B,0x85,0xEB,0xD2,0x6B,0xAB,0x06,0x6B,0x10,0x57,0x2C,0x88,0x70,0xF7,0x4F,0xAA,0x7F,0x12,0x47,0xD6,0xDE,0x74,0xB2,0x1D,0xA4,0xD7,0x76,0x9A,0xE0};for(int i=0;i&lt;39;++i){decode[i]^=v[i];}printf("%s",decode);return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h1&gt;&lt;p&gt;RC4属于对称密码算法中的流密码加密算法&lt;/p&gt;
&lt;p&gt;密钥长度可变，面向字节操作&lt;/p&gt;
&lt;p&gt;以一个足够大的S表为基础，</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>base64实现及细节剖析</title>
    <link href="https://gift1a.github.io/2022/02/06/base64%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/"/>
    <id>https://gift1a.github.io/2022/02/06/base64%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/</id>
    <published>2022-02-06T12:55:09.000Z</published>
    <updated>2022-03-11T05:09:48.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";void base64_encode(char raw[], char encode[]){int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){encode[i_] = base64_table[raw[i] &gt;&gt; 2];encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1] &amp; 0xf0) &gt;&gt; 4)];encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] &amp; 0xc0) &gt;&gt; 6)];encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];}if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}return;}int Findindex(char c){for (int i = 0; i &lt; strlen(base64_table); ++i){if (c == base64_table[i])return i;}}void base64_decode(char* encode, char* decode){int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;int i = 0, i_ = 0;for (; i &lt; encode_len; i_ += 4, i += 3){decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);decode[i + 2] = ((Findindex(encode[i_ + 2]) &amp; 0x3) &lt;&lt; 6) | ((Findindex(encode[i_ + 3])));}decode[decode_len] = 0;return;}int main(){char raw[] = "hgame{123456}";char encode[100] = { 0 };char decode[100] = { 0 };base64_encode(raw, encode);printf("%s", encode);base64_decode(encode, decode);printf("\n%s", decode);}</code></pre><h1 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h1><h2 id="编码部分"><a href="#编码部分" class="headerlink" title="编码部分"></a>编码部分</h2><h3 id="记录长度"><a href="#记录长度" class="headerlink" title="记录长度"></a>记录长度</h3><p>首先要先计算长度，base64就是将三个字节扩展为四个字节，所以要分成有余数和整除两种情况</p><pre class="language-c" data-language="c"><code class="language-c">int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;</code></pre><h3 id="编码部分-1"><a href="#编码部分-1" class="headerlink" title="编码部分"></a>编码部分</h3><p>首先先介绍一下两个工具，&amp;和|，和一些数据做&amp;运算可以取到我们想要的位，而|运算可以将两部分结合在一起</p><p>编码后的索引最多为六位，原先的数据可以是八位的</p><h4 id="encode-i"><a href="#encode-i" class="headerlink" title="encode[i]"></a>encode[i]</h4><p>这个其实是最好实现的，因为只需要取到前六位，所以直接&gt;&gt;2就可以实现</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_] = base64_table[raw[i] &gt;&gt; 2];</code></pre><h4 id="encode-i-1"><a href="#encode-i-1" class="headerlink" title="encode[i+1]"></a>encode[i+1]</h4><p>先明确我们的需求，从第一个数据获取最后的两位与第二个数据获取的前四位结合。需要用到&amp;，这里的结合就需要用到|。</p><p>首先要保证我们取到的是两位的，需要&amp;0x03</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>因为只有最后两位是1，根据按位&amp;，当有一个是0时运算后结果必定为0，所以就可以取到最后两位</p><p>下一步是移到正确的位置，需要用到位移运算符</p><p>这里第一个数的最后两位编码后是放在前面两位的位置，所以需要&lt;&lt;4</p><p>接下来取剩余的四位</p><p>剩余的四位来自第二个数的前四位</p><p>可以先&amp;0xf0使得后四位都为0，当然也可以不用，直接&gt;&gt;4</p><p>最后使用|结合起来</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>与</td><td>运</td><td>算</td><td></td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1]) &gt;&gt; 4)];</code></pre><h4 id="encode-i-2"><a href="#encode-i-2" class="headerlink" title="encode[i+2]"></a>encode[i+2]</h4><p>要用到第二个数据的后四位和第三个数据的前两位</p><p>同理，要保留第二个数据的后四位并且去除前四位，就需要&amp;0xf，移到正确的位置&lt;&lt;2，剩余两位留给第三个数据的前两位</p><p>要取到第三个数据的前两位</p><p>可以直接&gt;&gt;6保证前两位移动到最后的两位，也可以先用&amp;0xc0清除后四位，因为是00110000，最后结合起来就可以了</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] ) &gt;&gt; 6)];</code></pre><h4 id="encode-i-3"><a href="#encode-i-3" class="headerlink" title="encode[i+3]"></a>encode[i+3]</h4><p>只需要取到第三个数据的后六位就可以了</p><p>直接&amp;0x3f，因为0x3f的二进制是00111111</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];</code></pre><h4 id="填加"><a href="#填加" class="headerlink" title="填加="></a>填加=</h4><p>如果编码前的数据长度%3不等于0，需要使用=填充</p><p>如果多出一位的话，根据经过上述过程会变成两位，所以最后两位需要用到=来填充</p><p>多出两位，经过上述过程变成三位，所以只需填充最后一位为=</p><pre class="language-c" data-language="c"><code class="language-c">if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}</code></pre><h3 id="解码部分"><a href="#解码部分" class="headerlink" title="解码部分"></a>解码部分</h3><p>六位还原为八位</p><h4 id="去除"><a href="#去除" class="headerlink" title="去除="></a>去除=</h4><p>先计算解码后的长度，每四个对应三个，最后减去=的长度</p><pre class="language-c" data-language="c"><code class="language-c">int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;</code></pre><h4 id="decode-i"><a href="#decode-i" class="headerlink" title="decode[i]"></a>decode[i]</h4><p>其实和上面过程正好相反，取第一个编码数据的后六位（因为前两位是填充的0）和第二个编码数据的前两位，在此之前需要先去除前两位填充的0，所以要&amp;0x30，根据上面的过程，我们需要的是00110000，正好是0x30</p><p>再用|结合</p><pre class="language-c" data-language="c"><code class="language-c">decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;</code></pre><h4 id="decode-i-1"><a href="#decode-i-1" class="headerlink" title="decode[i+1]"></a>decode[i+1]</h4><p>需要第二个编码数据的后四位和第三个编码数据的前四位，也是需要先去除填充的0</p><p>所以第二个数据&amp;0xf保证取到后四位，&lt;&lt;4移到前四位</p><p>第三个数据&amp;0x3c（00111100）进行去除填充的前两位0以及取到需要的那四位，再&gt;&gt;2，最后使用|结合</p><pre class="language-c" data-language="c"><code class="language-c">decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);</code></pre><h4 id="decode-i-2"><a href="#decode-i-2" class="headerlink" title="decode[i+2]"></a>decode[i+2]</h4><p>第三个编码数据的后两位和第四个编码数据的那六位</p><p>和上述过程类似，就不赘述了</p><h4 id="字符数组结束"><a href="#字符数组结束" class="headerlink" title="字符数组结束"></a>字符数组结束</h4><p>最后记得填加字符数组结束符</p><pre class="language-c" data-language="c"><code class="language-c">decode[decode_len] = 0;</code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>base64还可以魔改，进行变表操作或者在编码过程中参杂异或（Dasctf2022）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h1&gt;&lt;pre class=&quot;language-c&quot; data-language=&quot;c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#inclu</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件手脱upx变形壳</title>
    <link href="https://gift1a.github.io/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/"/>
    <id>https://gift1a.github.io/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/</id>
    <published>2022-02-03T06:58:16.000Z</published>
    <updated>2022-03-11T05:10:23.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-hgame2022-week2-upx-magic1"><a href="#题目-hgame2022-week2-upx-magic1" class="headerlink" title="题目-hgame2022-week2-upx magic1"></a>题目-hgame2022-week2-upx magic1</h1><p>发现命令行脱壳没用，只能手脱，elf文件没办法使用esp定律，ida手脱</p><p>进入ida</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643878891388.png"></p><p>在第一个call下断点，进行动态调试</p><p>F7单步进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879064585.png"></p><p>到了第二个call再次F7进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879092434.png"></p><p>一路f8</p><p>retn后到</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879119459.png"></p><p>F7进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879160619.png"></p><p>有三个向上的跳转</p><p>在第三个跳转之后F4</p><p>一直F8到达程序真正的入口点</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879196863.png"></p><p>此时需要dumpfile</p><p>ALT+F7运行脚本，脚本需要修改后缀为idc</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;idc.idc&gt;#define PT_LOAD              1#define PT_DYNAMIC           2static main(void){         auto ImageBase,StartImg,EndImg;         auto e_phoff;         auto e_phnum,p_offset;         auto i,dumpfile;         ImageBase=0x400000;         StartImg=0x400000;         EndImg=0x0;         if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )  {    if(dumpfile=fopen("D:\\dumpfile2","wb"))//这路可以更改路径    {      e_phoff=ImageBase+Qword(ImageBase+0x20);      Message("e_phoff = 0x%x\n", e_phoff);      e_phnum=Word(ImageBase+0x38);      Message("e_phnum = 0x%x\n", e_phnum);      for(i=0;i&lt;e_phnum;i++)      {         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)                         {                                  p_offset=Qword(e_phoff+0x8);                                 StartImg=Qword(e_phoff+0x10);                                 EndImg=StartImg+Qword(e_phoff+0x28);                                 Message("start = 0x%x, end = 0x%x, offset = 0x%x\n", StartImg, EndImg, p_offset);                                 dump(dumpfile,StartImg,EndImg,p_offset);                                 Message("dump segment %d ok.\n",i);                         }             e_phoff=e_phoff+0x38;      }      fseek(dumpfile,0x3c,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fseek(dumpfile,0x28,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fclose(dumpfile);        }else Message("dump err."); }}static dump(dumpfile,startimg,endimg,offset) {        auto i;        auto size;        size=endimg-startimg;        fseek(dumpfile,offset,0);        for ( i=0; i &lt; size; i=i+1 )         {        fputc(Byte(startimg+i),dumpfile);        }}</code></pre><p>得到dumpfile2，拖进ida得到正常的代码</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879324566.png"></p><h3 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h3><p>这里要按位与上0xffff，因为这里最后只赋值了最后十六位，所以需要使用&amp;0xffff来限制位数，保证取到最后的十六位</p><p>有时候还存在左移溢出的问题：</p><p><a href="https://blog.csdn.net/u013658041/article/details/78116449">https://blog.csdn.net/u013658041/article/details/78116449</a></p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1644069404698.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt; #include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(){int s[]={0x8d68,0x9d49,0x2a12,0xab1a,0xcbdc,0xb92b,0x2e32,0x9f59,0xddcd,0x9d49,0xa90a,0xe70,0xf5cf,0x5ed5,0x3c03,0x7c87,0x2672,0xab1a,0xa50,0x5af5,0xff9f,0x9f59,0xbd0b,0x58e5,0x3823,0xbf1b,0x78a7,0xab1a,0x48c4,0xa90a,0x2c22,0x9f59,0x5cc5,0x5ed5,0x78a7,0x2672,0x5695};for(int i=0;i&lt;40;++i){for(int j=32;j&lt;=127;++j){int temp=(j&lt;&lt;8)&amp;0xffff;for(int  k=0;k&lt;8;++k){if((temp&amp;0x8000)!=0){temp=((2*temp)^0x1021)&amp;0xffff;}elsetemp=(2*temp)&amp;0xffff;}if(temp==s[i]){printf("%c",j);}}}return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目-hgame2022-week2-upx-magic1&quot;&gt;&lt;a href=&quot;#题目-hgame2022-week2-upx-magic1&quot; class=&quot;headerlink&quot; title=&quot;题目-hgame2022-week2-upx magic1&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Hook</title>
    <link href="https://gift1a.github.io/2022/02/03/Hook/"/>
    <id>https://gift1a.github.io/2022/02/03/Hook/</id>
    <published>2022-02-03T06:53:10.000Z</published>
    <updated>2022-03-11T05:11:47.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目-BUUCTF-easystrcmp"><a href="#题目-BUUCTF-easystrcmp" class="headerlink" title="题目-BUUCTF-easystrcmp"></a>题目-BUUCTF-easystrcmp</h1><p>进入主函数</p><p><img src="/2022/02/03/Hook/1643884712406.png"></p><p>看似是一个简单的比较，但是输入之后发现并不对</p><p>应该是做了什么处理，动态调试</p><p>点进strcmp函数</p><p><img src="/2022/02/03/Hook/1643884961802.png"></p><p>发现跳转到了加密函数</p><p>原理分析</p><p>因为存在init段，去查看函数</p><p><img src="/2022/02/03/Hook/1643885017644.png"></p><p>这样可以查看函数列表进行跳转</p><p><img src="/2022/02/03/Hook/1643885047181.png"></p><p>进入off函数</p><p><img src="/2022/02/03/Hook/1643885073169.png"></p><p>第一个函数点进去没发现什么，第二个函数点进去</p><p><img src="/2022/02/03/Hook/1643885101701.png"></p><p>可以看到先把strcmp函数的地址赋值给qword_201090</p><p>然后把sub_6EA函数赋值给off-102028,点进去</p><p><img src="/2022/02/03/Hook/1643885199097.png"></p><p>发现正好是strcmp的地址，所以真正运行起来，函数会跳转到sub_6EA函数中，而不是strcmp函数，这样就实现了一个简单的hook</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(){char flag[]="********CENSORED********";char s[]={0x42, 0x09,   0x4A, 0x49, 0x35, 0x43, 0x0A, 0x41, 0xF0, 0x19, 0xE6, 0x0B,   0xF5, 0xF2, 0x0E, 0x0B, 0x2B, 0x28, 0x35, 0x4A, 0x06, 0x3A,   0x0A, 0x4F};  for(int i=0;i&lt;strlen(flag);++i)  {  flag[i]+=s[i];  }  printf("%s",flag);return 0; } </code></pre><p><a href="https://www.cnblogs.com/iBinary/p/7599789.html%E5%85%B7%E4%BD%93%E8%AE%B2%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFHook">https://www.cnblogs.com/iBinary/p/7599789.html具体讲解什么是Hook</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目-BUUCTF-easystrcmp&quot;&gt;&lt;a href=&quot;#题目-BUUCTF-easystrcmp&quot; class=&quot;headerlink&quot; title=&quot;题目-BUUCTF-easystrcmp&quot;&gt;&lt;/a&gt;题目-BUUCTF-easystrcmp&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Init初始化</title>
    <link href="https://gift1a.github.io/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://gift1a.github.io/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-02-03T03:47:11.000Z</published>
    <updated>2022-03-11T05:11:54.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p><a href="https://carrychen.website/2021/05/14/elf-format/">https://carrychen.website/2021/05/14/elf-format/</a></p><p> .init节定义了一个_init函数，用于可执行目标文件开始时的初始化工作。当进入主程序之前，系统先执行.init节的指令代码初始化 </p><h1 id="例题-hgame2022-week2-fakeshell"><a href="#例题-hgame2022-week2-fakeshell" class="headerlink" title="例题-hgame2022-week2-fakeshell"></a>例题-hgame2022-week2-fakeshell</h1><p>先去看看init段进行了什么处理</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870839069.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870867197.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870876729.png"></p><p>在第二个函数发现了处理</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870922345.png"></p><p>查看aHappyh4me交叉引用</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870957940.png"></p><p>可以看到后面还有操作</p><p>定位到加密函数</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870991851.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643871002931.png"></p><p>可以知道是rc4加密，密钥在init段被修改了</p><p>写脚本，也可以使用工具CaptfEncoder-win-1.1.0</p><p>得到flag</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643871135186.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ELF文件结构&quot;&gt;&lt;a href=&quot;#ELF文件结构&quot; class=&quot;headerlink&quot; title=&quot;ELF文件结构&quot;&gt;&lt;/a&gt;ELF文件结构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://carrychen.website/2021/05/14/elf-</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>SEH原理和例题</title>
    <link href="https://gift1a.github.io/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/"/>
    <id>https://gift1a.github.io/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/</id>
    <published>2022-02-03T03:46:31.000Z</published>
    <updated>2022-03-11T05:12:39.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WINDOWS下的异常处理"><a href="#WINDOWS下的异常处理" class="headerlink" title="WINDOWS下的异常处理"></a>WINDOWS下的异常处理</h1><h2 id="异常列表"><a href="#异常列表" class="headerlink" title="异常列表"></a>异常列表</h2><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220203125855.jpg"></p><h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><p><a href="https://www.cnblogs.com/Sna1lGo/p/14732048.html#:~:text=Windows%E4%B8%AD,%E5%88%99%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E3%80%82%E4%BB%8B%E7%BB%8D">https://www.cnblogs.com/Sna1lGo/p/14732048.html#:~:text=Windows%E4%B8%AD,%E5%88%99%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E3%80%82介绍</a></p><h2 id="题目——hagme2022——week2——creakme2"><a href="#题目——hagme2022——week2——creakme2" class="headerlink" title="题目——hagme2022——week2——creakme2"></a>题目——hagme2022——week2——creakme2</h2><p>在静态分析中，只找到了tea加密算法，直接写脚本解不出来，去查看汇编代码（因为有时候ida没办法识别出一些汇编）</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643864939414.png"></p><p>第一个框对应上上面那句代码，这里按/就会显示出来对应反编译过来的伪代码</p><p>下面两个框的都是没被识别的语句</p><p>在图中位置下断点进行动态调试，会报错</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643865333034.png"></p><p>因为除数不能为0，去看看汇编</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643865908164.png"></p><p>按；写下注释</p><p>开始动态调试</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866006832.png"></p><p>选择yes，发现进入到这段未被反编译的语句</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866024820.png"></p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866787250.png"></p><p>第二次执行到这一段代码，可以看到ecx寄存器的值不是0，不会触发异常</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866890816.png"></p><p>发现没有执行异或，而是继续往下执行，这就是下一步进行的反汇编语句</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866944920.png"></p><p>因此可以知道，当变量num的最高位为0的时候，会触发异常，这时候系统会交给SEH进行处理，即__try代码</p><p>__except会执行异常后代码</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643867671850.png"></p><p>按空格查看执行顺序</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643867149242.png"></p><p>会发现这样一段独立出来的汇编代码</p><p>所以就可以写脚本，因为是unsigned int，右移31位就能知道最高位了</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    unsigned int tmp1, tmp2;    unsigned int num;    unsigned int init_num=0;    int Buf2[8] = { 0 };    unsigned int key[10] = { 1,2,3,4,5,6,7,8.9,0 };    Buf2[0] = 0x457E62CF;    Buf2[1] = 0x9537896C;    Buf2[2] = 0x1F7E7F72;    Buf2[3] = 0xF7A073D8;    Buf2[4] = 0x8E996868;    Buf2[5] = 0x40AFAF99;    Buf2[6] = 0xF990E34;    Buf2[7] = 0x196F4086;    for (int i = 0; i &lt; 32; i++)    {        init_num += 2654435761;        if ((init_num &gt;&gt;31) == 0)        {            init_num ^= 0x1234567;        }    }//0C78E4D05    for (int j = 0; j &lt; 8; j += 2)    {        tmp1 = Buf2[j], tmp2 = Buf2[j + 1];        num = init_num;        for (int i = 0; i &lt; 32; i++)        {            tmp2 -= (num + key[(num &gt;&gt; 11) &amp; 3]) ^ (tmp1 + ((16 * tmp1) ^ (tmp1 &gt;&gt; 5)));            if ((num&gt;&gt;31) == 0)            {                num ^= 0x01234567;            }            num -= 2654435761;            tmp1 -= (num + key[num &amp; 3]) ^ (tmp2 + ((16 * tmp2) ^ (tmp2 &gt;&gt; 5)));        }        Buf2[j] = tmp1;        Buf2[j + 1] = tmp2;    }    for (int i = 0; i &lt; 8; i++)    {        printf("%x\n", Buf2[i]);    }    printf("%s", Buf2);}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WINDOWS下的异常处理&quot;&gt;&lt;a href=&quot;#WINDOWS下的异常处理&quot; class=&quot;headerlink&quot; title=&quot;WINDOWS下的异常处理&quot;&gt;&lt;/a&gt;WINDOWS下的异常处理&lt;/h1&gt;&lt;h2 id=&quot;异常列表&quot;&gt;&lt;a href=&quot;#异常列表&quot;</summary>
      
    
    
    
    
    <category term="PE" scheme="https://gift1a.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>C语言汇编2</title>
    <link href="https://gift1a.github.io/2022/02/02/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%962/"/>
    <id>https://gift1a.github.io/2022/02/02/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%962/</id>
    <published>2022-02-01T16:04:39.000Z</published>
    <updated>2022-03-11T05:10:10.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指针&quot;&gt;&lt;a href=&quot;#指针&quot; class=&quot;headerlink&quot; title=&quot;指针&quot;&gt;&lt;/a&gt;指针&lt;/h1&gt;</summary>
      
    
    
    
    
    <category term="汇编" scheme="https://gift1a.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>VM逆向</title>
    <link href="https://gift1a.github.io/2022/01/23/VM%E9%80%86%E5%90%91/"/>
    <id>https://gift1a.github.io/2022/01/23/VM%E9%80%86%E5%90%91/</id>
    <published>2022-01-23T15:21:28.000Z</published>
    <updated>2022-03-11T05:13:03.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dasctf——EasyVm"><a href="#Dasctf——EasyVm" class="headerlink" title="Dasctf——EasyVm"></a>Dasctf——EasyVm</h1><p>一开始有个花指令，是比较常见的永真跳转，先对call指令按u取消定义，将e8改为90，再重新弄成函数就可以了</p><p>先找到加密的函数</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951424173.png"></p><p>点进去看看</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951469199.png"></p><p>这里是base64变种，在最后加了一个异或操作，先把脚本写出来</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);/*while (code[len] != '!' &amp;&amp; code[len] != 0){len++;}*/for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i]^0xa, b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1]^0xb, b64_table) &amp; 0x30) &gt;&gt; 4;str[i_ + 1] = (findIndex(memstr[i + 1]^0xb, b64_table) &amp; 0xf) &lt;&lt; 4 | (findIndex(memstr[i + 2]^0xc, b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2]^0xc, b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3]^0xd, b64_table));}int str_len = (len / 4) * 3 + len % 4;if (len % 4){str_len -= 1;}str[str_len] = 0;return str;}int main(){char code[100] = "";char decode[] = { 0 };base64_decode(code, decode, base64_table);printf("%s", decode);return 0;}</code></pre><p>接下来就是vm的部分</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951694407.png"></p><p>先看func函数的类型，是指针数组</p><p>这里需要结合动调看每条指令对应的操作</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642953729321.png"></p><p>在这里下断点之后F7进入函数</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642953871966.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955403773.png"></p><p>这就是func数组存放的东西，因为是指针，所以要先按d转为dd才会显示</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955602049.png"></p><p>先把指令提取出来</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char ida_chars[] ={  0xCA, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 0x00,  0xCC, 0xCF, 0xC9, 0xEE, 0x00, 0x00, 0x00, 0xCF, 0xD1, 0xD3,  0x01, 0xFE, 0xC2, 0xD2, 0x39, 0x00, 0x00, 0x00, 0xD4, 0xEC,  0xFF, 0x00};</code></pre><p>F8单步调试</p><p>0xCA</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955631076.png"></p><p>0xCB</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955978948.png"></p><p>0xCC</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955994447.png"></p><p>0xCF</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956392630.png"></p><p>每执行完再进入func[2]都能知道当前位置，便于查看指令</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956568041.png"></p><p>0xc9</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956806744.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957130761.png"></p><p>0xd1</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957467393.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957487310.png"></p><p>这里本来赋值为0，1，2，为了保持字符相等的情况，把 this[5]全部赋值为1</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642987459030.png"></p><p>0xd3</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988305784.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988338522.png"></p><p>0xc2</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988366450.png"></p><p>0xd2</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988655617.png"></p><p>长度判断</p><p>0xd4</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988824766.png"></p><p>0xcc</p><p>接下来又回到0xcc，所以就能猜测是循环做了异或操作，然后判断</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642989162099.png"></p><table><thead><tr><th>func[1]</th><th>指令集</th></tr></thead><tbody><tr><td>func[2]</td><td>加密后的flag的字符</td></tr><tr><td>func[3]</td><td>0</td></tr><tr><td>func[4]</td><td>索引</td></tr><tr><td>func[5]</td><td>判断字符相等</td></tr><tr><td>func[6]</td><td>对比的flag</td></tr><tr><td>func[7]</td><td>0</td></tr><tr><td>func[8]</td><td>加密后的字符串</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>0xca</td><td>先将this[1]指令后的数据存放到this[3]，然后往后跳转5，正好对应了下一条指令,一开始this[1]后一个数据为0，要先转为 dword</td></tr><tr><td></td><td></td></tr><tr><td>0xcb</td><td>先将this[1]指令后的数据存放到this[4]，然后往后跳转5，这也是下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xcc</td><td>把this[2]先赋值为this[8]+this[4]，这里this[4]是个整数，所以猜测this[4]是索引，然后继续执行下一指令</td></tr><tr><td></td><td></td></tr><tr><td>0xcf</td><td>将this[3]和this[2]的值异或后存放在this[3],进入下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xc9</td><td>先把this[1]下一个数据赋值给this[2],进入下一条指令，也就是0xee</td></tr><tr><td></td><td></td></tr><tr><td>0xcf</td><td>将this[3]和this[2]的值异或后存放在this[3],进入下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xd1</td><td>根据this[4]的索引来进行字符比较，这里是调试过程，所以为了进行下一步，需要修改汇编指令</td></tr><tr><td></td><td></td></tr><tr><td>0xd3</td><td>v1是指针，解引用是v1下一个位置，也就是0x1，整个就是0xee，这时候然后指向下三个位置，也就是c2指令</td></tr><tr><td></td><td></td></tr><tr><td>0xc2</td><td>索引this[4]+1</td></tr><tr><td></td><td></td></tr><tr><td>0xd2</td><td>this[4]是索引，所以是判断是否结束，这里没结束，所以this[5]赋值为0</td></tr><tr><td></td><td></td></tr><tr><td>0xd4</td><td>ec+2==ee</td></tr></tbody></table><p>整个过程就是这样</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220124125427.jpg"></p><p>因为偶数次的异或等于不变，所以只需对奇数次的进行异或即可</p><p>最终脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);/*while (code[len] != '!' &amp;&amp; code[len] != 0){len++;}*/for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1], b64_table) &amp; 0x30) &gt;&gt; 4;str[i_ + 1] = (findIndex(memstr[i + 1], b64_table) &amp; 0xf) &lt;&lt; 4 | (findIndex(memstr[i + 2], b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2], b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3], b64_table));}int str_len = (len / 4) * 3 + len % 4;if (len % 4){str_len -= 1;}str[str_len] = 0;return str;}int main(){char s[] ={  190,  54, 172,  39, 153,  79, 222,  68, 238,  95,  218,  11, 181,  23, 184, 104, 194,  78, 156,  74,  225,  67, 240,  34, 138,  59, 136,  91, 229,  84,  255, 104, 213, 103, 212,   6, 173,  11, 216,  80,  249,  88, 224, 111, 197,  74, 253,  47, 132,  54,  133,  82, 251, 115, 215,  13,0};char s2[] = { 0 };for (int i = 0; i &lt; 56; i+=2){s[i] ^= 0xee;}for (int i = 0; i &lt; 56; ++i){s2[i] = s[i];for (int k = i; k &gt; 0; k--){s2[i] ^= (s2[k - 1]);//该字符前面的全部都要异或上}}//printf("%s", s2);for (int i = 0; i &lt; 56; i = i + 4){s2[i] ^= 0xA;s2[i + 1] ^= 0xB;s2[i + 2] ^= 0xC;s2[i + 3] ^= 0xD;}char decode[] = { 0 };base64_decode(s2, decode, base64_table);printf("%s", decode);return 0;}</code></pre><h1 id="hgame2022-week4-easyvm"><a href="#hgame2022-week4-easyvm" class="headerlink" title="hgame2022-week4-easyvm"></a>hgame2022-week4-easyvm</h1><p>第一次尝试写解释器，跟着别人的大致思路的</p><p>首先VM就是模仿汇编，用指令代替汇编，用数据段来模拟寄存器和数据段，所以我们关键是要找到数据段和操作数、opcode，以及一些数据存放内容的含义</p><p>先来给寄存器重新命名</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447619996.png"></p><p>根据main函数中switch可以找到类寄存器的位置，重命名</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447726404.png"></p><p>从switch的v3可以知道，前面给v3赋值的就是操作数</p><p>r0[0]开始是0，所以操作指令第一个存储的位置是r0[109]，因为是int型，计算的时候×4，就可以找到地址</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447904556.png"></p><p>按g跳转，使用lazyida dump下来</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447995063.png"></p><p>接下来动调分析每条指令对应的汇编代码</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448145669.png"></p><p>先++，再赋值给它，就相当于push指令的入栈操作，然后还有一个r4后移一位</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448615771.png"></p><p>先–，再赋值给r5，相当于pop操作</p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448764344.png"></p><p>又回到0x12，还是push，但是因为r4++，所以已经后移，我们根据计算也可以找到存储数据的地址并提取出数据</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448880740.png"></p><p>回到汇编，这里的指令push了-5进入到堆栈，也就是寄存器下面的位置</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449458278.png"></p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449560687.png"></p><p>获取输入，并存储到a1中，这里的a1对应r3</p><table><thead><tr><th>getchar</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449886162.png"></p><p>熟悉的操作，把输入压入堆栈，记得栈顶往低处移动</p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645450099792.png"></p><p>这里的a1是r2</p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645450235632.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>根据前面的pop r5可以知道此时r5是0A，而我们的输入被存入了r3，也就是对我们的输入字符进行判断，那么r8应该就对应ZF标志位</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645513351201.png"></p><p>验证了上面的想法，这里的a1是r6，也就是-5，指令跳转回去，相当于进行循环，输入完成后会有一个换行符，getchar会吸收，这里也就是结束我们的循环</p><table><thead><tr><th>jnz</th><th>r0-5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>直接在下一条指令下断点，F9运行</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645513742181.png"></p><p>这里的a1是r2，用于记录输入长度，因为最后有一个回车符，所以要–</p><table><thead><tr><th>r2–</th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>根据前面就可以先对数组进行注释</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514228495.png"></p><p>r4没写上去，是内存中存储的一段数据</p><p>继续往下走</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514299405.png"></p><p>将内存段的下一个数据入栈，也就是0x20</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514469709.png"></p><table><thead><tr><th>pop</th><th>r5,这里懒得改了，可以点过去查看</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>接下来是0x12和0x9</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r6</td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514666638.png"></p><p>把r2的值赋给r3</p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514774277.png"></p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514918356.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>但是这次比较的是字符串的长度，也就是字符串长度是32</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515061894.png"></p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里r6存放的是2f，正好对应结束，所以这段就相当于exit</p><p>下面是0x12和0x09</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r6</td></tr></tbody></table><p>0x12和0x0A</p><p>这是0x0a的代码</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515342308.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r2</td></tr></tbody></table><p>0x13</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515472275.png"></p><p>r2此时为0，+9正好是堆栈的位置，也是存放我们输入数据的位置</p><table><thead><tr><th>mov</th><th>r3,stack[count]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>从下面开始就是加密的部分了</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515606892.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0B</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515758080.png"></p><table><thead><tr><th>pop</th><th>r7</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x15</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515807493.png"></p><table><thead><tr><th>add</th><th>r3,r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x03</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515866224.png"></p><table><thead><tr><th>xor</th><th>r3,r7</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515954359.png"></p><p>把处理完的数据重新放入栈中</p><table><thead><tr><th>mov</th><th>stack[count],r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516003430.png"></p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516131712.png"></p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xF</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516166189.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516207834.png"></p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>此时的r6是-10，也就是跳转回到前十条指令，这就是循环加密，现在就差最终的密文了，前面加密的部分直接运行过去</p><p>再次来到0x12</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516848887.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xA</p><table><thead><tr><th>pop</th><th>r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517151788.png"></p><p>接下来是三个0x12</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>push</td><td>data[r4++]</td></tr><tr><td>push</td><td>data[r4++]</td></tr></tbody></table><p>到了0x08，此时我们的比较数据已经被压入栈中</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517394177.png"></p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x13，将处理完的值重新从堆栈中取出</p><table><thead><tr><th>mov</th><th>r3,satck[count]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xF</p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x07</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517670674.png"></p><table><thead><tr><th>pop</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x04</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517727020.png"></p><table><thead><tr><th>mov</th><th>stack[count],r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x09</p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0D</p><p>r6是0x15，加上之后正好exit，和前面类似，压入栈是因为待会需要多次使用</p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里没有问题就会往下</p><p>0x09</p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>此时把-17给到r6</p><p>0x08</p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x05</p><table><thead><tr><th>push</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x06</p><table><thead><tr><th>push</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x04</p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x01</p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x00</p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0F//长度判断</p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xd，重新进入循环</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645518636756.png"></p><h2 id="最终的一些数据和分组和脚本"><a href="#最终的一些数据和分组和脚本" class="headerlink" title="最终的一些数据和分组和脚本"></a>最终的一些数据和分组和脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){int opcode[65] = {    0x00000012, 0x00000008, 0x00000012, 0x00000009, 0x00000010, 0x00000004, 0x00000001, 0x0000000F, 0x0000000D, //接受我们的输入 0x00000002, 0x00000012, 0x00000008, 0x00000012, 0x00000009, 0x00000000, 0x00000004, 0x0000000F, 0x0000000D,//对flag进行存储操作，比较长度，因为getchar最后是32，所以flag长度为32 0x00000012, 0x00000009, 0x00000012, 0x0000000A, 0x00000013, 0x00000012, 0x0000000B, 0x00000015, 0x00000003, 0x00000014, 0x00000001, 0x00000000, 0x0000000F, 0x0000000D, //flag加密，flag[i]*2^3c存储的值     0x00000012, 0x0000000A, 0x00000012, 0x00000012, 0x00000012, 0x00000008, 0x00000013, 0x0000000F, 0x00000007, 0x00000004, 0x00000009, 0x0000000D, 0x00000009, 0x00000008, 0x00000005, 0x00000006, 0x00000004, 0x00000001, 0x00000000, 0x0000000F, 0x0000000D, //字符串比较 0x00000012, 0x00000009, 0x00000012,     0x00000008, 0x00000012, 0x0000000A, 0x00000012, 0x00000007, 0x0000000F, 0x0000000C, 0x00000011, //打印     0x0000000E};unsigned char xor_table[32]={0x5e,0x46,0x61,0x43,0x0e,0x53,0x49,0x1f,0x51,0x5e,0x36,0x37,0x29,0x41,0x63,0x3b,0x64,0x3b,0x15,0x18,0x5b,0x3e,0x22,0x50,0x46,0x5e,0x35,0x4e,0x43,0x23,0x60,0x3b};unsigned char enc[32]={0x8E, 0x88, 0xA3, 0x99, 0xC4, 0xA5, 0xC3, 0xDD,0x19, 0xEC, 0x6C, 0x9B, 0xF3, 0x1B, 0x8B, 0x5B,0x3E, 0x9B, 0xF1, 0x86, 0xF3, 0xF4, 0xA4, 0xF8,0xF8, 0x98, 0xAB, 0x86, 0x89, 0x61, 0x22, 0xC1};unsigned int data[83] = {//用于跳转和判断长度的数     0x0000000A, -5, 0x00000020, 0x0000002F, -10, 0x00000000,     //异或数据 0x0000005E, 0x00000046, 0x00000061, 0x00000043, 0x0000000E, 0x00000053, 0x00000049, 0x0000001F, 0x00000051, 0x0000005E, 0x00000036, 0x00000037, 0x00000029, 0x00000041, 0x00000063, 0x0000003B, 0x00000064, 0x0000003B, 0x00000015, 0x00000018, 0x0000005B, 0x0000003E, 0x00000022, 0x00000050, 0x00000046, 0x0000005E, 0x00000035, 0x0000004E, 0x00000043, 0x00000023, 0x00000060, 0x0000003B, //用于跳转，以及赋值初始索引 0x00000000, -17, 0x00000015, //密文 0x0000008E, 0x00000088, 0x000000A3, 0x00000099, 0x000000C4, 0x000000A5, 0x000000C3, 0x000000DD, 0x00000019, 0x000000EC, 0x0000006C, 0x0000009B, 0x000000F3, 0x0000001B, 0x0000008B, 0x0000005B, 0x0000003E, 0x0000009B, 0x000000F1, 0x00000086, 0x000000F3, 0x000000F4, 0x000000A4, 0x000000F8,0x000000F8, 0x00000098, 0x000000AB, 0x00000086, 0x00000089, 0x00000061, 0x00000022, 0x000000C1, 0x00000002, 0x00000000, -6, 0x00000073, 0x00000075, 0x00000063, 0x00000063,     0x00000065, 0x00000073, 0x00000073};char flag[32]={0};for(int i=0;i&lt;32;++i){enc[i]=(enc[i]^xor_table[i])/2;}printf("%s",enc);return 0;}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dasctf——EasyVm&quot;&gt;&lt;a href=&quot;#Dasctf——EasyVm&quot; class=&quot;headerlink&quot; title=&quot;Dasctf——EasyVm&quot;&gt;&lt;/a&gt;Dasctf——EasyVm&lt;/h1&gt;&lt;p&gt;一开始有个花指令，是比较常见的永真跳转，先对</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>安卓知识</title>
    <link href="https://gift1a.github.io/2022/01/22/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/"/>
    <id>https://gift1a.github.io/2022/01/22/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/</id>
    <published>2022-01-22T07:34:10.000Z</published>
    <updated>2022-03-11T05:13:21.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="APK基本结构"><a href="#APK基本结构" class="headerlink" title="APK基本结构"></a>APK基本结构</h1><p><a href="https://www.cnblogs.com/zhaijiahui/p/6916556.html">https://www.cnblogs.com/zhaijiahui/p/6916556.html</a></p><p>因为java语言没办法直接控制硬件，所以要使用C/C++来写代码，保存在so文件中 </p><p>反编译之后是smali代码，动态调试</p><p>assets：存放未编译的资源</p><p>lib：存放so文件，即本地代码</p><p>libs：第三方包</p><p>META-INF：存放签名</p><p>res：编译后的资源</p><p>AndroidManifest.xml：用于存放清单</p><p>.dex文件：反编译后为smali代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;APK基本结构&quot;&gt;&lt;a href=&quot;#APK基本结构&quot; class=&quot;headerlink&quot; title=&quot;APK基本结构&quot;&gt;&lt;/a&gt;APK基本结构&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaijiahui/p/6916</summary>
      
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>C语言汇编</title>
    <link href="https://gift1a.github.io/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/"/>
    <id>https://gift1a.github.io/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/</id>
    <published>2022-01-20T10:40:09.000Z</published>
    <updated>2022-03-11T05:10:00.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VC6基础操作"><a href="#VC6基础操作" class="headerlink" title="VC6基础操作"></a>VC6基础操作</h1><p>F7：编译、F5：调试、F9：设置断点、F10：单步步过、F11：单步进入、shift+F5：结束调试</p><p>调试过程打开寄存器窗口和反汇编窗口</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643095481259.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643095520646.png"></p><h1 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h1><p>编译器不会管的函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643097998389.png"></p><p>__declspec(naked) Func()</p><p>调用空的裸函数会出现错误，因为有call，却没有ret</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643123413854.png"></p><p>进入后直接跳到int3，运行程序会报错</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643123914848.png"></p><p>解决这种只需要加入汇编语句ret，在C语言程序加入汇编语句，需要用到__asm{}。也就是说可以自己在里面写汇编代码来实现需求。</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126281063.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126324265.png"></p><p>执行完这段代码，ret回来了</p><h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><table><thead><tr><th>__cdecl（c、c++默认）</th><th>从右至左入栈</th><th>调用者清理栈</th></tr></thead><tbody><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理堆栈（内平栈）子函数平衡堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下的从右至左，寄存器传递速度更快。当只有两个参数传递进去，不需要平衡堆栈</td><td>自身清理堆栈</td></tr></tbody></table><p>所以不能通过ret来分析函数参数的个数</p><p>__cdecl</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643125931583.png"></p><p>外平栈</p><p>内部只有ret</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126021930.png"></p><p>__stdcall</p><p>右边的参数先入栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126780828.png"></p><p>可以看到这里call之后没有add来回复堆栈平衡，进入调用函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126852766.png"></p><p>可以看到ret变成了ret 8，这就是内平栈</p><p>__fastcall</p><p>两个参数存放在寄存器</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127369433.png"></p><p>没有修改堆栈，所以不需要add回复堆栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127503312.png"></p><p>有push和mov，外面没有add，进去看</p><p>也是内平栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127554833.png"></p><h1 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h1><p>公式一：寄存器+ret 4=参数个数</p><p>公式二：寄存器+[esp+8]+[ebp+0x]=参数个数</p><h1 id="寻找程序入口"><a href="#寻找程序入口" class="headerlink" title="寻找程序入口"></a>寻找程序入口</h1><p>callstack，调用窗口</p><p>main是我们写的程序的入口，但是不是真正程序的入口</p><p>因为在main函数之前需要调用如下函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127627555.png"></p><p>在callstack发现这个函数</p><p>Getversion()</p><p>_headp_int()</p><p>GetCommandLineA()</p><p>_crtGetEnvironmentStringA()</p><p>_setargv()</p><p>_setenvp()</p><p>_cinit()  </p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127791606.png"></p><p>main函数具有三个参数，所以要寻找具有三个参数的函数，找三个push，并且调用完会add 0xc</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127884930.png"></p><p>这里很符合</p><p>下断点进入，这里才是main函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127941350.png"></p><h1 id="数据类型与数据存储"><a href="#数据类型与数据存储" class="headerlink" title="数据类型与数据存储"></a>数据类型与数据存储</h1><p>1、存储数据的宽度 </p><p>2、存储数据的格式</p><p>3、作用范围</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>char、int、long、short：字节数1、4、4、2，对应上byte、dword、dword、word，long long在VC6对应__int 64</p><p>只会根据数据宽度进行操作，超出数据宽度的不会做修改</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643188104181.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643128939675.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643128998071.png"></p><p>g存储的只有0x56</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643129038958.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643129130357.png"></p><p>数据窗口是小端序</p><h4 id="有符号与无符号"><a href="#有符号与无符号" class="headerlink" title="有符号与无符号"></a>有符号与无符号</h4><p>C语言默认是有符号数</p><p>在内存中存储时无区别，但是在类型转换、比较大小和数学运算时需要注意</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>float、double在存储方式遵从IEEE的规范</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643166176045.png"></p><h1 id="局部变量和全局变量的区分"><a href="#局部变量和全局变量的区分" class="headerlink" title="局部变量和全局变量的区分"></a>局部变量和全局变量的区分</h1><p>局部变量是以ebp-开头的</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643180778946.png"></p><p>全局变量在编译完之后地址就不会改变</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643180903634.png"></p><p>直接放进地址，所以就是全局变量</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643181101615.png"></p><p>在vs2022会因为编译器版本问题，出现不同的汇编指令，但都是大同小异</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p>cmp+jcc指令</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643181892321.png"></p><p>cmp相当于减法，前面一个减后面一个，因为x&gt;y时继续执行，所以跳转指令的条件是小于等于</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182181368.png"></p><p>改成&gt;=之后，汇编指令变成了jl，汇编指令是和C语言反着来的</p><p>&lt;</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182345813.png"></p><p>==</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182397987.png"></p><h1 id="多分支语句"><a href="#多分支语句" class="headerlink" title="多分支语句"></a>多分支语句</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643183573683.png"></p><p>x&lt;=y的情况直接跳转到else中</p><p>x&gt;y则往后执行，执行完之后jmp跳转到else语句的后面</p><p>因为mov两边不能都是地址，所以需要用到寄存器</p><h2 id="if、else-if、else"><a href="#if、else-if、else" class="headerlink" title="if、else if、else"></a>if、else if、else</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643184460823.png"></p><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643187985614.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643187574671.png"></p><p>内部得到eax的值，eax一般用来存储返回值</p><p>参数传递4个字节</p><p>压栈的时候都是eax</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643188571362.png"></p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="switch语句反汇编"><a href="#switch语句反汇编" class="headerlink" title="switch语句反汇编"></a>switch语句反汇编</h2><p>当分支较少时采取if……else if ……else的方式</p><h3 id="case连续"><a href="#case连续" class="headerlink" title="case连续"></a>case连续</h3><p>创建大表</p><p> <img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726580401.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726615144.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726837151.png"></p><p>sub</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727141397.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727234505.png"></p><p>这里修改参数为103，case条件也修改，发现sub的值发生了变化，所以可以知道sub的值对应最小的case条件的值，这样对应上了大表的位置，所以sub是为了跳转到生成的大表</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727350589.png"></p><p>正好是case 103的地址</p><h3 id="case连续但中断"><a href="#case连续但中断" class="headerlink" title="case连续但中断"></a>case连续但中断</h3><p>101、102、103的情况使用default的地址填充</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727925669.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728035747.png"></p><p>只要有断开的，就会浪费一片内存地址，所以当间隔太远就不会使用这种方式</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728378338.png"></p><p>但是当间隔比较大的时候，出现了新情况</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728454178.png"></p><p>因为已经清空了edx，所以可使用该寄存器，这句话相当于把0x004010dd+eax的值对应地址的内容放入到dl中，dl是八位，对应1个字节，这个就是小表</p><p>当连续但相差较远时会采用小表</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728595269.png"></p><h3 id="case不连续"><a href="#case不连续" class="headerlink" title="case不连续"></a>case不连续</h3><p>当差值太大，不会生成大表，会直接采取if……else结构</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727643051.png"></p><p>先判断大于je，再判断等于cmp+jmp</p><h2 id="while循环反汇编"><a href="#while循环反汇编" class="headerlink" title="while循环反汇编"></a>while循环反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643730937945.png"></p><p>je是当ZF标志位为0是跳转，test是按位与操作，用于判断寄存器的值是否为0</p><h2 id="do……while反汇编"><a href="#do……while反汇编" class="headerlink" title="do……while反汇编"></a>do……while反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643731312416.png"></p><h2 id="for循环反汇编"><a href="#for循环反汇编" class="headerlink" title="for循环反汇编"></a>for循环反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643730507558.png"></p><h1 id="数组在内存的存储和寻址"><a href="#数组在内存的存储和寻址" class="headerlink" title="数组在内存的存储和寻址"></a>数组在内存的存储和寻址</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368384236.png"></p><p>这里数组的存储是从高位往低位存储，也就是从右到左开始存储到缓冲区中，替换缓冲区的数值</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368588775.png"></p><p>可以看到数组的存储</p><p>再看看数组引用</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368768572.png"></p><p>[ebp-4]是第一个形参的地址</p><p>[ebp-1ch]对应上数组首元素的地址，eax是存储着第一个形参，****<em>4是因为是int型数组，如果是short，则</em>2</p><p>，数组比较常见的形式就是[ebp+寄存器*数组类型对应的字节大小-数字]</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643369846681.png"></p><p>因为数组下标存在变量，而mov两边不能同时是地址，所以需要先用寄存器存储下标，而直接引用就不需要，即arr[1]</p><h2 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371348362.png"></p><p>因为每个寄存器最多存储四个字节，所以需要用到多个寄存器来存储</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371421546.png"></p><p>在数据窗口中是这样存放的</p><p>寄存器可以重复使用，比如长度不够的情况</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371753305.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VC6基础操作&quot;&gt;&lt;a href=&quot;#VC6基础操作&quot; class=&quot;headerlink&quot; title=&quot;VC6基础操作&quot;&gt;&lt;/a&gt;VC6基础操作&lt;/h1&gt;&lt;p&gt;F7：编译、F5：调试、F9：设置断点、F10：单步步过、F11：单步进入、shift+F5：结束调</summary>
      
    
    
    
    
    <category term="汇编" scheme="https://gift1a.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>汇编</title>
    <link href="https://gift1a.github.io/2022/01/19/%E6%B1%87%E7%BC%96/"/>
    <id>https://gift1a.github.io/2022/01/19/%E6%B1%87%E7%BC%96/</id>
    <published>2022-01-19T11:40:24.000Z</published>
    <updated>2022-03-11T05:13:39.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆栈图"><a href="#堆栈图" class="headerlink" title="堆栈图"></a>堆栈图</h1><p>调用函数实现两数相加</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592553591.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592569833.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592579671.png"></p><p>因为pop之后，有一部分的值还是之前保留下来的，所以要进行填充</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592639529.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592648442.png"></p><h1 id="LEA和MOV的区别"><a href="#LEA和MOV的区别" class="headerlink" title="LEA和MOV的区别"></a>LEA和MOV的区别</h1><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：</p><p>lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。</p><p>而mov指令则恰恰相反，例如：</p><p>mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p><h1 id="函数在汇编的结构"><a href="#函数在汇编的结构" class="headerlink" title="函数在汇编的结构"></a>函数在汇编的结构</h1><p>函数调用前，堆栈结构如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642649724413.png"></p><p>EBP栈底高位，ESP栈顶低位</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642649843226.png"></p><p>下面的三个PUSH是把函数的参数压入栈中，这里是立即数，也可以是寄存器里面的值，注意PUSH指令执行完ESP-4，即栈顶往低位移动</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650060363.png"></p><p>堆栈图如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650200472.png"></p><p>下一步是CALL指令，F7单步步入，CALL指令会修改EIP的值，将CALL指令下一条指令的地址压入栈顶 ，并且修改EIP的值，相当于一条PUSH和JMP指令，JMP只会修改EIP的值，EIP存放下一条会执行指令的地址</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650793595.png"></p><p>堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651074289.png"></p><p>这里JMP直接F8跳转过去，进入函数，入口是PUSH EBP</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651212988.png"></p><p>可以看到ESP没有变化</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651299175.png"></p><p>在函数调用中，这三步是提升栈顶，开辟空间</p><p>运行完堆栈应该如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651845629.png"></p><p>运行看看</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651761171.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651894330.png"></p><p>接下来这三步是保存现场，因为在函数调用中，这些寄存器可能被用到，所以要先把里面原本的值压入栈中，此时堆栈图为</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652121644.png"></p><p>EBP是FED0</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652204239.png"></p><p>已经被压入栈中 </p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652304817.png"></p><p>接下来这步是填充缓冲区</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652335865.png"></p><p>可以看到堆栈图中开辟的空间里面的值并不是为0，这是因为在调用完函数之后，这些空间的值没有被清除，所以需要填充</p><p>堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656762839.png"></p><p>这里有一点需要说明，local.18是什么意思呢</p><p>看下图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656813955.png"></p><p>我们去OD修改设置</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656868498.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656879655.png"></p><p>取消掉就可以了，刚才的指令发生了变化</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656905307.png"></p><p>接下来解释这几句指令</p><p>lea是取地址，意思是将ebp-0x48的地址存入EDI中</p><p>ECX一般用来存放循环次数，这里是0x12，即18次，这个对应开辟空间的大小</p><p>mov eax，0xCCCCCCCC是填充缓冲区</p><p>最后一句rep表示重复次数，次数由ECX决定，stos dword这条指令表示将EAX内的值放入EDI指定的内存单元中，注意执行一次后EDI会移动4，加减由DF标志位决定</p><p>DF决定movs执行完后esi和edi的移动方向，当为0时，加，否则为减。</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657323715.png"></p><p>看接下来的几行指令</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657469555.png"></p><p>1、将0x2赋给ebp地址的前一个内存单元，<strong>这里的0x2就是局部变量</strong></p><p>2、将EBP+0xc的值赋给eax，eax的值压入栈中，下面也是，画堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657989835.png"></p><p>这里压入栈的数值，将作为内部嵌套函数的参数</p><p>执行完之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658026768.png"></p><p>接下来又是调用函数，将CALL指令下一条指令的地址压入栈顶，EIP修改</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658203867.png"></p><p>F7步入</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658261575.png"></p><p>F8之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658343466.png"></p><p>红框部分和前面一样，都是调用函数前提升栈顶、开辟空间、保存现场、填充缓冲区，主要看操作部分</p><p>先把堆栈图画好</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659116555.png"></p><p>接下来看操作</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659284922.png"></p><p>这些都没有改变堆栈的值，第一条将0xA赋给EBP-0x4的内存单元，对应堆栈写出操作方式 EAX的值为1+2，最后+0xA，所以最后EAX的值为0xD</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659505718.png"></p><p>此时函数的操作部分已经结束，接下来就是退出函数了</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659609650.png"></p><p>对比一下，跟函数开始正好是反过来的</p><p>POP是先出栈再移动 ，这几个POP就相当于恢复现场，要恢复到未调用函数前，这也是为什么要先把这些值压入栈中的原因。</p><p>mov就是降低栈底，恢复到原来的位置</p><p>retn指令相当于POP EIP，先将栈顶的值赋给EIP，然后栈顶指针移动</p><p>堆栈图如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660789466.png"></p><p>执行后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660837614.png"></p><p>可以看到执行完之后，缓冲区的内容不会清理，这也是为什么需要填充缓冲区</p><p>回到后我们发现一个问题，就是函数调用前后堆栈不平衡，堆栈平衡是指调用函数前后堆栈应该相等，这里是因为将函数的参数压入了栈，所以需要接下来的ADD平衡堆栈</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660910037.png"></p><p>执行完之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642661042648.png"></p><p>和调用前一致，所以没问题了</p><p>剩下的就是重复之前的操作了，先执行函数操作指令，然后POP还原现场，retn后ADD恢复堆栈平衡</p><p>函数的参数存放在ebp+0x8开始因为call指令会将下一条指令地址压入栈中，而局部变量从ebp-0x4开始</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;堆栈图&quot;&gt;&lt;a href=&quot;#堆栈图&quot; class=&quot;headerlink&quot; title=&quot;堆栈图&quot;&gt;&lt;/a&gt;堆栈图&lt;/h1&gt;&lt;p&gt;调用函数实现两数相加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/19/%E6%B1%87%E7%BC%96/1642592</summary>
      
    
    
    
    
    <category term="汇编" scheme="https://gift1a.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
</feed>
