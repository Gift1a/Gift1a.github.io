<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-10-15T11:14:09.083Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ELF文件格式学习</title>
    <link href="https://gift1a.github.io/2022/10/15/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/10/15/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-10-15T11:14:09.000Z</published>
    <updated>2022-10-15T11:14:09.083Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Unicorn</title>
    <link href="https://gift1a.github.io/2022/10/11/Unicorn/"/>
    <id>https://gift1a.github.io/2022/10/11/Unicorn/</id>
    <published>2022-10-11T07:21:47.000Z</published>
    <updated>2022-10-13T05:27:32.381Z</updated>
    
    <content type="html"><![CDATA[<p>Unicorn&amp;&amp;Unidbg</p><span id="more"></span><h1 id="Unicorn简介"><a class="header-anchor" href="#Unicorn简介">¶</a>Unicorn简介</h1><p><a href="https://bbs.pediy.com/thread-253868.htm#msg_header_h1_4">Unicorn-In-Android</a></p><blockquote><p><strong>Unicorn是一个轻量级、多平台、多架构的CPU模拟器框架，使用Unicorn的API可以轻松控制CPU寄存器、内存等资源，调试或调用目标二进制代码</strong></p></blockquote><h1 id="Unicorn安装"><a class="header-anchor" href="#Unicorn安装">¶</a>Unicorn安装</h1><p>pip install unicorn即可</p><h1 id="Unicorn使用"><a class="header-anchor" href="#Unicorn使用">¶</a>Unicorn使用</h1><p>首先导入我们想要模拟执行代码需要的库模块，这里是<strong>x86</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br></pre></td></tr></tbody></table></figure><p>接着指定我们想要执行的数据<strong>必须是bytes型的数据</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code=<span class="built_in">bytes</span>([<span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x8B</span>, <span class="number">0x55</span>, <span class="number">0x0C</span>, <span class="number">0xB9</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x89</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x85</span>, <span class="number">0xD2</span>, <span class="number">0x74</span>, <span class="number">0x51</span>, <span class="number">0x53</span>, <span class="number">0x8B</span>, <span class="number">0x5D</span>, <span class="number">0x08</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x6A</span>, <span class="number">0x14</span>, <span class="number">0x58</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x3B</span>, <span class="number">0xD0</span>, <span class="number">0x8B</span>, <span class="number">0xF2</span>, <span class="number">0x0F</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0x2B</span>, <span class="number">0xD6</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x03</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xF8</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x03</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x43</span>, <span class="number">0x83</span>, <span class="number">0xEE</span>, <span class="number">0x01</span>, <span class="number">0x75</span>, <span class="number">0xED</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>,<span class="number">0xEF</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xC7</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0xC0</span>, <span class="number">0x89</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>, <span class="number">0xE9</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xC1</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0xC8</span>, <span class="number">0x6A</span>, <span class="number">0x14</span>, <span class="number">0x58</span>, <span class="number">0x85</span>, <span class="number">0xD2</span>, <span class="number">0x75</span>, <span class="number">0xBB</span>, <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x55</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xC1</span>, <span class="number">0xC1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>, <span class="number">0xE9</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xD1</span>, <span class="number">0x66</span>, <span class="number">0x0B</span>, <span class="number">0xC2</span>])</span><br></pre></td></tr></tbody></table></figure><p>指定我们想要代码模拟运行时的地址</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDRESS=<span class="number">0x400000</span></span><br></pre></td></tr></tbody></table></figure><p><strong>使用Uc类来初始化Unicorn实例</strong>，参数一是硬件架构、参数二是硬件模式，这里创建的环境是32位X86架构</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu=Uc(UC_ARCH_X86,UC_MODE_32)</span><br></pre></td></tr></tbody></table></figure><p><strong>使用mem_map()分配内存</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu.mem_map(ADDRESS,<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line"><span class="comment">#内存的大小必须是1024的倍数，这里分配的是2MB</span></span><br></pre></td></tr></tbody></table></figure><p>将要模拟运行的代码写入内存中，使用<strong>mem_write(ADDRESS,code)</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.mem_write(ADDRESS,code)</span><br></pre></td></tr></tbody></table></figure><p>通过<strong>reg.write()可以设置寄存器的值</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mu.reg_write(UC_X86_REG_EDX,<span class="number">0x1234</span>)</span><br></pre></td></tr></tbody></table></figure><p>使用<strong>emu_start()方法模拟运行</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu.emu_start(ADDRESS, ADDRESS+<span class="built_in">len</span>(code))</span><br><span class="line"><span class="comment">#需要指定起始地址和终止地址</span></span><br></pre></td></tr></tbody></table></figure><p>运行完毕后使用<strong>reg_read()方法读取寄存器的值即可</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data=mu.reg_read(UC_X86_REG_EDX)</span><br></pre></td></tr></tbody></table></figure><h1 id="Unicorn使用案例"><a class="header-anchor" href="#Unicorn使用案例">¶</a>Unicorn使用案例</h1><p>Flare-on4 3</p><p><img src="/2022/10/11/Unicorn/1665480315376.png" alt=""></p><p>中间一大段无法被正确反编译的明显是被加密过的，而前面do……while进行的正是解密操作，经过socket_receive函数处理后的buf的第一个字节用于解密操作</p><p>进入socket_receive函数</p><p><img src="/2022/10/11/Unicorn/1665480517542.png" alt=""></p><blockquote><p><strong>使用socket对本地的2222端口设置监听，accept函数如果没有接受到连接会一直处于阻塞状态</strong>，所以在这里会卡住</p></blockquote><p><img src="/2022/10/11/Unicorn/1665480732874.png" alt=""></p><p>可以看到2222端口正在被监听</p><p>我们可以编写python脚本来发送数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">POST = <span class="number">2222</span></span><br><span class="line">BufSize = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, POST)</span><br><span class="line">data = <span class="string">b'hello'</span></span><br><span class="line"><span class="comment">#初始化socket对象，AF_INET/SOCK_STREAM表示是TCP</span></span><br><span class="line">socket_ = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">socket_.connect(ADDR)</span><br><span class="line">socket_.send(data) </span><br><span class="line"><span class="comment">#这里的data必须是bytes型数据</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/10/11/Unicorn/1665481010605.png" alt=""></p><p>accept之后创建一个socket对象，然后将使用<strong>recv函数接收并存入buf中</strong></p><p>然后就将我们发送数据的第一个字节作为key进行SMC自解密</p><p><img src="/2022/10/11/Unicorn/1665481112399.png" alt=""></p><p>接着将SMC后数据的起始地址和长度121传入check进行校验</p><p>然后根据校验的情况<strong>send</strong>不同的数据到客户端</p><h2 id="socket爆破"><a class="header-anchor" href="#socket爆破">¶</a>socket爆破</h2><p>由于SMC解密用到的只有一个字节，所以我们可以爆破，不断传入数据直到接收到Congratulations! But wait, where’s my flag?</p><p>由于接收消息之后程序就直接关闭了，所以我们需要使用到<strong>os.startfile(exe)<strong>来运行程序，我们还需要将整数转为bytes型数据后发送，要用到</strong>struct.pack(“I”,data)</strong>，其作用如下</p><blockquote><ul><li>按照指定格式将Python数据转换为字符串,该字符串为字节流,如网络传输时,不能传输int,此时先将int转化为字节流,然后再发送;</li><li>按照指定格式将字节流转换为Python指定的数据类型;</li></ul></blockquote><p><img src="https://pic4.zhimg.com/80/v2-3ffa4805271e382316295a4e0b7614c3_720w.webp" alt=""></p><p>同时struct也可以指定大小端序</p><p><img src="/2022/10/11/Unicorn/1665482047506.png" alt=""></p><p>爆破脚本如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">POST = <span class="number">2222</span></span><br><span class="line">BufSize = <span class="number">1024</span></span><br><span class="line">ADDR = (HOST, POST)</span><br><span class="line">data = <span class="string">b'hello'</span></span><br><span class="line">exe_file = <span class="string">"greek_to_me.exe"</span></span><br><span class="line"><span class="built_in">print</span>(struct.pack(<span class="string">"I"</span>, <span class="number">0xA2</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">    os.startfile(exe_file)</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    socket_ = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">    socket_.connect(ADDR)</span><br><span class="line">    socket_.send(struct.pack(<span class="string">'I'</span>, i))  <span class="comment"># 接收到错误的数据之后就关闭了</span></span><br><span class="line">    data = socket_.recv(BufSize)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    socket_.close()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b'Congratulations'</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The key is %x"</span> % i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="Unicorn"><a class="header-anchor" href="#Unicorn">¶</a>Unicorn</h2><p>也是采用爆破的方式，这里模拟运行的是<strong>check函数</strong>，不断将SMC解密后的数据和数据的长度写入Unicorn的内存中并执行check函数，直到其返回值为0xFB5E为止</p><p>首先我们需要提取出被加密的数据和要执行的代码的机器码并转为字节流</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enc_data = [<span class="number">0x33</span>, <span class="number">0xe1</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x11</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x16</span>, <span class="number">0xf0</span>, <span class="number">0x32</span>, <span class="number">0x9f</span>, <span class="number">0xc4</span>, <span class="number">0x91</span>, <span class="number">0x17</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x14</span>, <span class="number">0xf0</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x15</span>, <span class="number">0xf1</span>, <span class="number">0xc4</span>, <span class="number">0x91</span>, <span class="number">0x1a</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x1b</span>, <span class="number">0xe2</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x18</span>, <span class="number">0xf2</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x19</span>, <span class="number">0xf1</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x1e</span>, <span class="number">0xf0</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x1f</span>, <span class="number">0xc4</span>, <span class="number">0x91</span>, <span class="number">0x1c</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x1d</span>, <span class="number">0xe6</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x62</span>, <span class="number">0xef</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x63</span>, <span class="number">0xf2</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x60</span>, <span class="number">0xe3</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x61</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x66</span>, <span class="number">0xbc</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x67</span>, <span class="number">0xe6</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x64</span>, <span class="number">0xe8</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x65</span>, <span class="number">0x9d</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6a</span>, <span class="number">0xf2</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x6b</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x68</span>, <span class="number">0xa9</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x69</span>, <span class="number">0xef</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6e</span>, <span class="number">0xee</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6f</span>, <span class="number">0xae</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6c</span>, <span class="number">0xe3</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6d</span>, <span class="number">0xef</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x72</span>, <span class="number">0xe9</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x73</span>, <span class="number">0x7c</span>, <span class="number">0x6a</span>]</span><br><span class="line">enc_data = <span class="built_in">bytes</span>(enc_data)</span><br><span class="line"></span><br><span class="line">code = [<span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x8B</span>, <span class="number">0x55</span>, <span class="number">0x0C</span>, <span class="number">0xB9</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x89</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x85</span>, <span class="number">0xD2</span>, <span class="number">0x74</span>, <span class="number">0x51</span>, <span class="number">0x53</span>, <span class="number">0x8B</span>, <span class="number">0x5D</span>, <span class="number">0x08</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x6A</span>, <span class="number">0x14</span>, <span class="number">0x58</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x3B</span>, <span class="number">0xD0</span>, <span class="number">0x8B</span>, <span class="number">0xF2</span>, <span class="number">0x0F</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0x2B</span>, <span class="number">0xD6</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x03</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xF8</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x03</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x43</span>, <span class="number">0x83</span>, <span class="number">0xEE</span>, <span class="number">0x01</span>, <span class="number">0x75</span>, <span class="number">0xED</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>,<span class="number">0xEF</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xC7</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0xC0</span>, <span class="number">0x89</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>, <span class="number">0xE9</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xC1</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0xC8</span>, <span class="number">0x6A</span>, <span class="number">0x14</span>, <span class="number">0x58</span>, <span class="number">0x85</span>, <span class="number">0xD2</span>, <span class="number">0x75</span>, <span class="number">0xBB</span>, <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x55</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xC1</span>, <span class="number">0xC1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>, <span class="number">0xE9</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xD1</span>, <span class="number">0x66</span>, <span class="number">0x0B</span>, <span class="number">0xC2</span>]</span><br><span class="line">code = <span class="built_in">bytes</span>(code)</span><br></pre></td></tr></tbody></table></figure><p>接着将加密后的数据进行解密后写入Unicorn中</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_bytes</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc_data)):</span><br><span class="line">        <span class="comment"># 声明为全局变量之后才能在函数内部修改</span></span><br><span class="line">        <span class="keyword">global</span> decoded_bytes</span><br><span class="line">        decoded_bytes[i] = ((enc_data[i] ^ key)+<span class="number">0x22</span>) &amp; <span class="number">0xff</span></span><br><span class="line">        <span class="comment">#由于python没有对变量进行限制，所以需要&amp;0xFF</span></span><br></pre></td></tr></tbody></table></figure><p>Unicorn模拟执行部分</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_code</span>(<span class="params"><span class="built_in">bytes</span></span>):</span></span><br><span class="line">    <span class="comment"># 指定代码模拟执行的地址</span></span><br><span class="line">    ADDRESS = <span class="number">0x400000</span></span><br><span class="line">    SIZE = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line">    STACK_ADDRESS = <span class="number">0x410000</span></span><br><span class="line">    DEC_BYTES_ADDR = <span class="number">0x420000</span></span><br><span class="line">    <span class="comment"># 使用Uc类来初始化Unicorn对象，其中第一个参数是硬件架构，第二个参数是硬件模式</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line">    <span class="comment"># 创建模拟代码运行的内存空间，这里设置为2MB，在这里运行的代码只能访问该内存，内存默认属性为</span></span><br><span class="line">    mu.mem_map(ADDRESS, SIZE)</span><br><span class="line">    <span class="comment"># 接下来将代码和解密后的数据写入地址中</span></span><br><span class="line">    mu.mem_write(ADDRESS, code)</span><br><span class="line">    mu.mem_write(DEC_BYTES_ADDR, <span class="built_in">bytes</span>)</span><br><span class="line">    <span class="comment"># 由于函数取出了栈的内容，所以我们要先将数据写入栈中</span></span><br><span class="line"></span><br><span class="line">    mu.reg_write(UC_X86_REG_ESP, STACK_ADDRESS)  <span class="comment"># 将栈的地址存入ESP中</span></span><br><span class="line">    <span class="comment"># 使用struct.pack将地址转为bytes之后写入栈中</span></span><br><span class="line">    mu.mem_write(STACK_ADDRESS+<span class="number">4</span>, struct.pack(<span class="string">'&lt;I'</span>,</span><br><span class="line">                 DEC_BYTES_ADDR))  <span class="comment"># 将堆栈的情况还原</span></span><br><span class="line">    mu.mem_write(STACK_ADDRESS+<span class="number">8</span>, struct.pack(<span class="string">'&lt;I'</span>, <span class="number">0x79</span>))</span><br><span class="line">    <span class="comment"># 执行代码，第一二个参数为起始地址和终止地址</span></span><br><span class="line">    mu.emu_start(ADDRESS, ADDRESS+<span class="built_in">len</span>(code))</span><br><span class="line">    check_sum = mu.reg_read(UC_X86_REG_AX)</span><br><span class="line">    <span class="keyword">return</span> check_sum</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是check函数是有参数的，所以我们需要先<strong>设置栈和ESP，并且将解密数据的地址和解密数据的长度按照顺序存入栈中</strong>，根据IDA的栈视图可以更快地确定函数参数在栈中地关系</p><p><img src="/2022/10/11/Unicorn/1665476344434.png" alt=""></p><p>爆破主体部分</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">    decode_bytes(i)</span><br><span class="line">    check_sum = run_code(<span class="built_in">bytes</span>(decoded_bytes))</span><br><span class="line">    <span class="keyword">if</span> check_sum == <span class="number">0xFB5E</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The key is "</span>, <span class="built_in">hex</span>(i))</span><br><span class="line">        md = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> md.disasm(<span class="built_in">bytes</span>(decoded_bytes), <span class="number">0x40107C</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"0x%x:\t%s\t%s"</span> % (j.address, j.mnemonic, j.op_str))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><p>当check的函数的返回值等于0xFB5E之后</p><p>使用<strong>capstone中的Cs指定代码的架构和模式，disasm(bytes_code,offset)将bytes字节流转为汇编代码</strong>，disasm的参数分别是机器码的字节流和偏移(我们指定)</p><p><img src="/2022/10/11/Unicorn/1665485005665.png" alt=""></p><p>完整代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pickletools <span class="keyword">import</span> bytes1</span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> x86_const</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面使用unicorn模拟执行check函数，进而得到我们想要的key</span></span><br><span class="line">enc_data = [<span class="number">0x33</span>, <span class="number">0xe1</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x11</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x16</span>, <span class="number">0xf0</span>, <span class="number">0x32</span>, <span class="number">0x9f</span>, <span class="number">0xc4</span>, <span class="number">0x91</span>, <span class="number">0x17</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x14</span>, <span class="number">0xf0</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x15</span>, <span class="number">0xf1</span>, <span class="number">0xc4</span>, <span class="number">0x91</span>, <span class="number">0x1a</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x1b</span>, <span class="number">0xe2</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x18</span>, <span class="number">0xf2</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x19</span>, <span class="number">0xf1</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x1e</span>, <span class="number">0xf0</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x1f</span>, <span class="number">0xc4</span>, <span class="number">0x91</span>, <span class="number">0x1c</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x1d</span>, <span class="number">0xe6</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x62</span>, <span class="number">0xef</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x63</span>, <span class="number">0xf2</span>, <span class="number">0x6</span>,</span><br><span class="line">            <span class="number">0x81</span>, <span class="number">0x60</span>, <span class="number">0xe3</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x61</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x66</span>, <span class="number">0xbc</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x67</span>, <span class="number">0xe6</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x64</span>, <span class="number">0xe8</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x65</span>, <span class="number">0x9d</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6a</span>, <span class="number">0xf2</span>, <span class="number">0xc4</span>, <span class="number">0x99</span>, <span class="number">0x6b</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x68</span>, <span class="number">0xa9</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x69</span>, <span class="number">0xef</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6e</span>, <span class="number">0xee</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6f</span>, <span class="number">0xae</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6c</span>, <span class="number">0xe3</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x6d</span>, <span class="number">0xef</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x72</span>, <span class="number">0xe9</span>, <span class="number">0x6</span>, <span class="number">0x81</span>, <span class="number">0x73</span>, <span class="number">0x7c</span>, <span class="number">0x6a</span>]</span><br><span class="line">enc_data = <span class="built_in">bytes</span>(enc_data)</span><br><span class="line"></span><br><span class="line">code = [<span class="number">0x55</span>, <span class="number">0x8B</span>, <span class="number">0xEC</span>, <span class="number">0x51</span>, <span class="number">0x8B</span>, <span class="number">0x55</span>, <span class="number">0x0C</span>, <span class="number">0xB9</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x89</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x85</span>, <span class="number">0xD2</span>, <span class="number">0x74</span>, <span class="number">0x51</span>, <span class="number">0x53</span>, <span class="number">0x8B</span>, <span class="number">0x5D</span>, <span class="number">0x08</span>, <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x6A</span>, <span class="number">0x14</span>, <span class="number">0x58</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x3B</span>, <span class="number">0xD0</span>, <span class="number">0x8B</span>, <span class="number">0xF2</span>, <span class="number">0x0F</span>, <span class="number">0x47</span>, <span class="number">0xF0</span>, <span class="number">0x2B</span>, <span class="number">0xD6</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x03</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xF8</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x7D</span>, <span class="number">0xFC</span>, <span class="number">0x03</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x43</span>, <span class="number">0x83</span>, <span class="number">0xEE</span>, <span class="number">0x01</span>, <span class="number">0x75</span>, <span class="number">0xED</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>,</span><br><span class="line">        <span class="number">0xEF</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xC7</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0xC0</span>, <span class="number">0x89</span>, <span class="number">0x45</span>, <span class="number">0xFC</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>, <span class="number">0xE9</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xC1</span>, <span class="number">0x0F</span>, <span class="number">0xB7</span>, <span class="number">0xC8</span>, <span class="number">0x6A</span>, <span class="number">0x14</span>, <span class="number">0x58</span>, <span class="number">0x85</span>, <span class="number">0xD2</span>, <span class="number">0x75</span>, <span class="number">0xBB</span>, <span class="number">0x5F</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x0F</span>, <span class="number">0xB6</span>, <span class="number">0x55</span>, <span class="number">0xFC</span>, <span class="number">0x8B</span>, <span class="number">0xC1</span>, <span class="number">0xC1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0xFF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x4D</span>, <span class="number">0xFC</span>, <span class="number">0x66</span>, <span class="number">0xC1</span>, <span class="number">0xE9</span>, <span class="number">0x08</span>, <span class="number">0x66</span>, <span class="number">0x03</span>, <span class="number">0xD1</span>, <span class="number">0x66</span>, <span class="number">0x0B</span>, <span class="number">0xC2</span>]</span><br><span class="line">code = <span class="built_in">bytes</span>(code)</span><br><span class="line"><span class="comment"># print(code)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先先对enc_data进行smc，之后将code和encdata、encdata的长度写入unicorn的栈中模拟执行(因为check是从栈中取值的)，通过eax的值传入</span></span><br><span class="line"></span><br><span class="line">decoded_bytes = [<span class="number">0</span>]*<span class="built_in">len</span>(enc_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_bytes</span>(<span class="params">key</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc_data)):</span><br><span class="line">        <span class="comment"># 声明为全局变量之后才能在函数内部修改</span></span><br><span class="line">        <span class="keyword">global</span> decoded_bytes</span><br><span class="line">        decoded_bytes[i] = ((enc_data[i] ^ key)+<span class="number">0x22</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_code</span>(<span class="params"><span class="built_in">bytes</span></span>):</span></span><br><span class="line">    <span class="comment"># 指定代码模拟执行的地址</span></span><br><span class="line">    ADDRESS = <span class="number">0x400000</span></span><br><span class="line">    SIZE = <span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line">    STACK_ADDRESS = <span class="number">0x410000</span></span><br><span class="line">    DEC_BYTES_ADDR = <span class="number">0x420000</span></span><br><span class="line">    <span class="comment"># 使用Uc类来初始化Unicorn对象，其中第一个参数是硬件架构，第二个参数是硬件模式</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line">    <span class="comment"># 创建模拟代码运行的内存空间，这里设置为2MB，在这里运行的代码只能访问该内存，内存默认属性为</span></span><br><span class="line">    mu.mem_map(ADDRESS, SIZE)</span><br><span class="line">    <span class="comment"># 接下来将代码和解密后的数据写入地址中</span></span><br><span class="line">    mu.mem_write(ADDRESS, code)</span><br><span class="line">    mu.mem_write(DEC_BYTES_ADDR, <span class="built_in">bytes</span>)</span><br><span class="line">    <span class="comment"># 由于函数取出了栈的内容，所以我们要先将数据写入栈中</span></span><br><span class="line"></span><br><span class="line">    mu.reg_write(UC_X86_REG_ESP, STACK_ADDRESS)  <span class="comment"># 将栈的地址存入ESP中</span></span><br><span class="line">    <span class="comment"># 使用struct.pack将地址转为bytes之后写入栈中</span></span><br><span class="line">    mu.mem_write(STACK_ADDRESS+<span class="number">4</span>, struct.pack(<span class="string">'&lt;I'</span>,</span><br><span class="line">                 DEC_BYTES_ADDR))  <span class="comment"># 将堆栈的情况还原</span></span><br><span class="line">    mu.mem_write(STACK_ADDRESS+<span class="number">8</span>, struct.pack(<span class="string">'&lt;I'</span>, <span class="number">0x79</span>))</span><br><span class="line">    <span class="comment"># 执行代码，第一二个参数为起始地址和终止地址</span></span><br><span class="line">    mu.emu_start(ADDRESS, ADDRESS+<span class="built_in">len</span>(code))</span><br><span class="line">    check_sum = mu.reg_read(UC_X86_REG_AX)</span><br><span class="line">    <span class="keyword">return</span> check_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>):</span><br><span class="line">    decode_bytes(i)</span><br><span class="line">    check_sum = run_code(<span class="built_in">bytes</span>(decoded_bytes))</span><br><span class="line">    <span class="keyword">if</span> check_sum == <span class="number">0xFB5E</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The key is "</span>, <span class="built_in">hex</span>(i))</span><br><span class="line">        md = Cs(CS_ARCH_X86, CS_MODE_32)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> md.disasm(<span class="built_in">bytes</span>(decoded_bytes), <span class="number">0x40107C</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"0x%x:\t%s\t%s"</span> % (j.address, j.mnemonic, j.op_str))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Unicorn-Hook"><a class="header-anchor" href="#Unicorn-Hook">¶</a>Unicorn-Hook</h1><p>Unicorn还提供了hook_add()方法来Hook</p><p>这种类型的hook在执行每条指令前都会先执行hook_code</p><p>hook_code函数 该函数需要以下参数：</p><ul><li>Uc实例</li><li>指令的地址</li><li>指令的大小</li><li>用户数据（我们可以在hook_add()的可选参数中传递这个值）</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu.hook_add(UC_HOOK_CODE,hook_code,start,end)</span><br><span class="line"><span class="comment">#hook_code是实现Hook的函数，start是被Hook代码的起始地址，end是被Hook代码的终止地址</span></span><br></pre></td></tr></tbody></table></figure><h1 id="Unicorn执行程序"><a class="header-anchor" href="#Unicorn执行程序">¶</a>Unicorn执行程序</h1><p>Unicorn执行程序其实和前面的执行一段执行是类似的，唯一不同的就是需要<strong>read</strong>文件。最后按照IDA中的偏移来设置开始执行的地址，这样方便我们对照和写入数据。</p><p>但是要注意有些外部函数比如<strong>printf</strong>之类的，由于加载进虚拟内存中所以无法使用</p><p><strong>通过Hook来修改修改EIP/RIP跳过执行即可</strong></p><p><strong>对于写入内存中的int型数据首先使用struct.pack()转为bytes，然后再写入</strong>，也可以通过<strong>pwntools</strong>直接转换</p><p><img src="/2022/10/11/Unicorn/1665549286204.png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> capstone <span class="keyword">import</span> x86_const</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">instruction_skip_list = [</span><br><span class="line">    <span class="number">0x4004ef</span>, <span class="number">0x4004f6</span>, <span class="number">0x400502</span>, <span class="number">0x40054f</span>, <span class="number">0x4004d0</span>, <span class="number">0x4004a0</span>, <span class="number">0x4004a6</span>, <span class="number">0x4004b0</span>]</span><br><span class="line">ENTRY = <span class="number">0x400670</span></span><br><span class="line">END = [<span class="number">0x400709</span>, <span class="number">0x4006F1</span>]</span><br><span class="line">stack = []</span><br><span class="line">d = {}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(name, <span class="string">"rb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> f.read()</span><br><span class="line"><span class="comment"># 将int型数据转为bytes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def p32(num):</span></span><br><span class="line"><span class="comment">#     return struct.pack("I", num)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 将bytes转为int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># def u32(data):</span></span><br><span class="line"><span class="comment">#     return struct.unpack("I", data)[0]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook_add</span>(<span class="params">mu, address, size, user_data</span>):</span></span><br><span class="line">    <span class="comment">#print('&gt;&gt;&gt;Tracing Instruction at 0x%x, instruction size = 0x %x' %(address, size))</span></span><br><span class="line">    <span class="comment"># 修改RSP跳过无法执行的指令</span></span><br><span class="line">    <span class="keyword">if</span> address <span class="keyword">in</span> instruction_skip_list:</span><br><span class="line">        mu.reg_write(UC_X86_REG_RIP, address+size)</span><br><span class="line">    <span class="comment"># 程序puts flag的函数地址400560</span></span><br><span class="line">    <span class="keyword">elif</span> address == <span class="number">0x400560</span>:</span><br><span class="line">        chr_data = mu.reg_read(UC_X86_REG_RDI)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(chr_data), end=<span class="string">''</span>)</span><br><span class="line">        <span class="comment"># 跳过这条指令</span></span><br><span class="line">        mu.reg_write(UC_X86_REG_RIP, address+size)</span><br><span class="line">    <span class="keyword">elif</span> address == ENTRY:</span><br><span class="line">        <span class="comment"># 在IDA中可以看到函数参数存储的寄存器，第一个参数是RDI，第二个是RSI</span></span><br><span class="line">        arg0 = mu.reg_read(UC_X86_REG_RDI)</span><br><span class="line">        p_rsi = mu.reg_read(UC_X86_REG_RSI)</span><br><span class="line">        <span class="comment"># RSI存储的是一个指针，需要读取出来后转为int型数据</span></span><br><span class="line">        arg1 = u32(mu.mem_read(p_rsi, <span class="number">4</span>))</span><br><span class="line">        <span class="comment"># 如果之前调用过的</span></span><br><span class="line">        <span class="keyword">if</span> (arg0, arg1) <span class="keyword">in</span> d:</span><br><span class="line">            (ret_rax, ret_ref) = d[(arg0, arg1)]</span><br><span class="line">            <span class="comment"># print(stack)</span></span><br><span class="line">            <span class="comment"># print(d)</span></span><br><span class="line">            mu.reg_write(UC_X86_REG_RAX, ret_rax)</span><br><span class="line">            mu.mem_write(p_rsi, p32(ret_ref))</span><br><span class="line">            mu.reg_write(UC_X86_REG_RIP, <span class="number">0x400582</span>)  <span class="comment"># 直接结束</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 存入栈中</span></span><br><span class="line">            stack.append((arg0, arg1, p_rsi))</span><br><span class="line">    <span class="keyword">elif</span> address <span class="keyword">in</span> END:</span><br><span class="line">        <span class="comment"># 将末尾的元素赋值给元组</span></span><br><span class="line">        (arg0, arg1, p_rsi) = stack.pop()</span><br><span class="line">        ret_rax = mu.reg_read(UC_X86_REG_RAX)</span><br><span class="line">        ret_ref = u32(mu.mem_read(p_rsi, <span class="number">4</span>))</span><br><span class="line">        d[(arg0, arg1)] = (ret_rax, ret_ref)  <span class="comment"># 将返回值和传入的参数对应起来</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="comment"># 指定架构和模式，64位</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_64)</span><br><span class="line">    ADDRESS = <span class="number">0x400000</span></span><br><span class="line">    SIZE = <span class="number">1024</span>*<span class="number">1024</span></span><br><span class="line">    STACK_ADDRESS = <span class="number">0x0</span></span><br><span class="line">    <span class="comment"># 分配虚拟空间</span></span><br><span class="line">    mu.mem_map(ADDRESS, SIZE)</span><br><span class="line">    mu.mem_map(STACK_ADDRESS, SIZE)</span><br><span class="line">    <span class="comment"># 数据写入，栈顶设置指向栈的末尾，函数调用前的堆栈EBP处于栈底，ESP栈顶，之后会提升堆栈</span></span><br><span class="line">    mu.mem_write(ADDRESS, data)</span><br><span class="line">    mu.reg_write(UC_X86_REG_RSP, STACK_ADDRESS+SIZE-<span class="number">1</span>)</span><br><span class="line">    mu.hook_add(UC_HOOK_CODE, hook_add, begin=ADDRESS, end=ADDRESS+SIZE)</span><br><span class="line">    mu.emu_start(<span class="number">0x4004E0</span>, <span class="number">0x400575</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = read(<span class="string">"./fibonacci"</span>)</span><br><span class="line">run(data)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="keystone和capstone"><a class="header-anchor" href="#keystone和capstone">¶</a>keystone和capstone</h1><blockquote><p><strong>keystone将汇编代码转为机器码，而capstone将机器码转为汇编代码</strong></p></blockquote><h1 id="Unidbg"><a class="header-anchor" href="#Unidbg">¶</a>Unidbg</h1><p>Unibdg是基于unicorn的，<a href="https://github.com/zhkl0228/unidbg">项目地址</a></p><p>git clone下来后导入IDEA</p><p><img src="/2022/10/11/Unicorn/1665581891080.png" alt=""></p><p>打开在TTEncrypt运行，导入成功会得到如下输出</p><p><img src="/2022/10/11/Unicorn/1665581950722.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Unicorn&amp;amp;&amp;amp;Unidbg&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Frida_Practice</title>
    <link href="https://gift1a.github.io/2022/09/24/Frida-Practice/"/>
    <id>https://gift1a.github.io/2022/09/24/Frida-Practice/</id>
    <published>2022-09-24T13:03:57.000Z</published>
    <updated>2022-10-11T15:29:08.105Z</updated>
    
    <content type="html"><![CDATA[<p>Frida-Practice</p><span id="more"></span><h1 id="样本链接"><a class="header-anchor" href="#样本链接">¶</a>样本链接</h1><p><a href="https://github.com/OWASP/owasp-mastg/tree/master/Crackmes">https://github.com/OWASP/owasp-mastg/tree/master/Crackmes</a></p><h1 id="Uncrackable3"><a class="header-anchor" href="#Uncrackable3">¶</a>Uncrackable3</h1><h2 id="校验so和dex"><a class="header-anchor" href="#校验so和dex">¶</a>校验so和dex</h2><p>首先创建一个<a href="https://zhuanlan.zhihu.com/p/127147909">HashMap</a>&lt;key,value&gt;，&lt;key,value&gt;是Entry的一个实体，获取资源值对应的字符串后转为Long类型，然后使用put方法存入HashMap中，获得到对应的文件后进行CRC校验</p><p>对so文件和dex文件进行CRC校验防止修改</p><p><img src="/2022/09/24/Frida-Practice/1664745653942.png" alt=""></p><p>遍历HashMap</p><p><img src="/2022/09/24/Frida-Practice/1665500859197.png" alt=""></p><h2 id="调试检测"><a class="header-anchor" href="#调试检测">¶</a>调试检测</h2><p>创建异步任务来检测调试</p><p><img src="/2022/09/24/Frida-Practice/1665501157986.png" alt=""></p><p>doInBackground方法是自定义的线程任务，onPostExecute在线程任务执行后进行，参数接收线程任务执行结果，参数为对UI控件进行设置，execute()用户手动调用异步任务</p><h2 id="Root-v2"><a class="header-anchor" href="#Root-v2">¶</a>Root</h2><p>Root环境检测</p><ul><li><p>test-keys表示为非官方发布版本， release-keys为官方发布版本</p></li><li><p>检查su命令-检测常用目录下是否存在su、判断系统环境变量是否存在su</p></li><li><p>检测指定路径下的文件是否存在</p></li></ul><p><img src="/2022/09/24/Frida-Practice/1664745696303.png" alt=""></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clazz=Java.use(<span class="string">"sg.vantagepoint.util.RootDetection"</span>)</span><br><span class="line">        clazz.checkRoot1.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        clazz.checkRoot2.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        clazz.checkRoot3.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">var</span> clazz11=Java.use(<span class="string">"sg.vantagepoint.util.IntegrityCheck"</span>);</span><br><span class="line">        clazz11.isDebuggable.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><h2 id="Frida检测"><a class="header-anchor" href="#Frida检测">¶</a>Frida检测</h2><p>使用<strong>Interceptor.replace替换循环检测Frida的函数</strong></p><blockquote><p><strong>第一个参数是要替换函数的地址，第二个参数是一个NativePointer类型的函数，一般由new NativeCallback创建，NativeCallback包括（函数的实现，函数的返回类型，函数的参数类型列表）。返回类型最好保持和原函数一致。同时我们也可以使用NativeFunction来主动调用原函数或是so层函数</strong></p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以直接Hook strstr比较函数 </span></span><br><span class="line"> <span class="keyword">var</span> addr=Module.findExportByName(<span class="string">"libc.so"</span>,<span class="string">"strstr"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(addr);</span><br><span class="line">        <span class="comment">//console.log(addr);</span></span><br><span class="line">        Interceptor.attach(addr,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                <span class="comment">//console.log(args[1].readCString());</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                retval.replace(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pt_create_func=Module.findExportByName(<span class="string">"libc.so"</span>,<span class="string">"pthread_create"</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"pt_create_func_addr:"</span>,pt_create_func);</span><br><span class="line">       <span class="keyword">var</span> detect_frida_addr=<span class="literal">null</span>;</span><br><span class="line">        Interceptor.attach(pt_create_func,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                <span class="keyword">if</span>(detect_frida_addr==<span class="literal">null</span>){</span><br><span class="line">                    <span class="keyword">var</span> base_addr=Module.findBaseAddress(<span class="string">"libfoo.so"</span>);</span><br><span class="line">                    detect_frida_addr=base_addr.add(<span class="number">0x30D0</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"Ptread_Addr:"</span>,base_addr);</span><br><span class="line">                    Interceptor.replace(<span class="built_in">this</span>.context.x2,<span class="keyword">new</span> NativeCallback(<span class="function"><span class="keyword">function</span>(<span class="params">a1</span>)</span>{</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">"Replace Success"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                },<span class="string">'void'</span>,[]));</span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><p><strong>如果想要在替换的函数中使用原函数的参数，需要注意参数类型</strong>，比如传入的env、jclass、data是指针类型，那么<strong>参数列表中就要声明为"pointer"</strong></p><p><img src="/2022/09/24/Frida-Practice/QQ%E5%9B%BE%E7%89%8720221003045438-1664744219994.jpg" alt=""></p><h2 id="Hook-函数用于获取参数"><a class="header-anchor" href="#Hook-函数用于获取参数">¶</a>Hook 函数用于获取参数</h2><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MainActivity = Java.use(<span class="string">"sg.vantagepoint.uncrackable3.MainActivity"</span>);<span class="comment">//Hook MainActivity的构造器，否则会提示so未加载</span></span><br><span class="line">         MainActivity.$init.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">                <span class="built_in">this</span>.$init();</span><br><span class="line">                attachToSecretGenerator();</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">var</span> addr2=Module.findExportByName(<span class="string">"libfoo.so"</span>,<span class="string">"Java_sg_vantagepoint_uncrackable3_CodeCheck_bar"</span>);</span><br><span class="line">        Interceptor.attach(addr2,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log((args[<span class="number">2</span>].readByteArray(<span class="number">32</span>)));<span class="comment">//读取数据</span></span><br><span class="line">                <span class="keyword">var</span> addr1=Module.findBaseAddress(<span class="string">"libfoo.so"</span>);</span><br><span class="line">                addr1=addr1.add(<span class="number">0x15038</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"=====xor_key====="</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(hexdump(addr1));</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attachToSecretGenerator</span>(<span class="params"></span>) </span>{</span><br><span class="line">    </span><br><span class="line">    Interceptor.attach(Module.findBaseAddress(<span class="string">'libfoo.so'</span>).add(<span class="number">0x10E0</span>), {</span><br><span class="line">      <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>{</span><br><span class="line">        <span class="comment">//因为参数会被加密，我们需要使用一个变量进行存储，再在onLeave打印加密结果</span></span><br><span class="line">        <span class="built_in">this</span>.answerLocation = args[<span class="number">0</span>];</span><br><span class="line">      },</span><br><span class="line">      <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>) </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.answerLocation.readByteArray(<span class="number">32</span>));</span><br><span class="line">      }</span><br><span class="line">    });</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h1 id="frida测试题"><a class="header-anchor" href="#frida测试题">¶</a>frida测试题</h1><p><a href="https://zhuanlan.zhihu.com/p/397872252">wp</a></p><p>Challenge-Six</p><p>反编译后的代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dta.test.frida.activity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> com.dta.test.frida.R;</span><br><span class="line"><span class="keyword">import</span> com.dta.test.frida.base.BaseActivity;</span><br><span class="line"><span class="keyword">import</span> com.dta.test.frida.base.Level;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loaded from: classes.dex */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SixthActivity</span> <span class="keyword">extends</span> <span class="title">BaseActivity</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// com.dta.test.frida.base.BaseActivity</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getActivityTitle</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"第六关"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// com.dta.test.frida.base.BaseActivity</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDescription</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> getString(R.string.sixth);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// com.dta.test.frida.base.BaseActivity, android.view.View.OnClickListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onClick(view);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; cls = Class.forName(<span class="string">"com.dta.test.frida.activity.RegisterClass"</span>);</span><br><span class="line">            <span class="keyword">if</span> (((Boolean) cls.getDeclaredMethod(<span class="string">"next"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]).invoke(cls.newInstance(), <span class="keyword">new</span> Object[<span class="number">0</span>])).booleanValue()) {</span><br><span class="line">                gotoNext(Level.Seventh);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                failTip();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Exception unused) {</span><br><span class="line">            failTip();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码中使用反射调用com.dta.test.frida.activity.RegisterClass中的next方法，然后接收其返回值</p><p><strong>Frida为我们提供了java.registerClass来注册类到内存中</strong>，其格式如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RegisterClass=Java.registerClass({</span><br><span class="line">            <span class="attr">name</span>:<span class="string">"com.dta.test.frida.activity.RegisterClass"</span>,</span><br><span class="line">            <span class="comment">//superClass:</span></span><br><span class="line">            <span class="comment">//类中定义的方法</span></span><br><span class="line">            <span class="attr">methods</span>:{</span><br><span class="line">                <span class="comment">//定义next方法</span></span><br><span class="line">                <span class="attr">next</span>: {</span><br><span class="line">                    <span class="comment">//返回值类型</span></span><br><span class="line">                    <span class="attr">returnType</span>: <span class="string">"boolean"</span>,</span><br><span class="line">                    <span class="comment">//函数参数列表，这里为空参</span></span><br><span class="line">                    <span class="attr">argumentTypes</span>:[],</span><br><span class="line">                    <span class="comment">//实现方法</span></span><br><span class="line">                    <span class="attr">implementation</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span><span class="comment">//返回true</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line">                <span class="comment">// $init: function () {</span></span><br><span class="line">                <span class="comment">//     console.log('Constructor called');</span></span><br><span class="line">                <span class="comment">//   }</span></span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><p>这样子就注册好了next方法，但是我们仍无法通过这一关</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(RegisterClass.$new().next());</span><br></pre></td></tr></tbody></table></figure><p>使用上述代码创建一个类的实例后调用next方法会发现我们的类成功注册并且next方法创建成功</p><p><img src="/2022/09/24/Frida-Practice/1665206578443.png" alt=""></p><p><strong>这里的问题出在了ClassLoader上</strong></p><p>翻看Class.forName()函数参数列表可以知道在其参数列表中存在ClassLoader</p><p><img src="/2022/09/24/Frida-Practice/1665206941779.png" alt=""></p><p><strong>默认为当前类的ClassLoader，在Android中默认的活动加载器为PathClassLoader</strong> ，Frida加载我们自定义类RegisterClass使用的<strong>ClassLoader</strong>跟SixthActivity的<strong>PathClassLoader</strong>并不是同一个ClassLoader，所以导致我们使用PathClassLoader来加载会出现<strong>ClassNotFoundException</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetClassLoader = RegisterClass.class.getClassLoader()<span class="comment">//获取类加载器，也就是我们自定义的RegisterClass的加载器</span></span><br><span class="line">       <span class="built_in">console</span>.log(targetClassLoader);</span><br></pre></td></tr></tbody></table></figure><p>使用<strong>class.getClassLoader</strong>获取类加载器后打印可知其使用的是DexClassLoader</p><p><img src="/2022/09/24/Frida-Practice/1665207462148.png" alt=""></p><p><strong>由于使用双亲委派机制，所以我们可以修改其父加载器使其能正确加载</strong></p><p>安卓类加载器的继承关系图</p><p><img src="/2022/09/24/Frida-Practice/R.png" alt="查看源图像"></p><blockquote><p><strong>双亲委派机制是指当加载类时首先不会选择自身进行加载，而是先交由其父加载器进行，如果父加载器加载不了再由自己进行加载，所以相当于从ClassLoader往下开始进行加载</strong></p></blockquote><p>我们可以在PathClassLoader与BaseDexClassLoader之间插入我们定义类的加载器</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> targetClassLoader = RegisterClass.class.getClassLoader()<span class="comment">//获取类加载器，也就是我们自定义的RegisterClass的加载器</span></span><br><span class="line">       <span class="built_in">console</span>.log(targetClassLoader);</span><br><span class="line">       Java.enumerateClassLoaders({<span class="comment">//枚举类加载器中能加载SixthActivity的</span></span><br><span class="line">            <span class="attr">onMatch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">loader</span>)</span>{</span><br><span class="line">                <span class="keyword">try</span>{</span><br><span class="line">                    <span class="keyword">if</span>(loader.findClass(<span class="string">"com.dta.test.frida.activity.SixthActivity"</span>)){</span><br><span class="line">                         <span class="comment">// PathClassLoader</span></span><br><span class="line">                         <span class="keyword">var</span> PathClassLoader = loader</span><br><span class="line">                         <span class="comment">//通过parent来获取类加载器的父类加载器</span></span><br><span class="line">                         <span class="keyword">var</span> BootClassLoader = PathClassLoader.parent.value</span><br><span class="line">                         PathClassLoader.parent.value = targetClassLoader</span><br><span class="line">                         targetClassLoader.parent.value = BootClassLoader<span class="comment">//在BootClassLoader和PathClassLoader中插入我们的类加载器,这样当BootClassLoader加载失败就会回到我们自定义的加载器来进行加载</span></span><br><span class="line">                    }</span><br><span class="line"> </span><br><span class="line">                }<span class="keyword">catch</span>(e){</span><br><span class="line">                    </span><br><span class="line">                }</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"Completed!"</span>)</span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><p>也可以Hook Class.forName方法，指定ClassLoader为RegisterClass的加载器</p><h1 id="Anti-Frida-Pass"><a class="header-anchor" href="#Anti-Frida-Pass">¶</a>Anti-Frida&amp;Pass</h1><p><a href="https://xxr0ss.github.io/post/frida_detection/">Frida-Detect</a></p><p>**由于Frida是代码注入工具，所以Frida的模块会在进程中留下痕迹，proc是Linux中的伪文件系统，而在内存中存在/proc/pid目录存储进程的一些信息，应用程序可以访问获得内核的信息，/proc/pid/maps显示进程的内存区域映射信息 **</p><ol><li><p><strong>通过maps检测</strong>：扫描/proc/pid/maps文件中的内存分布，寻找是否打开了/data/local/tmp路径下的so，（Frida在运 行时会先确定/data/local/tmp路径下是否有re.frida.server文件夹，若没有则创建该文件夹并存放frida-agent.so等文件），我们使用cat命令即可获得</p><p><img src="/2022/09/24/Frida-Practice/1664546229771.png" alt=""></p></li><li><p><strong>通过task检测</strong>：扫描task目录下所有/task/pid/status中的Name字段是否存在frida注入的特征，具体线程名为<strong>gmain、gdbus、gum-js-loop</strong>，一般这三个线程是在第11-13行，<strong>同时也会存在Name字段为pool-frida的线程</strong></p><p><img src="/2022/09/24/Frida-Practice/1664546751921.png" alt=""></p><p><img src="/2022/09/24/Frida-Practice/1664546732410.png" alt=""></p></li><li><p><strong>通过fd检测</strong>：通过readlink查看/proc/pid/fd和/proc/task/pid/fd下所有的文件，检测是否有frida相关文件</p><p><img src="/2022/09/24/Frida-Practice/1664547128892.png" alt=""></p></li><li><p><strong>端口检测</strong>：Frida默认的端口为<strong>27042</strong>，检测该TCP端口是否开放</p></li><li><p><strong>通过D-Bus检测</strong>： Frida是通过D-Bus协议进行通信的，所以可以遍历/proc/net/tcp文件，向每个开放的端口发送 D-Bus 的 认证消息 AUTH ，如果端口回复了 REJECT ，那么这个端口就是frida-server</p></li></ol><h1 id="Easy-AntiFrida-Pass"><a class="header-anchor" href="#Easy-AntiFrida-Pass">¶</a>Easy-AntiFrida-Pass</h1><h2 id="PortCheck"><a class="header-anchor" href="#PortCheck">¶</a>PortCheck</h2><p><img src="/2022/09/24/Frida-Practice/1664729895041.png" alt=""></p><h2 id="ThreadCheck"><a class="header-anchor" href="#ThreadCheck">¶</a>ThreadCheck</h2><p><img src="/2022/09/24/Frida-Practice/1664730157823.png" alt=""></p><h2 id="MapsCheck"><a class="header-anchor" href="#MapsCheck">¶</a>MapsCheck</h2><p><img src="/2022/09/24/Frida-Practice/1664730381755.png" alt=""></p><h2 id="TraceCheck"><a class="header-anchor" href="#TraceCheck">¶</a>TraceCheck</h2><p><img src="/2022/09/24/Frida-Practice/1664730547121.png" alt=""></p><h1 id="MemoryCheck"><a class="header-anchor" href="#MemoryCheck">¶</a>MemoryCheck</h1><p><strong>maps显示当前正在运行进程的地址映射或进程的内存地址空间的文件</strong></p><p><img src="/2022/09/24/Frida-Practice/1664730594599.png" alt=""></p><h2 id="fdCheck"><a class="header-anchor" href="#fdCheck">¶</a>fdCheck</h2><p><img src="/2022/09/24/Frida-Practice/1664730742475.png" alt=""></p><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>从上面的各种检测方式中，可以看出主要方式都是通过打开特定的文件和进程内存文件，然后使用字符串比较函数strstr，或者使用<strong>stat</strong>判断文件是否存在，也可以进行端口检测，<strong>Frida默认端口是27042</strong></p><p>对于端口检测，可以Hook掉<strong>connect函数的返回值</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span>=Process.getModuleByName(<span class="string">"libc.so"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">module</span>.base);</span><br><span class="line">        <span class="comment">//var methods=module.enumerateExports();</span></span><br><span class="line">        <span class="comment">// for(var i=0;i&lt;methods.length;++i){</span></span><br><span class="line">        <span class="comment">//     console.log(methods[i].name);</span></span><br><span class="line">        <span class="comment">// }</span></span><br><span class="line">        <span class="keyword">var</span> connect=<span class="built_in">module</span>.findExportByName(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(connect);</span><br><span class="line">        Interceptor.attach(connect,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line"></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"Change Success!!"</span>);</span><br><span class="line">                <span class="comment">//使用replace修改参数和返回值</span></span><br><span class="line">                retval.replace(<span class="number">1</span>);<span class="comment">//将返回值修改为1表示连接端口成功</span></span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>也可以修改frida-server默认端口</strong>，**/data/local/tmp # ./frida-server-15.1.17-android-arm64 -l 0.0.0.0:1234，然后adb forward tcp:1234 tcp:1234，脚本运行： frida -H 127.0.0.1:1234 -f owasp.mstg.uncrackable3  -l .\Uncrackme3.js **</p></blockquote><p>所以我们只需要Hook掉<strong>libc中的strstr函数</strong>即可</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span>=Process.getModuleByName(<span class="string">"libc.so"</span>);</span><br><span class="line"><span class="comment">//首先先获取模块，然后在模块的导出表中循寻找strstr函数，</span></span><br><span class="line"><span class="keyword">var</span> strstr=<span class="built_in">module</span>.findExportByName(<span class="string">"strstr"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(strstr);</span><br><span class="line">        Interceptor.attach(strstr,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                <span class="comment">//console.log(args[1].readCString());//C字符串读取为JS字符串</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                retval.replace(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//修改strstr函数的返回值</span></span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> stat=<span class="built_in">module</span>.findExportByName(<span class="string">"stat"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(stat);</span><br><span class="line">        Interceptor.attach(stat,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                </span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                retval.replace(<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>虽然这里的System.LoadLibrary是static属性的，但是不知道为啥没有提前加载=。=，所以需要我们手动Hook主活动的构造器</strong></p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MainActivity = Java.use(<span class="string">"com.yimian.envcheck.MainActivity"</span>);<span class="comment">//让他加载so</span></span><br><span class="line">        MainActivity.$init.implementation = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">               <span class="built_in">this</span>.$init();<span class="comment">//调用构造器</span></span><br><span class="line">       };</span><br></pre></td></tr></tbody></table></figure><p>当然我们也可以Hook掉比较的字符串，首先先在内存中写入我们用于比较的字符串(<strong>allocUtf8String</strong>)，然后将地址在onEnter回调函数中<strong>进而修改strstr函数的参数</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newStr=<span class="string">"new String"</span>;</span><br><span class="line">       <span class="keyword">var</span> newstraddr=Memory.allocUtf8String(newStr);<span class="comment">//写入内存，返回字符串第一个字符的地址</span></span><br><span class="line">       <span class="keyword">var</span> strcpy=<span class="built_in">module</span>.findExportByName(<span class="string">"strstr"</span>);</span><br><span class="line">       Interceptor.attach(strcpy,{</span><br><span class="line">           <span class="comment">//对于数值参数的修改，使用ptr()即可，字符串则需要在内存中Alloc后重新将地址赋值给参数</span></span><br><span class="line">           <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">               args[<span class="number">1</span>]=newstraddr;</span><br><span class="line">               <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">           },</span><br><span class="line">           <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">               </span><br><span class="line">           }</span><br><span class="line">       })</span><br></pre></td></tr></tbody></table></figure><p>在Memory的check中使用的是逐字符比较，我们可以<strong>Hook掉汇编指令中的比较值</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> byte1=[<span class="number">0x5F</span>,<span class="number">0x41</span>,<span class="number">0x01</span>,<span class="number">0x71</span>];</span><br><span class="line">      <span class="keyword">const</span> byte2=[<span class="number">0x7F</span>,<span class="number">0xE9</span>,<span class="number">0x01</span>,<span class="number">0x71</span>];</span><br><span class="line">      <span class="keyword">const</span> byte3=[<span class="number">0x7F</span>,<span class="number">0xE9</span>,<span class="number">0x01</span>,<span class="number">0x71</span>];</span><br><span class="line">      <span class="keyword">const</span> byte4=[<span class="number">0x3F</span>,<span class="number">0x42</span>,<span class="number">0x01</span>,<span class="number">0x71</span>];</span><br><span class="line">      <span class="keyword">const</span> byte5=[<span class="number">0x5F</span>,<span class="number">0x42</span>,<span class="number">0x01</span>,<span class="number">0x71</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> module_base=Module.findBaseAddress(<span class="string">"libtestfrida.so"</span>);</span><br><span class="line">      <span class="comment">//console.log(module_base);</span></span><br><span class="line">      <span class="keyword">var</span> func=module_base.add(<span class="number">0x001D5C</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(Instruction.parse(func));</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">console</span>.log(func);</span><br><span class="line">      <span class="keyword">var</span> func2=module_base.add(<span class="number">0x01E54</span>);</span><br><span class="line">      <span class="keyword">var</span> func5=module_base.add(<span class="number">0x1FF8</span>);</span><br><span class="line">      <span class="keyword">var</span> func3=module_base.add(<span class="number">0x01F24</span>);</span><br><span class="line">      <span class="keyword">var</span> func4=module_base.add(<span class="number">0x20BC</span>);</span><br><span class="line">      <span class="comment">//console.log(Instruction.parse(func4));</span></span><br><span class="line">      <span class="comment">//查看地址出的arm汇编</span></span><br><span class="line">     <span class="comment">// console.log(Instruction.parse(func));</span></span><br><span class="line">      <span class="comment">//console.log(Instruction.parse(func2));</span></span><br><span class="line">      Memory.protect(func,<span class="number">8</span>,<span class="string">'rwx'</span>);</span><br><span class="line">      Memory.protect(func2,<span class="number">8</span>,<span class="string">'rwx'</span>);</span><br><span class="line">      Memory.protect(func3,<span class="number">8</span>,<span class="string">'rwx'</span>);</span><br><span class="line">      Memory.protect(func4,<span class="number">8</span>,<span class="string">'rwx'</span>);</span><br><span class="line">      Memory.protect(func5,<span class="number">8</span>,<span class="string">'rwx'</span>);</span><br><span class="line">      func.writeByteArray(byte1);</span><br><span class="line">      func2.writeByteArray(byte2);</span><br><span class="line">      func3.writeByteArray(byte3);</span><br><span class="line">      func4.writeByteArray(byte4);</span><br><span class="line">      func5.writeByteArray(byte5);</span><br></pre></td></tr></tbody></table></figure><p>首先我们先找到想要Hook的<strong>CMP汇编地址，然后根据机器码创建byte数组，最后使用writeByteArray写入即可</strong></p><p>以0x1DA4为例，[5F,C9,01,71]是地址中原来的数据，C9是用于比较的数，我们只需要修改其即可，最后写入内存中</p><p><img src="/2022/09/24/Frida-Practice/1664731679822.png" alt=""></p><blockquote><p><strong>可以使用Instruction.prase(addr)打印汇编代码，使用Memory.protect(addr,size,“rwx”);来设置修改内存的属性和大小</strong></p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(func2,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.x11);</span><br><span class="line">                <span class="built_in">this</span>.context.x11=<span class="number">0x45</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.x11);</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.x11);</span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><p><strong>也可以使用Frida进行inlineHook，并且修改寄存器的值，这里的W11是X11的低32位</strong></p><p>最终效果</p><p><img src="/2022/09/24/Frida-Practice/1664734091908.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Frida-Practice&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android-Learning</title>
    <link href="https://gift1a.github.io/2022/09/06/Android-Learning/"/>
    <id>https://gift1a.github.io/2022/09/06/Android-Learning/</id>
    <published>2022-09-06T09:51:38.000Z</published>
    <updated>2022-09-30T15:32:15.041Z</updated>
    
    <content type="html"><![CDATA[<p>Android Learning</p><span id="more"></span><h1 id="Android-Studio项目目录"><a class="header-anchor" href="#Android-Studio项目目录">¶</a>Android Studio项目目录</h1><p><img src="/2022/09/06/Android-Learning/1662458792032.png" alt=""></p><ul><li><p>.gradle和.idea：这两个目录下放置的都是Android Studio自动生成的一些代码，我们无需关心</p></li><li><p><strong>app</strong>：项目中的代码、资源等内容几乎都是放置在这个目录下的，开发工作已基本都是在这个目录下进行的</p><p><img src="/2022/09/06/Android-Learning/1662459525767.png" alt=""></p><ul><li>​build：主要包含了一些在编译时自动生成的文件</li><li>libs：使用到的第三方jar包会被放在该目录下</li><li>android Test：用来编写Android Test测试用例，对项目进行自动化测试</li><li>java：放置java代码</li><li><strong>res</strong>：存放在项目中使用到的资源文件(图片、布局、字符串)，有多种相同开头的文件夹似乎为了<strong>让程序能够更好地兼容各种设备</strong><ul><li><strong>所有以drawable开头的文件夹都是用存放图片的</strong></li><li><strong>所有以mipmap开头的文件夹都是用来放应用图标的</strong></li><li><strong>所有以values开头的文件夹都是用来存放字符串、样式、颜色等配置的</strong></li><li><strong>latout文件夹是用来放布局文件的</strong></li></ul></li><li><strong>Android Manifest.xml</strong>：整个项目的配置文件，在程序中定义的四大组件都需要在这个文件中注册，还可以在这个文件中给应用程序添加权限声明</li><li>test：用于编写Unit Test测试用例的，对项目进行自动化测试</li><li>.gitignore：作用和外层的.gitignore文件类似</li><li>app.iml：IDEA项目自动创建的文件</li><li>build.gradle：这是app模块的gradle构建脚本，会指定很多项目构建相关的配置</li><li><strong><a href="http://proguard-rules.pro">proguard-rules.pro</a></strong>：这个文件用于制定项目代码的混淆规则</li></ul></li><li><p>build：主要包含了一些在编译时自动生成的文件</p></li><li><p>gradle：这个目录下包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前下载好gradle，而是自动联网下载gradle。<strong>Android Studio默认没有启用gradle wrapper方式，可以在File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Gradle进行配置</strong></p></li><li><p>gitignore：用来将指定的目录或文件排除在版本控制之外</p></li><li><p>build.gradle：这是项目全局的gradle构建脚本</p></li><li><p>gradle.properties：这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本</p></li><li><p>gradlew和gradlew.bat：这两个文件是用来在命令行界面中执行gradle命令的，<strong>分别对应Linux、Mac系统和Windows系统</strong></p></li><li><p>Myapplication.iml：iml是所有IntelliJ IDEA项目都会自动创建的一个文件，用于表示这是一个IDEA项目</p></li><li><p>local.properties：指定本机中Android SDK路径</p></li><li><p>settings.gradle：用于指定项目中所有引入的模块</p></li></ul><h2 id="APK的运行"><a class="header-anchor" href="#APK的运行">¶</a>APK的运行</h2><p>首先先在AndroidManifest.xml文件找到这段代码</p><p><img src="/2022/09/06/Android-Learning/1662461945309.png" alt=""></p><blockquote><p><strong>android:name=".ClassName"对该类名的函数进行注册，没有在AndroidManifest.xml里注册的活动是不能使用的,具体来说，android:name 属性的作用就是设置一个类，当app运行前创建实例，并可以将类中的数据在运行期间给所有 Activity 来访问。其中intent-filter里的两行代码<action android:name="android.intent.action.MAIN">和<category android:name="android.intent.category.LAUNCHAR">表示Mainactivity是这个项目的主活动，在手机上点集应用图标，首先启动这个活动</category></action></strong></p></blockquote><blockquote><p>活动是应用程序的门面，凡是在应用中能看到的东西都是放在活动中的</p></blockquote><p><img src="/2022/09/06/Android-Learning/1662462526161.png" alt=""></p><p>可以看到MainActivity是继承自AppCompatActivity的，<strong>Activity是Android系统提供的一个活动基类</strong>，项目中所有的活动都必须继承它或者它的子类才能拥有活动的特性(AppCompatActivity是Activity的子类)，<strong>而Oncreate()是MainActivity的方法，这个方法是一个活动被创建时必定要执行的方法</strong></p><blockquote><p>Android程序的设计逻辑讲究<strong>逻辑和视图分离</strong>，因此不建议在活动中直接编写界面，而应该<strong>在布局文件中编写界面，在活动中引入进来</strong>。Oncreate()方法第二行调用了setContentview方法，<strong>为当前的活动引入了一个activity_main布局</strong>。<strong>布局文件都是定义在res/layout目录下的</strong></p></blockquote><p>在res/layout/activity_main.xml下可以看到</p><p><img src="/2022/09/06/Android-Learning/1662463227507.png" alt=""></p><p><strong>TestView是Android系统提供的一个控件，用于在布局中显示文字</strong>，而显示出来的"Hello World!"就是通过android:text="Hello World!"定义的</p><h2 id="使用资源文件"><a class="header-anchor" href="#使用资源文件">¶</a>使用资源文件</h2><p>打开res/layout/strings.xml文件可以看到</p><p><img src="/2022/09/06/Android-Learning/1662463684630.png" alt=""></p><p>对于这个定义应用程序名的字符串，我们有两种方式来引用它</p><ul><li><strong>在代码中通过R.string.activity_main可以获得该字符串的引用</strong></li><li><strong>在XML中通过@string/activity_main可以获得该字符串的引用</strong></li></ul><p>基本的语法就是上面这两种，对于其他资源文件，只需要替换string部分即可，使用例子如下</p><p><img src="/2022/09/06/Android-Learning/1662464038119.png" alt=""></p><h2 id="详解build-gradle文件"><a class="header-anchor" href="#详解build-gradle文件">¶</a>详解build.gradle文件</h2><p>Android Stuido采用Gradle来构建项目。Gradle基于Groovy的领域特定语言(DSL)来声明项目设置</p><h3 id="项目外层的bulid-gradle文件"><a class="header-anchor" href="#项目外层的bulid-gradle文件">¶</a>项目外层的bulid.gradle文件</h3><p><img src="/2022/09/06/Android-Learning/1662464234618.png" alt=""></p><p>dependencies闭包中使用classpath声明了一个Gradle插件。由于Gradle还可以用于构建Java、C++等项目，所以需要声明插件</p><h3 id="app目录下的build-gradle文件"><a class="header-anchor" href="#app目录下的build-gradle文件">¶</a>app目录下的build.gradle文件</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">plugins {</span><br><span class="line">    id <span class="string">'com.android.application'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">android {</span><br><span class="line">    compileSdk <span class="number">31</span></span><br><span class="line"></span><br><span class="line">    defaultConfig {</span><br><span class="line">        applicationId <span class="string">"com.example.myapplication"</span></span><br><span class="line">        minSdk <span class="number">21</span></span><br><span class="line">        targetSdk <span class="number">31</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner <span class="string">"androidx.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    buildTypes {</span><br><span class="line">        release {</span><br><span class="line">            <span class="function">minifyEnabled <span class="keyword">false</span></span></span><br><span class="line"><span class="function">            proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android-optimize.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        }</span></span><br><span class="line"><span class="function">    }</span></span><br><span class="line"><span class="function">    compileOptions </span>{</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">dependencies {</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">'androidx.appcompat:appcompat:1.2.0'</span></span><br><span class="line">    implementation <span class="string">'com.google.android.material:material:1.3.0'</span></span><br><span class="line">    implementation <span class="string">'androidx.constraintlayout:constraintlayout:2.0.4'</span></span><br><span class="line">    testImplementation <span class="string">'junit:junit:4.+'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.ext:junit:1.1.2'</span></span><br><span class="line">    androidTestImplementation <span class="string">'androidx.test.espresso:espresso-core:3.3.0'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>第一行应用了一个插件，一般有两种值可选:<strong>com.android.application和com.android.library</strong>，分别表示这是一个应用程序模块和一个库模块</p><p>接下来是一个大的android闭包，主要用于配置项目构建的各种属性，<strong>compileSdkVersion用于指定项目构建版本的版本</strong>。android闭包中的defaultConfig闭包对项目中的更多细节进行配置，<strong>applicationId用于指定项目的包名，我们可以在这里修改包名</strong>，<strong>minSdkversion指定项目最低兼容的Android系统版本</strong>，<strong>targetSdkVersion指定的值表示你已经在该目标版做过充分的测试</strong>，<strong>versionCode和versionName分别指定项目的版本号和版本名</strong></p><p><strong>buildTypes</strong>闭包用于指定生成安装文件的相关配置，<strong>通常只会有debug和release闭包</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662465040715.png" alt="release闭包中的代码混淆"></p><p>dependencies闭包</p><p><img src="/2022/09/06/Android-Learning/1662465082606.png" alt=""></p><h2 id="Android中的日志工具Log"><a class="header-anchor" href="#Android中的日志工具Log">¶</a>Android中的日志工具Log</h2><p>Log中有五种方法</p><p><img src="/2022/09/06/Android-Learning/1662465165044.png" alt=""></p><p>在代码中加入Log.d(“MainActivity”,“Oncreate execute”);，然后重新运行就可以在logcat窗口中看见打印的信息</p><p><img src="/2022/09/06/Android-Learning/1662465488378.png" alt=""></p><p>由于每次传入参数Tag，我们可以在Oncreate方法外输入logt+Tab，<strong>此时就会以当前的类名作为值自动生成一个TAG常量</strong></p><p><img src="/2022/09/06/Android-Learning/1662465816903.png" alt=""></p><p>同时在logcat中可以添加过滤器来过滤我们不需要的信息</p><p><img src="/2022/09/06/Android-Learning/1662466014012.png" alt=""></p><p>我们可以通过Edit Filter Configuration创建根据Tag进行过滤的过滤器</p><h1 id="探究活动"><a class="header-anchor" href="#探究活动">¶</a>探究活动</h1><h2 id="手动创建活动"><a class="header-anchor" href="#手动创建活动">¶</a>手动创建活动</h2><p>首先先手动创建一个空的项目，然后手动添加Activity，注意此时不要将该活动注册，也不要设为当前项目的主活动</p><p><img src="/2022/09/06/Android-Learning/1662468554715.png" alt=""></p><blockquote><p><strong>项目中的任何活动都应该重写Activity中的Oncreate()方法，因为父类中也有该方法</strong></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里的onCreate()方法就是调用了父类的onCreate()方法</p><h3 id="创建和加载布局"><a class="header-anchor" href="#创建和加载布局">¶</a>创建和加载布局</h3><p>Android程序设计讲究逻辑和视图分离，最后每一个活动都能对于一个布局，<strong>布局就是用来显示界面内容的</strong></p><p>app/src/main/res-&gt;New-&gt;Directory/Android resource Directiory创建一个layout目录，然后再右键创建Layout resource file</p><p><img src="/2022/09/06/Android-Learning/1662469071207.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662469102288.png" alt=""></p><p>创建完成之后AS为我们提供了可视化布局编辑器，下图红色框中的三个按钮可以在文本模式和可视化布局下切换</p><p><img src="/2022/09/06/Android-Learning/1662469324554.png" alt=""></p><p>接下来我们添加一个Button元素</p><p><img src="/2022/09/06/Android-Learning/1662469483998.png" alt=""></p><blockquote><p><strong>如果我们需要在XML中引用一个id，就是用@id/id_name这种语法，如果是定义一个id，就使用@+id/id_name这种语法</strong>，下面三个属性分别是宽高和元素中显示的文字内容，<strong>创建之后我们就可以通过R.id.id_name来直接加载资源文件</strong></p></blockquote><p>此时切换回布局界面就可以看见我们创建的Button了</p><p><img src="/2022/09/06/Android-Learning/1662469811714.png" alt=""></p><p>接下来我们在活动中加载这个布局</p><p><img src="/2022/09/06/Android-Learning/1662469909141.png" alt=""></p><blockquote><p>在setContentView()方法中，我们一般会传入一个布局文件的id。<strong>项目中添加的任何资源都会在R文件中生成一个相应的资源id</strong>，因此我们创建的first_layout.xml布局的id现在应该是已经添加到R文件中了，<strong>接着只需要调用R.layout.first_layout就可以得到first_layout.xml布局的id</strong>，然后将这个值传入setContentView()方法即可</p></blockquote><h3 id="在AndroidManifest文件中注册"><a class="header-anchor" href="#在AndroidManifest文件中注册">¶</a>在AndroidManifest文件中注册</h3><p>接下来我们要将活动进行注册，而AS已经自动帮我们注册了，但是此时还未指定程序的主活动。</p><h3 id="配置主活动"><a class="header-anchor" href="#配置主活动">¶</a>配置主活动</h3><p>只需要在<activity>标签内部加入<intent-filter>标签，并且在这个标签里添加<action android:name="android.intent.action.MAIN">和<category android:name="android.intent.category.LAUNCHER">这两句声明即可</category></action></intent-filter></activity></p><p><img src="/2022/09/06/Android-Learning/1662478133964.png" alt=""></p><blockquote><p>注意如果添加<intent-filter>标签需要加上<strong>android:exported=“true”</strong></intent-filter></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662478054999.png" alt=""></p><p>然后运行即可，可以看到BUTTON1按钮已经创建好了</p><p><img src="/2022/09/06/Android-Learning/1662478160320.png" alt=""></p><p>下面这个是标签栏</p><p><img src="/2022/09/06/Android-Learning/1662478448578.png" alt=""></p><blockquote><p>如果应用程序中没有声明任何一个活动作为主活动，这个程序仍然是可以正常安装的，只是无法在启动器中看到或打开这个程序。<strong>这种程序一般都是作为第三方服务提供其他应用在内部进行调用的，比如支付宝的快捷支付服务</strong></p></blockquote><h3 id="在活动中使用Toast"><a class="header-anchor" href="#在活动中使用Toast">¶</a>在活动中使用Toast</h3><blockquote><p><strong>Toast是Android系统提供的一种非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失</strong></p></blockquote><p>先在我们创建的按钮中添加一个<strong>弹出Toast的触发点</strong>，在Oncreate函数中添加代码</p><p><img src="/2022/09/06/Android-Learning/1662530604544.png" alt=""></p><blockquote><p><strong>在活动中可以通过findViewById()方法获取到在布局文件中定义的元素，这里我们传入R.id.button_1来获得按钮的实例（new出来的对象）</strong>，这个值就是我们在first_layout.xml中通过android:id属性指定的。<strong>findViewById()方法返回一个View对象，我们需要向下转型为Button对象</strong>，得到按钮的实例之后，我们通过<strong>setOnclickListener()方法为按钮注册一个监听器，点击按钮就会执行监听器中的onClick()方法。因此弹出Toast的功能需要在onClick()方法中编写</strong></p><p>Toast的用法比较简单，<strong>通过makeText()创建出一个Toast对象，然后调用show()将Toast显示出来即可</strong>，makeText()方法需要三个参数，<strong>第一个参数是Context，也就是Toast要求的上下文，而活动本身就是一个Context对象，所以直接传入MainActivity.this即可，第二个参数是Toast显示的文本内容，第三个参数是Toast显示的时长，可以选择Toast.LENGTH_SHORT或Toast.LENGTH_LONG</strong></p></blockquote><p><strong>同时我们可以修改Toast的颜色、背景和字体大小，然后再调用show方法</strong></p><p><a href="https://www.itbaoku.cn/post/1922470.html">自定义Toast</a></p><h3 id="在活动中使用Menu"><a class="header-anchor" href="#在活动中使用Menu">¶</a>在活动中使用Menu</h3><blockquote><p><strong>首先在res目录下新建一个menu文件夹，接着在这个文件夹下新建一个叫main的菜单文件</strong></p></blockquote><p>接下来再main.xml中添加如下代码</p><p><img src="/2022/09/06/Android-Learning/1662532330621.png" alt=""></p><blockquote><p>这里我们创建了两个菜单项，<strong>其中<item>标签用来创建一个具体的菜单项，通过android:id为这个菜单指定一个唯一的标识符，通过android:title为这个菜单指定名称</item></strong></p></blockquote><p>接着重新回到MainAcivity中重写onCreateOptionsMenu()方法</p><blockquote><p><strong>可以通过Ctrl+O快速重写方法</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662532776687.png" alt=""></p><blockquote><p><strong>getMenuInflater()方法能够得到MenuInflater对象，再调用它的inflate方法就可以给当前活动创建菜单了。第一个参数用于指定使用哪一个资源文件来创建菜单，第二个参数用于指定我们的菜单项将添加到哪一个Menu对象中去</strong>，这里直接使用onCreateOptionsMenu方法中传入的menu参数，然后返回true表示创建成功。</p><p><strong>我们还需要定义菜单响应事件</strong>，在MainActivity中重写onOptionsMenuSelected方法</p></blockquote><p><img src="/2022/09/06/Android-Learning/1662533709258.png" alt=""></p><blockquote><p><strong>在onOptionsItemSelected方法中，通过调用item.getItemid()来判断我们点击的菜单项，然后为菜单项加入逻辑</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662533835910.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662533848885.png" alt=""></p><h3 id="销毁一个活动"><a class="header-anchor" href="#销毁一个活动">¶</a>销毁一个活动</h3><blockquote><p><strong>Activity类中提供了一个finish()方法来让我们结束当前的活动</strong></p></blockquote><p>我们在MainActivity中修改一下代码，此时点击Button1活动就会结束了</p><p><img src="/2022/09/06/Android-Learning/1662533977800.png" alt=""></p><h3 id="使用Intent在活动之间穿梭"><a class="header-anchor" href="#使用Intent在活动之间穿梭">¶</a>使用Intent在活动之间穿梭</h3><p>接下来我们会学习如何从主活动跳转到其他活动</p><h4 id="使用显式Intent"><a class="header-anchor" href="#使用显式Intent">¶</a>使用显式Intent</h4><p>接下来我们再创建一个活动，并且定义一个按钮，<strong>此时AS已经自动帮我们在AndroidManifest.xml文件中注册了</strong></p><blockquote><p><strong>LinearLayout表示线性布局，在Android中有六种布局</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662534666206.png" alt=""></p><blockquote><p><strong>Intent是Android程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据，Intent一般可被用于启动活动，启动服务以及发送广播等场景</strong></p><p><strong>Intent大致可以分为显式和隐式</strong></p><p><strong>Intent有多个构造函数的重载，其中一个是Intent(Context packageContext,Class&lt;?&gt;cls)。这个构造函数接受两个参数，第一个参数Context要求提供一个启动活动的上下文，第二个参数Class则是指定想要启动的目标活动</strong>。<strong>接下来我们将Intent对象传入Activity类中的startActivity方法启动目标活动</strong></p></blockquote><p>我们将当前活动作为上下文，出啊如SecondActivity.class作为目标互动，此时点击Button1就会通过startActivity来执行这个Intent</p><p><img src="/2022/09/06/Android-Learning/1662535515678.png" alt=""></p><p><strong>如果想销毁当前的互动，只需要点击Back键即可</strong></p><p><img src="/2022/09/06/Android-Learning/1662535887974.png" alt=""></p><blockquote><p>这种Intent的"意图"非常明显的，我们称之为显式Intent</p></blockquote><h4 id="使用隐式Intent"><a class="header-anchor" href="#使用隐式Intent">¶</a>使用隐式Intent</h4><blockquote><p><strong>隐式Intent并不在明确指出我们想要启动的活动，而是指定了一系列action和category等信息，然后交由系统去分析Intent，并帮我们找出合适的活动去启动</strong></p><p><strong>我们可以通过在<activity>标签下配置<intent-filter>的内容（intent过滤器），进而指定当前活动能够响应的action和category</intent-filter></activity></strong></p></blockquote><p>在<action>标签中我们指明了当前活动可以响应com.example.myapplication.ACTION_START这个action，而<category>标签则包含了一些附加信息，更精确地指定当前活动能够响应的Intent，只有Intent过滤器中的全部标签都满足时，这个活动才能响应该Intent</category></action></p><p><img src="/2022/09/06/Android-Learning/1662536765474.png" alt=""></p><p>修改MainActivity中按钮的点击事件</p><p><img src="/2022/09/06/Android-Learning/1662537043100.png" alt=""></p><blockquote><p><strong>这里我们传入不同的参数来使用不同的构造函数</strong>，这里我们直接将action的字符串传入，<strong>表明我们想要启动能够响应com.example.myapplication.ACTION_START这个action的活动</strong>。没有指定category是因为<strong>android.intent.category.DEFAULT</strong>是一种默认的category，在调用starActivity会自动将这个category添加到Intent中</p></blockquote><blockquote><p><strong>每个Intent中只能指定一个action，但却能指定多个category</strong>，接下来我们在Intent中增加一个category，并且在活动的<intent-filter>中添加该categoty，表示可以响应这个Intent中的category内容</intent-filter></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662537654946.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662537676941.png" alt=""></p><p>此时我们可以通过点击Button1进入SecondActivity活动</p><p><img src="/2022/09/06/Android-Learning/1662537864721.png" alt=""></p><p>这个就是隐式Intent</p><h4 id="更多隐式Intent的用法"><a class="header-anchor" href="#更多隐式Intent的用法">¶</a>更多隐式Intent的用法</h4><blockquote><p><strong>使用隐式Intent不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得Android多个应用程序之间的功能共享成为了可能</strong>，我们可以调用系统的浏览器来打开网页</p></blockquote><p>我们创建一个隐式Intent</p><p><img src="/2022/09/06/Android-Learning/1662554434138.png" alt=""></p><blockquote><p>首先制定了Intent的action是Intent.ACTION_VIEW，这是一个Android系统的内置动作，其常量值为android.intent.VIEW，然后通过Uri.prase()方法将一个网站字符串解析为Uri对象，再调用Intent的setData()方法将这个Uri对象传递进去，<strong>setdata()方法接受一个Uri对象，用于指定当前Intent正在操作的数据，而这些数据通常都是 以字符串的形式传入Uri.parse()方法中解析产生的</strong></p></blockquote><p>此时我们点击Button1就会启动浏览器并且打开百度</p><p><img src="/2022/09/06/Android-Learning/1662554707799.png" alt=""></p><blockquote><p>**我们还可以在<intent-filter>标签中再配置一个<data>标签，用于更精确地指定当前活动能够响应什么类型的数据 **</data></intent-filter></p></blockquote><p><data>标签主要可以配置以下内容</data></p><p><img src="/2022/09/06/Android-Learning/1662555045429.png" alt=""></p><p>只有<data>标签指定的内容和Intent中携带的Data完全一致时，当前活动才能响应该Intent，<strong>不过一般在<data>标签中不会指定过多的内容</data></strong>。当我们指定android:scheme为http就可以响应所有http协议的Intent了</data></p><p>下面是例子</p><p>创建一个ThirdActivity，然后修改layout布局文件，最后在AndroidManifest.xml中修改ThirdActivity的注册信息</p><p><img src="/2022/09/06/Android-Learning/1662557028153.png" alt=""></p><p>此时再点击Button1就会有两个活动来响应Intent，会跳出列表(<strong>目前能够响应这个Intent的所有程序</strong>)让我们来选择</p><blockquote><p>除此之外我们还可以指定其他协议</p></blockquote><p><img src="/2022/09/06/Android-Learning/1662557166726.png" alt=""></p><h4 id="向下一个活动传递数据"><a class="header-anchor" href="#向下一个活动传递数据">¶</a>向下一个活动传递数据</h4><blockquote><p><strong>Intent中提供了一系列putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动另一个活动之后，只需要把这些数据再从Intent中取出即可</strong></p></blockquote><p>比如说MainActivity中有一个字符串，现在想把这个字符串传递到SecondActivity中</p><p><img src="/2022/09/06/Android-Learning/1662559759330.png" alt="MainActivity"></p><p><img src="/2022/09/06/Android-Learning/1662559739461.png" alt="SecondActivity"></p><p>效果如下，可以在logcat中看到传入到SecondActivity中的data被打印</p><p><img src="/2022/09/06/Android-Learning/1662559790794.png" alt=""></p><blockquote><p><strong>在MainACtivity中使用显式Intent启动SecondActivity，并且通过putExtra()方法传递了一个字符串，其中第一个参数是键，用于后面从Intent中取值，第二个参数才是真正要传递的数据</strong></p><p><strong>在SecondActivity中使用getIntent()方法获取到用于启动SecondActivity的Intent，然后调用getStringExtra()方法传入相应的键值来获取传递的数据</strong>。不同类型的数据接收的方法也不同，整型则使用getIntExtra()方法</p></blockquote><h4 id="返回数据给上一个活动"><a class="header-anchor" href="#返回数据给上一个活动">¶</a>返回数据给上一个活动</h4><blockquote><p><strong>在Activity中还有一个startActivityForResult()方法，该方法也是用于启动活动的，并且能够在活动销毁的时候返回一个结果给上一个活动</strong></p><p><strong>startActivityForResult()方法接收两个参数，第一个参数是Intent，第二个参数是请求码，用于在之后的回调中判断数据的来源(请求码只要是一个唯一值即可)</strong></p><p>在MainActivity中<strong>以startActivityForResult方法来启动SecondActivity，请求码只要是一个唯一值就可以了</strong>，这里传入了1</p></blockquote><p>其中startActivityForResult方法被划横线是因为不推荐使用</p><p><img src="/2022/09/06/Android-Learning/1662563055534.png" alt="MainActivity"></p><blockquote><p><strong>在SecondActivity给button2注册点击事件，并在点击事件中添加返回数据的逻辑</strong>。我们构建了一个Intent，紧接着把要传递的数据存放在Intent中，然后调用了<strong>SetResult()方法，这个方法专门用于向上一个活动返回数据的，第一个参数用于向上一个活动返回处理结果，一般只使用RESULT_OK或RESULT_CANCELED这两个值，第二个参数则是把带有数据的Intent传递回去</strong>，然后finish()销毁当前活动</p></blockquote><p><img src="/2022/09/06/Android-Learning/1662563137259.png" alt="SecondActivity"></p><blockquote><p>由于我们使用startActivityForResult方法来启动SecondActivity的，<strong>SecondActivity被销毁之后会回调上一个活动的onActivityResult()方法，所以需要在MainActivity中重写这个方法来获取返回的数据</strong>。<strong>第一个参数requestCode是我们在启动活动时传入的请求码，第二个参数resultCode是我门在返回数据时的处理结果，第三个参数data即为携带数据的Intent</strong>。在活动结束后先通过检查requestCode的值来判断数据来源，然后通过resultCode来判断处理结果是否成功。最后从data中根据键取值并打印</p></blockquote><p><img src="/2022/09/06/Android-Learning/1662563666649.png" alt=""></p><p>运行结果，logcat中打印了SecondActivity返回的数据</p><p><img src="/2022/09/06/Android-Learning/1662562543095.png" alt=""></p><h3 id="活动的生命周期"><a class="header-anchor" href="#活动的生命周期">¶</a>活动的生命周期</h3><p>了解活动的生命周期可以让我们<strong>写出更加连贯流畅的程序</strong>，<strong>并学会如何合理管理应用资源</strong></p><h4 id="返回栈"><a class="header-anchor" href="#返回栈">¶</a>返回栈</h4><blockquote><p>Android的任务是可以层叠的，新启动的活动会覆盖在原活动之上，点击Back键会销毁最上面的活动，下一个活动就会重新显示出来</p><p><strong>Android使用Task来管理任务，一个任务就是一组存放在栈里的活动的集合，这个栈就是返回栈</strong>。当我们调用finish()方法或者点击Back键时，栈顶的活动就会出栈，此时前一个入栈的活动即为栈顶元素，<strong>系统总是会显示栈顶的活动给用户</strong></p></blockquote><h4 id="活动状态"><a class="header-anchor" href="#活动状态">¶</a>活动状态</h4><p>每个活动在其生命周期最多可能会有4种状态</p><ol><li>运行状态：此时活动处于返回栈栈顶</li><li>暂停状态：当一个活动不再处于栈顶位置但仍然可见时，此时活动进入暂停状态</li><li>停止状态：当一个活动不再处于栈顶位置，并且完全不可见的时候，就进去了停止状态。<strong>虽然此时系统仍会为这种活动保存相应的状态和成员变量，但是当其他地方需要内存时，处于停止状态的活动那个有可能会被系统回收</strong></li><li>销毁活动：当一个活动从返回栈种移除后就变成了销毁状态，<strong>系统会最倾向于回收处于这种状态的活动</strong>，从而保证手机的内存充足</li></ol><h4 id="活动的生存期"><a class="header-anchor" href="#活动的生存期">¶</a>活动的生存期</h4><blockquote><p>Activity类中定义了七个回调函数，覆盖了活动生命周期的每一个环节</p></blockquote><ul><li>oncreate()：他会在活动第一次被创建的时候调用，<strong>我们应该在这个方法中完成活动的初始化操作，比如加载布局、绑定事件等</strong></li><li>onStart()：这个方法在活动由不可见变为可见的时候调用</li><li>onResume()：<strong>这个方法准备好和用户进行交互的时候调用</strong>，此时的活动一定位于返回栈的栈顶并且处于运行状态</li><li>onPause()：这个方法在系统准备去启动或者恢复另一个活动的时候调用。<strong>我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据</strong></li><li>onStop()：这个方法在活动完全不可见的时候调用，<strong>它和onPause()方法的主要去别的在于：如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法不会执行</strong></li><li>onDestroy()：将活动的状态变为销毁状态</li><li>onRestart()：重新启动活动</li></ul><p>通过以上七种方法我们可以划分出活动的生命周期</p><p><img src="/2022/09/06/Android-Learning/1662651053888.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662651066246.png" alt="活动的展示图"></p><h5 id="举个例子"><a class="header-anchor" href="#举个例子">¶</a>举个例子</h5><p>我们先创建两个活动的并且创建对应的布局，在MainActivity设置两个Button分别来启动不同的活动，其中NormalActivity是正常活动，显示了一个TextView，而DialogActivity是对话框主题(只需要在AndroidManifest.xml选择活动的主题即可)</p><p>代码如下</p><p><img src="/2022/09/06/Android-Learning/1662685393193.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662685420751.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662685469070.png" alt="activity_main"></p><p><img src="/2022/09/06/Android-Learning/1662685490019.png" alt="AndroidManifest"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.android_text3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.android.material.snackbar.Snackbar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.navigation.NavController;</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.Navigation;</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.ui.AppBarConfiguration;</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.ui.NavigationUI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.android_text3.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.Menu;</span><br><span class="line"><span class="keyword">import</span> android.view.MenuItem;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> AppBarConfiguration appBarConfiguration;</span><br><span class="line">    <span class="keyword">private</span> ActivityMainBinding binding;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);<span class="comment">//加载main的布局</span></span><br><span class="line">        Button startNormalActivity=(Button) findViewById(R.id.start_noamal_activity);</span><br><span class="line">        <span class="comment">//创建按钮并且绑定</span></span><br><span class="line">        Button startDialogActivity=(Button)findViewById(R.id.start_dialog_activity);</span><br><span class="line">        startNormalActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{</span><br><span class="line">                Intent intent =<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,NormalLayoutActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        startDialogActivity.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>{</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,DialogLayoutActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Log.d(TAG,<span class="string">"onStart"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        Log.d(TAG,<span class="string">"onPause"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        Log.d(TAG,<span class="string">"onStop"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.d(TAG,<span class="string">"onDestroy"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        Log.d(TAG,<span class="string">"onRestart"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        Log.d(TAG,<span class="string">"onResume"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建之后是这个样子的</p><p><img src="/2022/09/06/Android-Learning/screen.png" alt=""></p><p>此时logcat显示，可以看到在MainActivity第一次被创建时会依次执行onCreate、onStart、onResume方法</p><p><img src="/2022/09/06/Android-Learning/1662686061919.png" alt=""></p><p>当我们点击NormalActivity，<strong>此时NoralActivity已经完全把MainActivity遮挡住了</strong>，onPause、onStop方法被执行</p><p><img src="/2022/09/06/Android-Learning/1662686248495.png" alt=""></p><p>接下来按下Back键，由于MainActivity已经创建过了，所以不会执行onCreate方法</p><p><img src="/2022/09/06/Android-Learning/1662686406193.png" alt=""></p><p>然后点击第二个按钮启动DialogActivity</p><p><img src="/2022/09/06/Android-Learning/screen1.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662686524600.png" alt=""></p><p>可以看到这里只执行了onPause方法，<strong>这是因为DialogActivity并没有完全遮挡住MainActivity，MainActivity只进入暂停状态</strong>，此时按下Back只有onResume方法被执行</p><p><img src="/2022/09/06/Android-Learning/1662686647049.png" alt=""></p><p>最后在MainActivity中按下Back</p><p><img src="/2022/09/06/Android-Learning/1662686681739.png" alt=""></p><p>这三个方法依次执行，最终销毁MainActivity</p><h4 id="活动被回收了怎么处理"><a class="header-anchor" href="#活动被回收了怎么处理">¶</a>活动被回收了怎么处理</h4><blockquote><p><strong>当一个活动进入停止状态时，其可能被系统回收</strong>。虽然可以执行onCreate方法重新创建活动，但是原本活动的临时数据就会被回收了。<strong>而Activity中的onSaveInstanceState()回调方法可以保证在活动被回收之前一定会被调用，因此可以通过该方法来解决活动那个被回收时临时数据得不到保存的问题</strong></p><p><strong>onSaveInstanceState会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如putString()方法保存字符串，putInt()方法保存整型数据。每个保存方法都需要两个参数，第一个参数是键，用于后面从Bundle取值，第二个参数是真正的数据</strong></p><p><strong>取出数据的时候只需要使用onSaveInstanceState中对应的get方法取出即可</strong></p><p><strong>onCreate方法中有一个Bundle参数，当活动被系统回收之前有使用onSaveInstanceState方法保存数据的话，这个参数就会带有之前保存的所有数据</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662688387603.png" alt=""></p><p>取出</p><p><img src="/2022/09/06/Android-Learning/1662688504281.png" alt=""></p><p><strong>Intent和Bundle的结合</strong></p><p><img src="/2022/09/06/Android-Learning/1662688520457.png" alt="1662688520457"></p><h4 id="活动的启动模式"><a class="header-anchor" href="#活动的启动模式">¶</a>活动的启动模式</h4><blockquote><p><strong>在实际项目中我们应该根据特定的需要为每个互动指定恰当的启动模式，启动模式有standard、singleTop、singleTask和singleInstance，我们可以在AndroidManifest.xml中通过个<activity>指定android:launchMode属性来选择启动模式</activity></strong></p></blockquote><h5 id="standard"><a class="header-anchor" href="#standard">¶</a>standard</h5><p><strong>活动默认的启动方式</strong></p><blockquote><p><strong>对于standard模式的的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新实例</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662699467689.png" alt="多个相同活动的返回栈"></p><p>此时需要连续点击三次Back才能退出程序，每点击一次按钮就会创建一个新的实例</p><p><img src="/2022/09/06/Android-Learning/1662701465444.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662701425060.png" alt=""></p><h5 id="singleTop"><a class="header-anchor" href="#singleTop">¶</a>singleTop</h5><p>当指定启动模式为singleTop时，当我们进入按钮时并不会再次重新创建实例，而是从栈顶取出相同的活动</p><p><img src="/2022/09/06/Android-Learning/1662701514289.png" alt=""></p><h5 id="singleTask"><a class="header-anchor" href="#singleTask">¶</a>singleTask</h5><blockquote><p><strong>使用singleTop模式可以很好地解决重复创建栈顶活动的问题，但是如果该活动没有处于栈顶位置，还是有可能会创建多个活动实例</strong>。</p><p><strong>而singleTask模式可以在启动活动时首先在栈中检查是否有该活动地实例，如果发现存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有则创建一个新的活动实例</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662723282294.png" alt=""></p><h5 id="singleInstance"><a class="header-anchor" href="#singleInstance">¶</a>singleInstance</h5><blockquote><p><strong>指定为singleInstance模式地活动会启用一个新的返回栈来管理这个活动</strong>。<strong>当我们想在本程序中和其他程序中共享一个活动的实例，但是每个应用程序都会有自己的返回栈，同一个活动在不同的返回栈入栈时必然是创建了新的实例。而在singleInstance模式下，会有一个单独的返回栈来管理这个活动，这就实现了共享活动实例</strong></p></blockquote><p>我们指定SencondActivity为singleInstance模式，MainActivity和ThirdActivity则是默认的启动模式，在每个活动中我们都让其打印当前任务的id(同一个任务使用同一个返回栈)，并且重写OnDestroy方法打印当前活动名称</p><p><img src="/2022/09/06/Android-Learning/1662778547326.png" alt=""></p><p>运行之后发现SencondActivity和MainActivity、ThirdActivity的任务id并不相同</p><p><img src="/2022/09/06/Android-Learning/1662778609979.png" alt=""></p><p>并且在ThirdActivity中点击Back键会直接返回到MainActivity中，再点击Back就返回到SecondActivity，<strong>这是因为MainActivity和ThirdActivity处于同一返回栈，只有当前返回栈为空，才会显示另一个返回栈的栈顶活动</strong></p><p><img src="/2022/09/06/Android-Learning/1662778853292.png" alt=""></p><p>原理示意图</p><p><img src="/2022/09/06/Android-Learning/1662730119493.png" alt=""></p><h4 id="随时随地退出程序"><a class="header-anchor" href="#随时随地退出程序">¶</a>随时随地退出程序</h4><blockquote><p>当我们创建多个活动而想要直接退出程序时，<strong>我们可以用一个专门的集合类来对所有的活动进行管理</strong></p><p><strong>只需要创建一个类，每当有一个活动被创建就加入到活动管理器中，销毁时移除，要是想在任何地方结束所有活动，直接调用ActivityCollector中的finishAll()方法即可</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662823868673.png" alt=""></p><h4 id="启动活动的最佳语法"><a class="header-anchor" href="#启动活动的最佳语法">¶</a>启动活动的最佳语法</h4><blockquote><p>前面介绍过两个活动之间使用Intent实现活动间数据的传递，其实<strong>更好的做法是创建一个方法来构建Intent对象，这样传入活动的参数就很明显了</strong></p></blockquote><p>在SecondActivity中写一个创建实例并传入数据的方法，最后启动活动，而MainActivity中直接调用SecondActivity活动中的这个方法即可，<strong>这样我们就能清楚看到SecondActivity活动所需要传入的参数</strong></p><p><img src="/2022/09/06/Android-Learning/1662824921483.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662824903256.png" alt=""></p><h1 id="UI开发的点点滴滴"><a class="header-anchor" href="#UI开发的点点滴滴">¶</a>UI开发的点点滴滴</h1><p>在每个活动的布局中</p><p><img src="/2022/09/06/Android-Learning/1662858899626.png" alt=""></p><h2 id="常用控件的使用方法"><a class="header-anchor" href="#常用控件的使用方法">¶</a>常用控件的使用方法</h2><h3 id="TextView"><a class="header-anchor" href="#TextView">¶</a>TextView</h3><blockquote><p><strong>主要用于在界面上显示一段文本信息</strong></p></blockquote><p>创建一个TextView控件</p><p><img src="/2022/09/06/Android-Learning/1662857331805.png" alt=""></p><blockquote><p>控件的属性详解：android:id给当前控件定义了一个唯一标识符，<strong>android:layout_width和android:layout_height分别指定了控件的宽度的高度，所有的控件都有这两种属性，主要有match_parent、fill_parent、wrap_content三种可选值，match_parent和fill_parent一样，表示让当前控件的大小和父布局的一样，也就是由父布局来决定当前控件的大小，wrap_content则表示当前控件的大小刚好能包含里面的内容，也就是孔家内容决定当前控件的大小</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662857822592.png" alt="居左上角对齐"></p><p>TextView的文字默认是居左上角对齐的，想要修改对齐方式只需要使用<strong>android:gravity，可选值有top、bottom、left、right、center，可以使用|来同时指定多个值</strong></p><p><img src="/2022/09/06/Android-Learning/1662857927093.png" alt="居中对齐"></p><blockquote><p><strong>此外我们还可以通过android:textSize和android:textColor属性来指定文字的大小和颜色</strong></p></blockquote><h3 id="Button"><a class="header-anchor" href="#Button">¶</a>Button</h3><p>Button的两种监听方式，<strong>可以通过android:textAllcaps来关闭和开启Button按钮的大小写</strong></p><p><img src="/2022/09/06/Android-Learning/1662880045024.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662880034972.png" alt=""></p><h3 id="EditText"><a class="header-anchor" href="#EditText">¶</a>EditText</h3><blockquote><p><strong>通过android:hint在未输入前提示，android:maxlines来指定最大行数，当输入的内容超过两行时，文本会自动向上滚</strong></p></blockquote><p><strong>我们也能在程序中获取输入然后进行处理</strong></p><p><img src="/2022/09/06/Android-Learning/1662880263558.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662880225392.png" alt=""></p><h3 id="ImageView"><a class="header-anchor" href="#ImageView">¶</a>ImageView</h3><p><img src="/2022/09/06/Android-Learning/1662880295831.png" alt=""></p><h3 id="ProgressBar"><a class="header-anchor" href="#ProgressBar">¶</a>ProgressBar</h3><p><img src="/2022/09/06/Android-Learning/1662880319835.png" alt=""></p><h3 id="ProgressDialog"><a class="header-anchor" href="#ProgressDialog">¶</a>ProgressDialog</h3><p><img src="/2022/09/06/Android-Learning/1662880345039.png" alt=""></p><h2 id="四种布局方式"><a class="header-anchor" href="#四种布局方式">¶</a>四种布局方式</h2><h3 id="线性布局LinearLayout"><a class="header-anchor" href="#线性布局LinearLayout">¶</a>线性布局LinearLayout</h3><p>分为竖直方向和水平方向的线性排列</p><p><img src="/2022/09/06/Android-Learning/1662880400002.png" alt=""></p><p><strong>控件在布局中的对齐方式</strong></p><p><img src="/2022/09/06/Android-Learning/1662880450324.png" alt=""></p><p><strong>控件的权重占比</strong></p><p><img src="/2022/09/06/Android-Learning/1662880491695.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662880503595.png" alt=""></p><p>如上设置EditText占了屏幕的四分之三</p><p><img src="/2022/09/06/Android-Learning/1662880530412.png" alt=""></p><h3 id="相对布局Relativelayout"><a class="header-anchor" href="#相对布局Relativelayout">¶</a>相对布局Relativelayout</h3><p>关于父布局的相对布局</p><p><img src="/2022/09/06/Android-Learning/1662880602902.png" alt=""></p><p><strong>关于控件的相对布局</strong></p><p><img src="/2022/09/06/Android-Learning/1662880633161.png" alt=""></p><h3 id="帧布局FrameLayout"><a class="header-anchor" href="#帧布局FrameLayout">¶</a>帧布局FrameLayout</h3><h3 id="百分比布局"><a class="header-anchor" href="#百分比布局">¶</a>百分比布局</h3><p>首先先在app/build.gradle导入</p><p><img src="/2022/09/06/Android-Learning/1662880698121.png" alt=""></p><p>百分比布局的使用</p><p><img src="/2022/09/06/Android-Learning/1662880722306.png" alt=""></p><h2 id="ListView"><a class="header-anchor" href="#ListView">¶</a>ListView</h2><blockquote><p>当我们需要展示大量数据给用户的时候就需要使用这个控件，比如查看QQ聊天记录、翻阅消息等，都需要让屏幕外的数据替代屏幕内的数据</p></blockquote><p>首先我们需要先把准备展示的数据提供好，<strong>数组中的数据无法直接传递给ListView，可以使用ArrayAdapter，可以通过泛型来指定要适配的数据类型，然后再Oncreate函数中将数据传入，传入适配数据之后，调用setAdapter犯法将构建好的适配器对象传递进去接口完成ListView与数据之间的关联</strong></p><h1 id="Android-NDK开发"><a class="header-anchor" href="#Android-NDK开发">¶</a>Android NDK开发</h1><p>首先先在AS中安装CMake和NDK</p><p><img src="/2022/09/06/Android-Learning/1662880920311.png" alt=""></p><h2 id="JNI和NDK"><a class="header-anchor" href="#JNI和NDK">¶</a>JNI和NDK</h2><p><a href="https://zhuanlan.zhihu.com/p/268635786">JNI和NDK</a></p><p>JNI(Java Native Interface的缩写)，译为Java本地接口，是Java与C/C<ins>沟通的一门技术，JNI的目的就是在java中调用C、C</ins>写的本地方法，android下使用JNI需要的.so文件，是通过ndk-build生成的</p><p><img src="/2022/09/06/Android-Learning/1629797694_6124bd3e04f4b48e0205d.png!small" alt="三者的关系"></p><p><strong>Java之所以需要调用C、C++写的本地方法是因为</strong></p><p><img src="/2022/09/06/Android-Learning/1662881292721.png" alt=""></p><h3 id="JNI开发"><a class="header-anchor" href="#JNI开发">¶</a>JNI开发</h3><p>首先先创建好项目</p><p><img src="/2022/09/06/Android-Learning/1662883396973.png" alt=""></p><ol><li>编写Java类，声明native方法(声明之后使用ALT+ENTER快速创建)</li><li>编写native代码</li><li>将native代码编译成so文件</li><li>在java类中引入so库，调用native方法</li></ol><h4 id="native命名方法"><a class="header-anchor" href="#native命名方法">¶</a><strong>native命名方法</strong></h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_myapplication_MainActivity_print</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement print()</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>函数命名规则：Java_类路径_方法名，JNIEnv时定义任何native方法的第一个参数，表示指向JNII环境的指针，可以通过他来访问JNI提供的接口方法，jobject表示Java对象中的this，如果是静态方法则表示jclass</strong>，JNIEXPORT和JNICALL时JNI定义的宏，可以在jni.h中找到</p></blockquote><h4 id="JNI数据类型和Java数据类型的关系"><a class="header-anchor" href="#JNI数据类型和Java数据类型的关系">¶</a>JNI数据类型和Java数据类型的关系</h4><p><strong>Native的基本数据类型其实就是将C/C++中的基本类型用typedef重新定义了一个新的名字，在JNI中可以直接访问</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint8_t</span>  jboolean; <span class="comment">/* unsigned 8 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int8_t</span>   jbyte;    <span class="comment">/* signed 8 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> jchar;    <span class="comment">/* unsigned 16 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int16_t</span>  jshort;   <span class="comment">/* signed 16 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span>  jint;     <span class="comment">/* signed 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span>  jlong;    <span class="comment">/* signed 64 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span>    jfloat;   <span class="comment">/* 32-bit IEEE 754 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>   jdouble;  <span class="comment">/* 64-bit IEEE 754 */</span></span><br></pre></td></tr></tbody></table></figure><p><strong>引用数据类型，JNI使用C语言时，所有引用类型都是以jobject</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jobject</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jclass</span> :</span> <span class="keyword">public</span> _jobject {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jstring</span> :</span> <span class="keyword">public</span> _jobject {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jarray</span> :</span> <span class="keyword">public</span> _jobject {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jobjectArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jbooleanArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jbyteArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jcharArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jshortArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jintArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jlongArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jfloatArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jdoubleArray</span> :</span> <span class="keyword">public</span> _jarray {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">jthrowable</span> :</span> <span class="keyword">public</span> _jobject {};</span><br></pre></td></tr></tbody></table></figure><h3 id="JNI的字符串处理"><a class="header-anchor" href="#JNI的字符串处理">¶</a>JNI的字符串处理</h3><h4 id="native操作JVM"><a class="header-anchor" href="#native操作JVM">¶</a>native操作JVM</h4><blockquote><p><strong>JNI会把Java中所有对象当作一个C指针传递到本地方法中，这个指针指向JVM的内部数据结构，而内部的数据的结构在内存中的存储方式是不可见的。只能从JNIEnv指针指向的函数表选择合适的JNI函数来操作JVM中的数据结构</strong></p></blockquote><p>比如说native访问java.lang.String时，不能像访问基本数据类型那样使用，<strong>因为它是一个Java的引用类型，所以在本地方法中只能通过类似GetStringUTFChars这样的JNI函数来访问字符串的内容</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.nfc.Tag;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.myapplication.databinding.ActivityMainBinding;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.w3c.dom.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to load the 'myapplication' library on application startup.</span></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.loadLibrary(<span class="string">"myapplication"</span>);<span class="comment">//在java中引入so库</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView tv=(TextView)findViewById(R.id.sample_text);</span><br><span class="line">        tv.setText(stringFromJNI());<span class="comment">//调用so方法</span></span><br><span class="line">        String result=print(<span class="string">"helloworld"</span>);</span><br><span class="line">        Log.d(TAG,result);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A native method that is implemented by the 'myapplication' native library,</span></span><br><span class="line"><span class="comment">     * which is packaged with this application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">stringFromJNI</span><span class="params">()</span></span>;<span class="comment">//声明native方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">print</span><span class="params">(String str)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Java_com_example_myapplication_MainActivity_print</span>(JNIEnv *env, jobject thiz, jstring str) {</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement print()</span></span><br><span class="line">    <span class="comment">//从Java的内存中把字符串拷贝出来，在native中使用</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*strFromJava=(<span class="keyword">char</span>*)env-&gt;<span class="built_in">GetStringUTFChars</span>(str,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(strFromJava==<span class="literal">NULL</span>){<span class="comment">//如果从内存中拷贝的字符串为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//字符串拷贝</span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">128</span>]={<span class="number">0</span>};</span><br><span class="line">    <span class="built_in">strcpy</span>(buff,strFromJava);</span><br><span class="line">    <span class="built_in">strcat</span>(buff,<span class="string">" My Friend!!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(str,strFromJava);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数据，并且自动转为Unicode</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(buff);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在上面的代码中，print()函数接收一个jstring，而jstring是指向JVM内部的一个字符串，不能直接使用。<strong>首先需要将jstring转为C语言的字符串类型char*后才能使用，这里必须使用合适的JNI函数来访问JVM内部的字符串数据类型</strong></p><blockquote><p><strong>java中可以定义某个函数为native类型，对于native函数只需要声明即可，因为该函数的实现是native层的，即由相应的C去实现，java编译器遇到native函数时不会关心该函数的具体实现，因此编译上不会出现任何错误</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662886096895.png" alt=""></p><blockquote><p>Java中默认使用Unicode编码，C/C++默认使用UTF编码，所以在native层和java层进行字符串交流的时候需要进行编码转换，GetStringUTFChars可以把jstring指针的Unicode字符串转为UTF-8格式的C字符串</p></blockquote><blockquote><p><strong>ReleaseStringUTFChars方法释放内存空间</strong>，native需要我们手动释放申请的内存空间，GetStringUTFChars调用时会新<strong>申请一块空间用来装拷贝出来的字符串</strong>，<strong>这个字符串用来方便native代码访问和修改</strong></p></blockquote><blockquote><p><strong>最后NewStringUTF传入char*类型的字符串，构造出一个java.lang.String的字符串对象，并转为Unicode编码</strong></p></blockquote><p><img src="/2022/09/06/Android-Learning/1662886772261.png" alt=""></p><h3 id="数组操作"><a class="header-anchor" href="#数组操作">¶</a>数组操作</h3><h4 id="基本类型数组"><a class="header-anchor" href="#基本类型数组">¶</a>基本类型数组</h4><p><strong>基本类型数组就是JNI中的基本数据类型组成的数组，可以直接访问</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_myapplication_MainActivity_SumArray</span><span class="params">(JNIEnv *env, jobject thiz, jintArray arr)</span> </span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement SumArray()</span></span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取数组长度</span></span><br><span class="line">    jint len=env-&gt;<span class="built_in">GetArrayLength</span>(arr);</span><br><span class="line">    <span class="comment">//动态申请数组</span></span><br><span class="line">    jint*c_array=(jint*)<span class="built_in">malloc</span>(len*<span class="built_in"><span class="keyword">sizeof</span></span>(jint));</span><br><span class="line">    <span class="comment">//初始化数据为0</span></span><br><span class="line">    <span class="built_in">memset</span>(c_array,<span class="number">0</span>,len);</span><br><span class="line">    <span class="comment">//将java中的数据赋值给C数组</span></span><br><span class="line">    env-&gt;<span class="built_in">GetIntArrayRegion</span>(arr,<span class="number">0</span>,len,c_array);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i){</span><br><span class="line">        result+=c_array[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//释放掉申请的内存</span></span><br><span class="line">    <span class="built_in">free</span>(c_array);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line">        <span class="keyword">int</span> final1=SumArray(arr);</span><br><span class="line">        Log.d(TAG,result);</span><br><span class="line">        Log.d(TAG,<span class="string">"sum is "</span>+final1);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">SumArray</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>得到结果</p><p><img src="/2022/09/06/Android-Learning/1662892351107.png" alt=""></p><blockquote><p><strong>C层能达到jint arr之后首先需要获取它的长度，然后动态申请一个数组(因为java层传递过来的数组长度是不定的，所以这里需要动态申请C层数组)。数组是jint型的，最后调用GetIntArrayRegion进行拷贝</strong></p></blockquote><h4 id="对象数组"><a class="header-anchor" href="#对象数组">¶</a>对象数组</h4><blockquote><p>所谓对象数组就是存储了多个对象的数组,<strong>对象数组中的元素是一个类的实例或其他数组的引用，不能直接访问Java传递给JNI层的数组</strong></p></blockquote><h3 id="Native调用Java方法"><a class="header-anchor" href="#Native调用Java方法">¶</a>Native调用Java方法</h3><h4 id="Native调用Java静态方法"><a class="header-anchor" href="#Native调用Java静态方法">¶</a>Native调用Java静态方法</h4><ol><li>首先调用FindClass函数传入Class描述符(<strong>Java类的全类名，在AS中输入MyJniclass会提示自动补全</strong>)，找到该类并得到jclass类型</li><li>然后通过GetStaticMethodID找到该方法的id，传入方法签名，得到jmethodID类型的引用。</li><li>构建入参，然后调用CallStaticObjectMethod去调用Java类里面的静态方法，然后传入参数，返回的直接就是Java层返回的数据。其实，这里的CallStaticObjectMethod是调用的引用类型的静态方法，<strong>与之相似的还有:CallStaticVoidMethod(无返参)，CallStaticIntMethod(返参是Int)，CallStaticFloatMethod</strong>等。</li><li>移除局部引用</li></ol><p>我们自己编写一个类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJniclass</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>{</span><br><span class="line">            Log.d(TAG,<span class="string">"Native Call Method From Java"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>接着我们编写native函数来调用这个类中的方法</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_example_myapplication_MainActivity_CallMethodFromJava</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>{</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement CallMethodFromJava()</span></span><br><span class="line">    <span class="comment">//从class路径下搜索整个类，并返回整个类的class对象，com.example.myapplication.MainActivity活动中的MyJniclass类</span></span><br><span class="line">    jclass clazz=env-&gt;<span class="built_in">FindClass</span>(<span class="string">"com/example/myapplication/MainActivity$MyJniclass"</span>);</span><br><span class="line">    <span class="comment">//找到clazz类中要调用的方法，第三个参数是方法的参数和返回类型</span></span><br><span class="line">    jmethodID get=env-&gt;<span class="built_in">GetStaticMethodID</span>(clazz,<span class="string">"Print"</span>,<span class="string">"()V"</span>);<span class="comment">//最后一个方法签名需要指定正确的参数和返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是含参数和返回值的方法还需要传入参数和返回值</span></span><br><span class="line">    env-&gt;<span class="built_in">CallStaticVoidMethod</span>(clazz,get);</span><br><span class="line">    env-&gt;<span class="built_in">DeleteLocalRef</span>(clazz);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>这里要注意GetStaticMethodID的第三个参数，他既包含了参数类型也包含了返回值，这里的()V表示无参数且返回值为Void</strong></p></blockquote><p><strong>对于参数为String，返回值为String的方法是这样的</strong></p><p><img src="/2022/09/06/Android-Learning/1662898813132.png" alt=""></p><p><strong>参数为String和int，返回值为Void</strong></p><p><img src="/2022/09/06/Android-Learning/1662898895052.png" alt=""></p><p><a href="https://stackoverflow.com/questions/13442116/getstaticmethodid-method-signature-for-public-static-myclass-mymethod">GetStaticMethodID第三个参数</a></p><h4 id="Native调用Java实例方法"><a class="header-anchor" href="#Native调用Java实例方法">¶</a>Native调用Java实例方法</h4><p><a href="https://blog.csdn.net/wd_cloud/article/details/108755809#:~:text=%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E6%98%AF%E5%9C%A8JNI_Onload%20%28%29%E5%87%BD%E6%95%B0%E4%B8%AD%E9%80%9A%E8%BF%87JNI%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84RegisterNatives%20%28%29%E6%96%B9%E6%B3%95%E6%9D%A5%E5%B0%86C%2FC%2B%2B%E6%96%B9%E6%B3%95%E5%92%8Cjava%E6%96%B9%E6%B3%95%E5%AF%B9%E5%BA%94%E8%B5%B7%E6%9D%A5%20%28%E6%B3%A8%E5%86%8C%29%2C%20%E6%88%91%E4%BB%AC%E5%9C%A8%E8%B0%83%E7%94%A8,System.loadLibrary%E7%9A%84%E6%97%B6%E5%80%99%2C%E4%BC%9A%E5%9C%A8C%2FC%2B%2B%E6%96%87%E4%BB%B6%E4%B8%AD%E5%9B%9E%E8%B0%83%E4%B8%80%E4%B8%AA%E5%90%8D%E4%B8%BA%20JNI_OnLoad%20%28%29%E7%9A%84%E5%87%BD%E6%95%B0%2C%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%80%E8%88%AC%E6%98%AF%E5%81%9A%E4%B8%80%E4%BA%9B%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2C%20%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E9%87%8C%E9%9D%A2%E6%B3%A8%E5%86%8C%E5%87%BD%E6%95%B0%2C%20%E6%B3%A8%E5%86%8C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%3A">JNI动态注册</a></p><p>和上面的差不多</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJNIClass</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDes</span><span class="params">(String text)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span>) {</span><br><span class="line">            text = <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"传入的字符串长度是 :"</span> + text.length() + <span class="string">"  内容是 : "</span> + text;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_xzh_allinone_jni_CallMethodActivity_createAndCallJavaInstanceMethod</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>{</span><br><span class="line"><span class="comment">//从jvm中加载类</span></span><br><span class="line">    jclass clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">"com/xzh/allinone/jni/MyJNIClass"</span>);</span><br><span class="line">    <span class="comment">//获取构造方法的方法id</span></span><br><span class="line">    jmethodID mid_construct = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">    <span class="comment">//通过实例获取getAge方法的方法id</span></span><br><span class="line">    jmethodID mid_get_age = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">"getAge"</span>, <span class="string">"()I"</span>);</span><br><span class="line">    jmethodID mid_set_age = env-&gt;<span class="built_in">GetMethodID</span>(clazz, <span class="string">"setAge"</span>, <span class="string">"(I)V"</span>);</span><br><span class="line">    jobject jobj = env-&gt;<span class="built_in">NewObject</span>(clazz, mid_construct);<span class="comment">//调用构造方法创建一个对象--实例，因为在java中，调用方法是通过p.Method()来进行的，所以需要先实例化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法setAge</span></span><br><span class="line">    env-&gt;<span class="built_in">CallVoidMethod</span>(jobj, mid_set_age, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">//再调用方法getAge 获取返回值 打印输出</span></span><br><span class="line">    jint age = env-&gt;<span class="built_in">CallIntMethod</span>(jobj, mid_get_age);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="string">"获取到 age = %d"</span>, age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//凡是使用是jobject的子类,都需要移除引用</span></span><br><span class="line">    env-&gt;<span class="built_in">DeleteLocalRef</span>(clazz);</span><br><span class="line">    env-&gt;<span class="built_in">DeleteLocalRef</span>(jobj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="静态注册和动态注册"><a class="header-anchor" href="#静态注册和动态注册">¶</a>静态注册和动态注册</h3><p><a href="https://www.jianshu.com/p/1d6ec5068d05?u_atoken=f54b5f88-d697-4530-8473-dcfb43749102&amp;u_asession=01kasl2qDBJbleSslAl8nnNxucgnzSWTc0WVbCuu0fDVqPJSGNRfd7Wn1iFYQeckDJX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K-p5bTmF9Nujo-Obbj53HtSPn5sJEo90JdruCukG2OVYmBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05DZ81BZt-FWBnKLVMjm1jMDzLcwQPv229vpEixdD0l6R6RtZBw5R0PKbMkcg0VL9S8qw_cJPMuspqwhO6wFVNmNFbT5q5aP6IbOSFZvaG9PTSBg7qy5i95N85W8z9rO_ilEOrf-Tnxu1_QxEhd49b5rziQFVHgLWHwnMsrK2XkDL9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzTkNwPsvCPOBm16fb8hI-vXiTdXVbtBrVRXhGmUUMb9wLoLNx2oKfcIBo1yjPF0Bne3h9VXwMyh6PgyDIVSG1W-wsuU0SnLFB58_42V-M_-cPuocUbzskgme5tE-44rhH_-oTfdCe-JcQv1dYrDr53W1vRGFAHeVTokTCWyoIBzImWspDxyAEEo4kbsryBKb9Q&amp;u_aref=cI4rIavOgNC5ecKshdMGLeSDjXI%3D">JNI函数注册</a></p><h4 id="静态注册"><a class="header-anchor" href="#静态注册">¶</a>静态注册</h4><p>首先在代码块中添加LoadLibrary函数加载动态链接库，<strong>这样后面的代码调用才能找到对应的原生函数(C++函数)</strong>。<strong>而静态代码块的执行时机早于构造函数、Oncreate方法，其在类加载的时候就被调用</strong></p><p><img src="/2022/09/06/Android-Learning/1663316049430.png" alt=""></p><blockquote><p><strong>静态注册原理是根据函数名将Java代码中的native方法与so中的JNI方法一一对应，当java层调用so层的函数时，如果发现其上有JNIEXPORT和JNICALL两个宏定义时，就会将so层函数(cpp中的函数)链接到对应的native方法中</strong>。下面是<strong>JNI函数名</strong>命名规则</p></blockquote><p><img src="/2022/09/06/Android-Learning/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220916161929.jpg" alt=""></p><p>例如check函数需要命名为</p><p><img src="/2022/09/06/Android-Learning/1663316412656.png" alt=""></p><p><strong>静态注册的缺点</strong></p><ol><li>必须遵循某些规则</li><li>JNI方法名过长</li><li>运行时需要根据函数名查找对应的JNI函数，程序运行效率不高（因为当so层存在多个JNI函数时，则需要一一比较）</li></ol><h3 id="动态注册"><a class="header-anchor" href="#动态注册">¶</a>动态注册</h3><blockquote><p>**动态注册的原理是在调用System.LoadLibrary()时会在so层调用一个名为JNI_OnLoad()的函数，我们可以提供一个函数映射表，然后在JNI_OnLoad()函数中通过JNI中提供的 RegisterNatives()方法来注册函数, 这样Java就可以通过函数映射表来调用函数，而不必通过函数名（静态注册中复杂的函数名）来查找对应函数 **</p></blockquote><p><strong>动态注册的实现步骤</strong></p><ol><li>首先利用结构体JNINativeMethod数组记录native方法与JNI方法的对应关系，即函数映射表</li><li>实现JNI_OnLoad方法，在加载动态库之后，执行动态注册</li><li>调用FindClass方法，获取java对象</li><li>调用RegisterNatives方法，传入java对象，JNINativeMethod数组以及注册数目完成注册</li></ol><p>其中JNINativeMethod结构体如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;         <span class="comment">// native方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* signature;    <span class="comment">// 方法签名，例如()Ljava/lang/String;</span></span><br><span class="line">    <span class="keyword">void</span>*       fnPtr;       <span class="comment">// 函数指针</span></span><br><span class="line">} JNINativeMethod;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">jstring <span class="title">stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>{</span><br><span class="line">    std::string hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数映射表</span></span><br><span class="line">JNINativeMethod methods[]{</span><br><span class="line">        <span class="comment">//直接为结构体赋值</span></span><br><span class="line">        {<span class="string">"stringFromJNI"</span>,<span class="string">"()Ljava/lang/String;"</span>,(<span class="keyword">void</span>*) stringFromJNI}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM*vm,<span class="keyword">void</span>*reserverd)</span></span>{</span><br><span class="line">    JNIEnv*env=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//首先获取jvm的环境，因为加载的类都在里面了，接下来获取类需要用到</span></span><br><span class="line">    <span class="keyword">if</span>(vm-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span>**)&amp;env,JNI_VERSION_1_6)!=JNI_OK){</span><br><span class="line">    <span class="keyword">return</span> JNI_ERR;<span class="comment">//告知版本</span></span><br><span class="line">}</span><br><span class="line">    <span class="comment">//获取java类，方便待会获取类中的成员方法</span></span><br><span class="line">    jclass clazz=env-&gt;<span class="built_in">FindClass</span>(<span class="string">"com/flag/regisiternative/MainActivity"</span>);</span><br><span class="line">    <span class="keyword">if</span>(clazz==<span class="literal">NULL</span>){</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将java中的函数和so层的函数进行注册，进而直接调用native方法即可调用JNI函数</span></span><br><span class="line">    jint result=env-&gt;<span class="built_in">RegisterNatives</span>(clazz,methods,<span class="built_in"><span class="keyword">sizeof</span></span>(methods)/<span class="built_in"><span class="keyword">sizeof</span></span>(methods[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>){</span><br><span class="line">        <span class="comment">//注册失败返回负值</span></span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>动态注册优点</strong></p><ul><li>通过函数映射表来查找对应的JNI方法，运行效率高</li><li>不需要遵循命名规则，灵活性更好</li></ul><p><strong>动态注册缺点</strong></p><ul><li>实现起来相对复杂</li><li>容易搞错方法签名导致注册失败</li></ul><h1 id="APK发布Release"><a class="header-anchor" href="#APK发布Release">¶</a>APK发布Release</h1><p><img src="/2022/09/06/Android-Learning/1662901583213.png" alt=""></p><p>创建一个key</p><p><img src="/2022/09/06/Android-Learning/1662901596834.png" alt=""></p><p>选择打包版本</p><p><img src="/2022/09/06/Android-Learning/1662901610064.png" alt=""></p><p><img src="/2022/09/06/Android-Learning/1662901718318.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android Learning&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Learning</title>
    <link href="https://gift1a.github.io/2022/09/06/Learning/"/>
    <id>https://gift1a.github.io/2022/09/06/Learning/</id>
    <published>2022-09-06T09:50:42.000Z</published>
    <updated>2022-09-06T09:51:12.834Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Android_Reverse_Engineering</title>
    <link href="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/"/>
    <id>https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/</id>
    <published>2022-08-31T12:09:58.000Z</published>
    <updated>2022-10-07T05:25:24.218Z</updated>
    
    <content type="html"><![CDATA[<p>Android_Reverse_Engineering</p><span id="more"></span><h1 id="Learning-Link"><a class="header-anchor" href="#Learning-Link">¶</a>Learning Link</h1><p><a href="https://blog.csdn.net/DaqianC/article/details/101135872">Ubuntu安装并管理多个版本的Python</a></p><p><a href="https://juejin.cn/post/6949078900064387103">Android逆向</a></p><p><a href="https://github.com/APKLab/APKLab">APKLAB</a></p><p><a href="https://github.com/dn0m1n8tor/AndroidPentest101">Android Pentest</a>是关于安卓渗透测试的，但是有一部分还是可以借鉴的</p><p><a href="https://tryhackme.com/room/androidhacking101">Android Hacking101</a></p><p><a href="https://github.com/tlamb96/kgb_messenger">Android Pratice</a></p><p><a href="https://github.com/cyberheartmi9/Frida-Guide/blob/main/Frida%20Guide/Frida%20Guide.md">Frida Guide</a></p><p><a href="https://www.ragingrock.com/AndroidAppRE/app_fundamentals.html">Android App reverse101</a></p><h1 id="Android-Application-Framework"><a class="header-anchor" href="#Android-Application-Framework">¶</a>Android Application Framework</h1><p>安卓是基于Linux内核和其他开源项目的修改版本的移动操作系统</p><h2 id="安卓操作系统"><a class="header-anchor" href="#安卓操作系统">¶</a>安卓操作系统</h2><h3 id="硬件"><a class="header-anchor" href="#硬件">¶</a>硬件</h3><p>Android的主要硬件平台是ARM，在以后的版本中也支持X86架构和X86-64架构</p><h3 id="内核"><a class="header-anchor" href="#内核">¶</a>内核</h3><p>截至2020年，Android使用Linux内核的4.4，4.9或4.14版本。Android Kernel 基于 Linux Kernel 的长期支持 （LTS）分支</p><h3 id="文件系统"><a class="header-anchor" href="#文件系统">¶</a>文件系统</h3><p>之前的Android使用YAFFS2文件系统，在Android2.3之后使用EXT4文件系统，虽然很多的OEM（原始设备制造厂商）已经尝试了F2FS，但以下的目录在任何Android都存在</p><ul><li><p>Boot：包含内核，虚拟硬盘等</p></li><li><p>System：包含操作系统文件，其中包括Android UI和预安装的应用程序</p></li><li><p>Recovery：引导到操作系统的替代选项，允许恢复和备份分区</p></li><li><p>Data：保存用户数据，其子文件夹包括</p><ul><li>Android：默认用于应用程序缓存和保存的数据</li><li>Alarms：警报的自定义音频文件</li><li>Cardboard：包含VR文件的数据</li><li>DCIM：相机拍摄的照片的视频</li><li>Downloads：存放在互联网上下载的文件</li><li>Notifications：某些应用通知的自定义提示音</li><li>Musics,Movies：存储第三方的音乐和视频</li><li>Pictures：存储第三方的图片</li><li>Podcasts：使用播客应用时存储播客文件</li><li>Videos：存储从第三方下载的视频</li></ul></li><li><p>Cache：存储常用数据和应用组件</p></li><li><p>Misc：包含其他重要的系统设置信息</p></li></ul><h2 id="安卓架构"><a class="header-anchor" href="#安卓架构">¶</a>安卓架构</h2><p><img src="/2022/08/31/Android-Reverse-Engineering/0.png" alt="img"></p><h3 id="Kernel"><a class="header-anchor" href="#Kernel">¶</a>Kernel</h3><p>它为用户提供了与硬件通信的接口。它包含程序用来指示硬件组件执行特定功能的基本驱动程序。这些驱动程序是音频，显示器，蓝牙等</p><h3 id="Hardware-Abstraction-Layer"><a class="header-anchor" href="#Hardware-Abstraction-Layer">¶</a>Hardware Abstraction Layer</h3><p><strong>硬件抽象层</strong> （<strong>HAL</strong>） 是代码的逻辑划分，用作计算机物理硬件与其软件之间的抽象层。它提供了一个设备驱动程序接口，允许程序与硬件进行通信</p><h3 id="Libraries"><a class="header-anchor" href="#Libraries">¶</a><strong>Libraries</strong></h3><p>位于内核的顶部，库为开发人员提供开发应用程序，资源文件甚至清单的支持。有一些原生库，如SSL，SQLite，Libc等，是原生代码有效执行任务所必需的。</p><h3 id="Android-Runtime"><a class="header-anchor" href="#Android-Runtime">¶</a><strong>Android Runtime</strong></h3><p>ART是Android操作系统使用的应用程序运行时环境，Runtime Environment是程序可以向计算机处理器发送指令并访问计算机主存(RAM)的状态。JAVA编写的Android应用程序，在编译期间首先转换为字节码，打包为APK和运行运行时</p><blockquote><p><strong>Android使用虚拟机来执行应用程序，以便将程序的执行和操作系统隔离开来，并免受恶意代码的侵害</strong></p></blockquote><p>在Android4.4之前，程序的运行是由DVM(<em>Dalvik Virtual Machine</em>)执行的，后来被Android Runtime替代</p><h3 id="Application-Framework"><a class="header-anchor" href="#Application-Framework">¶</a>Application Framework</h3><blockquote><p><strong>安卓由四大组件：Activity、Service、Broadcast Receiver、Content Provider</strong></p></blockquote><p>Android操作系统的整个功能集可以通过Java编写的API提供给开发人员，这些API是Android应用所需要的最重要的组件</p><ul><li>View System：主要用于构建应用程序的UI。包括列表、文本框和按键</li><li>Resource Manager：提供对布局文件、图形等非代码资源的访问</li><li>Notification Manager：允许应用在状态栏显示自定义警报</li><li>Activity Manager：管理应用的生命周期</li><li>Content Providers：使应用程序能够访问其他应用程序</li></ul><h3 id="System-Applications"><a class="header-anchor" href="#System-Applications">¶</a>System Applications</h3><p>预装的核心应用程序集，用于基本功能，如短信，日历，互联网浏览，联系人等</p><h2 id="编译与反编译"><a class="header-anchor" href="#编译与反编译">¶</a>编译与反编译</h2><p>ART的主要编译过程如下</p><p><img src="/2022/08/31/Android-Reverse-Engineering/2.png" alt="img"></p><p>APK文件只是一个包含XML文件，dex代码，资源文件和其他文件的ZIP压缩包，需要反编译的时候需要先解包然后再反编译，使用<strong>APKLab</strong>即可</p><h3 id="APK构建流程和执行过程"><a class="header-anchor" href="#APK构建流程和执行过程">¶</a>APK构建流程和执行过程</h3><p><img src="/2022/08/31/Android-Reverse-Engineering/4,856ab7b141.png" alt=""></p><ol><li>.java文件中的java源代码通过<strong>javac</strong>转换为字节码(.class文件)</li><li>所有的.class文件都通过dx编辑器转换为.dex文件(Dalvik可执行文件)。DEX字节码独立于设备架构，需要转换为本机机器代码才能在设备上运行</li><li>AAPT将资源(res文件夹)编译为二进制文件(resources.arsc)，并且将已经编译的资源、非编译的资源、.dex文件打包到apk文件中</li><li>对应用程序进行签名，然后才能发布</li></ol><p><a href="https://blog.csdn.net/u013773608/article/details/100033868">Dalvik JIT和ART的区别</a></p><p>如果Android使用的是Dalvik JIT编译器，那么每次运行程序时，他都会<strong>动态地将Dalvik字节码(也就是.dex文件)地一部分转换为字节码然后执行</strong>，随着程序的执行，将编译和缓存更多的字节码</p><p>如果是Android使用的是ART，那么在应用程序的安装阶段，他就会<strong>静态地将DEX字节码转换为机器代码</strong>，并且存储在设备的内存中，这是一次性事件</p><h3 id="Smali代码"><a class="header-anchor" href="#Smali代码">¶</a>Smali代码</h3><p>Smali是<strong>Dalvik VM内部执行的核心代码，是Dalvik自己的语法规范</strong></p><p><a href="https://www.jianshu.com/p/9931a1e77066">smali语言学习</a></p><p>Smali代码就是dex文件反编译之后的代码，所以说Smali语言是Android虚拟机的反汇编语言</p><blockquote><p>我们可以通过修改Smali代码来修改APK运行逻辑，再重新编译打包成新的APK</p></blockquote><h3 id="APK的大致内容"><a class="header-anchor" href="#APK的大致内容">¶</a>APK的大致内容</h3><p><img src="/2022/08/31/Android-Reverse-Engineering/1662380130833.png" alt="1662380130833"></p><ul><li><p>AndroidMainfest.xml：二进制XML格式的清单文件，存储应用程序的软件包名称，版本组件和其他元数据</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1662450909912.png" alt="包含的内容"></p></li><li><p>META_INF：清单，用于存储有关应用程序的元数据，它还包含APK的证书和前面</p></li><li><p>classes.dex：以dex格式编译的应用程序代码，Dalvik VM（<strong>相当关于Java中的JVM</strong>）可以识别和执行</p></li><li><p>res/：包含未编译成resources.arsc中的资源的文件夹</p></li><li><p>lib/：包含本地已编译代码文件-即本机代码库</p></li><li><p>assets/：应用程序的资产</p></li><li><p>resources.arsc：提前编译好的资源文件</p></li></ul><h2 id="APK程序的活动和入口"><a class="header-anchor" href="#APK程序的活动和入口">¶</a>APK程序的活动和入口</h2><h3 id="活动"><a class="header-anchor" href="#活动">¶</a>活动</h3><p><strong>活动是用来承载用户界面的容器，是Android的四大组件之一</strong>，我们再APP里面看到的页面就需要一个Activity，而页面之间的跳转就是Activity之间的跳转。比如，登陆页面是一个LoginActivity，注册页面是一个 RegisterActivity，当我们需要从登陆页面跳转到注册页面时，也就是 LoginActivity 通过 Intent 跳转到 RegisterActivity</p><h3 id="入口"><a class="header-anchor" href="#入口">¶</a>入口</h3><p>我们新建一个Android项目时会默认生成一个Activity，叫做 <strong>MainActivity</strong>，MainActivity就是这个项目的唯一页面，也就是APP的启动页面。<strong>每一个Activity都需要在AndroidManifest.xml文件中配置。每创建一个Activity都需要在这个文件中国注册</strong></p><p>在AndroidManifest.xml文件中<strong>android.intent.action.MAIN</strong>会将Mainactivity注册为最先启动多个Activity，同时我们也可以在其中配置Activity的其他属性</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1662453034704.png" alt=""></p><h4 id="Oncreate函数"><a class="header-anchor" href="#Oncreate函数">¶</a>Oncreate函数</h4><p>Oncreate函数<strong>通常配置需要的信息</strong>，<strong>一个Activity启动回调的第一个函数就是Oncreate，Oncreate函数做一些Activity启动的一些必要的初始化的工作</strong>。有点像Java中的构造函数</p><h1 id="Smali"><a class="header-anchor" href="#Smali">¶</a>Smali</h1><h2 id="学习链接"><a class="header-anchor" href="#学习链接">¶</a>学习链接</h2><p><a href="https://source.android.google.cn/docs/core/dalvik/dalvik-bytecode">字节码格式</a></p><p><a href="https://juejin.cn/post/6844903732774174734">smali详解</a></p><p><a href="https://blog.csdn.net/qq_43278826/article/details/108377201?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-108377201-blog-80825044.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-108377201-blog-80825044.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=3">AS调试时Smali下不了断点</a></p><p>下不了断点可能是版本不对，下载最新版即可</p><p><a href="https://blog.csdn.net/zhangjianming2018/article/details/124512370">AS中调试smali</a></p><p>直接使用APKLab解包(如果没有debuggable属性则<strong>需要先在application标签中加入android:debuggable=“true”，然后重新打包</strong>)，然后以调试方式启动最后附加上去即可(这里我直接开启调试是失败的)</p><blockquote><p><strong>adb shell am satrt -D -n 包名/.主活动</strong></p></blockquote><h2 id="smali学习"><a class="header-anchor" href="#smali学习">¶</a>smali学习</h2><p>Java编译器将.java源文件编译为.class字节码文件，然后JVM将字节码解释为机器代码在目标机器上执行。<strong>DVM指的是DalVIk VM，在Android中，java类被打包为DEX字节码文件(.dex)，DEX字节码经过Dalvik或者ART转为机器码进行执行，而smali就是dex文件反编译之后的汇编代码</strong></p><p><img src="/2022/08/31/Android-Reverse-Engineering/16784215bcc99e97_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt=""></p><blockquote><p><strong>JVM是基于栈帧的，也就是Stack-based，而DVM基于寄存器，也就是Register-based</strong></p></blockquote><h3 id="smali代码"><a class="header-anchor" href="#smali代码">¶</a>smali代码</h3><h4 id="smali和java的对比"><a class="header-anchor" href="#smali和java的对比">¶</a>smali和java的对比</h4><p><strong>注释</strong></p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在java中使用<span class="regexp">//</span></span><br><span class="line">而smali中使用<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p><strong>类声明</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在java中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">class_name</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在smali中</span></span><br><span class="line">.class 权限修饰符 类的全包名路径，使用L开头，以;结尾</span><br><span class="line">    </span><br><span class="line">.<span class="keyword">super</span> Ljava/lang/Object;#声明父类，默认为Object</span><br><span class="line">.implement L/java/lang/CharSequence;#如果实现了接口需要添加接口代码</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/31/Android-Reverse-Engineering/1663044873233.png" alt=""></p><p><strong>方法声明</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在java中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span></span>{};</span><br><span class="line"></span><br><span class="line"><span class="comment">//smali中</span></span><br><span class="line">.method 属性 方法名(参数的签名)返回值签名</span><br><span class="line"></span><br><span class="line">.end method;#成对出现</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/31/Android-Reverse-Engineering/1663045185308.png" alt=""></p><p>这里表示Onclick的属性是public、参数为View(<strong>因为View是对象，需要使用全包名路径</strong>)，返回值为void(V)</p><blockquote><p><strong>全包名路径时java中的.被修改为/,并且使用L开头,以;结尾</strong></p></blockquote><p><strong>字段声明</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中</span></span><br><span class="line"><span class="keyword">public</span> String a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//smali中,</span></span><br><span class="line">.filed <span class="keyword">public</span> a:com/lang/String;#声明了一个字段</span><br><span class="line">.filed 权限修饰符+静态修饰符+变量名:变量全类名路径</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量声明</span></span><br><span class="line">.filed <span class="keyword">public</span> a:com/lang/String;=<span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure><p><strong>字段取值赋值</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smali中</span></span><br><span class="line">iget iput sget sput#i表示instance，s表示<span class="keyword">static</span></span><br></pre></td></tr></tbody></table></figure><p><strong>方法调用</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smali中，以invoke开头</span></span><br><span class="line">在方法中必须声明方法中寄存器的数量</span><br></pre></td></tr></tbody></table></figure><p><strong>方法取值</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取返回值首先需要调用方法invoke，然后接收返回值move</span></span><br></pre></td></tr></tbody></table></figure><p><strong>smali和java基础数据类型对比</strong></p><table><thead><tr><th style="text-align:center">smali</th><th style="text-align:center">java</th></tr></thead><tbody><tr><td style="text-align:center">B</td><td style="text-align:center">byte</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">short</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">boolean</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">数组</td></tr><tr><td style="text-align:center">L+全类名路径，用/分割</td><td style="text-align:center">object</td></tr></tbody></table><h4 id="smali源码结构分析"><a class="header-anchor" href="#smali源码结构分析">¶</a>smali源码结构分析</h4><p>先自己编写一个简单的APK</p><p>源代码如下</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663046205303.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663057562069.png" alt=""></p><h5 id="声明"><a class="header-anchor" href="#声明">¶</a>声明</h5><p>类方法的声明</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663046313607.png" alt=""></p><p>.super表示继承的类，.source是java源文件</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663046332189.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663046374008.png" alt=""></p><p>实现的类</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663046435707.png" alt=""></p><h5 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h5><p>java中自动生成无参构造器</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663046503302.png" alt=""></p><p>.method和.end method一起使用，<strong>construct <init>是构造器特有的关键字</init></strong>，()V表示构造方法为无参构造且返回值为void</p><p>.line 14表示在源码中的行数为14行，<strong>可以删除</strong></p><p><strong>invoke-direct是方法的调用，凡是私有方法或者构造方法统统使用invoke-direct，这里的invoke-direct其实就是调用父类的初始化方法</strong></p><p>invoke-direct表示将p0参数传入后面的<strong>方法</strong>中，<strong>p0这里就是this指针，其实存在于构造器的参数列表中</strong>，将this传入后面的方法进行Object的初始化操作</p><blockquote><p><strong>invoke-direct {参数},方法所对应的全包名路径类; -&gt; 方法名称(方法参数签名)方法返回值签名</strong></p></blockquote><p><strong>return-void表示返回值为void</strong></p><blockquote><p>当返回值为String时，返回<strong>Object</strong></p><p>const-string v0,“hello” <strong>声明一个常量字符串</strong></p></blockquote><p><img src="/2022/08/31/Android-Reverse-Engineering/1663048128871.png" alt=""></p><blockquote><p><strong>在方法声明之后的.locals可以理解为调用该方法需要使用到的变量</strong></p></blockquote><p><img src="/2022/08/31/Android-Reverse-Engineering/1663048645736.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663049075238.png" alt=""></p><h5 id="main方法"><a class="header-anchor" href="#main方法">¶</a>main方法</h5><p><img src="/2022/08/31/Android-Reverse-Engineering/1663048903877.png" alt=""></p><p><strong>main函数的参数是[Ljava/lang/String;表明其参数为String数组</strong></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663048982355.png" alt=""></p><p><strong>.param表明参数对应的名称为args</strong></p><p><strong>.line两个之间的smali代码表示java源代码中的一行代码</strong></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663049205313.png" alt=""></p><p>对应java中</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663049224754.png" alt=""></p><h5 id="smali代码中的for循环"><a class="header-anchor" href="#smali代码中的for循环">¶</a><strong>smali代码中的for循环</strong></h5><p><img src="/2022/08/31/Android-Reverse-Engineering/1663056706023.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663056767581.png" alt=""></p><blockquote><p><strong>首先使用const初始化两个常量，然后进行比较if-ge代表如果p1&gt;=v0，则跳转到con_0分支，否则add-int/lit8 p1,p1,0x1表示将p1+0x1的值然后赋值给p1</strong>，即p1=p1+1，<strong>然后使用goto语句回到判断处</strong></p></blockquote><h5 id="Toast在smali中的代码"><a class="header-anchor" href="#Toast在smali中的代码">¶</a><strong>Toast在smali中的代码</strong></h5><p><img src="/2022/08/31/Android-Reverse-Engineering/1663057436575.png" alt=""></p><blockquote><p><strong>调用实例方法/一般方法一般使用invoke-virtual，invoke-static调用静态方法</strong></p></blockquote><p>先获取参数，然后存储到{}中，接着使用-&gt;(这里-&gt;相当于Toast.makeText(p1,v1,v0))将参数传入到makeText方法中，makeText(参数签名)返回值签名</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663057837115.png" alt=""></p><p>接收方法的返回值传递到p1然后show</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663058048017.png" alt=""></p><h4 id="关于方法返回的关键字"><a class="header-anchor" href="#关于方法返回的关键字">¶</a>关于方法返回的关键字</h4><table><thead><tr><th style="text-align:center">smali</th><th style="text-align:center">数据类型</th></tr></thead><tbody><tr><td style="text-align:center">return</td><td style="text-align:center">byte</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">short</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">return-wide</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">return-wide</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">return</td><td style="text-align:center">boolean</td></tr><tr><td style="text-align:center">return-void</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">return-object</td><td style="text-align:center">数组</td></tr><tr><td style="text-align:center">return-object</td><td style="text-align:center">String</td></tr></tbody></table><h4 id="静态代码块的smali代码"><a class="header-anchor" href="#静态代码块的smali代码">¶</a>静态代码块的smali代码</h4><p><clinit>初始化</clinit></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663059844715.png" alt=""></p><h4 id="smali各种方法的调用"><a class="header-anchor" href="#smali各种方法的调用">¶</a>smali各种方法的调用</h4><p>关键字</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">invoke-virtual</span><span class="comment">#非私有(private)实例方法的调用</span></span><br><span class="line"><span class="built_in">invoke-direct</span><span class="comment">#用于构造方法以及私有方法</span></span><br><span class="line"><span class="built_in">invoke-static</span><span class="comment">#调用静态方法，static方法不需要传入this实例</span></span><br><span class="line"><span class="built_in">invoke-super</span><span class="comment">#调用父类方法</span></span><br><span class="line"><span class="built_in">invoke-interface</span><span class="comment">#调用接口方法，interface为接口</span></span><br></pre></td></tr></tbody></table></figure><p>编写一个类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String a)</span></span>{</span><br><span class="line">        getname();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/31/Android-Reverse-Engineering/1663060304853.png" alt=""></p><h4 id="smali中对象的创建"><a class="header-anchor" href="#smali中对象的创建">¶</a>smali中对象的创建</h4><figure class="highlight vala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#声明实例</span></span><br><span class="line"><span class="keyword">new</span>-instance+变量名,对象包名路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#调用构造方法(即构造器)(如果该构造方法还定义了成员变量，那么在函数调用前需要提前声明，然后在invoke时当作参数一并传入)</span></span><br><span class="line">invoke-direct{变量名},对象全包名路径;-&gt;&lt;init&gt;(参数)返回类型</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Test();</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">new</span>-instance v0,LTest;</span><br><span class="line">invoke-direct{v0},LTest;-&gt;&lt;init&gt;()v#构造器默认无参返回<span class="keyword">void</span></span><br></pre></td></tr></tbody></table></figure><h4 id="数据的定义"><a class="header-anchor" href="#数据的定义">¶</a>数据的定义</h4><p>主要有字符串数据、字节码数据、数据类型数据</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串.smali中不能直接返回，需要先存储在容器中</span></span><br><span class="line"><span class="keyword">const</span>-string v0,<span class="string">"hello"</span></span><br><span class="line"><span class="keyword">return</span>-object v0</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节码对象</span></span><br><span class="line"><span class="keyword">const</span>-<span class="class"><span class="keyword">class</span> <span class="title">V0</span>,<span class="title">GoActivity</span></span>;</span><br><span class="line">startActivity在smali中分为两个步骤</span><br><span class="line">首先声明要启动的<span class="class"><span class="keyword">class</span>，以及当前<span class="title">Activity</span>的<span class="title">this</span>对象</span></span><br><span class="line"><span class="class"><span class="title">const</span>-<span class="title">class</span> <span class="title">v0</span>,<span class="title">SecondActivity</span></span></span><br><span class="line"><span class="class">然后创建<span class="title">Intent</span>对象,<span class="title">v1</span>用于接收<span class="title">init</span>的返回对象</span></span><br><span class="line"><span class="class">    <span class="title">new</span>-<span class="title">instance</span> <span class="title">v1</span>,<span class="title">Landroid</span>/<span class="title">content</span>/<span class="title">Intent</span></span>;</span><br><span class="line">invoke-direct{v1,p0,v0},Landroid/content/Intentl-&gt;&lt;init&gt;(Landroid/content/Intent;Ljava/lang/<span class="class"><span class="keyword">class</span></span>;)V</span><br><span class="line">最后调用StartActivity方法</span><br><span class="line">invoke-virtual{p0,v1},LTestActivity-&gt;StartActivity(Landroid/content/Intent;)V</span><br><span class="line">        </span><br><span class="line"><span class="comment">//数值型数据的定义        </span></span><br><span class="line"><span class="keyword">const</span><span class="comment">//占用一个容器</span></span><br><span class="line"><span class="keyword">const</span>-wide<span class="comment">//占用两个容器,long</span></span><br><span class="line">        <span class="keyword">const</span> v0,<span class="number">30</span></span><br><span class="line">        <span class="keyword">const</span>-wide v0,<span class="number">30</span>#占用v0和v1容器，会默认占用目标寄存器和目标寄存器的下一个容器，<span class="number">64</span>位</span><br><span class="line">        <span class="keyword">const</span>/<span class="number">4</span>#最大只允许四个二进制位，也就是<span class="number">1111</span>(有符号)(<span class="keyword">char</span>)</span><br><span class="line">        <span class="keyword">const</span>/<span class="number">16</span>#word</span><br><span class="line">        <span class="keyword">const</span>#占用一个寄存器，<span class="number">32</span>位,<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">const</span>/high16#最大只允许存放高十六位二进制位数值</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span>-wide/<span class="number">16</span></span><br><span class="line">        <span class="keyword">const</span>-wide/<span class="number">32</span></span><br><span class="line">        <span class="keyword">const</span>-wide</span><br><span class="line">        <span class="keyword">const</span>-wide/highssss32</span><br></pre></td></tr></tbody></table></figure><h4 id="字段的取值与赋值"><a class="header-anchor" href="#字段的取值与赋值">¶</a>字段的取值与赋值</h4><figure class="highlight livescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.filed</span><br><span class="line"><span class="keyword">static</span>对应sget<span class="string">\sput</span></span><br><span class="line">instance对应iput<span class="string">\sput</span></span><br></pre></td></tr></tbody></table></figure><p>同样的不同的数据类型也对应不同的类型</p><figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">LTest;</span><span class="comment">#声明类</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> private</span><span class="keyword"> static</span> a:<span class="class">Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span></span><br><span class="line"><span class="built_in">const-string </span>v0,<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">sput-object </span>v0,<span class="class">LTest;</span>-&gt;a:<span class="class">Ljava/lang/String;</span><span class="comment">#进行赋值</span><span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span> </span><br></pre></td></tr></tbody></table></figure><h4 id="条件跳转if"><a class="header-anchor" href="#条件跳转if">¶</a>条件跳转if</h4><p><img src="/2022/08/31/Android-Reverse-Engineering/1663065694339.png" alt=""></p><h4 id="寄存器"><a class="header-anchor" href="#寄存器">¶</a>寄存器</h4><p>内部寄存器声明，<strong>在Dalvik中，每个寄存器都是32位的，2个寄存器用于存储long和double</strong></p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.registers</span> 数量<span class="comment">#声明于方法内部</span></span><br><span class="line"><span class="string">.locals</span> 数量<span class="comment">#都是表明寄存器数量</span></span><br><span class="line">上面两者的区别在于</span><br><span class="line"><span class="string">.locals</span>指明了这个非参寄存器的数量，而寄存器的总数包括保存方法参数的寄存器<span class="params">(存储局部变量寄存器的数量)</span>，如v0、v1等，没有p0</span><br><span class="line"><span class="string">.registers</span>指定了在这个方法中有多少个可用的寄存器<span class="params">(局部+参数)</span>，如p0、v0、v1</span><br></pre></td></tr></tbody></table></figure><p>寄存器的两种命名方法-<strong>p命名法和v命名法</strong>，<strong>主要是使用p命名法</strong></p><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是v命名法，优先对局部变量进行声明</span></span><br><span class="line">比如v0和<span class="built_in">v1</span>已经被使用，那么方法中第一个参数存入<span class="built_in">v2</span>寄存器，依次往后</span><br><span class="line"><span class="comment">//p命名法，方法的参数使用p寄存器表示</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/31/Android-Reverse-Engineering/1663066658590.png" alt=""></p><h4 id="smali语法关键字"><a class="header-anchor" href="#smali语法关键字">¶</a>smali语法关键字</h4><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.line N<span class="comment">#表示与java源文件代码的映射关系，可删除</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">:cond_0</span><span class="comment">#条件分支，配合if使用</span></span><br><span class="line"></span><br><span class="line">.prologue<span class="comment">#表示程序的开始，可删除</span></span><br><span class="line"></span><br><span class="line">.goto_0<span class="comment">#goto跳转分支</span></span><br><span class="line"></span><br><span class="line">.local<span class="comment">#显示局部变量(寄存器中的值)别名信息，类比.line</span></span><br><span class="line"></span><br><span class="line">.locals N<span class="comment">#寄存器数量声明</span></span><br><span class="line"></span><br><span class="line">.Param p1,<span class="string">"a"</span><span class="symbol">:Ljava/lang/String</span>;<span class="comment">#也是起别名</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="smali代码注入"><a class="header-anchor" href="#smali代码注入">¶</a>smali代码注入</h2><h1 id="IDA-Dump-Android应用内存"><a class="header-anchor" href="#IDA-Dump-Android应用内存">¶</a>IDA Dump Android应用内存</h1><ol><li>首先先将应用程序附加到ida上</li><li>然后配置调试器在不同事件触发的地方设置断点</li><li>加载完目标so文件之后</li><li>首先获取应用程序的PID，<strong>adb shell ps</strong>，然后在adb shell内<strong>cat /proc/PID/map获取so文件起始地址</strong>，<strong>可以使用|grep "so"过滤</strong></li><li>然后编写IDAPython dump即可</li></ol><p><img src="/2022/08/31/Android-Reverse-Engineering/1663485969473.png" alt=""></p><blockquote><p><strong>在IDA中的Modules中能看到Odex文件，接下来可以从内存中Dump下来Dex文件，这是对抗动态加载壳的常用思路</strong></p></blockquote><h1 id="Root"><a class="header-anchor" href="#Root">¶</a>Root</h1><p><a href="https://zhuanlan.zhihu.com/p/506203078">Magisk Hide替代品</a></p><p><a href="https://blog.csdn.net/StepTp/article/details/120678944">Pixel 3xl Root</a></p><p><a href="https://www.jianshu.com/p/e86296765a0c">Xposed和Magisk</a></p><h2 id="Objection"><a class="header-anchor" href="#Objection">¶</a>Objection</h2><blockquote><p><strong>Objection可以快速完成诸如内存搜索、类和 模块搜索、方法Hook以及打印参数、返回值、调用栈等常用功能</strong></p><p><strong>Objection依托Frida完成了对应用的注入以及对函 数的Hook模板，使用时只需要将具体的类填充进去即可完成相应的 Hook测试</strong></p></blockquote><p>安装好之后，通过命令<strong>objection -g 包名 explore</strong>注入进程后即可进入REPL界面</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663557014085.png" alt=""></p><p>在REPL界面中，按空格键就会提示可用的命令，出现提示之后通过上下选择键及回车键便可输入命令</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663557327759.png" alt=""></p><ol><li><p>help命令：在当前命令前加help之后再回车即可查看当前命令的解释信息<img src="/2022/08/31/Android-Reverse-Engineering/1663557437706.png" alt=""></p></li><li><p>jobs命令：用于查看和管理当前所执行的Hook的任务，可以同时运行多项Hook任务</p></li><li><p>frida命令：查看Frida相关信息</p></li><li><p>内存漫游相关命令，<strong>Objection可以快速便捷地打印出内存中各种类地相关信息</strong></p><ul><li><strong>android hooking list classes</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663557730285.png" alt=""></li><li><strong>android hooking search classes 关键字</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663557907125.png" alt=""></li><li>**android hooking search methods <key>**来从内存中获取所有包含关键字key的方法</key></li><li>搜索到我们感兴趣的类后可以使用<strong>android hooking list class_methods</strong>来查看类的所有方法<img src="/2022/08/31/Android-Reverse-Engineering/1663558161849.png" alt=""></li><li><strong>android hooking list activities</strong>列出进程中所有的活动<img src="/2022/08/31/Android-Reverse-Engineering/1663558271389.png" alt=""></li><li><strong>android hooking list services</strong>列出进程所有的service，对于其余两个组件，只需要修改为<strong>receivers和providers</strong>即可</li></ul></li><li><p><strong>Hook命令</strong>：**通过android hooking watch class_method <methodname>**对指定类进行Hook<img src="/2022/08/31/Android-Reverse-Engineering/1663558826171.png" alt=""></methodname></p><p>还可以使用**–dump-args–dump-backtrace–dump-return**来打印函数的参数、调用栈以及返回值，<strong>默认会Hook对应方法的所有重载方法</strong></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663559042157.png" alt=""></p></li><li><p>Hook结束之后可以使用<strong>jobs kill pid</strong>来删除作业，<strong>jobs list</strong>列出所有作业</p></li><li><p><strong>主动调用</strong>：基于最简单的Java.choose的实现，**android heap search instances <classname>**来搜索实例，<strong>HashCode作为实例句柄来调用和执行函数</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663559758515.png" alt=""></classname></p><p>然后使用<strong>android heap execute HashCode Method</strong>，注意这里只能是无参的实例方法</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663562350795.png" alt=""></p></li><li><p><strong>主动调用有参实例方法</strong>：输入<strong>android heap evaluate HashCode Method</strong>之后需要自己编写脚本，其中<strong>clazz是该类的实例</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663563150239.png" alt=""></p></li><li><p><strong>启动活动命令</strong>:<strong>android intent launch_activity 活动</strong></p></li></ol><p>当我们无法使用USB进行连接时，还可以使用Objection进行网络模式连接</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663563355880.png" alt=""></p><h1 id="MT管理器"><a class="header-anchor" href="#MT管理器">¶</a>MT管理器</h1><p><a href="https://www.mianshigee.com/tutorial/mt-manual/basic.md">MT管理器的使用</a></p><h1 id="AS动态调试APK"><a class="header-anchor" href="#AS动态调试APK">¶</a>AS动态调试APK</h1><p><a href="https://blog.csdn.net/kenbo_257/article/details/122726128#:~:text=android%20studio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%201%20%E9%A6%96%E5%85%88%E8%A6%81%E6%87%82%E7%9A%84smali%E5%BE%97%E8%AF%AD%E6%B3%95%EF%BC%8C%E7%9F%A5%E9%81%93%E5%9C%A8%E5%93%AA%E9%87%8C%E4%B8%8B%E6%96%AD%E7%82%B9%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%EF%BC%8C%E8%B0%83%E8%AF%95%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%AE%9A%E4%BD%8D%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%B8%8D%E7%94%A8%E5%A4%AA%E7%B2%BE%E9%80%9A%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%80%E8%B5%B7%E7%A0%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A6%81%E7%9F%A5%E9%81%93%202%20%E4%BD%A0%E6%89%80%E8%B0%83%E8%AF%95%E7%9A%84apk%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%8C%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%90%8E%E4%BA%8C%E6%AC%A1%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%9C%89%E4%B8%80%E4%BA%9Bapk%E5%8C%85%E6%98%AF%E5%81%9A%E4%BA%86%E7%AD%BE%E5%90%8D%E6%95%88%E9%AA%8C%E7%9A%84%EF%BC%8C%E9%9C%80%E8%A6%81%E7%A0%B4%E8%A7%A3%E4%B9%8B%E5%90%8E%E6%89%8D%E8%83%BD%E6%89%93%E5%8C%85%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%98%AF%E5%8A%A0%E4%BA%86%E5%A3%B3%E7%9A%84%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E5%8E%BB%E5%A4%84%E7%90%86%E4%BD%A0%E6%89%80%E8%B0%83%E8%AF%95%E7%9A%84apk%E5%8C%85%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E4%BB%94%E7%BB%86%E8%AF%B4%E6%98%8E%E6%80%8E%E4%B9%88%E7%A0%B4%E8%A7%A3%E7%AD%BE%E5%90%8D%E6%95%88%E9%AA%8C%E5%92%8C%E8%84%B1%E5%A3%B3%E6%93%8D%E4%BD%9C%E3%80%82,3%20%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%88%96%E8%80%85%E6%89%8B%E6%9C%BA%EF%BC%88%E6%97%A0%E9%9C%80ROOT%EF%BC%89%EF%BC%8Cadb%E8%83%BD%E5%A4%9F%E6%AD%A3%E5%B8%B8%E9%93%BE%E6%8E%A5%E6%89%8B%E6%9C%BA%204%20%E9%9C%80%E8%A6%81android%20studio%20%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%89">AS动态调试APK</a></p><p><a href="https://blog.csdn.net/joby1981/article/details/16809869">通过资源id找到所在位置</a></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663078077134.png" alt=""></p><h1 id="Java"><a class="header-anchor" href="#Java">¶</a>Java</h1><h2 id="反射"><a class="header-anchor" href="#反射">¶</a>反射</h2><p>反射是框架的设计灵魂，<strong>反射就是将类的各个组成部分封装为其他对象</strong></p><p>首先我们先来看java代码文件在计算机中的经历的阶段</p><blockquote><p>Java源文件首先通过javac编译为class文件，class文件中存储<strong>成员变量、构造方法、普通方法</strong>。<strong>然后将硬盘中的class类通过类加载器(ClassLoader)加载到内存中，而Java中有class类对象来存储字节码文件中的信息</strong>，字节码文件中主要的内容有<strong>成员变量、构造方法、成员方法</strong>，因为上述内容可能存在多个，所以使用数组进行存储。最后在<strong>运行时阶段构造成员</strong>。这样就将类中的各个部分封装为其他对象</p></blockquote><p><img src="/2022/08/31/Android-Reverse-Engineering/1663419013223.png" alt=""></p><p><strong>反射的好处：可以在程序运行时阶段操作这些对象，同时可以解耦，提高程序的可扩展性</strong>，就像下面的输入提示，当我们输入"a."，程序会提示输入，<strong>这就是将String类的方法进行了封装Method[]，然后遍历数组将所有的方法进行展示</strong></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663289657209.png" alt=""></p><h3 id="反射的好处"><a class="header-anchor" href="#反射的好处">¶</a>反射的好处</h3><p>我们可以通过在配置文件中写入要加载的类和需要调用的方法（使用集合存储），然后在程序中加载类和调用方法。<strong>在框架中需要经常地通过配置外部文件，在不修改源码的情况下来控制程序</strong></p><h3 id="类加载"><a class="header-anchor" href="#类加载">¶</a>类加载</h3><p><strong>分为静态加载和动态加载</strong></p><ol><li>静态加载：在编译时加载相关的类，如果没有则报错，<strong>即使我们在程序中可能不会用到这个类，但也必须编写类（在switch……case中创建对象，这样可能不会用到该类）</strong>。依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类则不报错</li></ol><p><img src="/2022/08/31/Android-Reverse-Engineering/1663419595624.png" alt=""></p><p><strong>类加载时机</strong></p><ul><li>当创建对象时（new）<strong>静态加载</strong></li><li>当子类被加载时 <strong>静态加载</strong></li><li>调用类中的静态成员时 <strong>静态加载</strong></li><li>通过反射 <strong>动态加载</strong></li></ul><h3 id="获取Class对象的方式"><a class="header-anchor" href="#获取Class对象的方式">¶</a>获取Class对象的方式</h3><ol><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象，<strong>多用于配置文件，将类名定义在配置文件中，读取文件、加载类</strong></li><li><strong>当类已经加载进内存中</strong> 类名.class：通过类名的属性class获取，<strong>多用于参数的传递</strong></li><li><strong>当创建好对象</strong>，对象.getclass()：getclass方法在object中定义着，所有对象都有这个方法。，<strong>多用于对象的获取获取字节码方式</strong>——常用</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class cls1=Class.forName(<span class="string">"com.hspedu.super01.B"</span>);<span class="comment">//必须是全类名路径</span></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        </span><br><span class="line">        Class cls2=B.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        Class cls3=b.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//因为每一个Class只会在内存中创造一个Class类对象，所以这三者是一样的</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Class类对象的功能"><a class="header-anchor" href="#Class类对象的功能">¶</a>Class类对象的功能</h3><ol><li><p>获取成员变量们</p><ul><li>Field[] getFields()//获取多个</li><li>Field getField(String name)//获取一个</li><li>Field[] getDeclaredFields()，<strong>获取所有的成员变量，不管修饰符</strong>，此时我们就可以操作私有的成员变量</li><li>Field getDeclareField(String name)</li></ul></li><li><p>获取构造方法们</p><p>同样也有getconstructor等方法</p></li><li><p>获取成员方法们</p><p>同上</p></li><li><p>获取类名：String getName()</p></li></ol><h3 id="获取Field"><a class="header-anchor" href="#获取Field">¶</a>获取Field</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Field fields[]=bClass.getFields();<span class="comment">//这个方法是用来获取所有public的成员变量</span></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields){</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>获取到了两个对象</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663291619627.png" alt=""></p><blockquote><p><strong>getFields()用来获取所有public的成员变量</strong></p></blockquote><p><strong>获取到字段之后使用get和set对成员变量的值进行操作，参数为对象，因为成员变量是在对象内的</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Field fields[]=bClass.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields){</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        }</span><br><span class="line">        Field a=bClass.getField(<span class="string">"name"</span>);<span class="comment">//首先通过Class对象获取到字段</span></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        Object fin=a.get(b);<span class="comment">//创建对象后传入</span></span><br><span class="line">        System.out.println(fin);</span><br><span class="line"></span><br><span class="line">        a.set(b,<span class="string">"11111"</span>);<span class="comment">//将b对象中的字段的值设置为11111</span></span><br><span class="line">        System.out.println(b.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">       Field[] field=bClass.getDeclaredFields();</span><br><span class="line">       <span class="keyword">for</span>(Field field1:field){</span><br><span class="line">           System.out.println(field1);</span><br><span class="line">       }</span><br><span class="line">       Field m=bClass.getDeclaredField(<span class="string">"m"</span>);</span><br><span class="line">       B b=<span class="keyword">new</span> B();</span><br><span class="line">       m.setAccessible(<span class="keyword">true</span>);<span class="comment">//因为是私有的，需要设置暴力反射</span></span><br><span class="line">       Object obj=m.get(b);</span><br><span class="line">       System.out.println(obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取Constructor"><a class="header-anchor" href="#获取Constructor">¶</a>获取Constructor</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       Class bClass=B.class;</span><br><span class="line">        Constructor con=bClass.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(con);<span class="comment">//获取构造器，可以指定参数获取不同的构造器，空参构造器可以直接使用bClass.newInstance()来创建对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//constructor可以用于创建对象</span></span><br><span class="line">        Object text=con.newInstance(<span class="string">"Jack"</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="comment">//使用B的父类Object接收</span></span><br><span class="line">        System.out.println(text);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="获取Method"><a class="header-anchor" href="#获取Method">¶</a>获取Method</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Method method=bClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line">        B b=<span class="keyword">new</span> B();<span class="comment">//无参函数</span></span><br><span class="line">        method.invoke(b);<span class="comment">//直接调用</span></span><br><span class="line"></span><br><span class="line">        Method method1=bClass.getMethod(<span class="string">"eat"</span>,String.class);<span class="comment">//参数类型</span></span><br><span class="line">        System.out.println(method1.getName());<span class="comment">//获取方法名</span></span><br><span class="line">        method1.invoke(b,<span class="string">"apple"</span>);</span><br><span class="line"></span><br><span class="line">        Class aClass=Class.forName(<span class="string">"com.hspedu.super01.A"</span>);</span><br><span class="line">        <span class="comment">//Object父类方法也会被获取到，方法也支持暴力反射</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="整个过程的使用"><a class="header-anchor" href="#整个过程的使用">¶</a>整个过程的使用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Constructor con=bClass.getConstructor(String.class,<span class="keyword">int</span>.class);<span class="comment">//获取构造器</span></span><br><span class="line">        <span class="comment">//通过构造器创建对象，因为在java中，调用方法是通过p.Method()来进行的，所以需要通过实例来进行</span></span><br><span class="line">        Object b=con.newInstance(<span class="string">"jack"</span>,<span class="number">12</span>);</span><br><span class="line">        Method method=bClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"></span><br><span class="line">        method.invoke(b);<span class="comment">//直接调用</span></span><br><span class="line">        Method method1=bClass.getMethod(<span class="string">"eat"</span>,String.class);<span class="comment">//参数类型</span></span><br><span class="line">        System.out.println(method1.getName());<span class="comment">//获取方法名</span></span><br><span class="line">        method1.invoke(b,<span class="string">"apple"</span>);</span><br><span class="line"></span><br><span class="line">        Class aClass=Class.forName(<span class="string">"com.hspedu.super01.A"</span>);</span><br><span class="line">        <span class="comment">//Object父类方法也会被获取到，方法也支持暴力反射</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="泛型"><a class="header-anchor" href="#泛型">¶</a>泛型</h2><h2 id="多态-v2"><a class="header-anchor" href="#多态-v2">¶</a>多态</h2><p><strong>解决代码复用性不高且不利于代码维护的问题</strong></p><p>所谓的多态就是一个对象同时具备多种属性，比如小明既是学生也是人</p><p>下面以一个例子来看多态的好处，我们要实现主人喂动物这个操作，此时需要在master这个类中定义两种Feed方法</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663482436003.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663482673581.png" alt=""></p><p>而是用多态只需要一个方法即可</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663482730147.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663482743705.png" alt=""></p><blockquote><p><strong>父类类型 引用名=new 子类类型()</strong>，即为多态，<strong>也是多态中的向上转型</strong> 也就类似先在堆中new一个子类对象，接着使用父类的引用指向该对象地址，<strong>编译类型(编译时)看等号左边、运行类型(程序运行时)看等号右边</strong>，编译类型在定义对象时就确定了，运行类型是可以变化的。<strong>一个对象的编译类型和运行类型可以不一样</strong>，比如上面的dog定义为Animal类(编译类型)，但在运行时指向Dog类(运行类型)，<strong>成员变量是编译类型，方法是运行类型</strong></p></blockquote><p><strong>此时可以访问父类的所有成员以及调用子类中重写父类的方法、但是不能访问子类的特有方法，如果要访问，只能再向下转型，要注意的是向下转型对象的类型必须一致</strong>，这个操作就相当于重写使用一个cat引用名指向new出来的Cat对象，但是不能使用cat引用名指向new出来的Dog对象</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663483447057.png" alt=""></p><p><strong>多态的前提是两个对象存在继承关系</strong></p><h2 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h2><h3 id="抽象"><a class="header-anchor" href="#抽象">¶</a>抽象</h3><p>如果父类方法不确定如何进行方法体实现，那么这就是一个抽象方法。将图形作为父类，子类为长方形、圆形、三角形，我们可以<strong>通过不同的面积公式</strong>来求得各个图形的面积，但是我们没有办法直接求解图形的面积</p><blockquote><p>此时就需要抽象方法来定义，<strong>父类定义抽象方法(不需要函数体，因为每个图形对应的方法都是不同的)，然后子类继承父类后必须重写父类的抽象方法，但不用声明为abstract</strong></p></blockquote><p><strong>抽象方法所在的类必须是抽象类，抽象类不能直接new对象，抽象方法的调用：先通过实现类完成对抽象方法的实现，再通过实现类的对象调用</strong></p><p>测试代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//抽象类不能new对象</span></span><br><span class="line">        Rabbit rabbit1=<span class="keyword">new</span> Rabbit();</span><br><span class="line">        rabbit1.print();</span><br><span class="line"></span><br><span class="line">        Wolf wolf=<span class="keyword">new</span> Wolf();</span><br><span class="line">        wolf.print();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>父类，print是抽象方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//定义一个抽象方法，不需要方法体，需要子类自己重写</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>两个子类，<strong>使用@Override对父类的抽象方法进行重写，也可以说是实现，将其具体化</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Wolf"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="comment">//必须对父类的抽象方法进行实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Rabbit"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="接口-v2"><a class="header-anchor" href="#接口-v2">¶</a>接口</h3><blockquote><p><strong>接口就是一种公共的规范标准，相当于模板</strong></p></blockquote><p>比如USB接口，只要符合USB的标准就可以使用USB，打印机、U盘等，<strong>接口没有静态代码块和构造方法</strong></p><h4 id="抽象方法"><a class="header-anchor" href="#抽象方法">¶</a>抽象方法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口中默认声明为public abstract</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口中定义抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Method01</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method02</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>导入接口并使用<strong>implement表示对该接口进行实现</strong>，然后重写接口中<strong>所有的抽象方法</strong>，如果没有重写所有，则需要将实现类定义为<strong>抽象类</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.InterFace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">InterFace</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method01</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Method01"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method02</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Method02"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后创建实现类的对象后，通过实现类的对象调用即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test test=<span class="keyword">new</span> Test();</span><br><span class="line">test.Method01();</span><br><span class="line">test.Method02();</span><br></pre></td></tr></tbody></table></figure><h4 id="默认方法"><a class="header-anchor" href="#默认方法">¶</a>默认方法</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于接口中的抽象方法都需要实现，当我们需要在接口中添加方法时就需要修改使用了该接口的类</span></span><br><span class="line">   <span class="comment">//这时候就需要添加默认方法即可，此时就不需要在类中重写，关键字为default，需要加入方法体</span></span><br><span class="line">   <span class="comment">//默认方法也可以被覆盖重写</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">Method03</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"This is Method03"</span>);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h4 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h4><p><strong>静态方法：接口中不希望被被实现类使用的方法，关键字为static，只能通过接口名称调用，只能是public static</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method04</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Method04"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>静态方法的调用</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1663417512103.png" alt=""></p><h4 id="私有方法"><a class="header-anchor" href="#私有方法">¶</a>私有方法</h4><p><strong>Java9开始接口中允许定义私有方法</strong>，<strong>private的方法只有接口自己可以调用，不能被实现类或别人调用</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通私有方法</span></span><br><span class="line"><span class="keyword">private</span> 返回值类型 方法名(参数列表){方法体};</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表){方法体};</span><br></pre></td></tr></tbody></table></figure><h4 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h4><blockquote><p><strong>常量关键字为public static final，final表明为这个值不可被修改</strong></p></blockquote><h4 id="一个类实现多个接口"><a class="header-anchor" href="#一个类实现多个接口">¶</a>一个类实现多个接口</h4><p><strong>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口</strong></p><p>注意事项</p><ol><li>如果实现类所实现的多个接口中存在多个重复的抽象方法，<strong>只需要覆盖重写一次即可</strong></li><li>如果实现类没有覆盖重写所有抽象方法，则需要将实现类定义为<strong>抽象类</strong></li><li>如果实现类所实现的多个接口中存在重复的默认方法，那么<strong>需要对默认方法进行覆盖重写</strong></li><li>如果实现类的父类方法和接口中的默认方法冲突时，优先调用父类的方法</li></ol><h1 id="移动端攻防技术"><a class="header-anchor" href="#移动端攻防技术">¶</a>移动端攻防技术</h1><p><a href="https://xz.aliyun.com/t/4960">LLVM</a></p><h1 id="Xposed框架介绍"><a class="header-anchor" href="#Xposed框架介绍">¶</a>Xposed框架介绍</h1><p>Xposed更适用于长久化的使用，但是每次安装框架之后都需要重启，这也是其麻烦的一点</p><h2 id="AS编写Xposed框架"><a class="header-anchor" href="#AS编写Xposed框架">¶</a>AS编写Xposed框架</h2><p>Xposed框架本质上也是APK，但是我们需要让其被Xposed识别，所以我们先要安装好环境，由于Xposed很久没有发布了，不支持较高版本的Android8.0、8.1以上，但是Magisk有<strong>Edxposed</strong>来代替</p><p><a href="https://gitee.com/dev_dX/riruxposed#https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FElderDrivers%2FEdXposed%2Freleases">Root手机刷入Edxposed</a></p><h1 id="抓包详解"><a class="header-anchor" href="#抓包详解">¶</a>抓包详解</h1><blockquote><p><strong>在安卓App的逆向分析中，抓包通常是指通过一些手段来获取App与服务器之间传输的明文网络数据信息</strong>，我们可以通过获取到的信息快速定位关键接口函数的位置</p></blockquote><p><strong>主要有Hook抓包和中间人抓包</strong></p><ol><li><strong>Hook抓包</strong>：Hook抓包实际上是通过对发包函数的Hook来达到抓包的目的</li><li><strong>中间人抓包</strong>：将一段完整的客户端-服务器的通信方式割裂为两段客户端-服务器通信<img src="/2022/08/31/Android-Reverse-Engineering/1663657312049.png" alt=""></li></ol><p><strong>抓包的主要工具有Wireshark、BurpSuite、Charles、Fiddler</strong>，Fiddler不推荐使用</p><p><a href="https://www.jianshu.com/p/7f17061dbcbf?u_atoken=14182ace-0e0e-463f-9996-75c3d3185b89&amp;u_asession=01GKVj8-YWn0KueCdhU4ZSk658Da2FBjfO1JCBfh1Gr43oHEhvmXVEe8R5g-jOXD4fX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K9jobxe0zzCvOSFHghz6zYUkC1LUOsbnJoxzzl_EpVkQGBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=057B1HkqRcx00OK6N3B0TcaE5gAgguwngpuL6XYrGrnQfO-96XeptSZb0njPdZzroKKo_AyXFGwNvJgSrvJ4tPI7b5CAbw2ZXNkU3nT-gKy4hb0e7JHInY4BO5hKuzfsRZMoOuMaSf8YHl-pI56SBKYIe6smrNB6XbY-woE5mor2v9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzQMgAchpo_DngDnbnyfG1xD4wmivQt_BGPIdIwfuKPQjUDrMH9U5oL9icxwFsJSlo-3h9VXwMyh6PgyDIVSG1W-GXTIg1qMl4qfyOkBxxkWx6rN4WnkP27a0CQVvwR6dMvxujFdoiwZ9o5RqXUmYm7FT7neMKWToEY6c9-kDqUzamWspDxyAEEo4kbsryBKb9Q&amp;u_aref=Iy6h6y%2F3KS4PUfgkF%2BqPATFN9Ns%3D">Charles抓包</a></p><p><a href="https://blog.csdn.net/qq_35835118/article/details/94381177">Charles破解</a></p><p>其中手机中输入的代理主机名应为下面这个地址，使用ipconfig获取</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664076582081.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664111445479.png" alt=""></p><h1 id="安卓攻防技术"><a class="header-anchor" href="#安卓攻防技术">¶</a>安卓攻防技术</h1><p><a href="https://www.anquanke.com/post/id/246020">面试问题</a></p><ol><li><strong>动态加载方案</strong>：将u需要保护的代码单独编译成一个二进制文件，将其加密后保存在一个外部的二进制文件中。<strong>在外部程序运行的过程中再将保护的二进制文件解密并使用ClassLoader类加载器来动态加载和运行被保护的代码</strong>，<strong>Android中每个Java类都是由ClassLoader类加载器加载和运行的</strong></li><li><strong>App加固</strong>：最难绕过的保护手段就是App加固</li><li><strong>Root检测</strong></li><li><strong>NDK</strong>：将关键代码写入native层，Java层只作为加载器和调用端</li><li><strong>云端存储数据</strong></li><li><strong>反调试</strong>：<strong>运行时检测和事先阻止</strong>，<a href="https://www.freebuf.com/articles/mobile/291894.html">反调试</a><ul><li><strong>运行时检测</strong>：如果调用ptrace()函数进行进程附加，/proc/<pid>/status文件中的TracePid变量会在进程被附加后由0变为附加进程的pid，<strong>如果此时代码本身单开一个线程对这个文件的TracePid值进行循环检测，异常时则退出进程，就做到了阻止进程被破解者调试</strong></pid></li><li><strong>时间差检测</strong>：调试的时候指令执行时间较长，我们可以基于此进行检测</li><li><strong>双进程保护</strong>：主要是基于<strong>一个进程最多只能被一个进程ptrace附加的特性</strong>，实现fork一个子进程ptrace，然后ptrace自己</li></ul></li><li><strong>代码混淆</strong><ul><li>符号混淆：Google自带的混淆器<strong>ProGuard</strong>，主要是将有意义的名称改为a、b这种无符号的名称</li><li>压缩文件大小：只要修改App/build/grale文件，将buildTypes中的minifyEnabled对应的值改为true即可</li><li><strong>DexGuard</strong>：收费商业软件，是ProGuard的升级版，支持<strong>字符串加密、花指令、资源加密等</strong></li></ul></li></ol><p>攻击：</p><ol><li>静态分析和动态分析结合：IDA、GDB对so文件进行调试，Jeb、AS调试smali</li><li><strong>Hook和Trace</strong></li><li>反反调试：手动patch<strong>检测代码逻辑</strong>后重新打包</li></ol><h2 id="App加固"><a class="header-anchor" href="#App加固">¶</a>App加固</h2><blockquote><p><strong>App加固，类似动态加载，用加固厂商的壳程序包裹真实的App，在真实动态运行时再通过壳程序执行释放出来的真正的App</strong></p></blockquote><p>App加固的发展主要可以分为三个阶段</p><h3 id="DEX整体加固"><a class="header-anchor" href="#DEX整体加固">¶</a>DEX整体加固</h3><p>这个阶段的App加固的核心原理就是<strong>将DEX整体加密后动态加载</strong>，在对加密的文件解密之后调用<strong>DexClassLoader或者其他类加载函数</strong>来加载解密后的文件，由于对文件的操作过于明显，进阶为<strong>将加密的DEX在内存中进行加载的加固技术</strong>，<strong>但还是可以通过在内存中搜索DEX文件头或在加载DEX的函数上下断点、进行Hook就可以找到解密数据</strong></p><blockquote><p><strong>由于DEX整体加固总是将代码数据完整地存储在一段内存中，只要绕过反注入和反调试技术即可获取到数据</strong></p></blockquote><h4 id="Frida脱壳"><a class="header-anchor" href="#Frida脱壳">¶</a>Frida脱壳</h4><p>主要是基于Hook <strong>libart.so导出的OpenMemory函数</strong>，只在Android8.0以下才有</p><h3 id="代码抽取保护"><a class="header-anchor" href="#代码抽取保护">¶</a>代码抽取保护</h3><p>这个阶段App加固的关键在于<strong>真正的代码数据并不与DEX的整体结构数据存储在一起</strong>，就算DEX被完整地dump出来，也无法看到真正的代码逻辑</p><p><strong>核心原理是利用私有函数，通过对其自身进程的Hook来拦截函数被调用时的路径，在抽取的函数被真实调用之前，将无意义代码数据填充到对应的代码区中</strong>（将Dex文件中的指令编码部分与Dex文件主体分离并独立执行加密操作，<strong>而原先的指令转为NOP指令</strong>，这样加载进内存中的Dex反编译后代码部分就是空的）</p><p>代码抽取技术并不会对App中所有的函数进行抽取保护，特别是<strong>第三方库</strong>。并且，代码抽取技术通常在函数被第一次调用后就不再将函数内容重新置空，<strong>因此只需要在App运行时多处发几次程序逻辑，然后再进行DEX的dump即可得到更加完整的DEX文件</strong></p><h4 id="FART脱壳"><a class="header-anchor" href="#FART脱壳">¶</a>FART脱壳</h4><blockquote><p><strong>对抗指令抽取的首要目标就是要获取正确的被抽取的方法指令，而方法指令被执行前一定会被解密，可以借助Android调用类方法的机制，通过系统加载指令的函数访问到内存中解密的指令，进而导出</strong></p></blockquote><p><strong>ART环境中常用的脱壳点：脱动态加载壳的本质是要获取在内存中处于解密状态的Dex文件，因此需要准确定位Dex文件在内存中的位置和大小，ART加载链接类时，Android会先调用LoadClass()函数去加载Dex文件中的类，然后调用LoadClassMembers()函数去初始化类的所有变量以及函数对象</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClassMembers</span><span class="params">(Thread* self, <span class="keyword">const</span> DexFile&amp; dex_file,<span class="keyword">const</span> <span class="keyword">uint8_t</span>* class_data,Handle&lt;mirror::Class&gt; klass,<span class="keyword">const</span> OatFile::OatClass* oat_class)</span></span></span><br></pre></td></tr></tbody></table></figure><p>其中第二个参数就是对当前处理的dex对象的引用，<strong>在这个引用中我们可以得到Dex对象，从而获取Dex文件在内存中的地址以及长度</strong></p><p><a href="https://github.com/hanbinglengyue/FART">Fart脱壳源码</a></p><h4 id="DexHunter脱壳"><a class="header-anchor" href="#DexHunter脱壳">¶</a>DexHunter脱壳</h4><p><strong>通过主动加载DEX中的所有类并dump处所有方法对应的代码，最后将代码重构再填充回被抽取的DEX中</strong></p><h3 id="VMP与Dex2C"><a class="header-anchor" href="#VMP与Dex2C">¶</a>VMP与Dex2C</h3><p><strong>将所有的Java代码变成最终的native代码</strong></p><p>区别</p><h2 id="Ollvm"><a class="header-anchor" href="#Ollvm">¶</a>Ollvm</h2><p><a href="https://jev0n.com/2022/07/08/ollvm-1.html">https://jev0n.com/2022/07/08/ollvm-1.html</a></p><p><a href="https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html</a></p><p><a href="https://www.52pojie.cn/thread-1488350-1-1.html">https://www.52pojie.cn/thread-1488350-1-1.html</a></p><p><a href="https://mrt4ntr4.github.io/MODeflattener/">https://mrt4ntr4.github.io/MODeflattener/</a></p><h3 id="OLLVM环境配置与编译so文件"><a class="header-anchor" href="#OLLVM环境配置与编译so文件">¶</a>OLLVM环境配置与编译so文件</h3><p><a href="https://blog.csdn.net/u013314647/article/details/117740784?spm=1001.2014.3001.5506">OLLVM环境配置</a></p><p><a href="https://jev0n.com/2022/07/07/ollvm-0.html">参数详细说明</a></p><p>首先先配置好前面安装的NDK进行编译</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664171372070.png" alt=""></p><p>然后创建jni目录，在jni目录下创建<strong><a href="http://Android.mk">Android.mk</a>,<a href="http://Application.mk">Application.mk</a>，C/C++源文件</strong></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664171003366.png" alt=""></p><p>添加如下内容</p><p><strong>Android.mk文件</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := hello</span><br><span class="line">LOCAL_LDLIBS := -lm -llog</span><br><span class="line">LOCAL_SRC_FILES := hello.cpp   <span class="comment">#自己的.c or .cpp文件</span></span><br><span class="line">LOCAL_CFLAGS := -mllvm -sub -mllvm -bcf -mllvm -bcf_loop=3  -mllvm -bcf_prob=40 -mllvm -fla -mllvm -split_num=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//不同命令对应的混淆方式</span><br><span class="line"><span class="deletion">-mllvm -fla：控制流扁平化</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-mllvm -sub：指令替换</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-mllvm -bcf：虚假控制流程</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-mllvm -sobf： 字符串加密</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Application.mk文件</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">APP_ABI := all</span><br><span class="line"></span><br><span class="line">APP_PLATFORM=android-19</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>hello.cpp</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">//需要注意函数的命名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">{</span><br><span class="line"><span class="function">jstring <span class="title">Java_com_example_myapplication_MainActivity_getStringFromJni</span><span class="params">(JNIEnv* jni, jobject obj)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> jni-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">"Hello jni!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来cd到jni目录中，执行<strong>ndk-build</strong>即可</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664171707347.png" alt=""></p><p>然后在jni同路径下的libs目录即可找到编译完成的so文件</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664171751666.png" alt=""></p><p>混淆效果展示</p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664171777960.png" alt=""></p><p><img src="/2022/08/31/Android-Reverse-Engineering/1664171791787.png" alt=""></p><h3 id="指令替换混淆"><a class="header-anchor" href="#指令替换混淆">¶</a>指令替换混淆</h3><h3 id="控制流平坦化"><a class="header-anchor" href="#控制流平坦化">¶</a>控制流平坦化</h3><h3 id="伪造控制流"><a class="header-anchor" href="#伪造控制流">¶</a>伪造控制流</h3><h1 id="Android反调试"><a class="header-anchor" href="#Android反调试">¶</a>Android反调试</h1><p><a href="https://www.lxiaoyu.com/p/366552">init段的反调试</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android_Reverse_Engineering&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>IDAPython</title>
    <link href="https://gift1a.github.io/2022/08/30/IDAPython/"/>
    <id>https://gift1a.github.io/2022/08/30/IDAPython/</id>
    <published>2022-08-30T07:12:32.000Z</published>
    <updated>2022-10-09T09:56:50.737Z</updated>
    
    <content type="html"><![CDATA[<p>IDA Python</p><span id="more"></span><h1 id="IDAPython的API基本使用"><a class="header-anchor" href="#IDAPython的API基本使用">¶</a>IDAPython的API基本使用</h1><p><a href="http://www.qfrost.com/undefined/IDAPython/">IDAPython教程</a></p><h2 id="指令相关"><a class="header-anchor" href="#指令相关">¶</a>指令相关</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#next_addr(addr),prev_addr(addr)//获取当前地址的后一个地址，获取当前地址的前一个地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(prev_addr(<span class="number">0x4011E9</span>)),end=<span class="string">'\n'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(next_addr(<span class="number">0x4011E9</span>)),end=<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#0x4011e8</span></span><br><span class="line"><span class="comment">#0x4011ea</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#next_head()获取下一条指令的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#generate_disasm_line(addr,flags=0)得到addr的反汇编语句</span></span><br><span class="line"><span class="built_in">print</span>(generate_disasm_line(<span class="number">0x4011e8</span>,flags=<span class="number">0</span>),end=<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">#sub     esp, 40h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print_insn_mnem(addr)获取addr地址处的指令</span></span><br><span class="line"><span class="comment">#print_operand(addr,num)获取addr地址处的第num+1个操作数</span></span><br><span class="line"><span class="built_in">print</span>(print_insn_mnem(<span class="number">0x0401227</span>),end=<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(print_operand(<span class="number">0x0401227</span>,<span class="number">0</span>),end=<span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(print_operand(<span class="number">0x0401227</span>,<span class="number">1</span>),end=<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">#xor</span></span><br><span class="line"><span class="comment">#byte ptr [eax]</span></span><br><span class="line"><span class="comment">#54h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get_operand_value(addr,num)获取addr处第num+1个操作数的值</span></span><br><span class="line"><span class="built_in">print</span>(get_operand_value(<span class="number">0x0401227</span>,<span class="number">1</span>),end=<span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">#84</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get_strlit_contents(addr)获取addr处的字符串</span></span><br><span class="line"><span class="built_in">print</span>(get_strlit_contents(<span class="number">0x403140</span>),end=<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#b'Please input your flag:'</span></span><br><span class="line"></span><br><span class="line">set_cmt(addr, comm, rptble)  对addr处添加批注comm; rptble=<span class="literal">True</span>时若存在批注则不会更改，为<span class="literal">False</span>时会替换批注</span><br><span class="line"><span class="built_in">print</span>(set_cmt(<span class="number">0x40156F</span>, <span class="string">"This is comm"</span>, <span class="literal">False</span>))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># 0x40156F                 call    puts            ; This is comm</span></span><br><span class="line"></span><br><span class="line">set_name(addr, name, flags=SN_CHECK)  对addr处变量改名</span><br><span class="line"><span class="built_in">print</span>(set_name(<span class="number">0x404000</span>, <span class="string">"MyBuffer"</span>, SN_CHECK))</span><br></pre></td></tr></tbody></table></figure><h2 id="功能相关"><a class="header-anchor" href="#功能相关">¶</a>功能相关</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#add_bpt(addr,0,BPT_SOFT)在addr处设置断点</span></span><br><span class="line"><span class="comment">#del_bpt(addr)删除addr位置处的断点</span></span><br><span class="line"></span><br><span class="line">add_bpt(<span class="number">0x403140</span>,<span class="number">0</span>,BPT_SOFT)</span><br><span class="line">del_bpt(<span class="number">0x403140</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#enable(addr,True/False)设置addr处的断点是否开启</span></span><br><span class="line">enable_bpt(<span class="number">0x403140</span>,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#get_wide_byte(addr)获得addr处一字节的值</span></span><br><span class="line"><span class="comment">#get_wide_word(addr)获得addr处两字节的值</span></span><br><span class="line"><span class="comment">#get_wide_dword(addr)获得addr处四字节的值</span></span><br><span class="line"><span class="comment">#get_qword(addr)获得addr处八字节的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(get_qword(<span class="number">0x403140</span>)))</span><br><span class="line"><span class="comment">#0x6920657361656c50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#patch_byte(addr,val)将addr处patch一个字节为val</span></span><br><span class="line"><span class="comment">#patch_word(addr,val)将addr处patch两个字节为val</span></span><br><span class="line"><span class="comment">#patch_dword(addr,val)将addr处patch四个字节为val</span></span><br><span class="line"><span class="comment">#patch_qword(addr,val)将addr处patch八个字节为val</span></span><br><span class="line">patch_byte(<span class="number">0x0403140</span>,<span class="built_in">ord</span>(<span class="string">'U'</span>))</span><br></pre></td></tr></tbody></table></figure><p>还可以使用idaapi中的get_bytes</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line">data = idaapi.get_bytes(addr, size)</span><br></pre></td></tr></tbody></table></figure><h2 id="调试相关"><a class="header-anchor" href="#调试相关">¶</a>调试相关</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get_reg_value(string Register)通过寄存器名称获得寄存器的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(get_reg_value(<span class="string">"EIP"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#set_reg_value(long Value,String Register)通过寄存器名称修改寄存器的值</span></span><br><span class="line">set_reg_value(get_reg_value(<span class="string">"EIP"</span>)+<span class="number">16</span>,<span class="string">"EIP"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_process(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>)<span class="comment">#开启调试，中间的参数好像是命令行之类的</span></span><br><span class="line">continue_process()<span class="comment">#继续调试</span></span><br><span class="line"></span><br><span class="line">run_to(addr)<span class="comment">#运行到指定地址</span></span><br><span class="line"></span><br><span class="line">wait_for_next_event(EVENT_TYPE,flags)</span><br><span class="line"><span class="comment">#获取并清除调试器事件代码，普通代码返回0x20，断点、ret指令返回0x10，程序结束返回负数</span></span><br><span class="line"><span class="comment">#必须在导致进程执行的每个函数之后调用，以便检索调试器的事件代码，否则可能会阻止后续尝试单步执行或运行进程</span></span><br><span class="line"></span><br><span class="line">step_over()<span class="comment">#单步步过，我们需要在调用step_over之后调用一次wait_for_next_event函数</span></span><br><span class="line"></span><br><span class="line">step_over()</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)    <span class="comment">#是否获取返回值都可以清除调试器事件代码，从而继续执行调试</span></span><br><span class="line">step_over()</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line">step_over()</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#事件类型“WFNE_SUSP”将等待导致被调试进程挂起的事件，例如异常或断点</span></span><br><span class="line"><span class="comment">#事件类型“WFNE_CONT”可以恢复被挂起的进程，继续执行</span></span><br></pre></td></tr></tbody></table></figure><p>下面是个简单的案例，只要程序寄存器中的值为0x7FF7C6320967就停止执行</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_process(<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    step_over()</span><br><span class="line">    wait_for_next_event(WFNE_SUSP,-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> get_reg_value(<span class="string">"RIP"</span>) == <span class="number">0x7FF7C6320967</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></tbody></table></figure><h2 id="SUSCTF-tttree"><a class="header-anchor" href="#SUSCTF-tttree">¶</a>SUSCTF-tttree</h2><p>idapython脚本去花</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先先去除连续的push和pop</span></span><br><span class="line">start=<span class="number">0x140001000</span></span><br><span class="line">end=<span class="number">0x014001C694</span></span><br><span class="line">addr_list=[<span class="number">0</span>]*<span class="number">11</span></span><br><span class="line">now_addr=start</span><br><span class="line"></span><br><span class="line">addr_target=[<span class="string">'push    rax'</span>,<span class="string">'push    rax'</span>,<span class="string">'pushfq'</span>,<span class="string">'call    $+5'</span>,<span class="string">'pop     rax'</span>,<span class="string">'add     rax,'</span>,<span class="string">'mov '</span>,<span class="string">'popfq'</span>,<span class="string">'pop     rax'</span>,<span class="string">'retn'</span>]</span><br><span class="line"><span class="comment">#这是第一段patch，将连续的push和pop全部nop掉</span></span><br><span class="line"><span class="keyword">while</span>(now_addr&lt;=end):</span><br><span class="line">    addr_list[<span class="number">0</span>]=now_addr<span class="comment">#获取当前指令的地址</span></span><br><span class="line">    addr_list[<span class="number">1</span>]=next_head(now_addr)<span class="comment">#获取下一条指令的地址</span></span><br><span class="line">    <span class="keyword">if</span> print_insn_mnem(addr_list[<span class="number">0</span>])==<span class="string">'push'</span> <span class="keyword">and</span> print_insn_mnem(addr_list[<span class="number">1</span>])==<span class="string">'pop'</span> <span class="keyword">and</span> print_operand(addr_list[<span class="number">0</span>],<span class="number">0</span>)==print_operand(addr_list[<span class="number">1</span>],<span class="number">0</span>):</span><br><span class="line">        patch_byte(addr_list[<span class="number">0</span>],<span class="number">0x90</span>)</span><br><span class="line">        patch_byte(addr_list[<span class="number">1</span>],<span class="number">0x90</span>)</span><br><span class="line">        now_addr+=<span class="number">2</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    now_addr+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>():</span></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">5</span> <span class="keyword">or</span> i==<span class="number">6</span>:</span><br><span class="line">            cnt+=generate_disasm_line(addr_list[i],flags=<span class="number">0</span>).find(addr_target[i])!=-<span class="number">1</span><span class="comment">#没找到就返回-1</span></span><br><span class="line">            <span class="comment">#print(cnt)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cnt+=addr_target[i]==generate_disasm_line(addr_list[i],flags=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> cnt        </span><br><span class="line">now_addr=start</span><br><span class="line"><span class="keyword">while</span>(now_addr&lt;=end):</span><br><span class="line"><span class="comment">#先把后面的几条指令的地址存储起来，方便待会进行比对</span></span><br><span class="line">    <span class="comment">#对于已经nop的可以跳过</span></span><br><span class="line">    <span class="keyword">if</span> generate_disasm_line==<span class="string">"nop"</span>:</span><br><span class="line">        now_addr+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    addr_list[<span class="number">0</span>]=now_addr</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        addr_list[i]=next_head(addr_list[i-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> check()==<span class="number">10</span>:    </span><br><span class="line">        <span class="comment">#print(hex(addr_list[0]))找到对应的地址，可以开始进行patch了</span></span><br><span class="line">        patch_byte(addr_list[<span class="number">0</span>],<span class="number">0xE9</span>)</span><br><span class="line">        data=get_operand_value(addr_list[<span class="number">5</span>],<span class="number">1</span>)+addr_list[<span class="number">4</span>]<span class="comment">#获取add第二个参数的值</span></span><br><span class="line">        data-=(addr_list[<span class="number">0</span>]+<span class="number">5</span>)<span class="comment">#使其跳转的是绝对地址，jmp+地址的计算是jmp+当前jmp指令到要跳转位置的相对距离，所以需要减去基地址获取相对距离，并且jmp指令长度为5</span></span><br><span class="line">        patch_dword(addr_list[<span class="number">0</span>]+<span class="number">1</span>,data&amp;<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(addr_list[<span class="number">0</span>]+<span class="number">5</span>,addr_list[<span class="number">9</span>]+<span class="number">1</span>):</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br><span class="line">        now_addr=addr_list[<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> check()==<span class="number">9</span>:<span class="comment">#说明最后一个不是ret，那么对应的就是push指令</span></span><br><span class="line">        patch_byte(addr_list[<span class="number">0</span>],<span class="number">0x68</span>)</span><br><span class="line">        data=get_operand_value(addr_list[<span class="number">5</span>],<span class="number">1</span>)+addr_list[<span class="number">4</span>]<span class="comment">#获取add第二个参数的值</span></span><br><span class="line">        patch_dword(addr_list[<span class="number">0</span>]+<span class="number">1</span>,data&amp;<span class="number">0xFFFFFFFF</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(addr_list[<span class="number">0</span>]+<span class="number">5</span>,addr_list[<span class="number">8</span>]+<span class="number">1</span>):</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br><span class="line">        now_addr=addr_list[<span class="number">9</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#print("FAILED",end='\n')</span></span><br><span class="line">        now_addr+=<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;IDA Python&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程的通信</title>
    <link href="https://gift1a.github.io/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>https://gift1a.github.io/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</id>
    <published>2022-08-25T06:00:44.000Z</published>
    <updated>2022-08-30T07:06:48.123Z</updated>
    
    <content type="html"><![CDATA[<p>进程与线程的通信</p><span id="more"></span><h1 id="进程和线程的区别和联系"><a class="header-anchor" href="#进程和线程的区别和联系">¶</a>进程和线程的区别和联系</h1><p><a href="https://cloud.tencent.com/developer/article/1334756">进程的联系和区别</a></p><p><a href="https://zhuanlan.zhihu.com/p/403313422">举例理解进程和线程</a></p><h2 id="进程"><a class="header-anchor" href="#进程">¶</a>进程</h2><p><strong>进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位</strong>，通俗来说：进程就是程序的一个执行过程</p><p>进程主要有三个部分组成</p><ol><li><p>进程控制块PCB，包含了进程描述信息、进程控制和管理信息、资源分配清单、CPU相关信息</p></li><li><p>数据段，即程序运行过程中的各种数据(比如程序中定义的变量)</p></li><li><p>程序段：就是程序的代码</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661650750289.png" alt=""></p></li></ol><h2 id="线程"><a class="header-anchor" href="#线程">¶</a>线程</h2><p>单个CPU一次只能运行一个任务，而进程就代表CPU所能处理的单个任务，而一个进程可以包括多个线程。<strong>线程是独立调度的基本单位</strong>。 CPU有单核和多核区别，<strong>单核CPU</strong>其实就是多个线程会轮流得到那一个CPU核心的支持；在<strong>多核CPU</strong>中，一个核心可以服务于一个线程，例如我的电脑是4核的话，有四个线程A、B、C、D需要处理，那CPU会将他们分配到核心1、2、3、4，如果还有其他更多的线程，也必须要等待CPU的切换执行。</p><p><a href="https://www.jianshu.com/p/9218692cb209">线程的通信和同步方式</a></p><h3 id="共享进程空间"><a class="header-anchor" href="#共享进程空间">¶</a>共享进程空间</h3><p>一个进程的内存空间是共享的，<strong>每个线程都可以使用这些共享内存</strong></p><h3 id="共享内存"><a class="header-anchor" href="#共享内存">¶</a>共享内存</h3><p>当某个线程使用一些共享空间时，其他线程必须等待它试用结束才能继续使用这一块内存</p><h3 id="信号量"><a class="header-anchor" href="#信号量">¶</a>信号量</h3><p>用于保证多个线程不会互相冲突，<strong>互斥体就是其中的一种体现</strong>，通过CreateMutex和ReleaseMutex告知下一个线程此时内存可以访问，BUU-Youngter-drive</p><h3 id="互斥锁"><a class="header-anchor" href="#互斥锁">¶</a>互斥锁</h3><p>防止多个线程同时读写一块内存区域，而互斥锁就是信号量的一种特殊情况</p><h1 id="进程间通信"><a class="header-anchor" href="#进程间通信">¶</a>进程间通信</h1><p><strong>由于资源分配时将资源分配给了不同的进程，这样进程的资源是独立的，进程之间就无法共享数据和进行互相访问，如果我们需要在不同进程之间实现信息交互和状态传递，此时就需要进程间的通信</strong></p><h2 id="创建共享空间"><a class="header-anchor" href="#创建共享空间">¶</a>创建共享空间</h2><p><a href="https://blog.csdn.net/csafu/article/details/8602142">细节</a></p><h3 id="CreateFileMapping"><a class="header-anchor" href="#CreateFileMapping">¶</a>CreateFileMapping</h3><h3 id="MapViewOfFile"><a class="header-anchor" href="#MapViewOfFile">¶</a>MapViewOfFile</h3><h3 id="OpenFileMapping"><a class="header-anchor" href="#OpenFileMapping">¶</a>OpenFileMapping</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建内存地址，这些函数指定的权限标志和CreateFileMapping中的权限标志不一致，则会执行失败。</span></span><br><span class="line"><span class="keyword">char</span> init[] = <span class="string">"Helloworld!"</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="keyword">final</span>[<span class="number">30</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//第一个是需要创建映射的文件句柄，0xFFFF表示创建空间</span></span><br><span class="line">HANDLE hobject = CreateFileMapping(<span class="number">0</span>, <span class="number">0</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">0x1000</span>u, (LPCWSTR)<span class="string">"FLAG"</span>);</span><br><span class="line">LPVOID address = MapViewOfFile(hobject, <span class="number">0xF001F</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x1000</span>u);</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="keyword">void</span>*)address, init, <span class="built_in">strlen</span>(init));</span><br><span class="line"><span class="comment">//第一个参数是文件映射对对象的句柄，第二个为属性为访问权限</span></span><br><span class="line"><span class="comment">/*HANDLE hobject1 = CreateFileMappingA(0, 0, PAGE_READWRITE, 0, 0x1000u, "FLAG");</span></span><br><span class="line"><span class="comment">LPVOID address1 = MapViewOfFile(hobject, 0xF001F, 0, 0, 0x1000u);*/</span></span><br><span class="line">HANDLE Myshare = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, (LPCWSTR)<span class="string">"FLAG"</span>);</span><br><span class="line">LPVOID address1 = MapViewOfFile(hobject, <span class="number">0xF001F</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x1000</span>u);</span><br><span class="line"><span class="built_in">memcpy</span>(<span class="keyword">final</span>, address1,<span class="built_in">strlen</span>(init));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="keyword">final</span>);</span><br><span class="line">UnmapViewOfFile(Myshare);</span><br><span class="line">CloseHandle(address1);</span><br><span class="line">UnmapViewOfFile((LPVOID)address);</span><br><span class="line">CloseHandle(hobject);</span><br></pre></td></tr></tbody></table></figure><h1 id="多线程-v2"><a class="header-anchor" href="#多线程-v2">¶</a>多线程</h1><h2 id="创建线程"><a class="header-anchor" href="#创建线程">¶</a>创建线程</h2><p>首先来看创建线程的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CreateThread</span></span><br><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpThreadAttributes,<span class="comment">//安全属性，通常设置为NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">  SIZE_T dwStackSize,<span class="comment">//参数用于设定参数可以将多少地址空间用于他自己的堆栈，每个线程拥有自己的堆栈</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPTHREAD_START_ROUTINE lpStartAddress,<span class="comment">//参数用于指明想要新线程执行的线程函数的地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID lpParameter,<span class="comment">//线程函数的参数，在线程启动执行时将该参数传递给线程函数，既可以是数字，也可以是指向包含其他信息的一个数据结构的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwCreationFlags,<span class="comment">//0表示创建完毕后立即调度，CREATE_SUSPENDED表示创建之后挂起</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD lpThreadId<span class="comment">//线程ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//返回值，线程句柄</span></span><br></pre></td></tr></tbody></table></figure><p>线程函数的格式是统一的</p><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">DWORD</span> <span class="selector-tag">WINAPI</span> 函数名(LPVOID 线程参数)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>线程函数放类中需要加static修饰，或者直接放类外</p></blockquote><p>下面是创建线程的例子</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Thread</span><span class="params">(LPVOID lparam)</span> </span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This is A Thread Test\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this is main\n"</span>);</span><br><span class="line">HANDLE hObject = CreateThread(<span class="number">0</span>, <span class="number">0</span>, Thread, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">CloseHandle(hObject);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们在运行时会发现一个问题，多次运行的结果并不相同</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661655709477.png" alt=""></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661655717925.png" alt=""></p><p>这是因为线程原则上是并行执行的，而不是顺序执行的，操作系统来决定线程的执行顺序——<strong>CPU调度</strong>，所以可能是主线程先结束，也可能是其他线程先结束</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661656781866.png" alt=""></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661656793282.png" alt=""></p><p><a href="https://www.its404.com/article/kofandlizi/6458011">CloseHandle</a></p><p>同时需要注意Closehandle这个函数，<strong>因为他的作用不是用于关闭线程，而是释放线程句柄，表示不再对这个线程进行操作</strong>，线程句柄是一个内核对象，我们可以通过线程句柄来操作线程，<strong>但是线程的生命周期和线程句柄的生命周期不一样的。线程的生命周期就是线程函数从开始执行到return，线程句柄的生命周期是从CreateThread返回到你CloseHandle()</strong></p><p>当我们不再使用句柄时一定要记得释放，因为句柄属于系统资源，使用完就得还回去</p><h2 id="多线程执行"><a class="header-anchor" href="#多线程执行">¶</a>多线程执行</h2><p>通过上面的例子我们可以知道多个线程的执行顺序是由操作系统决定的，但是有时候我们需要明确线程的执行先后顺序，这时候我们就需要对线程进行控制</p><h3 id="WaitForSingleObject"><a class="header-anchor" href="#WaitForSingleObject">¶</a>WaitForSingleObject()</h3><p>使用WaitForSingleObject()来控制</p><p>通过传入线程的句柄和等待的时间(参数中以毫秒为单位)来控制，INFINITE表示无限(0xFFFFFFFF)，即当线程执行完之后再执行其他线程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(hObject, INFINITE);</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661658143013.png" alt=""></p><p>而没有WaitForSingleObject是这样的</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661658184863.png" alt=""></p><h3 id="互斥对象"><a class="header-anchor" href="#互斥对象">¶</a>互斥对象</h3><p><a href="https://www.cnblogs.com/jinxiang1224/p/8468339.html">互斥对象创建</a></p><p><a href="https://zditect.com/article/11173924.html">多线程环境</a></p><p>互斥对象是系统内核维护的一种数据结构，<strong>它保证了对象对单个线程的访问权</strong></p><p>互斥对象的结构</p><ol><li>一个使用数量：指有多少个线程在调用该对象</li><li>一个线程ID：指互斥对象维护的线程的ID</li><li>一个计数器：表示当前线程调用该对象多少次</li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line">HANDLE hObject;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">10</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Fun1</span><span class="params">(LPVOID data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">WaitForSingleObject(hObject, INFINITE);</span><br><span class="line"><span class="keyword">if</span> (k-- &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d次调用Thread1\n"</span>,k);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">ReleaseMutex(hObject);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Fun2</span><span class="params">(LPVOID data)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">WaitForSingleObject(hObject, INFINITE);</span><br><span class="line"><span class="keyword">if</span> (k-- &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d次调用Thread2\n"</span>,k);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">ReleaseMutex(hObject);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">::hObject = CreateMutex(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//表示对全局变量进行赋值</span></span><br><span class="line">HANDLE hObject1 = CreateThread(<span class="number">0</span>, <span class="number">0</span>, Fun1, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">HANDLE hObject2 = CreateThread(<span class="number">0</span>, <span class="number">0</span>, Fun2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">CloseHandle(hObject1);</span><br><span class="line">CloseHandle(hObject2);</span><br><span class="line">Sleep(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661685902421.png" alt=""></p><p>可以看到此时已经是两个线程交替执行了，但是谁先执行还是不确定的</p><p>下面对几个关键的函数进行说明</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateMutexx</span><span class="params">(<span class="comment">//用于创建或打开一个已经命名或者匿名的互斥对象</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPSECURITY_ATTRIBUTES lpMutexAttributes,<span class="comment">//一般设置为NULL，表示对互斥对象使用默认的安全性</span></span></span></span><br><span class="line"><span class="params"><span class="function">   BOOL bInitialOwner,<span class="comment">//True表示创建者对象的线程获得该对象的使用权，内部计数器+1，否则该线程不获得互斥对象的所有权</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpName<span class="comment">//如果此参数为NULL，表示创建一个匿名的互斥对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;<span class="comment">//返回互斥对象的句柄</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReleaseMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//当我们对共享资源访问结束后，我们需要释放该对象的所有权，让这个互斥对象处于已通知状态，此时调用ReleaseMutex相当于互斥对象的计数器-1</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//当线程调用该函数，表示当前线程使用完毕该资源，其他线程有机会获得对象的所有权，进而访问共享资源</span></span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hMutex;<span class="comment">//需要释放的互斥对象的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE hHandle,<span class="comment">//所请求互斥对象的句柄，一旦互斥对象处于有信号状态，该函数就返回(表示未被使用中)，如果互斥对象一直处于无状态对象(表示在被其他线程使用)，该线程暂停执行</span></span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD dwMilliseconds<span class="comment">//指定等待的时间间隔，以毫秒为单位，INFINITE表示一直等待直到共享资源处于未被使用状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="双进程保护"><a class="header-anchor" href="#双进程保护">¶</a>双进程保护</h1><blockquote><p><strong>双进程保护：实际上是程序本身作为以恶搞进程或一个调试器，并且在调试模式下运行自身程序</strong></p></blockquote><p>这种程序的技术特点是</p><ol><li>无法被调试，因为程序本身也是一个调试器，我们直到一般情况下一个程序只能被一个调试器所调试，如果他的程序先抢占作为了调试器，那么我们就没办法进行调试，<strong>所以解决办法只能是在他的调试器附加之前你先开始调试</strong></li><li>一般来说，为了防止你抢占调试器，程序中会添加一个异常处理函数，并且在程序中加入使程序异常的代码，然后程序本身作为调试器对异常进行处理，而我们作为调试者，在调试过程中无法处理异常的代码</li></ol><h2 id="创建子进程"><a class="header-anchor" href="#创建子进程">¶</a>创建子进程</h2><p><strong>在Windows和Linux下的函数不一样</strong>，父进程创建的子进程，如果父进程关闭，子进程不一定关闭</p><h3 id="Windows下"><a class="header-anchor" href="#Windows下">¶</a>Windows下</h3><p>直接通过当前文件和CreateProcess即可</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CreateProcess说明</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span></span></span><br><span class="line"><span class="function"><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpApplicationName,<span class="comment">//要创建进程的文件路径,当其为NULL时，可执行模块的名字必须处于lpCommandLine最前面并且由空格符与后面的字符分开</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTSTR lpCommandLine,  <span class="comment">//传入给新进程的命令行字符串 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">//前两个参数可以搭配使用也可以单独使用</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpProcessAttributes,<span class="comment">//决定句柄是否被子进程继承 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">//决定线程是否被继承         </span></span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL bInheritHandles, <span class="comment">//指示新进程是否从调用进程继承了句柄，如果为真，调用进程中的每一个可继承的打开句柄都将被子进程继承</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwCreationFlags, <span class="comment">//指定附加的、用来控制优先类的进程的创建的表示，他有多个值并且对应不同的含义 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpEnvironment,<span class="comment">//指向一个新进程的环境块，如果参数为空，新进程使用调用进程的环境          </span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPCTSTR lpCurrentDirectory,<span class="comment">//指定子进程的工作路径 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTARTUPINFO lpStartupInfo,<span class="comment">//指向一个用于决定新进程主窗体如何实现的STARTINFO结构体，我们只需要给这个结构体的第一个成员(cb)赋值为其结构体大小         </span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPPROCESS_INFORMATION lpProcessInformation<span class="comment">//指向一个用来接收新进程的识别信息的PROCESS_INFORMATION结构体，该结构返回有关新进程及其主线程的信息 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    HANDLE hPRocess;//进程句柄</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    HANDLE hThread;//主线程句柄</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    DWORD dwProcessId;//进程ID</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    DWORD dwThreadId;//线程ID</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    只要创建成功系统就会给这个结构体赋值</span></span></span></span><br><span class="line"><span class="comment"><span class="params"><span class="function">    */</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;  </span><br></pre></td></tr></tbody></table></figure><p>dwCreationFlags对应的参数，<strong>而我们要实现双进程保护需要使用到DEBUG_PROCESS</strong>，这样调用进程将被作为调试器来调试新进程，并且把调试程序的所有调试时间通知给调试器，可以使用<strong>WaitForDebugEvent函数来接收</strong></p><p><a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags">dwCreationFlags常量值</a></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661734802012.png" alt=""></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661689897124.png" alt=""></p><p>dwCreation还可以用来控制新进程的优先类</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661690092331.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">2</span>)<span class="comment">//根据命令行参数的个数来区分主进程和子进程</span></span><br><span class="line">{</span><br><span class="line">__asm <span class="keyword">int</span> <span class="number">3</span>;<span class="comment">//断点</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, (LPCSTR)<span class="string">"这是一个简单的例子"</span>, (LPCSTR)<span class="string">"TraceMe"</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">struct _STARTUPINFOW StartupInfo;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> <span class="title">ProcessInformation</span>;</span></span><br><span class="line">GetStartupInfoW(&amp;StartupInfo);</span><br><span class="line"><span class="comment">//printf("%s\n", argv[0]);</span></span><br><span class="line">TCHAR CommandLine[] = TEXT(<span class="string">"D:\\new\\wmctf2022\\Test_RAAA\\Release\\Test_RAAA.exe DIO"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Father\n"</span>);</span><br><span class="line">BOOL test = CreateProcess(<span class="literal">NULL</span>, CommandLine, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, DEBUG_ONLY_THIS_PROCESS|DEBUG_PROCESS, <span class="number">0</span>, <span class="number">0</span>, &amp;StartupInfo, &amp;ProcessInformation);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, test);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_EVENT</span> <span class="title">DebugEvent</span>;</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">WaitForDebugEvent(&amp;DebugEvent, INFINITE);<span class="comment">//等待调试事件</span></span><br><span class="line"><span class="keyword">if</span> (DebugEvent.dwDebugEventCode == <span class="number">5</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//表示退出调试事件</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (DebugEvent.dwDebugEventCode == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> test[<span class="number">23</span>];</span><br><span class="line">CONTEXT Context;</span><br><span class="line"><span class="comment">//报告异常处理事件</span></span><br><span class="line"><span class="built_in">memcpy</span>(test, &amp;DebugEvent.u, <span class="number">0x54</span>);</span><br><span class="line"><span class="keyword">if</span> (test[<span class="number">0</span>] == EXCEPTION_BREAKPOINT)<span class="comment">//如果触发的是断点异常</span></span><br><span class="line">{</span><br><span class="line">HANDLE hThread=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取触发异常的上下文数据，然后进行修改后赋值回去</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;Context, <span class="number">0</span>, <span class="keyword">sizeof</span>(Context));</span><br><span class="line">Context.ContextFlags = <span class="number">0x10007</span>;</span><br><span class="line">GetThreadContext(hThread, &amp;Context);</span><br><span class="line">Context.Eip += <span class="number">1</span>;<span class="comment">//获取上下文信息之后处理异常</span></span><br><span class="line">SetThreadContext(hThread, &amp;Context);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, <span class="number">0x10002</span>);<span class="comment">//继续执行子进程</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://docs.microsoft.com/zh-cn/windows/win32/debug/getexceptioncode">DebugEvent.Code</a></p><h3 id="Linux下"><a class="header-anchor" href="#Linux下">¶</a>Linux下</h3><p>使用fork函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"创建子进程失败\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"进入子进程,进程ID为%d\n"</span>,getpid());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是父进程，进程ID为%d\n"</span>,getpid());</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661740938764.png" alt=""></p><p>子进程创建之后我们可以使用ptrace进行跟踪，**Ptrace 可以让父进程控制子进程运行，并可以检查和改变子进程的核心image的功能 **</p><p><a href="https://www.jianshu.com/p/b1f9d6911c90">Linux ptrace</a></p><p><a href="https://bbs.pediy.com/thread-265812.htm#:~:text=ptrace%20%28PTRACE_foom%2C%20pid%2C...%29%20%2F%2F%20pid%E4%B8%BAlinux%E4%B8%AD%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BA%BF%E7%A8%8BID%20%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8%20fork%20%28%29,%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%A7%E8%A1%8C%20execve%20%28%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%29%E6%9D%A5%E5%90%AF%E5%8A%A8%E8%B7%9F%E8%B8%AA%E3%80%82%20%E8%BF%9B%E7%A8%8B%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%20PTRACE_ATTACH%20%E6%88%96%20PTRACE_SEIZE%20%E8%BF%9B%E8%A1%8C%E8%B7%9F%E8%B8%AA%E3%80%82">Linux Ptrace</a></p><h3 id="QWB-easyre"><a class="header-anchor" href="#QWB-easyre">¶</a>QWB-easyre</h3><h4 id="考点-v11"><a class="header-anchor" href="#考点-v11">¶</a>考点</h4><p>PTRACE双进程保护、SMC</p><h4 id="题目分析"><a class="header-anchor" href="#题目分析">¶</a>题目分析</h4><p>首先使用Finger恢复符号</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661836456721.png" alt=""></p><blockquote><p>这里ptrace的值原本是0，而ptrace的第一个参数是个共用体，我们可以将鼠标置于第一个参数上，然后按M导入enum，搜索对应的共用体即可</p></blockquote><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661836601857.png" alt=""></p><p>程序首先创建re3文件，将内嵌的ELF文件数据写入文件中，然后fork一个子进程，此时若是父进程fork，会返回子进程的PID，进入if语句，子进程fork返回值为0，进入else语句，接着让生成的子<strong>进程执行PTRACE_TRACEME，然后启动新的程序re3文件，此时re3作为新的进程替换子进程</strong>，（这一过程就相当于Windows中的双击程序之后先创建explorer进程，然后通过explorer进程运行我们想打开的程序，然后explorer进程就相当于结束了，而我们的程序变成了新的进程）那么<strong>re3仍然接受父进程的调试并且继承原来进程的命令行参数</strong></p><p><a href="https://blog.csdn.net/yangbodong22011/article/details/50197785">execve函数</a></p><h5 id="子进程-v2"><a class="header-anchor" href="#子进程-v2">¶</a>子进程</h5><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661836792311.png" alt=""></p><p>首先进行命令行参数判断，<strong>由于使用execve函数创建进程时继承了原本进程的命令行参数，而原本进程是父进程的子进程，继承了父进程的命令行参数</strong>，所以待会调试的时候需要加上命令行参数</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661836944153.png" alt=""></p><p>然后在另一函数处发现了一处SMC，int 3断点会使得子进程通知，并且通知父进程调试，由父进程处理</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661836986652.png" alt=""></p><p>恢复数据之后的就是数织游戏，并且在init处对数据进行了修改，并且使用了setjmp和longjmp代替了循环</p><p><a href="http://www.52cxydh.com/docs/cyuyanjiaocheng/qita/cyuyanzhongde-setjump-he-longjump">setjmp和longjmp</a></p><h5 id="父进程"><a class="header-anchor" href="#父进程">¶</a>父进程</h5><h6 id="第一次循环"><a class="header-anchor" href="#第一次循环">¶</a>第一次循环</h6><p><strong>waitpid函数用于停止父进程，等待子进程执行</strong></p><p>由于原先创建的子进程被替换了，所以信号量会被发送到父进程中，接受到之后使用PTRACE_CONT使子进程继续执行</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661837122485.png" alt=""></p><p>接着通过prop/{pid}/maps获取子进程程序的开始地址，再从内存中read数据，这里的数据很特殊需要注意一下，第一个存储的是长度</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661837960123.png" alt=""></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661838508133.png" alt="从内存中read的数据"></p><p>然后继续waitpid，之后子进程运行到第一处int 3中断，返回父进程处理，首先使用<strong>PTRACE_GETREGS</strong>获取子进程中寄存器的值存储到REG结构体中（这里我没创建结构体(绝对不是因为我们找到REG的结构体成员)，所以看起来很怪，因为看不出来哪里给Rip_addr进行了赋值，但实际上这里就是RIP）</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661838166600.png" alt=""></p><p>紧接着<strong>PTRACE_PEEKTEXT</strong>从目标地址中返回数据，从接受到的数据我们可以知道返回的数据类型为QWORD，而这个数据正好是子进程int 3断点位置处的数据</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661839123742.png" alt="返回的数据"></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661839212443.png" alt="子进程int 3处的数据"></p><p>接下里进入SMC函数，首先获取长度0x27，然后获取异常处地址然后+10处的数据，<strong>read_from_addr函数通过异常处+10位置-程序开始的地址然后从前面读出来的一大串数据进行比对取值</strong>，比如此次相减得到0x2213，也就是8723，那么对应得到820555419</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661839518457.png" alt=""></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661839809183.png" alt=""></p><p>而0x2213正好是int 3断点处+10</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661839855923.png" alt=""></p><p>接着对得到的820555419字符串进行MD5加密，再从后往前开始传递数据，只传递一半，并且将数据改为字符串形式，最后将字符串改为QWORD，<strong>比如820555419MD5之后为357C98DED772654AE188CFC9EA1C2723，从后往前每两个一组转为字符串，得到23271CEAC9CF88E1，最后转为QWORD:0x23271CEAC9CF88E1h</strong>，然后和原来地址处的值异或</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661840207721.png" alt=""></p><p>最后<strong>PTRACE_POKETEXT</strong>将数据写回去</p><p>for循环直到所有地址处的数据都进行SMC解密</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661840362045.png" alt=""></p><p>结束SMC之后修改RIP，然后将新的REG结构体写入子进程中，并且调用<strong>PTRACE_CONT</strong>从新的地址处开始执行</p><h6 id="第二次循环"><a class="header-anchor" href="#第二次循环">¶</a>第二次循环</h6><p>程序继续wait，等到程序运行到第二个int 3处，此时该地址的QWORD的值正好为0xCAFE1055BFCCLL</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661840698699.png" alt=""></p><p>进入else中</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661840797460.png" alt=""></p><p>此时就是对原来SMC的数据进行重新加密并放入子进程中</p><h6 id="第三次循环"><a class="header-anchor" href="#第三次循环">¶</a>第三次循环</h6><p>最后waitpid等待子进程结束，返回信号，最后remove掉re3文件，父进程退出</p><h4 id="恢复SMC的数据"><a class="header-anchor" href="#恢复SMC的数据">¶</a>恢复SMC的数据</h4><h5 id="编写脚本恢复"><a class="header-anchor" href="#编写脚本恢复">¶</a>编写脚本恢复</h5><p>首先我们先<strong>使用条件断点</strong>获取到最终异或的值，然后编写idapython脚本恢复数据并且nop掉一些没用的数据</p><p>Edit BreakPoint-&gt;“…”-&gt;编写脚本打印RAX寄存器的值</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661841489175.png" alt=""></p><p>得到</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x23271ceac9cf88e1</span>,<span class="number">0x4d9403a34275494c</span>,<span class="number">0xf1ac2fea63c94ea9</span>,<span class="number">0xf32554baaf233dcc</span>,<span class="number">0xad5ea15de7bcf568</span>,<span class="number">0xabdfc454b2ec9fd0</span>,<span class="number">0xa5ee2b4680957b2b</span>,<span class="number">0xaf42f81128b7fb38</span>,<span class="number">0xca34bde4268cae3</span>,<span class="number">0x4ee274bc39f2d547</span>,<span class="number">0x53458e3ea10ab93b</span>,<span class="number">0x2e5fb32efac34cff</span>,<span class="number">0x99f8f6faa7a64aec</span>,<span class="number">0xef38004300eda44d</span>,<span class="number">0xee67c44e2bcd18fc</span>,<span class="number">0x9b1c209768ecb41e</span>,<span class="number">0xfae74344fcba3cdb</span>,<span class="number">0x62654e739151118d</span>,<span class="number">0xbfa53d12825ac60</span>,<span class="number">0x5fda7e9212d8d034</span>,<span class="number">0xe8e15b2ffd058214</span>,<span class="number">0x6258db99ec82ff1f</span>,<span class="number">0xc1f8d40001b68bf6</span>,<span class="number">0x6211d421f8ab1d50</span>,<span class="number">0xd25bc129ebbbd366</span>,<span class="number">0xaea9e2a30d3fcd24</span>,<span class="number">0x12e2013bc48da1de</span>,<span class="number">0x1db06bde7ca30286</span>,<span class="number">0x226499b91812859b</span>,<span class="number">0xb2b0d80d0f244ce4</span>,<span class="number">0xfba26ec5f66ad4a5</span>,<span class="number">0xef4975489b39baa5</span>,<span class="number">0x75da0adeb0d03511</span>,<span class="number">0xcbb9c9ef1c68088d</span>,<span class="number">0xb707f2ec82b077b8</span>,<span class="number">0x4989b97aadc513bb</span>,<span class="number">0x74c613b6d47fcde</span>,<span class="number">0x1d6396837a7ad9d8</span>,<span class="number">0x7f1a74782535fe54</span></span><br></pre></td></tr></tbody></table></figure><p>然后写脚本将对应位置处的值异或上即可</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xor_data = {<span class="number">8723</span>: <span class="number">2533025110152939745</span>, <span class="number">8739</span>: <span class="number">5590097037203163468</span>, <span class="number">8755</span>: <span class="number">17414346542877855401</span>, <span class="number">8771</span>: <span class="number">17520503086133755340</span>, <span class="number">8787</span>: <span class="number">12492599841064285544</span>, <span class="number">8803</span>: <span class="number">12384833368350302160</span>, <span class="number">8819</span>: <span class="number">11956541642520230699</span>, <span class="number">8835</span>: <span class="number">12628929057681570616</span>, <span class="number">8851</span>: <span class="number">910654967627959011</span>, <span class="number">8867</span>: <span class="number">5684234031469876551</span>, <span class="number">8883</span>: <span class="number">6000358478182005051</span>, <span class="number">8899</span>: <span class="number">3341586462889168127</span>, <span class="number">8915</span>: <span class="number">11094889238442167020</span>, <span class="number">8931</span>: <span class="number">17237527861538956365</span>, <span class="number">8947</span>: <span class="number">17178915143649401084</span>, <span class="number">8963</span>: <span class="number">11176844209899222046</span>, <span class="number">8979</span>: <span class="number">18079493192679046363</span>, <span class="number">8995</span>: <span class="number">7090159446630928781</span>, <span class="number">9011</span>: <span class="number">863094436381699168</span>, <span class="number">9027</span>: <span class="number">6906972144372600884</span>, <span class="number">9043</span>: <span class="number">16780793948225765908</span>, <span class="number">9059</span>: <span class="number">7086655467811962655</span>, <span class="number">9075</span>: <span class="number">13977154540038163446</span>, <span class="number">9091</span>: <span class="number">7066662532691991888</span>, <span class="number">9107</span>: <span class="number">15157921356638311270</span>, <span class="number">9123</span>: <span class="number">12585839823593393444</span>, <span class="number">9139</span>: <span class="number">1360651393631625694</span>, <span class="number">9155</span>: <span class="number">2139328426318955142</span>, <span class="number">9171</span>: <span class="number">2478274715212481947</span>, <span class="number">9187</span>: <span class="number">12876028885252459748</span>, <span class="number">9203</span>: <span class="number">18132176846268847269</span>, <span class="number">9219</span>: <span class="number">17242441603067001509</span>, <span class="number">9235</span>: <span class="number">8492111998925944081</span>, <span class="number">9251</span>: <span class="number">14679986489201789069</span>, <span class="number">9267</span>: <span class="number">13188777131396593592</span>, <span class="number">9283</span>: <span class="number">5298970373130621883</span>, <span class="number">9299</span>: <span class="number">525902164359904478</span>, <span class="number">9315</span>: <span class="number">2117701741234018776</span>, <span class="number">9331</span>: <span class="number">9158760851580517972</span>}</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x2213</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = get_qword(addr)</span><br><span class="line">    key = xor_data[addr]</span><br><span class="line">    dec = data ^ key</span><br><span class="line">    idc.patch_qword(addr, dec)</span><br><span class="line">    addr += <span class="number">16</span></span><br></pre></td></tr></tbody></table></figure><h5 id="让父进程先结束，而子进程处于运行状态，attach到ida上"><a class="header-anchor" href="#让父进程先结束，而子进程处于运行状态，attach到ida上">¶</a>让父进程先结束，而子进程处于运行状态，attach到ida上</h5><p>需要先对程序patch，首先为了让子进程不结束，我们需要使子进程进入死循环，即原地TP，接着就是不让父进程对子进程解密后的结果加密，也就是修改为XOR 0，最后要让父进程提前结束而不是父进程等待子进程结束之后再结束，需要修改for循环次数为2次，此时所有的patch都已经执行完毕</p><p><a href="http://1.12.239.117:8090/archives/qwb2022-easyre">FallW1nd的神之一手</a></p><h5 id="动调dump法"><a class="header-anchor" href="#动调dump法">¶</a>动调dump法</h5><p><a href="https://www.bilibili.com/video/BV1ug411y77V?spm_id_from=333.337.search-card.all.click">Itlly师傅的动调dump大法</a></p><h1 id="exe文件添加和加载资源文件"><a class="header-anchor" href="#exe文件添加和加载资源文件">¶</a>exe文件添加和加载资源文件</h1><h2 id="添加资源文件"><a class="header-anchor" href="#添加资源文件">¶</a>添加资源文件</h2><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661435725924.png" alt=""></p><p>然后导入文件即可</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661435753854.png" alt=""></p><p><strong>然后为资源类型命名</strong></p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661435800476.png" alt="1661435800476"></p><p>效果如下</p><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661435817631.png" alt=""></p><h2 id="加载资源文件"><a class="header-anchor" href="#加载资源文件">¶</a>加载资源文件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HRSRC test = FindResourceA(<span class="number">0</span>,(LPCSTR)<span class="number">101</span>, <span class="string">"EXEC"</span>);<span class="comment">//第二个参数是名称，第三个参数是类型</span></span><br><span class="line">DWORD Size = SizeofResource(<span class="number">0</span>, test);</span><br><span class="line">HGLOBAL hResData = LoadResource(<span class="number">0</span>, test);<span class="comment">//返回资源的句柄</span></span><br><span class="line">LPCVOID lpBuffer = LockResource(hResData);<span class="comment">//返回资源的第一个字节的地址</span></span><br><span class="line">HANDLE hFile = CreateFileA(<span class="string">"tmp.exe"</span>, <span class="number">0xC0000000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0x80</span>, <span class="number">0</span>);<span class="comment">//创建文件句柄</span></span><br><span class="line">DWORD NumberofByteWritten = <span class="number">0</span>;</span><br><span class="line">BOOL <span class="keyword">final</span> = WriteFile(hFile, lpBuffer, Size, &amp;NumberofByteWritten, <span class="number">0</span>);<span class="comment">//写入文件</span></span><br><span class="line">FlushFileBuffers(hFile);</span><br><span class="line">CloseHandle(hFile);</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/08/25/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/1661474185837.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;进程与线程的通信&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法刷题</title>
    <link href="https://gift1a.github.io/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"/>
    <id>https://gift1a.github.io/2022/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/</id>
    <published>2022-07-13T12:14:02.000Z</published>
    <updated>2022-07-13T12:14:02.172Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA学习</title>
    <link href="https://gift1a.github.io/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-07-09T15:27:26.000Z</published>
    <updated>2022-08-20T19:06:42.970Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA</p><span id="more"></span> <h1 id="IDE"><a class="header-anchor" href="#IDE">¶</a>IDE</h1><p>对于IntelliJ IDEA，首先需要创建项目，然后添加包，最后创建类，然后开始写函数</p><h2 id="IDEA快捷键"><a class="header-anchor" href="#IDEA快捷键">¶</a>IDEA快捷键</h2><ul><li>ALT+D删除所在行</li><li>ALT+Enter自动添加包</li><li>ctrl+alt+L快速格式化代码</li><li>ctrl+alt+向下箭头快速复制粘贴当前行</li><li>shift+F10快速運行程序</li><li>alt+insert 快速生成构造器</li><li>ctrl+H查看类的继承关系</li><li>将光标放在一个方法后，Ctrl+B可以定位到定义方法处</li><li>在最后添加.var可以快速分配变量名new Scanner(<a href="http://System.in">System.in</a>).var然后回车可以自动添加变量名</li></ul><h2 id="IDEA自定义模板"><a class="header-anchor" href="#IDEA自定义模板">¶</a>IDEA自定义模板</h2><p>在file-&gt;settings-&gt;editor-&gt;Live template可以查看和增加模板</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660925052869.png" alt=""></p><p>在java模板中，输入main之后回车就会自动补全，<strong>sout是输出的模板，fori是for循环的模板</strong></p><p>自己也可以添加模板</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660925188848.png" alt=""></p><p>记得添加应用场景，我们这里设置为JAVA</p><h1 id="JAVA概述"><a class="header-anchor" href="#JAVA概述">¶</a>JAVA概述</h1><h2 id="JAVA-白皮书-的关键术语"><a class="header-anchor" href="#JAVA-白皮书-的关键术语">¶</a>JAVA"白皮书"的关键术语</h2><ul><li>简单性</li><li>面向对象，也就是重点在于数据即对象和对象的接口上</li><li>分布式：JAVA有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议</li><li>健壮性：JAVA采用的指针模型可以消除重写内存和损坏数据可能性</li><li>安全性</li><li>体系结构中立：编译过的代码可以很容易在任何机器上运行</li><li>可移植性：JAVA的数据类型具有固定的大小，二进制数据以固定的格式进行存储和传输，字符串是用标准的Unicode格式存储的</li><li>解释型：JAVA解释器可以在任何移植了解释器的机器上执行JAVA字节码</li><li>高性能：字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定CPU的机器码</li><li>多线程：多线程可以带来更好的交互响应和实时行为</li><li>动态性：JAVA可以适应不断发展的环境</li></ul><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1659890869055.png" alt=""></p><p>Java运行机制及运行过程</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1659891609491.png" alt=""></p><p>JRE和JDK</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1659892029919.png" alt=""></p><h1 id="JAVA的基本程序设计结构"><a class="header-anchor" href="#JAVA的基本程序设计结构">¶</a>JAVA的基本程序设计结构</h1><h2 id="一个简单的JAVA应用程序"><a class="header-anchor" href="#一个简单的JAVA应用程序">¶</a>一个简单的JAVA应用程序</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Helloworld!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实class关键字表示类，class后跟类名（必须以字母开头，后面可以是字母和数字的任意组合，但不能是关键字），表明JAVA程序中的全部内容都包含在类中，public表示是公共的，用于控制程序的其他部分对这段代码的访问级别，<strong>main方法必须声明为public</strong></p><p><strong>源代码的文件名必须与公共类的名字相同，并用.java作为扩展名</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657765232969.png" alt=""></p><blockquote><p>与C<ins>中不同的是，<strong>Java中的所有函数都属于某个类的方法</strong>，而在C</ins>中被叫做成员函数</p></blockquote><p>System.out.println(“Helloworld!”)这一句使用了System.out对象并调用了它的println方法，相当于函数调用</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660923438800.png" alt=""></p><h2 id="使用命令行编译和运行java文件"><a class="header-anchor" href="#使用命令行编译和运行java文件">¶</a>使用命令行编译和运行java文件</h2><p>当我们编写好.java文件（源文件）之后，使用javac test.java命令编译为test.class文件（字节码文件），然后通过java test运行。<strong>有了java源文件，通过编译器将其编译成JVM可以识别的字节码文件，在该源文件目录下，通过javac编译工具对java文件进行编译。而运行就是将字节码文件装载到jvm执行</strong></p><blockquote><p>这里使用java test运行是因为java表示运行一个java的类，也就是类似自动补充为test.class</p></blockquote><p><strong>还需要注意一点：由于命令行默认为GBK编码，所以我们需要将java文件改为GBK编码格式</strong></p><h2 id="java开发注意事项"><a class="header-anchor" href="#java开发注意事项">¶</a>java开发注意事项</h2><ul><li><p>Java应用程序的执行入口是main()方法，其格式如下：public static main(String[] args){……}</p></li><li><p>一个源文件最多只能有一个public类，其他类的个数不限，<strong>编译后每一个类都会生成一个class文件</strong></p></li><li><p>如果源文件包含一个public类，<strong>则其文件名必须按该类名命名</strong></p></li><li><p>一个源文件最多只能有一个public类，其他类的个数不限，也可以将main方法写入非public类中，然后指定运行非public类，这样入口方法就是非public类的main方法</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"helloworld!"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"hello,Dog!"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tiger</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"hello,Tiger!"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1659895220537.png" alt=""></p><h2 id="文档注释"><a class="header-anchor" href="#文档注释">¶</a>文档注释</h2><p>对于不同的需求，文档注释也可以选择不同的符号</p><p><a href="https://www.runoob.com/java/java-documentation.html">Java文档注释</a></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1659937244048.png" alt=""></p><h2 id="数据类型"><a class="header-anchor" href="#数据类型">¶</a>数据类型</h2><p>在Java中，一共有8种基本类型，其中4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型</p><h3 id="整型"><a class="header-anchor" href="#整型">¶</a>整型</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657765879366.png" alt="整型"></p><p><strong>加上前缀0b或者0B就可以写二进制数</strong>，如0b1001就是9</p><p><strong>还可以为数字字面量加下划线</strong>，如1_000_000表示一百万，Java编译器会去除这些下划线</p><p><strong>对于long类型的数据，需要在结尾加’L’或者’l’</strong>，如果将long类型的值赋值给int型变量，可能会有损失，需要使用强制转换</p><h3 id="浮点类型-v2"><a class="header-anchor" href="#浮点类型-v2">¶</a>浮点类型</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657766088689.png" alt="浮点类型"></p><p>float类型的数值有一个后缀F或者f（例如3.14F），没有后缀F的浮点数值默认为Double类型，也可以在浮点数值后添加后缀D或d</p><p>浮点数在机器中存放形式：浮点数=符号位+指数位+尾数位，尾数可能会有损失，造成精度丢失</p><blockquote><p>对于小数点前，如果都是0，可以省略，也就是说0.123可以省略为.123</p><p>科学计数法：5.12e2就是5.12×10^2</p></blockquote><p>打印的结果如下，这里会默认为double类型数据，所以会在小数点后添加0</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660534153788.png" alt=""></p><p><strong>通常情况下我们使用double，因为其精度更高</strong></p><p><strong>由于是近似计算，所以对于运算结果是小数进行相等判断时，需要小心，应该是以两个数的差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="comment">// float num1 = 1.1F;</span></span><br><span class="line"><span class="comment">// double num2 = .123;</span></span><br><span class="line"><span class="comment">//System.out.println(num2);</span></span><br><span class="line"><span class="comment">// System.out.println(5.12e2);</span></span><br><span class="line"><span class="comment">// System.out.println(5.12e-2);</span></span><br><span class="line"><span class="keyword">double</span> num1 = <span class="number">2.7</span>;</span><br><span class="line"><span class="keyword">double</span> num2 = <span class="number">8.1</span> / <span class="number">3</span>;</span><br><span class="line">System.out.println(num1);</span><br><span class="line">System.out.println(num2);</span><br><span class="line"><span class="keyword">if</span>(num1 == num2){</span><br><span class="line">System.out.println(<span class="string">"相等"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(Math.abs(num1 - num2) &lt; <span class="number">0.01</span>){</span><br><span class="line">System.out.println(<span class="string">"差值接近，近似相等"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660535049772.png" alt=""></p><h3 id="Java-API文档"><a class="header-anchor" href="#Java-API文档">¶</a>Java API文档</h3><p><a href="https://www.matools.com/api/java8">Java8 API 中文版</a></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660535508852.png" alt="java类的组织形式"></p><h3 id="char类型"><a class="header-anchor" href="#char类型">¶</a>char类型</h3><p>char类型的值可以表示为十六进制值，其范围从\u0000到\uffff</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657766303117.png" alt="转义符"></p><h3 id="Unicode和char类型"><a class="header-anchor" href="#Unicode和char类型">¶</a>Unicode和char类型</h3><p>由于不同地区的编码机制不同，所以需要做出统一，这也促进了Unicode的出现，<strong>Unicode使用后两个字节来表示字符</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660543321689.png" alt="字符编码表"></p><h3 id="boolean类型"><a class="header-anchor" href="#boolean类型">¶</a>boolean类型</h3><p>boolean类型有两个值：false和true</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657766858388.png" alt="c++和Java种boolean的区别"></p><h3 id="变量"><a class="header-anchor" href="#变量">¶</a>变量</h3><p>Java中每个变量都需要一个类型</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657767021797.png" alt=""></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657767051594.png" alt="声明变量的提示"></p><p>变量的初始化和C++类似，就不赘述了</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657767111757.png" alt=""></p><h3 id="常量-v2"><a class="header-anchor" href="#常量-v2">¶</a>常量</h3><p>在Java中，利用关键字final指示常量（表示这个变量只能被赋值一次，被赋值之后就不能再改了）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI=<span class="number">3.14</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>在Java中，经常希望某个常量可以在一个类中的多个方法中被使用，通常将这些常量称为<strong>类常量</strong></p></blockquote><p><strong>可以使用关键字static final设置一个类常量</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657767561643.png" alt="类常量设置"></p><p><strong>此处使用public static final关键字来声明，那么在其他类的方法也可以使用</strong></p><h3 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h3><p>加减乘除和C++一样</p><p>但是对于浮点数的精度问题是我们需要解决的，因为不同位数机器计算得到的精度是不同的，所以<strong>对于使用strictfp关键字标记的方法必须使用严格的浮点计算来生成可再生的结果</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657768813515.png" alt=""></p><h3 id="数学函数与常量"><a class="header-anchor" href="#数学函数与常量">¶</a>数学函数与常量</h3><p>在Math类中，包含了各种各样的数学寒湖是</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657769131596.png" alt=""></p><p>导入Math包就不要在数学方法名和常量名前添加前缀"Math"</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657769148706.png" alt=""></p><h3 id="数值类型之间的转换"><a class="header-anchor" href="#数值类型之间的转换">¶</a>数值类型之间的转换</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657769438403.png" alt=""></p><p><strong>精度小的类型自动转换为精度大的数据类型</strong>，这个就是自动类型转换</p><blockquote><p>byte、char、short之间可以进行运算，<strong>在计算时首先转换为int类型</strong>。不同类型数据进行运算时会转为精度最高的类型</p></blockquote><h3 id="强制类型转换"><a class="header-anchor" href="#强制类型转换">¶</a>强制类型转换</h3><p>和C++一样，<strong>可能造成精度降低或溢出</strong>，但是如果想对浮点数进行舍入操作以便得到最接近的整数，可以使用Math.round方法</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657769812482.png" alt="boolean的强制转换"></p><p><strong>char类型可以保存int的常量值，但不能保存int的变量值</strong></p><h3 id="基本数据类型和String类型的转换"><a class="header-anchor" href="#基本数据类型和String类型的转换">¶</a>基本数据类型和String类型的转换</h3><h4 id="基本数据类型转String类型"><a class="header-anchor" href="#基本数据类型转String类型">¶</a>基本数据类型转String类型</h4><p><strong>将基本数据类型的值+""即可</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stringtobasic</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n1=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">float</span> f1=<span class="number">1.1F</span>;</span><br><span class="line"><span class="keyword">double</span> d1=<span class="number">4.5</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1=<span class="keyword">true</span>;</span><br><span class="line">String s1=n1+<span class="string">""</span>;</span><br><span class="line">String s2=f1+<span class="string">""</span>;</span><br><span class="line">String s3=d1+<span class="string">""</span>;</span><br><span class="line">String s4=b1+<span class="string">""</span>;</span><br><span class="line">System.out.println(s1+<span class="string">" "</span>+s2+<span class="string">" "</span>+s3+<span class="string">" "</span>+s4+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="String类型转基本数据类型"><a class="header-anchor" href="#String类型转基本数据类型">¶</a>String类型转基本数据类型</h4><p><strong>使用基本数据类型对应的包装类的相应方法，得到基本数据类型</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">stringtobasic</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">String s5 = <span class="string">"1213"</span>;</span><br><span class="line"><span class="keyword">int</span> num1=Integer.parseInt(s5);</span><br><span class="line"><span class="keyword">double</span> num2=Double.parseDouble(s5);</span><br><span class="line">System.out.println(num1);</span><br><span class="line">System.out.println(num2);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660547059010.png" alt=""></p><p>但是对于char类型，无法转换，只能取出字符串对应位置的字符，下面代码就是取出字符串中下标为0的字符</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s5.charAt(<span class="number">0</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="需要注意的事项"><a class="header-anchor" href="#需要注意的事项">¶</a>需要注意的事项</h4><p>但是当字符串由字符组成时，对其进行转换就会报错</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660547592647.png" alt=""></p><h3 id="结合赋值和运算符"><a class="header-anchor" href="#结合赋值和运算符">¶</a>结合赋值和运算符</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657769875353.png" alt=""></p><h3 id="自增与自减运算符"><a class="header-anchor" href="#自增与自减运算符">¶</a>自增与自减运算符</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657769965388.png" alt=""></p><h3 id="关系和boolean运算符"><a class="header-anchor" href="#关系和boolean运算符">¶</a>关系和boolean运算符</h3><p>关系运算符和C++相同，同时Java也支持三元运算符</p><h3 id="位运算符"><a class="header-anchor" href="#位运算符">¶</a>位运算符</h3><p><strong>对于短路&amp;&amp;，第一个条件为假则不往后判断，而逻辑与&amp;，即使第一个条件为假，第二个条件也会判断</strong></p><p>除了按位与、或、非，左移右移，Java还有</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657770108927.png" alt=""></p><h3 id="括号与运算符级别"><a class="header-anchor" href="#括号与运算符级别">¶</a>括号与运算符级别</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657770134712.png" alt="运算符有级别表"></p><h3 id="枚举类型"><a class="header-anchor" href="#枚举类型">¶</a>枚举类型</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1657770292288.png" alt=""></p><h3 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h3><p>Java字符串就是Unicode字符序列，在标准Java类库中提供了一个预定义类，很自然地叫做String，每个用双引号括起来地字符串都是String类的一个实例</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1658585139994.png" alt=""></p><h4 id="子串"><a class="header-anchor" href="#子串">¶</a>子串</h4><p>String类中的substring方法可以从一个较大的字符串中提取处一个子串</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String greeting=<span class="string">"hello"</span>;</span><br><span class="line">String s=greeting.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><p>表示截取greeting对象的前三个字符存储到s中</p><h4 id="拼接"><a class="header-anchor" href="#拼接">¶</a>拼接</h4><p>Java语言运行使用+号拼接两个字符串</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a=<span class="string">"abcdefg"</span>;</span><br><span class="line">String b=<span class="string">"hijklmn"</span>;</span><br><span class="line">string c=a+b; </span><br></pre></td></tr></tbody></table></figure><p>上述代码将"abcdefghijklmn"赋值给c。</p><p><strong>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1658585964121.png" alt="例子"></p><p>这种特性通常用在输出语句中，比如</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"The answer is "</span>+answer);</span><br></pre></td></tr></tbody></table></figure><p><strong>如果需要把多个字符串放在一起，用一个定界符分割，可以使用静态join方法</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1658586146230.png" alt=""></p><h4 id="字符串比较"><a class="header-anchor" href="#字符串比较">¶</a>字符串比较</h4><p><strong>使用equals方法进行字符串比较</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">whiletest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String name = <span class="string">""</span>;</span><br><span class="line">String passwd = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> chance = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>;++i){</span><br><span class="line">System.out.println(<span class="string">"请输入您的用户名："</span>);</span><br><span class="line">name = myScanner.next();</span><br><span class="line">System.out.println(<span class="string">"请输入您的密码："</span>);</span><br><span class="line">passwd = myScanner.next();</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"丁真"</span>.equals(name) &amp;&amp; <span class="string">"666"</span>.equals(passwd)){</span><br><span class="line">System.out.println(<span class="string">"登陆成功"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">chance--;</span><br><span class="line">System.out.println(<span class="string">"你还有"</span>+chance+<span class="string">"次登陆机会"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="键盘输入语句"><a class="header-anchor" href="#键盘输入语句">¶</a>键盘输入语句</h2><p>首先导入包中的类，然后创建一个对象，接着接收用户输入——不同的数据类型对应了不同的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//表示把java.util包中的Scanner类导入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">inputtest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="comment">//new创建一个对象，创建Scanner对象</span></span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//接收用户输入，使用相关的方法</span></span><br><span class="line">System.out.println(<span class="string">"请输入你的名字："</span>);</span><br><span class="line">String name = myScanner.next();<span class="comment">//接收用户输入</span></span><br><span class="line">System.out.println(<span class="string">"请输入你的年龄："</span>);</span><br><span class="line"><span class="keyword">int</span> age=myScanner.nextInt();<span class="comment">//接收用户输入，类型为int</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="程序控制结构"><a class="header-anchor" href="#程序控制结构">¶</a>程序控制结构</h2><h3 id="分支控制——单分支、双分支、多分支"><a class="header-anchor" href="#分支控制——单分支、双分支、多分支">¶</a>分支控制——单分支、双分支、多分支</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">controltest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"请输入年龄："</span>);</span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> age = myScanner.nextInt();</span><br><span class="line"><span class="keyword">if</span>(age &gt; <span class="number">18</span>){</span><br><span class="line">System.out.println(<span class="string">"您的年龄大于18"</span>);</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span>(age == <span class="number">18</span>) {</span><br><span class="line">System.out.println(<span class="string">"您的年龄等于18"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.println(<span class="string">"您的年龄小于18"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>在分支中还可以嵌套分支结构</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">controltest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入成绩："</span>);</span><br><span class="line"><span class="keyword">double</span> score = myScanner.nextDouble();</span><br><span class="line"><span class="keyword">if</span>( score &gt; <span class="number">8.0</span> ){</span><br><span class="line">System.out.println(<span class="string">"请输入性别："</span>);</span><br><span class="line"><span class="keyword">char</span> gender = myScanner.next().charAt(<span class="number">0</span>);<span class="comment">//由于接收的是字符串，需要转为字符</span></span><br><span class="line"><span class="keyword">if</span>( gender == <span class="string">'男'</span>){</span><br><span class="line">System.out.println(<span class="string">"你是男的"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.println(<span class="string">"你是女的"</span>);</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.println(<span class="string">"您出局了"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="switch分支结构"><a class="header-anchor" href="#switch分支结构">¶</a>switch分支结构</h4><p>每个case中的类型应该一致，也需要和switch中的类型(只能是byte,short,int,char,String,enum)一致</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660570025649.png" alt="switch流程图"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchtest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入a-g中的字符"</span>);</span><br><span class="line"><span class="keyword">char</span> input = myScanner.next().charAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">switch</span>(input){</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期一"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期二"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期三"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期四"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期五"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期六"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">System.out.println(<span class="string">"星期天"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"输入错误"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="循环分支结构"><a class="header-anchor" href="#循环分支结构">¶</a>循环分支结构</h3><h4 id="for循环"><a class="header-anchor" href="#for循环">¶</a>for循环</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">fortest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i){</span><br><span class="line">System.out.println(<span class="string">"helloworld"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="while循环"><a class="header-anchor" href="#while循环">¶</a>while循环</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">whiletest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(n&lt;<span class="number">10</span>){</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">n++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="do……while循环"><a class="header-anchor" href="#do……while循环">¶</a>do……while循环</h4><p>也是和C一样的</p><h4 id="打印空心金字塔"><a class="header-anchor" href="#打印空心金字塔">¶</a>打印空心金字塔</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">whiletest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>-i;++k){</span><br><span class="line">System.out.print(<span class="string">' '</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*i+<span class="number">1</span>;++j){</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||j==<span class="number">2</span>*i||i==<span class="number">4</span>){</span><br><span class="line">System.out.print(<span class="string">"*"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.print(<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">System.out.println();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组、排序和查找"><a class="header-anchor" href="#数组、排序和查找">¶</a>数组、排序和查找</h2><h3 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h3><p>数组创建后，如果没有赋值，有默认值</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660634477557.png" alt=""></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arraytest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];<span class="comment">//声明数组并开辟空间，也可以先声明再开辟空间，这是动态初始化</span></span><br><span class="line">        <span class="keyword">int</span> b[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};<span class="comment">//这是静态初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;++i){</span><br><span class="line">System.out.println(a[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>数组扩容</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arraytest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">Scanner myScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">System.out.println(<span class="string">"您是否需要继续添加元素(Y/N)"</span>);</span><br><span class="line"><span class="keyword">char</span> a = myScanner.next().charAt(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>( a == <span class="string">'Y'</span> || a == <span class="string">'y'</span>){</span><br><span class="line">System.out.println(<span class="string">"请输入你想添加的元素"</span>);</span><br><span class="line"><span class="keyword">int</span> add = myScanner.nextInt();</span><br><span class="line"><span class="keyword">int</span> arrNew[]= <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++){</span><br><span class="line">arrNew[i] = arr[i];</span><br><span class="line">}</span><br><span class="line">arrNew[arrNew.length-<span class="number">1</span>] = add;</span><br><span class="line">arr = arrNew;</span><br><span class="line">System.out.println(<span class="string">"添加元素后的数组为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i){</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">System.out.println(<span class="string">"退出成功"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>二维数组的静态初始化，和C不同的是需要加{}来限制为一维数组，否则会报错</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arraytest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> arr[][] = {</span><br><span class="line">{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>},</span><br><span class="line">{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>},</span><br><span class="line">{<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>},</span><br><span class="line">{<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;++j){</span><br><span class="line">System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println(<span class="string">""</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>二维数组的动态初始化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arraytest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];<span class="comment">//创建二维数组，但是只确定一维数组的个数，但是每个一维数组还没开辟空间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i){</span><br><span class="line">arr[i]=<span class="keyword">new</span> <span class="keyword">int</span>[i+<span class="number">1</span>];<span class="comment">//给每个一维数组开辟空间</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;++j){</span><br><span class="line">arr[i][j]=i+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;++j){</span><br><span class="line">System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>杨辉三角</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">arraytest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"><span class="keyword">int</span> arr[][]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][];<span class="comment">//创建二维数组，但是只确定一维数组的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i){</span><br><span class="line">arr[i]=<span class="keyword">new</span> <span class="keyword">int</span>[i+<span class="number">1</span>];<span class="comment">//给每个一维数组开辟空间</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;++j){</span><br><span class="line"><span class="keyword">if</span>(j==<span class="number">0</span>||j==i){</span><br><span class="line">arr[i][j]=<span class="number">1</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">arr[i][j] = arr[i-<span class="number">1</span>][j]+arr[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line">System.out.print(arr[i][j]+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h4><p>冒泡排序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorttest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-i-<span class="number">1</span>; j++){</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]){</span><br><span class="line"><span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++){</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="查找"><a class="header-anchor" href="#查找">¶</a>查找</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Insert</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> arr[] = {<span class="number">10</span>,<span class="number">12</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">90</span>};</span><br><span class="line"><span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i){</span><br><span class="line"><span class="keyword">if</span>(arr[i]==<span class="number">30</span>){</span><br><span class="line">index=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(index==-<span class="number">1</span>){</span><br><span class="line">System.out.println(<span class="string">"未找到"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.println(<span class="string">"其所在下标为"</span>+index);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="面向对象编程"><a class="header-anchor" href="#面向对象编程">¶</a>面向对象编程</h1><h2 id="类与对象"><a class="header-anchor" href="#类与对象">¶</a>类与对象</h2><p>引入类与对象的原因是同一个对象可能有多种属性和行为，<strong>类就是数据类型（我们自己定义的），而对象就是一个具体的实例</strong></p><ol><li>类是抽象的，概念的。代表一类事物</li><li>对象是具体的，实际的，代表一个具体事物，即实例</li><li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Object01</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//创建一个猫对象，然后赋值给cat1</span></span><br><span class="line">Cat cat1 = <span class="keyword">new</span> Cat();<span class="comment">//直接创建对象，也可以先声明对象再创建</span></span><br><span class="line">cat1.name =<span class="string">"小白"</span>;</span><br><span class="line">cat1.age = <span class="number">3</span>;</span><br><span class="line">cat1.color=<span class="string">"白色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第二只猫，new是在堆中开辟空间，而new的返回值是开辟空间的地址，也就是对象，而cat2是对象名</span></span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat();</span><br><span class="line">cat2.name =<span class="string">"小花"</span>;</span><br><span class="line">cat2.age = <span class="number">10</span>;</span><br><span class="line">cat2.color=<span class="string">"花色"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问对象属性</span></span><br><span class="line">System.out.println(<span class="string">"第一只猫的信息"</span>+<span class="string">" "</span>+cat1.name+<span class="string">" "</span>+cat1.age+<span class="string">" "</span>+cat1.color);</span><br><span class="line">System.out.println(<span class="string">"第二只猫的信息"</span>+<span class="string">" "</span>+cat2.name+<span class="string">" "</span>+cat2.age+<span class="string">" "</span>+cat2.color);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用面向对象的方式来解决养猫问题</span></span><br><span class="line"><span class="comment">//定义一个猫类Cat</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>{</span><br><span class="line"><span class="comment">//Cat类的属性</span></span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String color;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="对象在内存中的存储"><a class="header-anchor" href="#对象在内存中的存储">¶</a>对象在内存中的存储</h3><p>在执行创建类过程中，会加载类的属性信息和方法信息。对于属性信息，根据类型不一样分配不同的空间，字符串存储指向常量池的地址，基本数据类型则直接存储</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660672515191.png" alt=""></p><h3 id="属性和细节"><a class="header-anchor" href="#属性和细节">¶</a>属性和细节</h3><p><strong>属性也可以称为成员变量或者filed(字段)</strong>，属性可以是对象也可以是基本数据类型</p><p>属性的定义语法同变量，示例：访问修饰符(public/private/protected/默认)-用于控制属性的访问范围，属性类型，属性名</p><h3 id="类与对象的内存分配机制"><a class="header-anchor" href="#类与对象的内存分配机制">¶</a>类与对象的内存分配机制</h3><p>new是在堆中开辟空间，而new的返回值是开辟空间的地址，也就是对象，而cat2是对象名，所以我们可以直接将cat2赋值给新的对象名(相当于地址拷贝)，如</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat3 = cat2; </span><br></pre></td></tr></tbody></table></figure><h4 id="Java内存的结构分析"><a class="header-anchor" href="#Java内存的结构分析">¶</a>Java内存的结构分析</h4><ul><li>栈：一般存放基本数据类型</li><li>堆：存放对象(Cat cat,数组等)</li><li>方法区：常量池(常量，比如字符串)，类加载信息</li></ul><h4 id="Java创建对象的简单分析"><a class="header-anchor" href="#Java创建对象的简单分析">¶</a>Java创建对象的简单分析</h4><ol><li>先加载类信息(属性和方法信息，只会加载一次)</li><li>在堆中分配空间new()，进行默认初始化</li><li>把地址赋值给对象名，p就指向对象</li><li>进行指定初始化（属性赋值）</li></ol><h2 id="成员方法"><a class="header-anchor" href="#成员方法">¶</a>成员方法</h2><p>相当于定义在类中的函数</p><h3 id="基本定义和使用"><a class="header-anchor" href="#基本定义和使用">¶</a>基本定义和使用</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method01</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//方法的使用,先创建一个对象，然后进行调用</span></span><br><span class="line">Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.speak();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//public是方法的属性，()表示无参，void表示无返回值,{}是方法体，可以写入需要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"我是一个好人"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="方法的调用机制"><a class="header-anchor" href="#方法的调用机制">¶</a>方法的调用机制</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">int</span> returnRes = p1.GetSum(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在类中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Getsum</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>{</span><br><span class="line"><span class="keyword">int</span> res = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660806993074.png" alt=""></p><p>new一个对象在堆中开辟空间</p><p>调用Getsum方法后开辟新栈，将参数通过栈传递，进行操作后返回到调用方法的位置</p><h3 id="成员方法的好处"><a class="header-anchor" href="#成员方法的好处">¶</a>成员方法的好处</h3><p>对于需要多次进行的操作，方法能够减少代码的冗杂度</p><h3 id="方法使用细节"><a class="header-anchor" href="#方法使用细节">¶</a>方法使用细节</h3><ol><li>如果想让方法返回多个结果，可以使用数组存储返回值，也就是说返回值可以是基本数据类型，也可以是引用数据类型</li><li>实参和形参的类型必须相同或兼容、个数、顺序需要一致</li><li>方法体（方法内部）中不能再定义其他方法，也就是说方法不能嵌套定义</li><li><strong>对于同一类中的方法可以直接调用，而不同类的方法调用需要通过对象名调用</strong>。跨类的方法调用和访问修饰符有关</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method01</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Person2 person2 = <span class="keyword">new</span> Person2();</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">person2.m();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"speak"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal01</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">speak();</span><br><span class="line">System.out.println(<span class="string">"cal01"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>{</span><br><span class="line">Person person1 = <span class="keyword">new</span> Person();<span class="comment">//需要在方法中创建Person类的对象</span></span><br><span class="line">person1.cal01(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">"m类调用"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="方法传参机制"><a class="header-anchor" href="#方法传参机制">¶</a>方法传参机制</h3><ul><li>当传递的是基本数据类型时，传递的只是值，传递参数的地址的值不变，也就是<strong>值拷贝、值传递</strong>，此时形参的变化不会影响实参</li><li>而引用类型传递的是地址的值，可以在方法中对实参的值进行修改，这就是<strong>引用传递</strong></li></ul><h3 id="方法递归调用"><a class="header-anchor" href="#方法递归调用">¶</a>方法递归调用</h3><p>即在方法体中调用自己，注意使用递归时要有<strong>递归出口</strong>，并且需要向推出递归的条件逼近</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归打印</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Javatest</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method01</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">test test1 = <span class="keyword">new</span> test();</span><br><span class="line">test1.Recursion01(<span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Recursion01</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">2</span>){</span><br><span class="line">Recursion01(n-<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println(n);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="使用递归解决迷宫问题"><a class="header-anchor" href="#使用递归解决迷宫问题">¶</a>使用递归解决迷宫问题</h4><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660841676419.png" alt="map"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Map</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//初始化迷宫，1表示设置了障碍物，0表示未设置</span></span><br><span class="line"><span class="keyword">int</span> map[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i){</span><br><span class="line">map[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i){</span><br><span class="line">map[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">map[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">map[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;++j){</span><br><span class="line">System.out.print(map[i][j]+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println();</span><br><span class="line">}</span><br><span class="line">test test1 = <span class="keyword">new</span> test();</span><br><span class="line"><span class="keyword">boolean</span> final1= test1.Findway(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"\n=======找路的情况如下======="</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;++i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;++j){</span><br><span class="line">System.out.print(map[i][j]+<span class="string">" "</span>);</span><br><span class="line">}</span><br><span class="line">System.out.println();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用递归回溯来解决迷宫问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>{<span class="comment">//i、j表示老鼠所在的位置</span></span><br><span class="line"><span class="comment">//0表示可以走，1表示障碍物，2表示可以走，3表示走过，但是走不通是死路，当map[6][5]==2时，表示找到迷宫出口</span></span><br><span class="line"><span class="comment">//先确定老鼠找路的策略，因为有四个方向可以选择</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Findway</span><span class="params">(<span class="keyword">int</span> map[][],<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>){</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">if</span>(map[i][j]==<span class="number">0</span>){</span><br><span class="line">map[i][j]=<span class="number">2</span>;<span class="comment">//标记可以走并且已经走过</span></span><br><span class="line"><span class="keyword">if</span>(Findway(map,i+<span class="number">1</span>,j)){</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//尝试往下走</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span>(Findway(map,i,j+<span class="number">1</span>)){<span class="comment">//右</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span>(Findway(map,i-<span class="number">1</span>,j)){<span class="comment">//上</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span>(Findway(map,i,j-<span class="number">1</span>)){<span class="comment">//左</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">map[i][j]=<span class="number">3</span>;<span class="comment">//由于前面所有方向所返回的都是false，表示走不通，将该点标记为3，然后返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//结束本次递归，也就是回溯到上一个位置</span></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">else</span> {<span class="comment">//此时map[i][j]的值只能是1，2，3，1、3都表示不能走了，而2表示可以走，但是已经走过了，也可以直接结束本次递归，因为每次递归都是用于判断某个位置能不能走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="回溯"><a class="header-anchor" href="#回溯">¶</a>回溯</h4><p>使用上面的迷宫寻路问题来理解回溯，假设在该位置添加一个障碍物</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660842267622.png" alt=""></p><p>在(1,1)位置往下走到(2,1)，此时(2,1)左右下都为1，走不了，而上为2表示已经走过了，不需要再走，所以将(2,1)标为3，return false表示判断完毕，鉴定为不能走，然后回溯到(1,1)位置，因为在(1,1)位置只尝试了向下走，还未尝试其他方向</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660842473564.png" alt=""></p><h3 id="方法重载"><a class="header-anchor" href="#方法重载">¶</a>方法重载</h3><p>java中允许同一个类中，多个同名方法的存在，但要求<strong>形参列表不一致（形参类型或者个数）</strong>，<strong>返回类型不同不构成方法的重载</strong>，比如System.out.println()，out是PirntStream类型</p><p>重载的好处：</p><ul><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ul><h3 id="可变参数"><a class="header-anchor" href="#可变参数">¶</a>可变参数</h3><p>Java允许将同一个类中<strong>多个同名同功能但参数个数不同</strong>的方法，封装成一个方法</p><p><strong>基本语法</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">HspMethod m = <span class="keyword">new</span> HspMethod();</span><br><span class="line">System.out.println(m.sum(<span class="number">1</span>,<span class="number">5</span>,<span class="number">100</span>));</span><br><span class="line">System.out.println(m.sum(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HspMethod</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>{</span><br><span class="line"><span class="comment">//int... 表示接收的是可变参数，类型是int，即可以接收多个int</span></span><br><span class="line"><span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以当作数组</span></span><br><span class="line"><span class="comment">//遍历nums求和即可</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i){</span><br><span class="line">res+=nums[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>使用细节</strong></p><ul><li>可变参数的实参可以为数组，可变参数的本质就是数组</li><li>可变参数可以和普通类型的参数一起放在形参列表，但必须宝恒可变参数在最后</li><li>一个形参列表中只能出现一个可变参数</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">HspMethod m = <span class="keyword">new</span> HspMethod();</span><br><span class="line"><span class="keyword">int</span> arr[]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> arr1[]={<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">m.sum(arr);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HspMethod</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>{</span><br><span class="line"><span class="comment">//int... 表示接收的是可变参数，类型是int，即可以接收多个int</span></span><br><span class="line"><span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以当作数组</span></span><br><span class="line"><span class="comment">//遍历nums求和即可</span></span><br><span class="line">System.out.println(<span class="string">"长度为:"</span>+nums.length);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="作用域"><a class="header-anchor" href="#作用域">¶</a>作用域</h2><p>可以参考C语言的作用域：<strong>全局变量无需初始化，都可以使用，而局部变量只能在函数内部使用，需要初始化</strong></p><ol><li>在java中，主要的变量就是属性（成员变量）和局部变量</li><li>局部变量一般是指在成员方法中定义的变量</li><li>Java中作用域的分类：全局变量：也就是属性，作用域为整个类体；局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</li><li>全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Cat cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">cat1.cry();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>{</span><br><span class="line"><span class="comment">//全局变量，也就是属性，作用域为整个类，属性在定义时可以直接赋值</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//n和name为局部变量，其作用域为cry方法中</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">String name = <span class="string">"jack"</span>;</span><br><span class="line">System.out.println(age);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="作用域使用细节"><a class="header-anchor" href="#作用域使用细节">¶</a>作用域使用细节</h3><ol><li>属性和局部变量可以重名，访问时遵循就近原则</li><li>在同一个作用域中，两个局部变量或两个属性不能同名</li><li>属性生命周期较长，伴随对象的创建而创建，而局部变量生命周期较短，伴随着他的代码块的执行而创建，即在一次方法调用过程中</li><li>修饰符不同：全局变量/属性可以添加修饰符，局部变量不能添加修饰符</li><li>全局变量/属性：可以被本类使用，或其他类使用(通过对象调用)，局部变量只能在本类中对应的方法被调用</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">Person person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.cry();</span><br><span class="line">Person2 person2 = <span class="keyword">new</span> Person2();</span><br><span class="line">person2.test(person1);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line"><span class="comment">//全局变量，也就是属性，作用域为整个类，属性在定义时可以直接赋值</span></span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">String name = <span class="string">"jack"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//n和name为局部变量，其作用域为cry方法中</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line">System.out.println(name);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Person p)</span></span>{</span><br><span class="line">System.out.println(p.name);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="构造器"><a class="header-anchor" href="#构造器">¶</a>构造器</h2><p>构造方法又叫构造器，主要用于完成<strong>对新对象属性的初始化</strong></p><ol><li>构造器的修饰符可以默认，也可以是public、protected、private</li><li>构造器没有返回值</li><li>方法名和类名字必须相同</li><li>参数列表和成员方法一样的规则</li><li><strong>在创建对象的时候，系统自动调用该类的构造器完成对对象的初始化</strong></li></ol><p>基本语法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">constructor c1 = <span class="keyword">new</span> constructor(<span class="string">"jack"</span>,<span class="number">30</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constructor</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String pName,<span class="keyword">int</span> pAge)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"构造器被调用"</span>);</span><br><span class="line">name = pName;</span><br><span class="line">age = pAge;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="构造器使用细节"><a class="header-anchor" href="#构造器使用细节">¶</a>构造器使用细节</h3><ol><li>一个类可以定义多个不同的构造器，即构造器重载</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">constructor c1 = <span class="keyword">new</span> constructor(<span class="string">"jack"</span>,<span class="number">30</span>);</span><br><span class="line">constructor c2 = <span class="keyword">new</span> constructor(<span class="string">"kim"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constructor</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String pName,<span class="keyword">int</span> pAge)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"构造器被调用"</span>);</span><br><span class="line">name = pName;</span><br><span class="line">age = pAge;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String pName)</span></span>{</span><br><span class="line">name =pName;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>如果没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)，即Person(){}。<strong>一旦定义了构造器，默认的构造器就会被覆盖</strong></li></ol><p>定义一个空类，使用javap对空类进行反编译，可以看到在类中有一个默认构造器（反编译出来的是构造器的声明）</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660887309747.png" alt=""></p><h2 id="this关键字"><a class="header-anchor" href="#this关键字">¶</a>this关键字</h2><p>java虚拟机会给每个对象分配this，代表当前对象</p><p>简化理解：每个人都可以说"我的"，但是每个人说出来的"我的"是不同的，所以<strong>每个对象的this都不一样，但是可以使用this代表当前对象</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constructor</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.name = name;<span class="comment">//this.name表示当前对象的name属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;<span class="comment">//this.age表示当前对象的age属性</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String pName)</span></span>{</span><br><span class="line">name =pName;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">constructor c1 = <span class="keyword">new</span> constructor(<span class="string">"jack"</span>,<span class="number">30</span>);</span><br><span class="line">System.out.println(c1);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constructor</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String pName)</span></span>{</span><br><span class="line">name =pName;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过上述结果打印的结果可知，<strong>this指向自己</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660895386320.png" alt=""></p><p>下图是this在内存中的表示</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660895427895.png" alt="this在内存中的理解"></p><h3 id="this使用细节"><a class="header-anchor" href="#this使用细节">¶</a>this使用细节</h3><ol><li>this关键字可以用来访问本类的属性、方法、构造器</li><li>this用于区分当前类的属性和局部变量</li><li>访问成员方法的语句：this.方法名(参数列表)</li><li>访问构造器语法：this(参数列表)；注意只能在构造器中使用(即只能在构造器中访问另外一个构造器)，<strong>并且必须放在构造器的第一行</strong>，注意不能在普通方法使用上述语句。<strong>this()可以在构造器中调用本类中的其他构造器</strong></li><li>this不能在类定义的外部使用，只能在类定义的方法中使用</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overload1</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">constructor c1 = <span class="keyword">new</span> constructor();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">constructor</span></span>{</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>{</span><br><span class="line">System.out.println(<span class="string">"另一个构造器被调用"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">constructor</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"jack"</span>,<span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"第一个构造器被调用"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="包"><a class="header-anchor" href="#包">¶</a>包</h2><h3 id="包的三大作用"><a class="header-anchor" href="#包的三大作用">¶</a>包的三大作用</h3><ol><li>区分相同的类</li><li>当类很多时，可以很好地管理类（将功能相同或者近似的类放入同一个包中进行管理）</li><li>控制访问的范围-访问修饰符</li></ol><h3 id="包的基本语法"><a class="header-anchor" href="#包的基本语法">¶</a>包的基本语法</h3><p>package com.hsperdu;</p><p>package关键字，表示打包</p><p>com.hsperdu包名</p><h3 id="包的原理"><a class="header-anchor" href="#包的原理">¶</a>包的原理</h3><p>包的本质实际上就是创建不同的文件夹/目录来保存类文件</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660931088982.png" alt=""></p><p>由于两个Dog类属于两个不同的包，所以可以同时存在</p><h3 id="包的案例"><a class="header-anchor" href="#包的案例">¶</a>包的案例</h3><p>不同包下的Dog类</p><p>我们先在资源文件目录下创建两个包，名称为com.xiaoming和com.xiaoqiang，可以看到<strong>它自动生成了com文件夹，文件夹中存储两个我们需要的包</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660931537475.png" alt=""></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660931705569.png" alt=""></p><p>我们可以同时在两个包中创建Dog类，其放在了两个不同的包</p><p><strong>我们可以导入不同的包进而使用其中的类，也可以使用包名指定使用包中的类</strong>，对于两个相同的类，只能导入其中一个包</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660932008323.png" alt=""></p><h3 id="包的命名和命名规范"><a class="header-anchor" href="#包的命名和命名规范">¶</a>包的命名和命名规范</h3><p>命名规则</p><ol><li>只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字</li></ol><p>命名规范</p><ol><li>一般是小写字母+小圆点</li><li>一般是com.公司名.项目名.应用模块名</li></ol><h3 id="常用的包"><a class="header-anchor" href="#常用的包">¶</a>常用的包</h3><ol><li>java.lang //基本包，默认引入，不需要再引入</li><li>java.util //util包，系统提供的工具包、工具类，使用Scanner</li><li><a href="http://java.net">java.net</a> //网络包、网络开发</li><li>java.awt  //是做java的界面开发，GUI</li></ol><h3 id="包的使用细节"><a class="header-anchor" href="#包的使用细节">¶</a>包的使用细节</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//表示只会引入java.util包下的Scanner</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//表示将java.util包下的所有类都引入</span></span><br></pre></td></tr></tbody></table></figure><p>但是<strong>建议需要什么类就导入什么类即可</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//表示只会引入java.util包下的Scanner</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//表示将java.util包下的所有类都引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Import01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//使用系统提供的Arrays完成数组排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = {-<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">3</span>};</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li><p>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package</p></li><li><p>import指令位置放在package的下面，在类定义前面，可以有多句且无顺序要求</p><p>表明Import01这个类属于com.hspedu.pkg这个包中</p></li></ol><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660933622123.png" alt=""></p><h2 id="访问修饰符"><a class="header-anchor" href="#访问修饰符">¶</a>访问修饰符</h2><ul><li>公开级别：用<strong>public</strong>修饰、对外公开</li><li>受保护级别：用<strong>protected</strong>修饰，对子类和同一个包中的类公开</li><li>默认级别：没有修饰符号，向同一个包的类公开</li><li>私有级别：用<strong>private</strong>修饰，只有类本身可以访问，不对外公开</li></ul><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660934198599.png" alt=""></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660935677424.png" alt="在同一类中"></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660935646557.png" alt="在同包不同类中"></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660935721248.png" alt="在不同包中"></p><h3 id="使用的注意事项"><a class="header-anchor" href="#使用的注意事项">¶</a>使用的注意事项</h3><ol><li>修饰符可以用来修饰类中的属性，成员方法以及类</li><li>只有默认的和public才能修饰类，并且遵循上述访问权限的特点</li><li>成员方法的访问规则和属性完全一样</li></ol><h2 id="封装"><a class="header-anchor" href="#封装">¶</a>封装</h2><p>把抽象出的数据(属性)和对数据的操作(方法)封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作(方法)，才能对数据进行操作</p><h3 id="封装的理解和好处"><a class="header-anchor" href="#封装的理解和好处">¶</a>封装的理解和好处</h3><ol><li>隐藏方法的实现细节</li><li>可以对数据进行验证，保证安全合理</li></ol><h3 id="封装的实现"><a class="header-anchor" href="#封装的实现">¶</a>封装的实现</h3><ol><li>将属性进行私有化[不能直接修改属性]</li><li>提供一个公共的set方法，用于对属性判断并赋值</li><li>提供一个公共的get方法，用于获取属性的值</li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.Encapsualtion01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Encapsulation1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.setName(<span class="string">"jackkkkk"</span>);</span><br><span class="line">        person.setAge(<span class="number">200</span>);</span><br><span class="line">        person.setSalary(<span class="number">30000</span>);</span><br><span class="line">        System.out.println(person.info());</span><br><span class="line">        <span class="comment">//由于属性设置为private，不能直接访问，可以调用get方法</span></span><br><span class="line">        <span class="comment">//System.out.println(person.getSalary());</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> String name;<span class="comment">//name公开</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//age私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;<span class="comment">//</span></span><br><span class="line">    <span class="comment">//自己写set和get方法太慢了，可以使用快捷键ALT+INS，选择setter和getter</span></span><br><span class="line">    <span class="comment">//根据要求完善代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (name.length() &lt;= <span class="number">6</span> &amp;&amp; name.length() &gt;= <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"名字长度出错，默认为Admin"</span>);</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="string">"Admin"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">1</span> &amp;&amp; age &lt;= <span class="number">120</span>) {</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"设置的年龄不对，需要在1-120之间，默认设置为18"</span>);</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法返回属性信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name="</span> + <span class="keyword">this</span>.name + <span class="string">" age="</span> + <span class="keyword">this</span>.age + <span class="string">" salary="</span> + <span class="keyword">this</span>.salary;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="将构造器与set方法结合"><a class="header-anchor" href="#将构造器与set方法结合">¶</a>将构造器与set方法结合</h3><p>当直接使用构造器，会发现不会对我们传入的参数进行检查，此时Set方法无效了。<strong>所以我们可以将Set方法写在构造器中，对传入的数据进验证</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"jack"</span>,<span class="number">18</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>{</span><br><span class="line">        setName(name);</span><br><span class="line">        setAge(age);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="继承-v3"><a class="header-anchor" href="#继承-v3">¶</a>继承</h2><p><strong>使用继承来解决代码复用性</strong>，<strong>当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可</strong></p><p>比如在两个类中具有类似方法和三个完全相等的属性</p><p>Pupil类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小学生-&gt;模拟小学生考试的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pupil</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testing</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"小学生"</span> + name + <span class="string">"正在考小学数学"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"小学生名"</span> + name + <span class="string">" 年龄"</span> + age + <span class="string">" 分数"</span> + score);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Graduate类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟大学生考试的的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testing</span><span class="params">()</span> </span>{<span class="comment">//和Pupil类中的不一样</span></span><br><span class="line">        System.out.println(<span class="string">"大学生"</span> + name + <span class="string">"正在考大学数学"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"大学生名"</span> + name + <span class="string">" 年龄"</span> + age + <span class="string">" 分数"</span> + score);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="继承关系图"><a class="header-anchor" href="#继承关系图">¶</a>继承关系图</h3><p>此时A类为父类(基类)，B、C类为子类(派生类)</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1660984460601.png" alt=""></p><h3 id="继承的基本语法"><a class="header-anchor" href="#继承的基本语法">¶</a>继承的基本语法</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>{}</span><br></pre></td></tr></tbody></table></figure><p>两个子类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小学生-&gt;模拟小学生考试的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pupil</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testing</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"小学生"</span> + name + <span class="string">"正在考小学数学"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟大学生考试的的情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Student</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testing</span><span class="params">()</span> </span>{<span class="comment">//和Pupil类中的不一样</span></span><br><span class="line">        System.out.println(<span class="string">"大学生"</span> + name + <span class="string">"正在考大学数学"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>父类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Graduate和Pupil的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>{</span><br><span class="line">    <span class="comment">//共有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//共有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">double</span> score)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"小学生名"</span> + name + <span class="string">" 年龄"</span> + age + <span class="string">" 分数"</span> + score);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Test</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Pupil pupil = <span class="keyword">new</span> Pupil();</span><br><span class="line">        pupil.name=<span class="string">"小明"</span>;</span><br><span class="line">        pupil.age=<span class="number">10</span>;</span><br><span class="line">        pupil.testing();</span><br><span class="line">        pupil.setScore(<span class="number">100</span>);</span><br><span class="line">        pupil.showInfo();</span><br><span class="line"></span><br><span class="line">        Graduate graduate = <span class="keyword">new</span> Graduate();</span><br><span class="line">        graduate.name=<span class="string">"大明"</span>;</span><br><span class="line">        graduate.age=<span class="number">20</span>;</span><br><span class="line">        graduate.testing();</span><br><span class="line">        graduate.setScore(<span class="number">120</span>);</span><br><span class="line">        graduate.showInfo();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="继承的好处"><a class="header-anchor" href="#继承的好处">¶</a>继承的好处</h3><ol><li>代码的复用性提高了</li><li>代码的扩展性和维护性提高了</li></ol><h3 id="继承的细节"><a class="header-anchor" href="#继承的细节">¶</a>继承的细节</h3><ol><li>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，<strong>要通过公共的方法去访问</strong>（父类提供公共方法进行访问）</li></ol><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1661016055315.png" alt=""></p><p>在父类中设置get方法来访问private属性、也可以在父类中定义公共方法调用private方法</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1661016235712.png" alt=""></p><ol><li><strong>子类必须调用父类的构造器，完成父类的初始化</strong></li></ol><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pupil pupil = <span class="keyword">new</span> Pupil();<span class="comment">//在父类和子类分别添加无参构造器，然后创建对象</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1661016794784.png" alt=""></p><ol><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会<strong>先去调用</strong>父类的<strong>无参构造器</strong>。如果父类中没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作</li></ol><p>当父类使用有参构造器，<strong>需要使用super来指定父类中的构造器(通过参数)</strong>，且<strong>super()需要放在子类构造器的第一行</strong>，先对父类进行初始化再进行子类的初始化，<strong>所有的构造器如果没有写super()和this()，第一行默认都有super()，不过被省略了</strong></p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1661017507232.png" alt=""></p><ol><li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下：<strong>super(参数列表)</strong>。也就是当父类有多个构造器时，通过super中的参数列表来指定使用父类中的构造器</p></li><li><p>super()和this()都只能放在构造器的第一行，因此不能同时存在</p></li><li><p>java所有类都是<strong>Object</strong>的子类，Object是所有类的基类</p><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1661018361388.png" alt=""></p></li><li><p>父类构造器的调用不限于直接父类，将一直往上追溯直到Object类(顶级父类)。也就是说<strong>子类会调用父类的构造器，而父类也会先调用父类的父类的构造器</strong>，一直往上</p></li><li><p>子类最多只能继承一个父类(直接继承)，即java中是<strong>单继承机制</strong></p></li><li><p>不能滥用继承，子类和父类之间必须满足is a的逻辑关系，如猫 is a 动物</p></li></ol><h3 id="继承的本质"><a class="header-anchor" href="#继承的本质">¶</a>继承的本质</h3><p><img src="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/1661019665247.png" alt="在内存中的创建"></p><p>当父类和父类的父类具有相同的属性时，<strong>访问时采取就近原则</strong>，若此时我们需要访问的属性在父类中是private，则会报错，并且不会去爷爷类找</p><h2 id="super关键字"><a class="header-anchor" href="#super关键字">¶</a>super关键字</h2><p><strong>super代表父类的引用，用于访问父类的属性、方法、构造器</strong></p><ol><li>访问父类的属性、方法，但不能访问父类的private属性和方法</li><li>访问父类的构造器(前面用过)，<strong>super(参数列表)，只能放在构造器的第一句</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;JAVA&lt;/p&gt;</summary>
    
    
    
    <category term="JAVA" scheme="https://gift1a.github.io/categories/JAVA/"/>
    
    
    <category term="JAVA" scheme="https://gift1a.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-08T08:38:10.238Z</published>
    <updated>2022-08-05T18:40:38.420Z</updated>
    
    <content type="html"><![CDATA[<p>title: 数据结构与算法</p><p>数据结构与算法</p><span id="more"></span> <h1 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h1><h2 id="基本概念和术语"><a class="header-anchor" href="#基本概念和术语">¶</a>基本概念和术语</h2><h3 id="数据"><a class="header-anchor" href="#数据">¶</a>数据</h3><p>数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</p><p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录</p><p>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位</p><p>数据对象：是性质相同的数据元素的集合，是数据的子集</p><h3 id="结构"><a class="header-anchor" href="#结构">¶</a>结构</h3><p>不同数据元素之间不是独立的，而是存在特定的关系，而这些关系就是结构</p><p><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</strong></p><h2 id="逻辑结构与物理结构"><a class="header-anchor" href="#逻辑结构与物理结构">¶</a>逻辑结构与物理结构</h2><p>逻辑结构是面向问题的，物理结构就是面向计算机的，其基本的目标就是将数据及逻辑关系存储到计算机的内存中</p><h3 id="逻辑结构"><a class="header-anchor" href="#逻辑结构">¶</a>逻辑结构</h3><p>逻辑结构：<strong>是指数据对象数据元素之间的相互关系</strong>，这也是我们今后需要关注的地方</p><h4 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h4><p>使用示意图表示数据的逻辑结构时，要注意两点：</p><ul><li>将每一个数据元素看作一个结点，用圆圈表示</li><li>元素之间的逻辑关系用结点之间的连线表示，如果这个给关系是由方向的，那么用带箭头的连线表示</li></ul><h4 id="集合结构"><a class="header-anchor" href="#集合结构">¶</a>集合结构</h4><p><strong>集合结构：集合结构中的数据元素除了同属于一个集合外</strong>，它们之间没有其他关系，类似于数学中的集合</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png" alt="集合结构"></p><h4 id="线性结构"><a class="header-anchor" href="#线性结构">¶</a>线性结构</h4><p><strong>线性结构：线性结构中的数据元素是一对一的关系</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501980892.png" alt="线性结构"></p><h4 id="树形结构"><a class="header-anchor" href="#树形结构">¶</a>树形结构</h4><p><strong>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502028932.png" alt="树形结构"></p><h4 id="图形结构"><a class="header-anchor" href="#图形结构">¶</a>图形结构</h4><p><strong>图形结构：图形结构的数据元素是多对多的关系</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502086807.png" alt="图形结构"></p><h3 id="物理结构——存储结构"><a class="header-anchor" href="#物理结构——存储结构">¶</a>物理结构——存储结构</h3><p><strong>物理结构：是指数据的逻辑结构在计算机中的存储形式</strong></p><p>数据的存储结构应正确反映数据元素之间的逻辑关系</p><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构">¶</a>顺序存储结构</h4><p><strong>顺序存储结构：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502487332.png" alt="顺序存储结构"></p><h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构">¶</a>链式存储结构</h4><p><strong>链式存储结构：是把数据元素存放在任意的存储单元中，这组存储单元可以是连续的，也可以是不连续的</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502635250.png" alt="链式存储结构"></p><p>此时数据元素的存储关系不能反映其逻辑关系，所以需要一个指针存放数据元素的地址，通过指针可以找到相关联数据元素的地址。相较于顺序存储结构，链式存储结构更为灵活，<strong>也更适合处理需要变化的结构</strong>，比如排队，当队伍中需要添加或者删去成员时，使用顺序存储结构则需要处理大量数据</p><h2 id="抽象数据类型"><a class="header-anchor" href="#抽象数据类型">¶</a>抽象数据类型</h2><h3 id="数据类型-v2"><a class="header-anchor" href="#数据类型-v2">¶</a>数据类型</h3><p><strong>数据类型：是指一组性质形同的值的集合及定义在此集合上的一些操作的总称</strong></p><h3 id="抽象数据类型-v2"><a class="header-anchor" href="#抽象数据类型-v2">¶</a>抽象数据类型</h3><p><strong>抽象数据类型：是指一个数据建模及定义在该模型上的一组操作</strong>，比如整型</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657503293323.png" alt="抽象数据类型标准格式"></p><h1 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h1><p><strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列。并且每条指令表示一个或多个操作</strong></p><p><strong>算法的基本特性：输入、输出、有穷性、确定性、可行性</strong></p><p><strong>算法的基本要求：</strong></p><ul><li>正确性</li><li>可读性：便于阅读、理解和交流</li><li>健壮性：当输入数据不合法时算法能做出相关处理</li><li>时间效率高和存储量低</li></ul><h2 id="算法时间和空间复杂度"><a class="header-anchor" href="#算法时间和空间复杂度">¶</a>算法时间和空间复杂度</h2><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657504108330.png" alt="算法时间复杂度定义"><br>$$<br>O(1)叫做常数阶、O(n)叫做线性阶、O(n^2)叫做平方阶<br>$$</p><h3 id="时间复杂度的计算"><a class="header-anchor" href="#时间复杂度的计算">¶</a>时间复杂度的计算</h3><p>推导大O阶：</p><ul><li>用常数1取代运行时间中的所有加法常数</li><li>在修改后的运行次数函数中，只保留最高阶项</li><li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常数阶</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//这里代码的执行次数和问题的大小n无关，所以为常数，也就是O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//以上代码会执行n次，所以位O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数阶</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;n)</span><br><span class="line">{</span><br><span class="line">    count=count*<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//程序不再执行的条件是2^(count)&gt;=n，也就是count=log2n，所以这个循环的时间复杂度为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平方阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//因为上述程序为嵌套循环，所以会执行n*n次，所以时间复杂度为O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于下述循环嵌套，时间复杂度计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对于上述程序，我们先计算程序的执行次数，因为外层循环执行次数必定为n，主要看内层循环，内层循环执行次数总和为n+(n-1)+(n-2)+……=(n+1)/2，最终得到n^2/2+n/2</span></span><br><span class="line"><span class="comment">//按照上面的大O推导法，1、没有加法常数不予考虑，2、只保留最高阶也就是n^2/2，3、去除这个项的系数，得到n^2，所以时间复杂度为O(n^2)</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510055411.png" alt="常见的时间复杂度"></p><h3 id="空间复杂度的计算"><a class="header-anchor" href="#空间复杂度的计算">¶</a>空间复杂度的计算</h3><p>算法的空间复杂度通过计算算法所需要的存储空间实现</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510171290.png" alt=""></p><p>主要是数组大小，变量只占一个存储单元</p><h1 id="线性表"><a class="header-anchor" href="#线性表">¶</a>线性表</h1><p>线性表：零个或多个数据元素的有限序列，元素之间是有序的<img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514042881.png" alt="线性表的数学语言定义"></p><p>所以线性表元素的个数n定义为线性表的长度，当n=0时为空表</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514222426.png" alt="位序"></p><p><strong>在较复杂的线性表中，一个数据元素可以由若干个数据项组成</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514307777.png" alt="复杂线性表"></p><h2 id="线性表的抽象数据类型"><a class="header-anchor" href="#线性表的抽象数据类型">¶</a>线性表的抽象数据类型</h2><p>前面说过抽象数据类型分为数据和操作</p><p>在这里线性表的抽象数据类型定义如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">    DATA</span><br><span class="line">    线性表的数据对象集合为(a1,a2,a3……，an)，每个元素的类型均为DataType。除了第一个元素a1外，其余元素都有且只有一个直接前驱元素，除最后一个元素外，其余元素都有且只有一个直接后继元素。数据元素之间的关系是一对一的关系</span><br><span class="line">    <span class="function">Operation</span></span><br><span class="line"><span class="function">    <span class="title">InitList</span><span class="params">(*L)</span><span class="comment">//初始化操作，建立一个空的线性表</span></span></span><br><span class="line"><span class="function">    <span class="title">ListEmpty</span><span class="params">(*L)</span><span class="comment">//若线性表为空，返回true，否则返回false</span></span></span><br><span class="line"><span class="function">    <span class="title">ClearList</span><span class="params">(*L)</span><span class="comment">//将线性表清空</span></span></span><br><span class="line"><span class="function">    <span class="title">GetElem</span><span class="params">(L,i,*e)</span><span class="comment">//将线性表L中的第i个位置元素值返回给e</span></span></span><br><span class="line"><span class="function">    <span class="title">LocateElem</span><span class="params">(L,e)</span> <span class="comment">//在线性表L中查找和e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则返回0表示失败</span></span></span><br><span class="line"><span class="function">    <span class="title">ListInsert</span><span class="params">(*L,i,e)</span><span class="comment">//在线性表L的第i个位置擦汗如新元素e</span></span></span><br><span class="line"><span class="function">    <span class="title">ListDelete</span><span class="params">(*L,i,*e)</span><span class="comment">//删除线性表L中的第i个未知元素，并用e返回其值</span></span></span><br><span class="line"><span class="function">    <span class="title">ListLength</span><span class="params">(L)</span><span class="comment">//返回线性表L的元素个数</span></span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>以上只是线性表的基础操作，对于复杂的一些操作可以分解为简单的操作，比如求A和B集合的并集这一操作可以分解为遍历B表，将A表中不存在的元素插入到A表中</strong></p></blockquote><h2 id="线性表的顺序存储结构"><a class="header-anchor" href="#线性表的顺序存储结构">¶</a>线性表的顺序存储结构</h2><p><strong>线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素</strong></p><p>描述顺序存储结构需要三个特性：</p><ul><li>存储空间的起始位置：数组data，他的存储位置就是存储空间的存储位置</li><li>线性表的最大存储容量：数组长度MaxSize</li><li>线性表的当前长度：length</li></ul><h3 id="顺序存储结构的插入与删除"><a class="header-anchor" href="#顺序存储结构的插入与删除">¶</a>顺序存储结构的插入与删除</h3><p>这两者其实是比较麻烦的，对于插入数据，插入位置之后的元素都需要后移，删除则为前移。</p><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常</li><li>如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量</li><li>从最后一个元素开始向前遍历到第i个位置，分别将他们往后移动一个位置</li><li>将要插入的元素填入位置i处</li><li>表长+1</li></ul><p>删除算法也是类似的</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516394208.png" alt="线性表的优缺点"></p><h2 id="线性表的链式存储结构"><a class="header-anchor" href="#线性表的链式存储结构">¶</a>线性表的链式存储结构</h2><p><strong>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素</strong>，由于是任意的，我们还需要存储当前元素的后继元素地址</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516611507.png" alt="单链表的定义"></p><p><strong>一般会在单链表的第一个结点前附设一个头结点，在其数据域存储线性表的长度，然后让头结点的指针指向第一个结点</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516871062.png" alt="头指针与头结点的异同"></p><p>为了更好地理解，贴出下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516922060.png" alt=""></p><h3 id="单链表的读取、插入和删除"><a class="header-anchor" href="#单链表的读取、插入和删除">¶</a>单链表的读取、插入和删除</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//类型</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">}List;<span class="comment">//名称</span></span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">InsertNode</span><span class="params">(List* <span class="built_in">list</span>)</span><span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">{</span><br><span class="line">List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">tmp-&gt;data = i;</span><br><span class="line">tmp-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"><span class="built_in">list</span>-&gt;next = tmp;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">List* <span class="title">CreateList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">List* Node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">Node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建空的头结点</span></span><br><span class="line"><span class="keyword">return</span> InsertNode(Node);<span class="comment">//插入结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (Linklist-&gt;next != <span class="literal">NULL</span>)<span class="comment">//第一个是空结点，所以先指向第一个结点</span></span><br><span class="line">{</span><br><span class="line">Linklist = Linklist-&gt;next;<span class="comment">//遍历单向链表</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Linklist-&gt;data);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">DeteleNode</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> goal = <span class="number">3</span>;<span class="comment">//删除结点需要先记录前一个结点的位置</span></span><br><span class="line">List* p = Linklist, * q;<span class="comment">//初始化p用于遍历链表</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next-&gt;data == goal)<span class="comment">//当前节点下一结点的值为3</span></span><br><span class="line">{</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Linklist;<span class="comment">//返回的是头节点</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">List* <span class="title">InsertBytail</span><span class="params">(List* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">List* tmplist = <span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">{</span><br><span class="line">List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">tmp-&gt;data = i;</span><br><span class="line">tmp-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建新节点</span></span><br><span class="line"><span class="comment">//从尾部插入</span></span><br><span class="line">tmplist-&gt;next = tmp;</span><br><span class="line">tmplist = tmplist-&gt;next;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">List* Linklist;</span><br><span class="line">Linklist= CreateList();</span><br><span class="line"><span class="comment">//PrintList(Linklist);</span></span><br><span class="line">Linklist=DeteleNode(Linklist);</span><br><span class="line">PrintList(Linklist);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>链表创建时可以使用尾插法和头插法，尾插法就是创建的结点从尾部插入，而头插法则反之</p><h2 id="静态链表"><a class="header-anchor" href="#静态链表">¶</a>静态链表</h2><p>即使用结构体数组来替代指针来描述单链表</p><blockquote><p><strong>首先让结构体数组拥有两个成员，data和cur。数据域data原来存放数据元素，也就是我们要处理的元素。而游标cur相当于单链表中的next指针，存放该元素的后继元素在数组中的下标，但是为了方便插入数据，通常需要把数组建立得大一些</strong></p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//游标Cursor，为0时表示无指向</span></span><br><span class="line">}Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure><p>同时我们需要对第一个元素和最后一个元素进行特殊元素处理，不存放数据。<strong>我们通常把未被使用得数组元素称为备用链表</strong></p><blockquote><p>数组第一个元素即下标为0的元素cur就存放备用链表(空位置)的第一个结点的下标。而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表的头结点的作用</p></blockquote><h3 id="静态链表的插入和删除操作"><a class="header-anchor" href="#静态链表的插入和删除操作">¶</a>静态链表的插入和删除操作</h3><p>前面可知，动态链表结点的申请和释放分别借用malloc和free函数。<strong>而在静态链表中，操作的是数组</strong>，为了区分哪些数组是被使用过的，我们可以将所有未被使用过的以及已经被删除的分量用游标链成一个备用的链表（使cur指向下一个空位置）</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657620383741.png" alt="静态链表"></p><h4 id="静态链表插入"><a class="header-anchor" href="#静态链表插入">¶</a>静态链表插入</h4><p>首先我们需要在备用链表中找到一个空位置，相当于(malloc)，然后将该位置的元素加入数据链表中此时当前的空位置会被占用，所以list[0]-&gt;cur也需要改变。</p><h4 id="静态链表删除"><a class="header-anchor" href="#静态链表删除">¶</a>静态链表删除</h4><p>和插入一样，都需要对备用链和数据链进行更改</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line">}Component, StaticList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//找到备用链表中的空位置</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur)<span class="comment">//如果备用链表已被使用过</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[i]-&gt;cur;<span class="comment">//因为当前位置被占用，所以从备用链表中解除</span></span><br><span class="line"><span class="keyword">return</span> i;<span class="comment">//返回空位置的下标</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateList</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxsize - <span class="number">1</span>; ++i)<span class="comment">//初始化备用链表，此时空间都没被使用，所以list[0]-&gt;cur为0</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">list</span>[i]-&gt;cur = i + <span class="number">1</span>;<span class="comment">//cur相当于next，指向下一个结点</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//结尾的结点的cur赋值为0</span></span><br><span class="line"><span class="built_in">list</span>[Maxsize - <span class="number">1</span>]-&gt;cur = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//从备用链表中获取空结点的位置,从而创建数据链表的头节点</span></span><br><span class="line"><span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">int</span> head = k;<span class="comment">//返回头节点的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//申请数据结点</span></span><br><span class="line"><span class="keyword">int</span> s = Malloc(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">list</span>[s]-&gt;data = i;</span><br><span class="line">k = s;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">list</span>[k]-&gt;cur = <span class="number">0</span>;<span class="comment">//数据链表的末尾结尾以0结尾，表示cur指向NULL</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//因为第一个是头结点无数据，所以跳过</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//插入的位置，首先在备用链表中获取空结点的下标</span></span><br><span class="line"><span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line"><span class="built_in">list</span>[k]-&gt;data = <span class="number">10</span>;<span class="comment">//给指定位置的元素赋值，下一步将其从中间插入，同时备用链表也需要改变</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[k]-&gt;cur;<span class="comment">//这样就实现了不移动元素在中间插入数据</span></span><br><span class="line"><span class="built_in">list</span>[<span class="number">4</span>]-&gt;cur = k;</span><br><span class="line"><span class="built_in">list</span>[k]-&gt;cur = <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;data == <span class="number">10</span>)<span class="comment">//当前结点的后一个结点数值为10</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//当找到我们刚才插入的结点时，备用链表和数据链表都需要进行做出改变</span></span><br><span class="line"><span class="comment">//首先改变数据链表</span></span><br><span class="line"><span class="built_in">list</span>[head]-&gt;cur = <span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur;<span class="comment">//跳过下一结点</span></span><br><span class="line"><span class="comment">//接下来改变备用链表，将其看作备用链表的结点</span></span><br><span class="line"><span class="keyword">int</span> tmp = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line"><span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line"><span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur = tmp;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//后移</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">StaticList <span class="built_in">list</span>[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> head = CreateList(<span class="built_in">list</span>);</span><br><span class="line">InsertNode(<span class="built_in">list</span>);</span><br><span class="line">DeleteNode(<span class="built_in">list</span>, head);</span><br><span class="line">PrintList(<span class="built_in">list</span>, head);</span><br><span class="line">InsertNode(<span class="built_in">list</span>);</span><br><span class="line">PrintList(<span class="built_in">list</span>, head);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634024878.png" alt="静态链表的优缺点"></p><h2 id="循环链表"><a class="header-anchor" href="#循环链表">¶</a>循环链表</h2><p>之前提到的单链表都只存储向后的指针，所以没办法找到他的前驱节点。而我们只要将链表改为一个环就可以解决这样的问题，而这样的链表就是循环链表——解决了一个问题（如何从当中的一个结点出发，访问到链表的全部结点）</p><p><strong>将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为但循环链表，简称循环链表</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634585653.png" alt="循环链表和单链表的差异"></p><p>循环链表如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657635089691.png" alt="循环链表"></p><p>在单链表中，我们有了头结点时，可以用O(1)的时间访问第一个结点，但是要访问到最后一个结点则需要O(n)时间，因为所有结点都要访问一遍。</p><p>我们可以改造一下上面的循环链表，不用头指针，而是用<strong>指向终端结点的尾指针来表示循环链表</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636505788.png" alt=""></p><h3 id="两个循环链表的合并"><a class="header-anchor" href="#两个循环链表的合并">¶</a>两个循环链表的合并</h3><p>有了尾结点合并时就会比较简单</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636794584.png" alt="流程图"></p><p>rearA和rearB是两条循环链表的尾指针</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=readA-&gt;next;<span class="comment">//保存A表的头结点</span></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next;<span class="comment">//将B链的第一个结点（不是头结点）赋值给rearA-&gt;next</span></span><br><span class="line">readB-&gt;next=p;</span><br><span class="line"><span class="built_in">free</span>(p)<span class="comment">//释放p</span></span><br></pre></td></tr></tbody></table></figure><h2 id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h2><p>在单向链表中，由于存在next指针，所以我们访问下一节点的时间复杂度为O(1)，而访问前一个结点则需要O(n)，所以设计出了双向链表。</p><p><strong>双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域</strong>，所以在双向链表中的每个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">prior</span>;</span><span class="comment">//直接前驱结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">next</span>;</span><span class="comment">//直接后继结点</span></span><br><span class="line">}DulNode,*DuLinkList;</span><br></pre></td></tr></tbody></table></figure><p>双向链表也可以是循环表</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657677859248.png" alt="双向循环链表"></p><h3 id="双向链表的查找、插入和删除"><a class="header-anchor" href="#双向链表的查找、插入和删除">¶</a>双向链表的查找、插入和删除</h3><p>查找的话只需要往一个方向遍历即可，不需要使用两个指针。</p><p>但是在插入和删除的时候需要同时对两个指针变量作出修改</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678031412.png" alt="插入的流程图"></p><blockquote><p>在编写代码时一定要注意顺序</p></blockquote><p>双向链表是使用空间换取时间的例子。</p><h1 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h1><p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong></p><blockquote><p><strong>栈顶——允许插入和删除，栈顶的另一端就是栈底，不含任何元素的叫空栈。栈又被称为后进先出的线性表</strong>，简称LIFO结构</p></blockquote><p><strong>栈的插入操作叫作进栈，也可以叫做压栈、入栈；栈的删除操作叫做出栈</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678420041.png" alt="出栈入栈图"></p><p>相同的元素出栈次序的变化是很多的</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678529526.png" alt="出入栈的例子"></p><h2 id="栈的抽象数据类型"><a class="header-anchor" href="#栈的抽象数据类型">¶</a>栈的抽象数据类型</h2><p>对于栈的插入和删除操作，我们改名为push和pop</p><p><strong>入栈(push)是先移动栈顶指针再压入元素，出栈(pop)是弹出元素再移动栈顶指针</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈</span><br><span class="line">DAta</span><br><span class="line">同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Opreation</span></span><br><span class="line"><span class="function"><span class="title">InitStack</span><span class="params">(*S)</span></span>;<span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line">DestroyStack(*S);<span class="comment">//若栈存在，则销毁他</span></span><br><span class="line">ClearStack(*S);<span class="comment">//将栈清空</span></span><br><span class="line">StackEmpty(S);<span class="comment">//判断栈是否为空</span></span><br><span class="line">GetTop(S,*e);<span class="comment">//若栈不为空，用e返回栈顶元素</span></span><br><span class="line">Push(*S,e);<span class="comment">//入栈</span></span><br><span class="line">Pop(*S,*e);<span class="comment">//出栈</span></span><br><span class="line">StackLength(S);<span class="comment">//返回栈S的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure><p>因为栈是线性表，所以也具有顺序和链式存储方式</p><h2 id="栈的顺序存储及实现"><a class="header-anchor" href="#栈的顺序存储及实现">¶</a>栈的顺序存储及实现</h2><p>栈的顺序存储简称为顺序栈，线性表的顺序存储是用数组表示的，我们将栈底定义在数组下标为0的位置，并且使用top变量来指示栈顶的位置，<strong>当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定为top等于-1</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//用于栈顶指针</span></span><br><span class="line">}Sqstack;</span><br></pre></td></tr></tbody></table></figure><p>出栈入栈的代码也是相对简单的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data[MaxSize];</span><br><span class="line"><span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">}Sqstack;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == MaxSize - <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断是否满栈</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//先移动栈顶指针，再压入</span></span><br><span class="line"><span class="built_in">stack</span>-&gt;top++;</span><br><span class="line"><span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> <span class="keyword">final</span>)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//判断是否为空栈</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span> = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line"><span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="两栈共享空间"><a class="header-anchor" href="#两栈共享空间">¶</a>两栈共享空间</h3><p>在前面的例子中存在很大的一个缺陷，那就是需要事先确定数组存储空间大小，<strong>对于一个栈我们需要设计出合适大小的数组来处理，但是对于两个相同类型的栈，我们却可以做到最大限度地利用其是先开辟地存储空间来进行操作</strong></p><p>我们可以使用一个数组类存储两个栈</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657680434915.png" alt="数组存储两个栈"></p><p>此时我们需要两个栈顶指针top1和top2，<strong>当top+1==top2时表示两个栈都满了</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top1;</span><br><span class="line"><span class="keyword">int</span> top2;</span><br><span class="line">}SqdoubleStack;</span><br></pre></td></tr></tbody></table></figure><p>对于两栈共享空间的push和pop，还需要有一个用于判断是栈1还是栈2的参数stackNumber</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682240174.png" alt="两栈共享空间push操作"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682220519.png" alt="两栈共享空间pop操作"></p><h2 id="栈的链式存储结构"><a class="header-anchor" href="#栈的链式存储结构">¶</a>栈的链式存储结构</h2><p>栈的链式存储结构，简称为<strong>链栈</strong></p><p>对于链栈来说不需要头结点，因为已经有栈顶了</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682407800.png" alt="链栈"></p><p><strong>对于空栈来说链表的原定义头指针指向NULL，那么链栈的空就是top=NULL</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>//栈的结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span><span class="comment">//栈的结点</span></span><br><span class="line">}StackNode, * LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>//栈的链表结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">LinkStackPtr top;<span class="comment">//栈顶</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure><h3 id="链栈的入栈和出栈"><a class="header-anchor" href="#链栈的入栈和出栈">¶</a>链栈的入栈和出栈</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">s-&gt;data = e;<span class="comment">//结点赋值</span></span><br><span class="line">s-&gt;next = S-&gt;top;<span class="comment">//将新结点与原本的栈顶相连</span></span><br><span class="line">S-&gt;top = s;<span class="comment">//栈顶指向新的结点</span></span><br><span class="line">S-&gt;count++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">LinkStackPtr p;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (S-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">e = S-&gt;top-&gt;data;</span><br><span class="line">p = S-&gt;top;<span class="comment">//将栈顶结点赋值给p，待会free掉</span></span><br><span class="line">S-&gt;top = S-&gt;top-&gt;next;<span class="comment">//使得栈顶指针后移一个结点</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">S-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684222256.png" alt="顺序栈和链栈的对比"></p><h2 id="栈的作用"><a class="header-anchor" href="#栈的作用">¶</a>栈的作用</h2><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684273946.png" alt=""></p><h2 id="栈的应用"><a class="header-anchor" href="#栈的应用">¶</a>栈的应用</h2><h3 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h3><p>递归一个典型的例子就是斐波那契数列（每一项的元素都是前两项元素之和）</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684630710.png" alt="斐波那契数列表达式"></p><p>这里可以使用递归计算，会比较简单</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> Fbi(n - <span class="number">1</span>) + Fbi(n - <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Fbi(i));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657688706889.png" alt="斐波那契数列的执行过程"></p><p><strong>递归的定义：间接地调用自己的函数，同时我们需要注意要有递归的出口</strong>，而对于函数的传参和返回值都是使用栈来实现的</p><h3 id="四则运算表达式求值"><a class="header-anchor" href="#四则运算表达式求值">¶</a>四则运算表达式求值</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689038037.png" alt="带括号的四则运算"></p><p>但是光按照括号来判断是不够的，所以采用以下方法</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689312633.png" alt=""></p><p>就是遇到数字就入栈，遇到符号就从栈中取出两个元素（注意先后），做运算后再入栈</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689418201.png" alt="具体过程"></p><p>但是上面的方法需要先将中缀表达式先转为后缀表达式</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689587176.png" alt="中缀表达式先转为后缀表达式过程"></p><h1 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h1><p><strong>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p><p><strong>队列是一种先进先出的线性表，简称FIFO，运行插入的一端称为队尾，允许删除的一端叫做队头</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689730159.png" alt="队列的结构图"></p><h2 id="队列的抽象数据类型"><a class="header-anchor" href="#队列的抽象数据类型">¶</a>队列的抽象数据类型</h2><p>同样是线性表，队列也有类似线性表的各种操作，<strong>不同的就是插入数据只能在队尾插入，删除数据只能在队头进行</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列</span><br><span class="line">Data</span><br><span class="line">同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function"><span class="title">InitQueue</span><span class="params">(*Q)</span></span>;<span class="comment">//初始化操作，建立一个空队列Q</span></span><br><span class="line">DestroyQueue(*Q);<span class="comment">//若队列Q存在，则销毁他</span></span><br><span class="line">ClearQueue(*Q);<span class="comment">//将队列清空</span></span><br><span class="line">QueueEmpty(*Q);<span class="comment">//判断队列是否为空</span></span><br><span class="line">GetHead(Q,*e);<span class="comment">//若队列存在且非空，用e返回队列Q的队头元素</span></span><br><span class="line">EnQueue(*Q,e);<span class="comment">//若队列Q存在，插入新元素e到队列Q中并成为队尾元素</span></span><br><span class="line">DeQueue(*Q,*e);<span class="comment">//删除队列Q中队头元素，用e返回其值</span></span><br><span class="line">QueueLength(Q);<span class="comment">//返回队列Q的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure><h2 id="循环队列"><a class="header-anchor" href="#循环队列">¶</a>循环队列</h2><p>队列作为特殊的线性表也有顺序存储和链式存储</p><h3 id="队列顺序存储的不足"><a class="header-anchor" href="#队列顺序存储的不足">¶</a>队列顺序存储的不足</h3><p>如果以数组下标为0的位置作为队头，那么入队时只需要在队尾追加元素即可，但是出队的话比较复杂，因为队头之后的所有元素都需要前移，时间复杂度为O(n)</p><p>但我们可以不去限制队列的元素必须存储在数组的前n个元素，也就是说<strong>队头不需要一定在下标为0的位置</strong></p><p>为了避免当只有一个元素时队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时队列为空</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691539985.png" alt="队列顺序存储的出队和入队"></p><p>可以看出当出队后再进行入队时发生了数组越界的情况（无法入队），而数组前两个位置还是空的，<strong>这就是假溢出</strong>，这时候就需要循环队列了</p><h3 id="循环队列的定义"><a class="header-anchor" href="#循环队列的定义">¶</a>循环队列的定义</h3><p><strong>队列的头尾相接的顺序存储结构叫做循环队列</strong></p><p>按照上面的例子，当入队a5时，可以将rear指向数组下标为0的位置</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691779653.png" alt="rear指向0下标处"></p><p>这样我们就可以继续入队了</p><p>此时新的问题出现了，空队列时front等于rear，当队列满的时候也是front=rear，为了区分，有两种方法</p><ul><li>设置一个标志量flag，当front==rear，且flag=0时为队列空，当flag=1时为队列满</li><li>可以修改队列满的条件，当数组还剩下一个空闲单元时我们就认为队列满了</li></ul><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710307674.png" alt="条件2"></p><p>下面重点讨论第二种方法</p><p>由于rear可能比fornt大，也可能小，所以不能仅凭二者相差1来判断是否为满队列（因为可能相差整整一圈）</p><p>设队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710665197.png" alt="队列长度计算"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> Data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">//尾指针，若队列不空指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的入队操作，首先判断是否为满队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//尾指针后移，如果为最后则转到数组头部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的出队操作，队头出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    <span class="comment">//队头后移</span></span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="队列的链式存储结构"><a class="header-anchor" href="#队列的链式存储结构">¶</a>队列的链式存储结构</h2><p>队列的链式存储结构其实就是线性表的单链表，只不过他只能尾进头出而已。我们称之为<strong>链队列</strong></p><p>为了操作方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657711606663.png" alt="链队列"></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>//结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//队列的链表结构</span></span><br><span class="line">QueuePtr front, rear;<span class="comment">//队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure><h3 id="链队列的入队和出队操作"><a class="header-anchor" href="#链队列的入队和出队操作">¶</a>链队列的入队和出队操作</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化结点</span></span><br><span class="line"><span class="comment">//链接上队列，队尾插入</span></span><br><span class="line">Q-&gt;rear-&gt;next = s;</span><br><span class="line">Q-&gt;rear = s;<span class="comment">//把当前结点设置为队尾结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">QueuePtr p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用变量p暂时存储需要删除的结点</span></span><br><span class="line">p = Q-&gt;front-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next;<span class="comment">//队头指针后移</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">//如果队尾指向第一个数据结点，则删除之后恢复空队列</span></span><br><span class="line">{</span><br><span class="line">Q-&gt;rear = Q-&gt;front;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>——————下划线——————</p><p>刷题巩固一下我的🐖脑</p><h1 id="串"><a class="header-anchor" href="#串">¶</a>串</h1><p><strong>串是由零个或者多个字符组成的有限序列，又名叫字符串</strong></p><h2 id="串的抽象数据类型"><a class="header-anchor" href="#串的抽象数据类型">¶</a>串的抽象数据类型</h2><p>相较于线性表的更关注单个元素的操作，比如查找删除插入一个元素，但串中更多的是查找子串的位置、得到指定位置的子串替换子串等操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串</span><br><span class="line">Data</span><br><span class="line">串中的一个元素仅由一个字符组成</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">    <span class="title">StrAssion</span><span class="params">(T,*chars)</span></span>;<span class="comment">//生成一个其值等于字符串常量chars的串T</span></span><br><span class="line">    StrCopy(T,S);<span class="comment">//串S存在，由串S复制得到串T</span></span><br><span class="line">    ClearString(S);<span class="comment">//串S存在，将该串清空</span></span><br><span class="line">    StringEmpty(S);<span class="comment">//判断串是否为空</span></span><br><span class="line">StrLength(S);<span class="comment">//返回串S的元素个数，即串的长度</span></span><br><span class="line">StrCompare(S,T);<span class="comment">//字符串比较，若S&gt;T则返回值&gt;0,S=T,返回值=0，S&lt;T,返回值&lt;0，</span></span><br><span class="line">Concat(T,S1,S2);<span class="comment">//用T返回由S1和S2连接而成的新串</span></span><br><span class="line">SubString(Sub,pos,len);<span class="comment">//用Sub返回串S的第pos个字符串起长度为len的子串</span></span><br><span class="line">Index(S,T,pos);<span class="comment">//若主串S中存在和串T值相同的子串，则返回他在主串S中第pos个字符之后第一次出现的位置，否则则返回0</span></span><br><span class="line">Replace(S,T,V);<span class="comment">//用V替换主串S中出现的所有与T相等的不重叠的子串</span></span><br><span class="line">StrInsert(S,pos,T);<span class="comment">//在串S的第pos个字符之前插入串T</span></span><br><span class="line">StrDelete(S,pos,len);<span class="comment">//从串S中删除第pos个字符起长度为len的子串</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure><h2 id="串的存储结构"><a class="header-anchor" href="#串的存储结构">¶</a>串的存储结构</h2><h3 id="串的顺序存储结构"><a class="header-anchor" href="#串的顺序存储结构">¶</a>串的顺序存储结构</h3><p><strong>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的</strong>，顺序存储结构需要规定数组的大小，但是涉及两串的连接，新串的插入以及字符串的替换都会超过数组的最大长度Maxsize，<strong>于是对于串的顺序存储，串值的存储空间可在程序执行过程中动态分配而得，也就是使用堆</strong></p><h3 id="串的链式存储结构"><a class="header-anchor" href="#串的链式存储结构">¶</a>串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个数据元素是一个字符，如果仍使用一个结点来存储一个字符，会造成大量的空间浪费。<strong>因此一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以使用其他非串值字符进行补齐</strong>，由于链式存储结构需要确定一个结点存储多少个字符，比较麻烦，所以一般使用顺序存储结构</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658123888513.png" alt=""></p><h2 id="朴素的模式匹配算法"><a class="header-anchor" href="#朴素的模式匹配算法">¶</a>朴素的模式匹配算法</h2><p>也就是BF算法</p><p><strong>子串的定位操作通常称作串的模式匹配</strong></p><p>就是对主串的每一个字母作为子串的开头，与要匹配的字符串进行匹配。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = pos;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;<span class="built_in">strlen</span>(S) &amp;&amp; j &lt;<span class="built_in">strlen</span>(T))<span class="comment">//下标小于子串和主串长度</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])<span class="comment">//当前位置的字符串匹配成功则继续往后匹配</span></span><br><span class="line">{</span><br><span class="line">++i;</span><br><span class="line">++j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//</span></span><br><span class="line">{</span><br><span class="line">i = i - j + <span class="number">1</span>;<span class="comment">//i返回上次匹配首位的下一位</span></span><br><span class="line">j = <span class="number">1</span>;<span class="comment">//重新回到子串首位进行匹配</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> i - <span class="built_in">strlen</span>(T);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当每次不成功的匹配都发生在串T的最后一个字符，此时时间复杂度会非常大，可见这种匹配方式较为低效</p><h2 id="KMP模式匹配算法"><a class="header-anchor" href="#KMP模式匹配算法">¶</a>KMP模式匹配算法</h2><p><strong>KMP常用于相同字符较少的字符串中，效率较高</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658245851001.png" alt=""></p><p>可以看到由于望江楼前三个不同且成功匹配，那么第一个红框内的判断是多余的，我们可以直接进行回溯进行比较，而i都是往后的所以不需要回溯，只需要回溯j指针</p><p>下图就是KMP算法的匹配流程</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658246082896.png" alt=""></p><p>我们把T串每个位置的j值的变化定义为一个数组next</p><p>上面的是针对子串T中无重复元素的，下面我们来看一下T串中含有重复串如何使用KMP算法</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658246312528.png" alt=""></p><p>首先需要计算未匹配位置前字符串的前缀和后缀，其最长前缀、后缀有共同元素"望江"，长度为2，<strong>所以j指针回溯为2，也就是将"楼"字（下标为2）对应上次未成功匹配的位置</strong>。</p><p><strong>这是因为由于前缀和后缀具有相同的元素的话，j指针移动相同元素对应长度就可以做到匹配。</strong>（看图就可以理解了）</p><p>接下来我们可以看一下一段快完善的KMP算法代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IndexKmp</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span>* next = genNext(T);<span class="comment">//生成next表</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(S) &amp;&amp; j &lt; <span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;<span class="comment">//匹配的话，模式串和原串指针都后移</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">j = next[j];<span class="comment">//j指针回溯</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> j = <span class="built_in">strlen</span>(T) ? i - j : <span class="number">1</span>;<span class="comment">//有无匹配的字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="next的手动计算"><a class="header-anchor" href="#next的手动计算">¶</a>next的手动计算</h4><p><strong>计算next数组前，我们首先要先知道前后缀是什么，举个例子就能明白了，假如字符串S为"abcdef"，那么S的前缀集合为{a,ab,abc,abcd,abcde}，后缀集合为{f,ef,def,cdef,bcdef}</strong></p><p>接下来我们手动计算next数组</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658247591189.png" alt=""></p><p><strong>对于下标为5的字符"江"，其前面的字符串是"望江楼上望"，前后缀相同的元素为"望"，长度为1，所以该位置的next数组元素为1</strong>，也就是说下次匹配时将从下标为1的位置进行匹配。</p><p>从这里可以看出，如果第一个模式串元素不匹配，那么next[0]=0，由于串S的i指针不会移动，此时会陷入while的死循环。</p><p>所以对next数组进行改进，且修改KMP算法的代码（其实多加一个特判即可）</p><p><strong>我们在0下标前添加一个万能字符，表示可以和所有字符进行匹配，然后改next[0]=-1</strong>，这样的话当第一个元素不匹配时，d=next[0]=-1，因为-1下标处为万能字符，所以必定匹配，进入if条件中</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658248876847.png" alt=""></p><p>代码修改为</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IndexKmp</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span>* next = genNext(T);<span class="comment">//生成next表</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(S) &amp;&amp; j &lt; <span class="built_in">strlen</span>(T))</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;<span class="comment">//匹配的话，模式串和原串指针都后移</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">j = next[j];<span class="comment">//j指针回溯</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> j = <span class="built_in">strlen</span>(T) ? i - j : <span class="number">1</span>;<span class="comment">//有无匹配的字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="next的代码计算"><a class="header-anchor" href="#next的代码计算">¶</a>next的代码计算</h4><p>就是计算出相同的最长前后缀的长度，这个过程和我们进行子串匹配极为类似，所以也可以采用类似的思想</p><p>先贴代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">genNext</span><span class="params">(<span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span>* next = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="built_in">strlen</span>(T),<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;<span class="comment">//此时比较的母串和模式串都是其本身</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(T) - <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">-1</span> || T[i] == T[j])</span><br><span class="line">{</span><br><span class="line">i++;</span><br><span class="line">j++;<span class="comment">//因为已经++，所以接下来作比较就是下一个字符了</span></span><br><span class="line">next[i] = (T[i] != T[j] ? j : next[j]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">j = next[j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来我们看看是如何得到这段代码的</p><p>分为两种情况</p><ul><li>匹配：next[i+1]=next[i]+1=j+1;</li><li>失配：j=next[j];</li></ul><p>将其自身与自身进行匹配，找到相同的字符就相当于找到了相同的真前缀和真后缀，画个图进行理解</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658283222671.png" alt=""></p><p>当我们成功匹配时，由于是自身进行匹配，那么两个位置处的字符相等，而这两个字符分别是前后缀。（此时next为1）在此基础上，长串指针和短串指针都后移继续进行匹配，若仍匹配成功</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658283403139.png" alt=""></p><p>由于前一个匹配成功，后一位置也匹配成功，所以next的值为前一位next+1，也就是next[i+1]=next[i]+1;</p><p>当失配时，j指针需要回溯</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284025306.png" alt=""></p><p>假如在当前位置失配，d指针回溯的位置应该是d位置处的next值，即下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284102069.png" alt=""></p><p>这样即可继续往后匹配</p><h5 id="例子-v5"><a class="header-anchor" href="#例子-v5">¶</a>例子</h5><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284266466.png" alt=""></p><p>从当前位置红色区域开始，若下标为10的位置成功匹配，那么"流"位置的next值为4+1</p><p>但当前位置的字符失配，所以j指针需要回溯，回溯的距离为相同最大真后前缀长度，也就是"望江"的长度，<strong>代码表示为j=next[j]</strong>，如下图所示**</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284621215.png" alt=""></p><p>然后接着进行匹配，还是失配，j指针继续回溯，此时无相同真前缀和真后缀，所以回溯到0位置，"江"和"望"依旧无法匹配，所以"流"位置的next值为0</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284864446.png" alt=""></p><h3 id="改进"><a class="header-anchor" href="#改进">¶</a>改进</h3><p>在开始讲之前我们先来看一个KMP的匹配</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658295908560.png" alt=""></p><p>可以看到如果子串为"望江楼望江流"时，红框中第一次是"望"和","作比较，第二次也是，这样子是重复的。于是需要对next表进行改进，如果当前两字符相等，该位置回溯的值（也就是next数组中的值）需要继续往前找相同前后缀</p><p>原来的next表为</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658296711020.png" alt=""></p><p>由于下标为4的"望"的next为0，而T[0]=“望”，所以修改为T[0]处的next值，下标为5的"江"同理改为0</p><p>修改之后的next表为</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658296844289.png" alt=""></p><h1 id="树"><a class="header-anchor" href="#树">¶</a>树</h1><p>之前接触的一对一的线性结构，但是我们会遇到很多一对多的问题，这时候就需要研究这种数据结构——树</p><blockquote><p><strong>树是n(n&gt;=0)个结点的有限集，n=0时为空树。在任意一棵非空树中：1、有且仅有一个特定的称为根的结点；2、当n&gt;1时，其余结点可分为m个互不相交的有限集T1、T2、……，其中每一个集合本身又是一棵树，并称为根的子树</strong></p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285177849.png" alt="树的结构图"></p><p>在上图中，有左子树T1和右子树T2</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285240432.png" alt=""></p><p>对于树的定义需要注意两点</p><ul><li>根节点是唯一的</li><li>子树的个数没有限制，但他们一定是互不相交的</li></ul><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285325411.png" alt="不符合树的定义"></p><h2 id="结点分类"><a class="header-anchor" href="#结点分类">¶</a>结点分类</h2><p>结点拥有的子树数称为结点的度，度为0的结点称为叶结点或者终端结点，其他结点称为非终端结点或者分支结点。根结点和分支结点都被称为内部结点。<strong>树的度是树内各结点的度的最大值</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285589499.png" alt="树的结点分类"></p><h2 id="结点间的关系"><a class="header-anchor" href="#结点间的关系">¶</a>结点间的关系</h2><p>结点的子树的根称为该结点的孩子，该结点即为孩子的双亲。<strong>同一双亲的孩子之间互称兄弟，结点的祖先是从根到该结点所经分支上的所有结点</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285780007.png" alt="树的关系图"></p><h2 id="树的其他相关概念"><a class="header-anchor" href="#树的其他相关概念">¶</a>树的其他相关概念</h2><h3 id="结点的层次"><a class="header-anchor" href="#结点的层次">¶</a>结点的层次</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285898473.png" alt=""></p><h3 id="有序与无序"><a class="header-anchor" href="#有序与无序">¶</a>有序与无序</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285942270.png" alt=""></p><h3 id="森林"><a class="header-anchor" href="#森林">¶</a>森林</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285978054.png" alt=""></p><h3 id="树结构"><a class="header-anchor" href="#树结构">¶</a>树结构</h3><ul><li>根结点：无双亲，唯一</li><li>叶结点：无孩子，可以多个</li><li>中间节点，一个双亲多个孩子</li></ul><h2 id="树的抽象数据类型"><a class="header-anchor" href="#树的抽象数据类型">¶</a>树的抽象数据类型</h2><p>相较于线性结构，树的操作有很大的变化</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树</span><br><span class="line">Data</span><br><span class="line">树是由一个根节点和若干棵子树构成，树中结点具有相同的数据类型和层次关系</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function"><span class="title">InitTree</span><span class="params">(*T)</span></span>;<span class="comment">//构造空树</span></span><br><span class="line">DestroyTree(*T);<span class="comment">//销毁树</span></span><br><span class="line">    CreationTree(*T,definition);<span class="comment">//按definition中给出树的定义来构造树</span></span><br><span class="line">ClearTree(*T);<span class="comment">//若树T存在，则将树T清为空树</span></span><br><span class="line">TreeEmpty(*T);<span class="comment">//判断树是否为空</span></span><br><span class="line">TreeDepth(*T);<span class="comment">//计算树的深度</span></span><br><span class="line">Root(T);<span class="comment">//返回T的根结点</span></span><br><span class="line">Value(T,cur_e);<span class="comment">//返回树T中cur_e的值</span></span><br><span class="line">Assign(T,cur_e,value);<span class="comment">//赋值</span></span><br><span class="line">Parent(T,cur_e);<span class="comment">//返回其双亲，根节点除外</span></span><br><span class="line">LeftChild(T,cur_e);<span class="comment">//若cur_e为树的非叶结点，则返回它的最左孩子，否则返回空</span></span><br><span class="line">RightSibling(T,cur_e);<span class="comment">//返回该结点的右兄弟</span></span><br><span class="line">InsertChild(*T,*p,i,c);<span class="comment">//p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树</span></span><br><span class="line">DeleteChile(*T,*p,i);<span class="comment">//删除T中p所指结点的第i棵子树</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure><h2 id="树的存储结构"><a class="header-anchor" href="#树的存储结构">¶</a>树的存储结构</h2><p>由于树的某个结点可以有多个孩子，所以我们无论以何种顺序将树中所有结点存储到数组中，<strong>结点的存储位置都无法直接反映逻辑关系</strong></p><p>所以需要充分利用顺序存储和链式存储的特点实现对树的存储结构的表示，有三种表示法</p><ul><li>双亲表示法</li><li>孩子表示法</li><li>孩子兄弟表示法</li></ul><h3 id="双亲表示法"><a class="header-anchor" href="#双亲表示法">¶</a>双亲表示法</h3><p>我们假设以一组连续空间存储树的结点，<strong>同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>，也就是说每个结点除了知道自己是谁以外，还知道它的双亲在哪</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658299227922.png" alt="结点结构"></p><p>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的双亲表示法结点结构定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置</span></span><br><span class="line">}PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//树结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//根的位置和结点数</span></span><br><span class="line">}pTree;</span><br></pre></td></tr></tbody></table></figure><p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这就意味着我们所有的结点都存有它双亲的位置</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658301382777.png" alt="树结构和树双亲表示"></p><p>这样我们可以根据结点的parent指针很容易找到它的双亲结点，时间复杂度为O(1)，直到当parent=-1，表示此时找到了树结点的根。但如果我们想知道结点的孩子是什么，则需要遍历树。</p><p><strong>我们可以增加一个结点最左边孩子的域，也就是长子域</strong>，这样就可以很容易得到结点的孩子下标。对于没有孩子的结点，长子域设置为-1</p><p>如图所示</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326018314.png" alt=""></p><p>如此一来，对于有0、1、2个孩子的节点来说，这样的结构解决了要找结点孩子的问题。</p><p><strong>如果更关注兄弟之间的关系，双亲表示法无法体现，此时需要增加一个右兄弟域</strong>，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标，不存在右兄弟则为-1</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326372469.png" alt=""></p><p>我们需要根据不同的情况来选择存储结构</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326404928.png" alt=""></p><h3 id="孩子表示法"><a class="header-anchor" href="#孩子表示法">¶</a>孩子表示法</h3><p>换一种考虑方式，由于树中的每个结点可能有多棵子树，，可以使用多重链表，即<strong>每个结点有多个指针域，其中每个指针指向一棵子树的结点</strong>，这就是多重链表表示法。不过树的每个结点的度，也就是他的孩子个数是不同的，下面设计两种方案</p><h4 id="方案一"><a class="header-anchor" href="#方案一">¶</a>方案一</h4><p><strong>指针域的个数等于树的度</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326812794.png" alt="结构链表"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326874291.png" alt=""></p><p>可以看到A结点存储两个指针，分别指向其子树B和C，其他也是这样</p><p><strong>由于每个结点都需要存储度个数的指针，所以对于空间浪费较大</strong>，但当树中各结点的度相距较小时，这样反而是优点（因为存储的空间被充分利用了）</p><h3 id="方案二"><a class="header-anchor" href="#方案二">¶</a>方案二</h3><p><strong>每个结点指针域的个数等于该结点的度，同时我们专门取一个位置来存储结点指针域的个数</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658327278373.png" alt="方案二结构流程图"></p><p>这种方法克服了浪费空间的缺点，但由于各个结点的链表是不同的结构，加上要计算结点的度的数值，会消耗较多时间。</p><h4 id="孩子表示法-v2"><a class="header-anchor" href="#孩子表示法-v2">¶</a>孩子表示法</h4><p><strong>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328073829.png" alt=""></p><p>为此我们设计两种结点结构，一种是<strong>孩子链表的孩子结点</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328318770.png" alt="孩子结点"></p><p>其中child是数据域，<strong>用于存储某个结点在表头数组中的下标</strong>，next是指针域，用于存储某结点的下一个孩子结点的指针</p><p>另一种是<strong>表头数组的表头结点</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328570902.png" alt="表头结点"></p><p>孩子表示法的结构定义代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的孩子表示法结构定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//孩子结点的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>*<span class="title">next</span>;</span><span class="comment">//next指针</span></span><br><span class="line">}*ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//表头结构</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">}CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//树结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//根的位置和结点数</span></span><br><span class="line">}CTree;</span><br></pre></td></tr></tbody></table></figure><p>这样查找某个结点的孩子或者兄弟，只需要查找这个结点的孩子单链表即可。当我们需要遍历整棵树也只需要对头结点的数据进行循环即可</p><p>但是当我们想要知道某个结点的双亲是谁时需要整棵树遍历才行。所以可以将双亲表示法和孩子表示法结合一下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658329348770.png" alt="双亲孩子表示法"></p><h3 id="孩子兄弟表示法"><a class="header-anchor" href="#孩子兄弟表示法">¶</a>孩子兄弟表示法</h3><p>刚才我们分别从双亲的角度和孩子的角度研究树的存储结构，接下来我们从树结点的兄弟角度来看，但是<strong>对于树这种层级结构，之研究结点的兄弟是不行的</strong>。这是因为<strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658329839317.png" alt="结点结构"></p><p>代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的孩子兄弟表示法结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>*<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">}CSNOde,*CSTree;</span><br></pre></td></tr></tbody></table></figure><p>对于图6-4-1的树来说，孩子兄弟表示法结构实现的示意图如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658333093630.png" alt=""></p><p>数据后跟的分别是第一个孩子结点的指针和第一个孩子结点的右兄弟结点指针。</p><p>这种表示法，给<strong>查找某个结点的某个孩子带来了方便，只需要通过firstchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子</strong>，当然如果想找到某个结点的双亲，该表示法是有缺陷的。<strong>所以可以再增加一个parent指针域来解决快速查找双亲的问题</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658333931260.png" alt=""></p><p>将孩子兄弟表示法的结构体变形一下就成了这个样子，<strong>也就是二叉树</strong></p><h2 id="二叉树"><a class="header-anchor" href="#二叉树">¶</a>二叉树</h2><p><strong>对于在某个阶段都是两种结果的情形，比如开和关、0和1、真和假等，都适合用树状结构来建模，而这种树是一种特殊的树状结构——二叉树</strong></p><blockquote><p><strong>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成</strong></p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371418983.png" alt="二叉树结构图"></p><h3 id="二叉树特点"><a class="header-anchor" href="#二叉树特点">¶</a>二叉树特点</h3><ul><li><strong>每个结点最多有两棵子树</strong>，所以二叉树综不存在度大于2的结点</li><li><strong>左子树和右子树是有顺序的，次序不能颠倒</strong></li><li><strong>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</strong></li></ul><p>二叉树具有五种基本情况</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371646629.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371693564.png" alt=""></p><h3 id="特殊二叉树"><a class="header-anchor" href="#特殊二叉树">¶</a>特殊二叉树</h3><h4 id="斜树"><a class="header-anchor" href="#斜树">¶</a>斜树</h4><p><strong>所有的结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树，两者统称为斜树</strong></p><h4 id="满二叉树"><a class="header-anchor" href="#满二叉树">¶</a>满二叉树</h4><p><strong>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372050513.png" alt="满二叉树"></p><p>满二叉树的特点</p><ul><li><strong>叶子只能出现在最下一层</strong>，出现在其他层就不可能达成平衡</li><li><strong>非叶子结点的度一定是2</strong></li><li><strong>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多</strong></li></ul><h4 id="完全二叉树"><a class="header-anchor" href="#完全二叉树">¶</a>完全二叉树</h4><p><strong>对一棵具有n个结点的二叉树按层序编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</strong></p><p>满二叉树一定是一棵完全二叉树，而完全二叉树不一定是满的</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372793932.png" alt="完全二叉树"></p><p>下面给出判断的例子来增进理解</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372917054.png" alt=""></p><p>完全二叉树的特点</p><ul><li><strong>叶子结点只能出现在最下两层</strong></li><li><strong>最下层的叶子一定集中在左部连续位置</strong></li><li>倒数二层，若有叶子结点，一定都在右部连续位置</li><li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况（因为这样必定空出一个位置）</li><li><strong>同样结点数的二叉树，完全二叉树的深度最小</strong></li></ul><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658373145515.png" alt="完全二叉树判断"></p><h3 id="二叉树性质"><a class="header-anchor" href="#二叉树性质">¶</a>二叉树性质</h3><h3 id="性质1"><a class="header-anchor" href="#性质1">¶</a>性质1</h3><p><strong>在二叉树的第i层上至多有2^(i-1)个结点</strong></p><h3 id="性质2"><a class="header-anchor" href="#性质2">¶</a>性质2</h3><p><strong>深度为k的二叉树至多有2^k-1个结点</strong></p><h3 id="性质3"><a class="header-anchor" href="#性质3">¶</a>性质3</h3><p><strong>对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，那么n0=n2+1</strong></p><p>由分支数和结点个数可以进行推导</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388031089.png" alt=""></p><h3 id="性质4"><a class="header-anchor" href="#性质4">¶</a>性质4</h3><p><strong>具有n个结点的完全二叉树深度为[log2(n)]+1（[x]表示不大于x的最大整数）</strong></p><p>由满二叉树的定义，深度为k的满二叉树结点数一定为2^k-1，因为这是最多的节点个数，然后倒推回去就可以得到公式k=log2(n+1)</p><p>而根据完全二叉树的定义</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388393575.png" alt=""></p><h3 id="性质5"><a class="header-anchor" href="#性质5">¶</a>性质5</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388476010.png" alt=""></p><p>性质5的例子</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388579944.png" alt=""></p><h2 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构">¶</a>二叉树的存储结构</h2><h3 id="二叉树的顺序存储结构"><a class="header-anchor" href="#二叉树的顺序存储结构">¶</a>二叉树的顺序存储结构</h3><p><strong>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系</strong></p><p>顺序存储结构一般只用于完全二叉树，这是因为对于普通的二叉树，可以将其按照安全二叉树编号，把不存在的结点设置为空</p><p>如下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389028020.png" alt=""></p><p>但是这种情况仍需要分配2^k-1的空间，浪费了空间</p><h3 id="二叉链表"><a class="header-anchor" href="#二叉链表">¶</a>二叉链表</h3><p>顺序结构的适用性不强，所以考虑链式结构。</p><p><strong>二叉树每个结点最多有两个孩子，所以为他设计一个数据域和两个指针域</strong>，这样的链表叫做二叉链表</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389266516.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链表的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span>*<span class="title">lchild</span>,<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">}BitNode,*BitTree;</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389350501.png" alt="二叉链表结构示意图"></p><h2 id="遍历二叉树"><a class="header-anchor" href="#遍历二叉树">¶</a>遍历二叉树</h2><p>对于二叉树的遍历来说，<strong>次序较为重要</strong></p><blockquote><p><strong>二叉树的遍历是指从根结点开始，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次</strong></p></blockquote><h3 id="前序遍历"><a class="header-anchor" href="#前序遍历">¶</a>前序遍历</h3><p><strong>根结点-&gt;左子树-&gt;右子树</strong></p><p><strong>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389761608.png" alt=""></p><p>先前序遍历根结点的左子树，从B结点开始，到D结点，再到G，此时对于D的左子树已经遍历完成，接下来前序遍历D的右子树，再之后A的左子树遍历完成，就到C，E，I，F</p><h3 id="中序遍历"><a class="header-anchor" href="#中序遍历">¶</a>中序遍历</h3><p><strong>左子树-&gt;根-&gt;右子树</strong></p><p><strong>若二叉树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389991208.png" alt=""></p><p>先从根结点开始，中序遍历左子树，也就是B的那一部分，把B看作B子树的根结点，然后按照中序遍历左子树D，还是按照中序遍历，G是D的左孩子，先对其遍历，再到G的根结点D，再到右子树H，往上层回溯，此时B的左子树遍历完成，到B，而B无右子树，跳过对B右子树的遍历，再到A，最后对A的右子树遍历。（这里对于E，只有右子树，没有左子树，所以访问顺序先E再I）</p><h3 id="后序遍历"><a class="header-anchor" href="#后序遍历">¶</a>后序遍历</h3><p><strong>左子树-&gt;右子树-&gt;根结点</strong></p><p><strong>若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点</strong></p><p>也可以根据左子树-&gt;右子树-&gt;根结点依次进行后序遍历的方式进行</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658390559641.png" alt=""></p><p>先对左子树B开始，B有左子树，对其进行后序遍历，D的左孩子为G，先对其访问，然后是右孩子H，再到根结点D，B的左子树遍历完成，无右子树，直接访问B，再到根结点的右子树进行后序遍历。</p><h3 id="层序遍历"><a class="header-anchor" href="#层序遍历">¶</a>层序遍历</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658390961739.png" alt="层序遍历结构图"></p><h3 id="多种遍历方法的意义"><a class="header-anchor" href="#多种遍历方法的意义">¶</a>多种遍历方法的意义</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391006060.png" alt=""></p><h3 id="前中后序遍历算法"><a class="header-anchor" href="#前中后序遍历算法">¶</a>前中后序遍历算法</h3><p>其实就是上面说的遍历顺序的不同</p><ul><li>前序：根-&gt;左子树-&gt;右子树</li><li>中序：左子树-&gt;根-&gt;右子树</li><li>后序：左子树-&gt;右子树-&gt;根</li></ul><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391313478.png" alt="前序遍历算法"></p><p>其他都差不多，而对于遍历过程也已经在上面提及了，就不赘述了</p><h3 id="推导遍历结果"><a class="header-anchor" href="#推导遍历结果">¶</a>推导遍历结果</h3><p>和离散数学中的推导一致，只需要知道各种遍历的遍历特点，再根据递归即可根据遍历结果即可还原出原本的二叉树</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391555792.png" alt="二叉树遍历的性质"></p><h2 id="二叉树的建立"><a class="header-anchor" href="#二叉树的建立">¶</a>二叉树的建立</h2><p>如果我们要在内存中建立一个如图6-9-1左图这样的树，为了能让每个结点确认是否有左右孩子，我们对他进行了扩展，变成右图的样子，<strong>也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如’#'</strong>，我们称这种处理后的二叉树为原二叉树的扩展二叉树。<strong>扩展二叉树可以做到：如果已知一个遍历序列就可以确定一棵二叉树</strong>，这也是为什么我们先对二叉树进行扩展，比如左图的前序遍历序列为AB#D##C##</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391801250.png" alt=""></p><p>有了此准备，我们可以看看如何生成一棵二叉树</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按前序输入二叉树中结点的值（一个字符）</span></span><br><span class="line"><span class="comment">//#表示空树，构造二叉链表示二叉树T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span>*<span class="title">lchild</span>,<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">}BitNode,*BitTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBitTree</span><span class="params">(BitTree*T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%C"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>)</span><br><span class="line">    {</span><br><span class="line">        *T=<span class="literal">NULL</span>;<span class="comment">//表示结点为空</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        *T=(BitTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BitNode));</span><br><span class="line">        <span class="keyword">if</span>(!*T)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//开辟失败</span></span><br><span class="line">        }</span><br><span class="line">        (*T)-&gt;data=ch;</span><br><span class="line">        CreateBitTree(&amp;(*T)-&gt;lchild);<span class="comment">//构造左子树</span></span><br><span class="line">        CreateBitTree(&amp;(*T)-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658392330019.png" alt="生成二叉树的原理"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658410756146.png" alt="中序后续构造二叉树"></p><h2 id="线索二叉树"><a class="header-anchor" href="#线索二叉树">¶</a>线索二叉树</h2><p>对于二叉链表，我们可以看到有许多空指针的存在，浪费了大量的空间</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658410788739.png" alt=""></p><p>另一方面我们在遍历完二叉树后知道每个结点的前驱和后继结点是哪个，可是这是建立在遍历过的基础之上。<strong>在二叉链表上，我们只知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱或后驱结点是谁</strong>。要是想知道，必须遍历一次，且以后每次需要知道时，都必须先遍历一次。那么我们可以考虑<strong>子啊创建时就记住前驱和后继结点</strong>，这将会节省时间</p><p><strong>所以我们可以考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点</strong></p><p>我们把这种<strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</strong></p><h3 id="例子-v6"><a class="header-anchor" href="#例子-v6">¶</a>例子</h3><p>如下图我们对这棵树进行中序遍历之后，将所有的空指针域中的rchild改为指向它的后继结点</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658414870561.png" alt=""></p><p>于是我们可以通过指针知道H的后继节点是D（图中的1），I的后继是B，J的后继是E，E的后继是A，F的后继是C，G的后继因为不存在而指向NULL，此时有6个空指针域被利用</p><p>再如下图将这棵二叉树的所有空指针域中的lchild改为指向当前结点的前驱，H的前驱是NULL，I的前驱是D，J的前驱是B，F的前驱是A，G的前驱是C，一共5个空指针域被利用。结合前面，总共11个空指针域被利用。</p><p>通过下图更容易看出(空心箭头实现为前驱，虚线黑箭头为后继)：<strong>其实线索二叉树相当于把一棵二叉树转为了一个双向链表</strong>，这样对于我们查找、插入、删除结点都带来了便利。我们把<strong>对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658415381940.png" alt=""></p><p>但仍然有问题需要解决，那就是我们如何知道某一结点的lchild是指向它的左孩子还是指向前驱？rchild是指向右孩子还是后继？比如E结点的lchild是指向它的左孩子J，而rchild却是指向它的后继A。因此，<strong>我们在每个结点再增设两个标志域ltag和ratg，注意ltag和rtag只是存放0或1数字的布尔变量</strong>，其占用的内存空间要小于像lchild和rchild指针变量。</p><p>结点结构体如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658416056518.png" alt=""></p><p>因此对于二叉链表图可以修改为下图的样子</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658416112659.png" alt=""></p><h3 id="线索二叉树结构实现"><a class="header-anchor" href="#线索二叉树结构实现">¶</a>线索二叉树结构实现</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的二叉线索存储结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span>Link,Thread} PointerTag;<span class="comment">//Link==0表示指向左右孩子指针，Thread==1表示指向前驱或者后缀的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitThrNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitThrNode</span>*<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PoniterTag RTag;<span class="comment">//左右标志</span></span><br><span class="line">}BitThrNode,*BitThrTree;</span><br></pre></td></tr></tbody></table></figure><p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或者后继的线索</strong>，由于前驱和后继的信息只有在遍历该二叉树才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong></p><p>中序遍历线索化的递归函数代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BitThrThree pre;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BitThrTree p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    {</span><br><span class="line">        InThreading(p-&gt;lchild);<span class="comment">//递归左子树线索化</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果没有左孩子</span></span><br><span class="line">    {</span><br><span class="line">        p-&gt;LTag=Thread;<span class="comment">//前驱线索</span></span><br><span class="line">        p-&gt;lchild=pre;<span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//前驱没有右孩子</span></span><br><span class="line">    {</span><br><span class="line">        pre-&gt;RTag=Thread;<span class="comment">//后驱线索</span></span><br><span class="line">        pre-&gt;rchild=p;<span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">    }</span><br><span class="line">    pre=p;<span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">    InThreading(p-&gt;rchild);<span class="comment">//递归右子树线索化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658456052300.png" alt="线索化的思路"></p><p>有了线索二叉树之后，我们对其遍历时发现，其实就相当于是操作一个双向链表</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658456133754.png" alt="双向链表遍历"></p><p>遍历的代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T指向头结点，头结点左链lchild指向根结点，头结点右链指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BitThrTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    BItThrTree p;</span><br><span class="line">    p=T-&gt;lchild;<span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)<span class="comment">//空树或遍历结束时，p==T（头结点）</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag==Link)<span class="comment">//当LTag==0时，表示其没有左孩子，循环到中序序列的第一个结点</span></span><br><span class="line">        {</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//打印结点数据</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)</span><br><span class="line">        {<span class="comment">//存在后继结点，不存在右孩子且不指向头结点</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//D因为存在右孩子，所以不进入循环</span></span><br><span class="line">        }</span><br><span class="line">        p=p-&gt;rchild;<span class="comment">//指向结点D的右孩子I</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658457363746.png" alt="代码解释"></p><p><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构是不错的选择</strong></p><h2 id="树、森林与二叉树的转换"><a class="header-anchor" href="#树、森林与二叉树的转换">¶</a>树、森林与二叉树的转换</h2><p>在将树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行存储，<strong>所以借助二叉链表，树和二叉树可以相互进行转换</strong></p><h3 id="树转换为二叉树"><a class="header-anchor" href="#树转换为二叉树">¶</a>树转换为二叉树</h3><ol><li>加线。在所有兄弟结点之间加一条连线</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。<strong>注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</strong></li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658459926402.png" alt=""></p><h3 id="森林转换为二叉树"><a class="header-anchor" href="#森林转换为二叉树">¶</a>森林转换为二叉树</h3><p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作，步骤如下</p><ol><li>把每个树转换为二叉树</li><li>第一棵二叉树不动，<strong>从第二棵二叉树开始，一次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子</strong>，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658460850375.png" alt="森林转为二叉树"></p><h3 id="二叉树转换为树"><a class="header-anchor" href="#二叉树转换为树">¶</a>二叉树转换为树</h3><p>也就是树转换为二叉树的逆过程，步骤如下</p><ol><li>加线。若某结点的左孩子存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点……与该结点连线。</li><li>去线。删除二叉树中所有结点与其右孩子结点的连线</li><li>层次调整</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658461230926.png" alt=""></p><h3 id="二叉树转换为森林"><a class="header-anchor" href="#二叉树转换为森林">¶</a>二叉树转换为森林</h3><p>判断一棵二叉树能够转换为一棵树还是森林，<strong>只需要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</strong>，如果是转换成森林，步骤如下</p><ol><li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分类的二叉树</li><li>再将每棵分离后的二叉树转化为树即可。</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658471975240.png" alt=""></p><h3 id="树与森林的遍历"><a class="header-anchor" href="#树与森林的遍历">¶</a>树与森林的遍历</h3><p>树的遍历方式分为两种方式</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li></ol><p>森林的遍历也分为两种方式</p><ol><li><strong>前序遍历</strong>：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样的方式白遍历除去第一棵树的剩余数构成的森林，比如前面一张图中的森林按照前序遍历序列的结果是ABCDEFGHJI</li><li><strong>后序遍历</strong>：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次以同样的方式遍历除去第一棵树的剩余树构成的森林，还是以上面的森林图为例，按照后序遍历的结果就是BCDAFEJHIG</li></ol><p>我们可以发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p><p>这就告诉我们，<strong>当以二叉链表作为书的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现</strong></p><h2 id="赫夫曼树及其应用——最优二叉树"><a class="header-anchor" href="#赫夫曼树及其应用——最优二叉树">¶</a>赫夫曼树及其应用——最优二叉树</h2><p>赫夫曼编码是最基本的压缩编码方式，在编码中用到的特殊的二叉树称之为赫夫曼树</p><h3 id="引例"><a class="header-anchor" href="#引例">¶</a>引例</h3><p>首先举一个例子</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474794616.png" alt=""></p><p>我们用上面这一段代码来判断学僧的五级分制等级，其对应的流程图如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474905887.png" alt=""></p><p>但是在实际生活中，每个分数段占比是不同的，分布规律如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474962728.png" alt="分布规律"></p><p>那么对于70分以上大约占总数的80%的成绩都需要经过3次以上的判断才能得到结果，所以对其进行优化，得到下面的二叉树</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658475067397.png" alt=""></p><h3 id="赫夫曼树定义与原理"><a class="header-anchor" href="#赫夫曼树定义与原理">¶</a>赫夫曼树定义与原理</h3><p>我们先把这两棵二叉树简化成叶子结点带权的二叉树，如下图所示，其中A表示不及格、B表示及格、C表示中等、D表示良好、E表示优秀。<strong>每个叶子的分支线上的数字就是刚才我们提到的五级分制的成绩所占比例数</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658475507875.png" alt=""></p><p><strong>从树中的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度</strong>，如二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到D结点的路径长度为2。<strong>树的路径长度就是从树根到每一结点的路径长度之和</strong>。二叉树a的路径长度为1+1+2+2+3+3+4+4=20，二叉树b的路径长度为1+2+3+3+2+1+2+2=16</p><p>如果考虑到带权的结点，<strong>结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和</strong></p><blockquote><p><strong>假设有n个权值(w1,w2,w3……,wn)，构造一棵有n个结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称为赫夫曼树</strong>，也叫做最优二叉树</p></blockquote><p>有了上述定义，我们可以计算上面两棵树的WPL值</p><p>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315</p><p>注意：<strong>这里5是A叶子的权，1是A叶子的路径长度，其他同理</strong></p><p>二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658492477590.png" alt="WPL值的用处"></p><p>那么这样的二叉树是如何构造出来的，这样的二叉树是不是就是最优的赫夫曼树呢</p><p>下面给出解决办法</p><ol><li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即A5，E10，B15，D30，C40。</li><li>取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的作为左孩子，这里就是A为N1的左孩子，E为N1的右孩子，此时新结点的权值为15</li><li>将N1替换A和E，插入有序序列中，保持从小到大排列，即N1结点15，B15，D20，C40</li><li>重复步骤2，将N1与B作为新节点N2的两个子节点，N2的权值为30</li><li>接下来就是重复上述步骤</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493307449.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493319282.png" alt=""></p><p>上图即为流程图，此时二叉树的带权路径长度WPL为205小于二叉树b的WPL220，显然此时构造的二叉树才是最优的赫夫曼树</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493362584.png" alt="赫夫曼树的算法描述"></p><h3 id="赫夫曼编码"><a class="header-anchor" href="#赫夫曼编码">¶</a>赫夫曼编码</h3><p>赫夫曼树主要适用于解决数据传输的最优化问题</p><p>由于在各种语言中，字母或者汉字的出现频率是不同的</p><h4 id="例子-v7"><a class="header-anchor" href="#例子-v7">¶</a>例子</h4><p>假设要传输一段文字内容为"BADCADFEED"，我们会想到用二进制0和1来表示</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494223805.png" alt=""></p><p>我们假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，合起来正好是100%，所以我们可以重新按照赫夫曼树来规划它们</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493967428.png" alt="构造后的赫夫曼树"></p><p>此时我们对这六个字母<strong>用其从树根到叶子所经过路径的0或1来编码，可以得到如下定义</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494167497.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494234357.png" alt=""></p><p>可以看到使用赫夫曼树节约了存储和传输的成本</p><p>当我们接收到赫夫曼树压缩过后的新编码时，该如何进行解码是一个问题</p><p>由于每个字符的编码长度不等，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码</strong></p><p>我们可以发现赫夫曼树对于字母的编码不存在容易与1001、1000混淆的"10"和"100"编码</p><p>但是我们在解码的时候还是需要约定好同样的赫夫曼编码规则</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494824396.png" alt=""></p><h4 id="赫夫曼编码定义"><a class="header-anchor" href="#赫夫曼编码定义">¶</a>赫夫曼编码定义</h4><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494855213.png" alt=""></p><h3 id="树的总结"><a class="header-anchor" href="#树的总结">¶</a>树的总结</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494922433.png" alt=""></p><h1 id="图"><a class="header-anchor" href="#图">¶</a>图</h1><h2 id="图的定义"><a class="header-anchor" href="#图的定义">¶</a>图的定义</h2><blockquote><p>在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继元素。在树状结构中，数据元素之间有着明显的层次关系西，并且每一层上的数据元素可能和下一层中的多个元素相关，但只能和上一层中一个元素相关（就好比一对父母可以有多个孩子，但是一个孩纸只有一对父母）。</p></blockquote><blockquote><p><strong>图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关</strong></p></blockquote><p><strong>图是由顶点的有穷非空集合和顶点之间变得集合组成的，通常表示为：G(V,E)。其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</strong></p><p>对于图的定义，我们需要明确几点</p><ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，<strong>在图中数据元素叫做顶点</strong></li><li>在线性表可以有空表，在树中可以有空树。<strong>但是在图结构中，不允许没有顶点</strong>。在定义中，若V是顶点的集合，则强调了顶级集合V有穷非空</li><li>在图中，<strong>任何两个顶点之间都可能有关系，顶点之间的逻辑关系用边表示</strong></li></ul><h3 id="各种图定义"><a class="header-anchor" href="#各种图定义">¶</a>各种图定义</h3><blockquote><p><strong>无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi,Vj)来表示</strong>。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图</p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658506790378.png" alt="无向图"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658506813144.png" alt="无向图的定义"></p><blockquote><p><strong>有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧，用有序偶&lt;Vi,Vj&gt;，Vi称为弧尾，Vj称为弧头</strong>。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图</p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507035312.png" alt="有向图"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507064079.png" alt=""></p><p>需要注意弧头和弧尾的位置</p><p><strong>注意无向边是用()表示的，有向边是用&lt;&gt;表示的</strong></p><p><strong>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507189949.png" alt="非简单图"></p><p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有n个结点的无向完全图有n×(n-1)/2条边</p><blockquote><p>因为对于无向完全图，任意两个结点都需要存在边，那么任选一个结点，其连接的边数为n-1，有n个结点，乘以n即可，又因为是无向的，所以有重复的，需要除以2</p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507433419.png" alt="无向完全图"></p><p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有n个顶点的有向完全图有n×(n-1)条边（推导方法同上）</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507763980.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507826201.png" alt="有向图和无向图边数范围"></p><p><strong>有很多条边或弧的图称为稀疏图，反之称之为稠密图</strong>。这里的稀释和稠密都是相对概念</p><p>有些图的边或弧具有与他相关的数字，<strong>这种与图的边或弧相关的数叫做权</strong>。这些权可以表示从一个顶点到另一个顶点的距离或者耗费。<strong>这种带权的图通常称之为网</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508217686.png" alt="网"></p><p>下面是子图的定义</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508278580.png" alt=""></p><h3 id="图的顶点与边间的关系"><a class="header-anchor" href="#图的顶点与边间的关系">¶</a>图的顶点与边间的关系</h3><p><strong>无向图顶点的度和邻接点、关联</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508543901.png" alt=""></p><p><strong>有向图顶点的邻接、出入度</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508680038.png" alt=""></p><p><strong>无向图顶点之间的路径表示</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508771955.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508996796.png" alt="无向图顶点路径"></p><p>上图即为顶点B到顶点D的四种不同</p><p>有向图间顶点路径表示</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509086094.png" alt=""></p><p><strong>树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的</strong></p><p><strong>路径的长度是路径上的边或弧的数目</strong>，上图左侧路径长度为2，右侧长度为3</p><p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环，序列中顶点不重复出现的路径称之为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称之为简单回路或者简单环</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509572350.png" alt="环与简单环的区分"></p><h3 id="连通图相关术语"><a class="header-anchor" href="#连通图相关术语">¶</a>连通图相关术语</h3><p><strong>连通图的定义</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509634251.png" alt=""></p><p><strong>无向图中的极大连通子图称为连通分量</strong>。连通分量强调：</p><ul><li>是子图</li><li>子图是连通的</li><li>连通子图含有极大顶点数</li><li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li><li><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659013775048.png" alt="连通分量例子"></li></ul><p>上图蓝色和黄色环都是连通分量</p><p>图1是一个无向非连通图，但是他有两个连通分量，即图2和图3，而图4尽管是图1的子图，但它却不满足连通子图的极大顶点数</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509870590.png" alt=""></p><p><strong>强连通图的定义</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658510316515.png" alt=""></p><p><strong>连通图的生成树定义</strong></p><p>所谓的<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559123775.png" alt=""></p><p><strong>如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1条边，一定会构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径</strong>。不过有n-1条边并不一定是生成树</p><p><strong>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树</strong>。对于有向树的理解，可以把入度为0的顶点看作树中的根结点，其余顶点入度为1表明树中非根结点的双亲只有一个</p><p><strong>一个有向图的生成森林由若干棵有向树组成，含有图中的全部顶点，但只有足以构成若干棵不相交的有向树的弧</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559712143.png" alt="有向树和生成森林"></p><h3 id="图的定义与术语总结"><a class="header-anchor" href="#图的定义与术语总结">¶</a>图的定义与术语总结</h3><p>先前也有介绍，这里是汇总</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559797254.png" alt=""></p><h2 id="图的抽象数据类型"><a class="header-anchor" href="#图的抽象数据类型">¶</a>图的抽象数据类型</h2><p>图作为一种数据结构，它的抽象数据类型带有自己特点，不同应用需要不同的运算集合，构造不同的抽象数据操作</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559961774.png" alt=""></p><h3 id="图的存储结构"><a class="header-anchor" href="#图的存储结构">¶</a>图的存储结构</h3><p>从图的逻辑结构定义来看，<strong>图上任意一个顶点都可以被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系</strong></p><p>以下四张图片其实都是一个图，只不过顶点的位置不同</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560072053.png" alt=""></p><p><strong>由于任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系</strong></p><p>先前的存储方式来存储图结构的不可行性</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560213917.png" alt=""></p><h4 id="邻接矩阵"><a class="header-anchor" href="#邻接矩阵">¶</a>邻接矩阵</h4><blockquote><p><strong>图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中结点信息，一个二维数组(称为邻接矩阵)促成农户图中的边或弧的信息</strong></p></blockquote><p>下面是邻接矩阵存储图结构的一个例子</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560596124.png" alt=""></p><p>知道邻接矩阵之后，我们可以获取如下信息</p><ul><li>可以判定任意两顶点是否有边无边</li><li>要知道某个顶点的度，其实就是这个元素Vi在邻接矩阵中第i行或第i列的元素之和（这是因为无向图的边数组是个对称矩阵）。对于顶点V1的度就是1+0+1+0=2</li><li>求顶点Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，该处位置值为1则表示是邻接点</li></ul><p>下面是有向图的邻接矩阵</p><p><strong>有向图中由于存在出度入度，顶点V1的入度为1，是第V1列各数之和，顶点V1的出度为2，即第V1行的各数之和</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561214345.png" alt=""></p><p>对于网来说，每条边上都带有权，接下来使用邻接矩阵来表示网</p><p>此时边数组中的元素为权值，无法到达使用无穷符号来表示，自身到自身权值为0</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561472350.png" alt=""></p><p>邻接矩阵实现图的结构定义和代码实现如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659014166220.png" alt=""></p><h4 id="邻接表"><a class="header-anchor" href="#邻接表">¶</a>邻接表</h4><p>对于边数相对顶点较少的稀疏图，邻接矩阵是对存储空间的极大浪费。如下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561990643.png" alt=""></p><p>为了解决顺序存储结构预先分配内存造成的空间浪费问题，我们引出了链式存储的结构。所以我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。</p><p><strong>类比树中孩子表示法将结点存入数组，并对结点的孩子进行链式存储。我们把这种数组与链表相结合的存储方法称为邻接表</strong></p><p>邻接表的处理方法如下</p><ol><li>图中顶点用一个一维数组存储，使用数组可以较容易地读取顶点信息。此外，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息</li><li>图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以用单链表存储，<strong>无向图称为顶点Vi的边表，有向图则称为顶点Vi作为弧尾的出边表</strong></li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658562778894.png" alt="无向图邻接表"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658562890868.png" alt=""></p><p><strong>当我们想知道某个顶点的度时，就去查找这个顶点的边表中结点的个数。若要判断顶点Vi到Vj是否存在边，只需要测试顶点Vi的边表adjvex是否存在结点Vj的下标j就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻接点</strong></p><p>若是有向图，邻接表的结构是类似的。<strong>要注意的是有向图由于有方向，我们是以顶点为弧尾(起点)来存储边表的，这样很容易得到每个顶点的出度。但有时为了便于确定顶点的入度或以顶点尾弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点Vi都建立一个链接为Vi为弧头的表</strong></p><p>逆邻接表只需要按照求有向图的邻接表逆向求得即可</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658582916769.png" alt=""></p><p><strong>此时我们很容易就可以算出某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现</strong></p><p>对于带权值的网图，<strong>可以在边表结点定义中再增加一个weight的数据域，存储权信息即可</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658583879842.png" alt=""></p><p>结构定义和代码实现如下</p><h4 id="十字链表"><a class="header-anchor" href="#十字链表">¶</a>十字链表</h4><p>十字链表的存储结构代码实现</p><p><a href="http://data.biancheng.net/view/323.html">http://data.biancheng.net/view/323.html</a></p><p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，<strong>想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况</strong>。而十字链表就是解决这种问题的——<strong>将出边表与入边表结合起来</strong>，也就是每个顶点具有两条链表，一条是入边链表，另一条则是出边链表</p><p>对于顶点表和边表的结点结构重新定义</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658584667202.png" alt=""></p><blockquote><p>以下图为例，总共有六条弧，我们根据其起点和终点画出边表的结构(结点前两个位置是起点和终点，后两个位置是指向终点相同的下一条边和指向起点相同的下一条边)，然后进行连接。</p><p>对于A0顶点，后两个位置分别为入边表指针和出边表指针，黑线是出边表，对于A0，出边即以0为起点，此时只有01这个结点，所以指向01结点，而因为此时没有以0为起点的结点，所以01结点后两个位置设置为NULL。A1、A2、A3同理。</p><p>对于A4，43结点链接到出边表之后，还有一个42起点也是由4为起点的结点，所以43结点的第四个位置(也就是起点相同的下一条边)</p></blockquote><p><strong>对于入边表也是同理</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659014906155.png" alt=""></p><h4 id="邻接多重表"><a class="header-anchor" href="#邻接多重表">¶</a>邻接多重表</h4><p>邻接多重表代码实现</p><p><a href="http://data.biancheng.net/view/324.html">http://data.biancheng.net/view/324.html</a></p><p>十字链表是用于有向图的，而邻接多重表则适用于无向图，由于无向图不考虑方向，<strong>此时使用邻接表则会出现重复的情况</strong></p><p>在邻接表中，同样是将顶点存储于顺序表中，然后为每一个顶点配备一条链表，<strong>链表的每个结点存储的都是和当前顶点有直接关联的边</strong></p><p>顶点的定义和邻接表的相同</p><p>边表的结点结构体定义如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659028717214.png" alt=""></p><p>下面简单看个例子</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659028914337.png" alt=""></p><p>由于是无向边，所以ivex和jvex的位置可以互换，但是为了方便画图还是将与当前顶点相关的放在前面。</p><p>总共有01、02、12、23、30结点，开始进行连线，和当前顶点有关则链入链表中</p><p>对于V0，首先和01结点相连，接下来ilnk指向下一个与当前顶点相关的边，也就是5号路径，同理进行6号路径（此时没有与0相关的边，所以将ilink设置为NULL）。对于1，和当前V0结点无关，其下一边暂时标记为NULL。对于V1，则有关，所以使用7号路径进行连接。其他也是同理</p><h4 id="边集数组"><a class="header-anchor" href="#边集数组">¶</a>边集数组</h4><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659106849346.png" alt=""></p><h2 id="图的遍历"><a class="header-anchor" href="#图的遍历">¶</a>图的遍历</h2><blockquote><p><strong>图的遍历，即从图中某一顶点出发访问图中其余顶点，使得每一个顶点被访问且仅访问一次</strong></p></blockquote><p>其实对于两种遍历方式的不同，举个例子就可以进行理解</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659031094651.png" alt=""></p><p>以上述无向图的遍历为例，对两种遍历方式进行区分</p><p>深度遍历和广度遍历的代码</p><p><a href="http://data.biancheng.net/view/326.html">http://data.biancheng.net/view/326.html</a></p><h3 id="深度优先遍历——DFS"><a class="header-anchor" href="#深度优先遍历——DFS">¶</a>深度优先遍历——DFS</h3><p>所谓深度优先搜索，就是从图中的某个顶点出发，不停的寻找相邻的、尚未访问的顶点：<strong>图的深度优先遍历类似树的前序遍历</strong></p><ul><li>如果找到多个，则任选一个顶点，然后继续从该顶点出发；</li><li>如果一个都没有找到，则回退到之前访问过的顶点，看看是否有漏掉的；</li></ul><p>对于上述无向图的遍历过程</p><ol><li>V1与V2和V3相邻，且这两个结点都没被访问过，任选一个，我们先选V2</li><li>对于V2同理，V2和未被访问过的V4和V5相邻，选择V4</li><li>V4和未被访问的V8相邻，选择V8，然后再到V5</li><li>到V5时，此时和V5相邻的V8和V5都已经被访问过，需要回退到V8，对V8进行该过程，直到V1</li><li>此时对V3那边重复上述过程进行遍历</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659032578715.png" alt="顶点访问顺序"></p><h3 id="广度优先遍历——BFS"><a class="header-anchor" href="#广度优先遍历——BFS">¶</a>广度优先遍历——BFS</h3><p>所谓广度优先搜索，就是从图中的某个顶点出发，寻找紧邻的、尚未访问的顶点，找到多少就访问多少，然后分别从找到的这些顶点出发，继续寻找紧邻的、尚未访问的顶点。 <strong>图的广度优先遍历类似树的层序遍历</strong></p><p>步骤</p><ol><li>首先访问V1结点，此时有两个未被访问的与V1相邻的V2和V3结点，对他们两个结点进行访问（先后顺序自己决定）</li><li>然后再进行V2这边的遍历，V4和V5都是未被访问的与V2相邻的结点，对其进行访问，接着就是V8**，自 V8 之后，访问序列中再无其它顶点，意味着从 V1 顶点出发，无法再找到尚未访问的顶点。这种情况下，广度优先搜索算法会从图的所有顶点中重新选择一个尚未访问的顶点，然后从此顶点出发，以同样的思路继续寻找其它尚未访问的顶点。**</li><li>对于V3这一边的也是同理</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659033043654.png" alt="访问顺序"></p><p>对于上述过程使用队列来实现较为方便</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659077593147.png" alt=""></p><p>过程</p><ol><li>首先将第一个访问的顶点入队</li><li>然后队头A出队，将与A结点相邻且未被访问的顶点从左至右入队</li><li>接着队头B出队，将与B相邻且未被访问的顶点入队，也就是CIG</li><li>接着就是队头F出队，将与F相邻且未被访问的顶点出队，因为G被访问过，所以只有E入队</li><li>后面也是相同的，直到队列为空</li></ol><p><strong>使用队列的入队出队正好满足先对一个顶点的相邻且未被访问的顶点进行访问</strong></p><p>代码如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659076471338.png" alt=""></p><h3 id="邻接矩阵的深度优先遍历和广度优先遍历"><a class="header-anchor" href="#邻接矩阵的深度优先遍历和广度优先遍历">¶</a>邻接矩阵的深度优先遍历和广度优先遍历</h3><p>我们知道对于图是可以用邻接矩阵进行存储的，也就是通过0和1来表示两顶点之间的关系</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659033906924.png" alt=""></p><p>对于上面的邻接矩阵，我们分别进行深度优先遍历和广度优先遍历</p><h4 id="深度优先遍历"><a class="header-anchor" href="#深度优先遍历">¶</a>深度优先遍历</h4><ol><li>我们假设从0结点开始，然后在第0行寻找值为1的位置，表示两个结点间具有边，此时有1、2、3、4、6，我们选取1结点进行深度遍历。因为要回溯，<strong>我们还需要存储前一个结点的位置</strong></li><li>对第1行寻找值为1且未被遍历过的位置，也就是3，回溯的结点为0</li><li>接下来对结点3所在行进行查找，也就是2，回溯的结点是3</li><li>重复上述步骤，直到所有结点都被遍历完成</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075758476.png" alt="遍历的顺序"></p><p>图中上面一行存储的是回溯的位置（因为第二行中所有有边的结点都已经被遍历，回溯到4结点，所以2下一个是5）</p><p>代码</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075956216.png" alt=""></p><p>邻接表的深度优先遍历代码</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075986634.png" alt=""></p><h4 id="广度优先遍历"><a class="header-anchor" href="#广度优先遍历">¶</a>广度优先遍历</h4><ol><li>先对与0结点有边的进行遍历，有1、2、3、4、6</li><li>接着分别对1、2、3、4、6结点重复上述操作，直到所有结点都被遍历</li><li>最终在3结点发现其与5结点有边</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659076130788.png" alt=""></p><p>箭头表示从该结点出发进行遍历</p><p>邻接表的广度优先算法</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659509892924.png" alt=""></p><h2 id="最小生成树"><a class="header-anchor" href="#最小生成树">¶</a>最小生成树</h2><p>我们曾经提到过，<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的结点，但只有足以构成一棵树的n-1条边（也就是说在生成树任意链接两个结点都会形成环）</strong></p><p><strong>我们把构造连通网的最小代价生成树（即每条边的权值和最小）称为最小生成树</strong></p><p><strong>下面两种算法都是求最小生成树的算法，其本质都是贪心算法，但是贪心的策略不同</strong></p><p><a href="https://www.bilibili.com/video/BV1pT4y1v7Pm?spm_id_from=333.999.0.0&amp;vd_source=673ee828d0176702765d0a486b2a4554">最小生成树算法讲解</a></p><h3 id="普里姆-Prim-算法"><a class="header-anchor" href="#普里姆-Prim-算法">¶</a>普里姆(Prim)算法</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659100456751.png" alt="Prim算法的定义"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659101707889.png" alt=""></p><p>也就是说先创建一个只有初始结点的点集和空的边集，然后在找到与点集中相关的边，然后比较权值选出权最小的边，且边的另一顶点不在点集中(否则会形成环)，此时将该边加入到边集中，将另一顶点加入到点集中</p><p>例子如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659101404959.png" alt=""></p><p>对于上面这个连通图</p><ol><li>首先初始化已生成的点集为{1}，边集为空</li><li>找到和点集相关的边，其中17边权最小，且顶点7不在已生成边的点集中，所以将17边加入边集，顶点7加入点集，此时点集为{1,7}</li><li>然后重复上面的过程，和顶点1、7相邻的权最小的边是边76，顶点6不在点集中，则76边加入边集，顶点6加入点集</li><li>和上面一样，但是这里出现了一个问题，边16的权最小，但是由于6已经在点集中，所以边16不能加入边集，否则会形成环。所以选择边13</li><li>接下来就是重复上面的步骤，直至所有顶点都加入边集中</li></ol><p><strong>而代码实现，是基于邻接矩阵的</strong>，所系需要先创建邻接矩阵</p><p><a href="https://www.bilibili.com/video/BV1wh411o7Lc?p=5&amp;vd_source=673ee828d0176702765d0a486b2a4554">Prim算法代码讲解</a></p><p>下面的代码求得最小生成树的权值和</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 65537</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">float</span> MGraph[][n], <span class="keyword">int</span> v0, <span class="keyword">float</span>  sum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> lowCost[n], vSet[n];</span><br><span class="line"><span class="keyword">int</span> v, k, min;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">{</span><br><span class="line">lowCost[i] = MGraph[v0][i];<span class="comment">//权值赋值</span></span><br><span class="line">vSet[i] = <span class="number">0</span>;<span class="comment">//设置为未在树中</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">v = v0;</span><br><span class="line">vSet[v] = <span class="number">1</span>;<span class="comment">//表示v0结点已经被访问</span></span><br><span class="line">sum = <span class="number">0</span>;<span class="comment">//初始化最小生成树的权值为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="comment">//将剩余顶点加入树中</span></span><br><span class="line">{</span><br><span class="line">min = INF;<span class="comment">//初始化设置一个较大的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">{<span class="comment">//遍历树中顶点到树外顶点的权</span></span><br><span class="line"><span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; lowCost[j] &lt; min)</span><br><span class="line">{</span><br><span class="line">min = lowCost[j];<span class="comment">//如果不在树中</span></span><br><span class="line">k = j;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">vSet[k] = <span class="number">1</span>;<span class="comment">//设置该顶点已经在树中</span></span><br><span class="line">v = k;</span><br><span class="line">sum += min;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; MGraph[v][j] &lt; lowCost[j])<span class="comment">//更新未加入树顶点的权值</span></span><br><span class="line">{</span><br><span class="line">lowCost[j] = MGraph[v][j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在开始讲解代码之前，我们先来看一下代码中的变量，<strong>V0表示生成树的初始顶点，lowCost数组当前生成树到图中其余顶点的边的最小权值，vSet数组存储各顶点被加入生成树的状态，1表示已经加入，0表示未加入，n表示顶点个数，MGraph数组是邻接矩阵，min表示最小权值，V始终指向刚并入树中的顶点</strong>（注意：顶点到顶点自身的权值在这里设置为无穷大）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">{</span><br><span class="line">lowCost[i] = MGraph[v0][i];<span class="comment">//权值赋值</span></span><br><span class="line">vSet[i] = <span class="number">0</span>;<span class="comment">//设置为未在树中</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">v = v0;</span><br><span class="line">vSet[v] = <span class="number">1</span>;<span class="comment">//表示v0结点已经被访问</span></span><br><span class="line">sum = <span class="number">0</span>;<span class="comment">//初始化最小生成树的权值为0</span></span><br></pre></td></tr></tbody></table></figure><p>表示并入树的第一个顶点为V0</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659292214785.png" alt=""></p><p>对于图中的图最小生成树初始化如上图</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="comment">//将剩余顶点加入树中</span></span><br><span class="line">{</span><br><span class="line">min = INF;<span class="comment">//初始化设置一个较大的数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">{<span class="comment">//遍历树中顶点到树外顶点的权</span></span><br><span class="line"><span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; lowCost[j] &lt; min)</span><br><span class="line">{</span><br><span class="line">min = lowCost[j];<span class="comment">//如果不在树中</span></span><br><span class="line">k = j;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">vSet[k] = <span class="number">1</span>;<span class="comment">//设置该顶点已经在树中</span></span><br><span class="line">v = k;</span><br><span class="line">sum += min;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; MGraph[v][j] &lt; lowCost[j])<span class="comment">//更新权值</span></span><br><span class="line">{</span><br><span class="line">lowCost[j] = MGraph[v][j];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面就是生成最小生成树的过程</p><p>首先整个大循环就是对其余n-1个顶点加入生成树的过程</p><ol><li><p>第一个for循环：遍历当前顶点的lowCost数组，找到其中最小的权值并赋值给min（以便后续计算sum），并且标记最小权值的边的顶点（设置为已加入树中）</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659292941199.png" alt=""></p></li><li><p>第二个for循环：由于树的长大，当前生成树树到其余顶点的权值（lowCost数组的值）也会发生变化，需要使用此for循环进行改变，而由于存储的是最小权值，所以<strong>需要小于lowCost对应位置的值</strong>。而<strong>对于已经并入树的顶点，其权值已经进行了比较，所以只针对那些vSet值为0的顶点</strong></p></li></ol><h3 id="克鲁斯卡尔-Kruskal-算法"><a class="header-anchor" href="#克鲁斯卡尔-Kruskal-算法">¶</a>克鲁斯卡尔(Kruskal)算法</h3><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659102484953.png" alt="Kruskal的定义"></p><p><strong>Kruskal算法直接以边为目标去构建</strong>，因为权值是在边上的，直接去找最小权值的边来构建生成树是很自然的想法，<strong>不过在构建时需要判断是否会形成环</strong></p><p>还是以上面的连通图为例子，使用Kruskal算法进行最小生成树的构造</p><ol><li>首先先对每条边的权值进行由小到大的排序，并将每个点各自生成一个集合</li><li>权值2最小，我们选取6、7顶点，因为这两者不在同一集合中，不会形成环。接着将6、7顶点各自的集合合并为一个集合，也就是{6,7}。对于4、5也是同理</li><li>接着就是权值3，因为{6,7}集合中没有1，所以不会星辰环，合并后的集合为{1,6,7}</li><li>下一步为权值4，但是顶点1、6在同一集合中，所以不行</li><li>后面的也是同理，接着是权值为6、7的边，在这之后，集合为{1,6,7,3,2}，还有一个{4,5}</li><li>对于权值为8，23边显然不行，因为2、3顶点在同一集合中，所以只能是3、4边，此时加入集合的是{4,5}这一含顶点4的整个集合。所以最后结果为{1,6,7,3,2,4,5}</li></ol><p><strong>使用代码进行实现时，依旧是邻接矩阵为输入数据的</strong></p><h4 id="并查集"><a class="header-anchor" href="#并查集">¶</a>并查集</h4><p>上面所说的判断是否处于同一集合，正是并查集</p><p><a href="https://www.bilibili.com/video/BV1mb4y1x7cH?spm_id_from=333.337.search-card.all.click&amp;vd_source=673ee828d0176702765d0a486b2a4554">并查集视频讲解</a></p><ol><li>并查集的初始情况</li></ol><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294269254.png" alt=""></p><p>2.找到权值最小的边并且判断一条边的两个顶点是否属于一棵树，然后将边的终点作为起点的子树</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294503426.png" alt=""></p><p><strong>使用代码判断两个顶点是否属于同一棵树则需要一直往其根结点找，如果两顶点所在树的根结点不同，表示不属于同一棵树</strong>，代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (p != v[p])</span><br><span class="line">{</span><br><span class="line">p = v[p];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.最终效果</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294711806.png" alt=""></p><h4 id="代码详解与分析"><a class="header-anchor" href="#代码详解与分析">¶</a>代码详解与分析</h4><p><a href="https://www.bilibili.com/video/BV1wh411o7Lc?p=6&amp;vd_source=673ee828d0176702765d0a486b2a4554">Kruskal算法代码讲解</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> a, b;<span class="comment">//a表示边的起始顶点，b表示边的终点顶点</span></span><br><span class="line"><span class="keyword">int</span> w;<span class="comment">//边的权</span></span><br><span class="line">}Road;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100</span>];<span class="comment">//存储并查集的结构，在这里存储其父结点的下标</span></span><br><span class="line">Road road[maxSize];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">while</span> (p != v[p])<span class="comment">//当它的父结点不是本身，往上层找到其根结点，只有根结点才会保证其存储的值和其下标相同</span></span><br><span class="line">{</span><br><span class="line">p = v[p];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Road roda[], <span class="keyword">int</span> n, <span class="keyword">int</span> e, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">{</span><br><span class="line">v[i] = i;<span class="comment">//初始化并查集数组，将数组下标赋值给下标位置处，表示每个顶点都是根结点</span></span><br><span class="line">}</span><br><span class="line">sort(road, e);<span class="comment">//权值排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; ++i)</span><br><span class="line">{</span><br><span class="line">a = Getroot(road[i].a);</span><br><span class="line">b = Getroot(road[i].b);</span><br><span class="line"><span class="keyword">if</span> (a != b)<span class="comment">//根结点不同，表示</span></span><br><span class="line">{</span><br><span class="line">v[a] = b;<span class="comment">//生成子树</span></span><br><span class="line">sum += road[i].w;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="存储结构"><a class="header-anchor" href="#存储结构">¶</a>存储结构</h5><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294750516.png" alt=""></p><p>按照代码最终可得</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294852056.png" alt=""></p><p>在v数组中，下标为3位置存储的值为0，<strong>表示3下标的顶点其父结点为下标为0的顶点</strong>。</p><h2 id="最短路径"><a class="header-anchor" href="#最短路径">¶</a>最短路径</h2><p><strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点</strong></p><blockquote><p>最短路径：<strong>在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径</strong></p></blockquote><p>最短路径与最小生成树不同，<strong>路径上不一定包含n个顶点，也不一定包含n-1条边</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659330246464.png" alt="网图"></p><h3 id="迪杰斯特拉-Dijkstra-算法"><a class="header-anchor" href="#迪杰斯特拉-Dijkstra-算法">¶</a>迪杰斯特拉(Dijkstra)算法</h3><p><strong>适用于解决单源最短路径</strong></p><p>这是一个按照路径长度递增的次序产生最短路径的算法</p><p>下面是迪杰斯特拉算法的整个过程</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659330361377.png" alt=""></p><blockquote><p><strong>整个过程就是一步步求出他们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径</strong></p></blockquote><p>上面的图可以简化成三个步骤</p><ol><li><p>**初始化：**先找出从源点V0到各终点Vk的直达路径(V0,Vk)，即通过一条弧到达的路径</p></li><li><p>**选择：**从这些路径中找出一条长度最短的路径（V0,u）</p></li><li><p>**更新：**然后对其余各条路径进行适当调整，<strong>若在图中存在弧(u,Vk)，且(V0,u)+(u,Vk)&lt;(V0,Vk)，则以路径(V0,u,Vk)代替(V0,Vk)</strong></p><p><strong>简单点理解就是两条弧的权值之和小于原本一条弧的权值</strong></p></li><li><p>在调整后的各条路径中，再找长度最短的路径，以此类推</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Pathmatrix[MAXVEX];<span class="comment">//用于存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX];<span class="comment">//用于存储到各点最短路径的权值和</span></span><br><span class="line"><span class="comment">/*Dijkstra算法，求有向网G的V0顶点到其余顶点V最短路径P[v]及带权长度D[v]</span></span><br><span class="line"><span class="comment">* P[v]的值为前驱顶点下标，D[v]表示从V0到v的最短路径长度和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortPath_Dijkstra</span><span class="params">(MGraph G, <span class="keyword">int</span> v0, Pathmatrix p, ShortPathTable D)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> v, w, k, min;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">final</span>[MAXVEX];<span class="comment">//final[w]=表示求得顶点V0到Vw的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++)<span class="comment">//初始化数据</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">0</span>;<span class="comment">//全部顶点初始化为未知最短路径状态</span></span><br><span class="line">D[v] = G.matrix[v0][v];<span class="comment">//将与v0有连线的顶点加上权值</span></span><br><span class="line">p[v] = <span class="number">0</span>;<span class="comment">//初始化路径数组P为0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">D[v0] = <span class="number">0</span>;<span class="comment">//v0到v0的路径为0</span></span><br><span class="line"><span class="keyword">final</span>[v0] = <span class="number">1</span>;<span class="comment">//v0到v0不需要求路径</span></span><br><span class="line"><span class="comment">//开始主循环，每次求得V0到某个v顶点的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">{</span><br><span class="line">min = INFINITY;<span class="comment">//当前所指离V0顶点的最近距离</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[w] &lt; min)</span><br><span class="line">{</span><br><span class="line">k = w;</span><br><span class="line">min = D[w];<span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[k] = <span class="number">1</span>;<span class="comment">//将目前找到的最近的顶点置为1</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//修正当前最短路径及距离</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//如果经过v顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (min + G.matrix[k][w]) &lt; D[w])</span><br><span class="line">{</span><br><span class="line"><span class="comment">//说明找到了更短的路径，修改D[w]和p[w]</span></span><br><span class="line">D[w] = min + G.matrix[k][w];<span class="comment">//修改当前路径长度</span></span><br><span class="line">p[w] = k;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结合代码和算法的步骤进行讲解</p><h4 id="思路和数组说明"><a class="header-anchor" href="#思路和数组说明">¶</a>思路和数组说明</h4><p>首先将顶点分为两组，S集合表示已求出最短路径的顶点的集合，T集合表示尚未确定最短路径的顶点集合，<strong>在代码中使用final数组存储各顶点是否被确定最短路径，值为1表示已被确定，在S集合中，0则为未被确定，在T集合中</strong>。其中我们需要保证两点：</p><ol><li>从源点V0到S中各顶点的最短路径长度都不大于从V0到T中任何顶点的最短路径长度</li><li>每个顶点对应一个距离值：S中顶点对应从V0到此顶点的最短路径，T中顶点对应从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度</li></ol><p><strong>使用D数组存储该顶点到其他顶点的最短路径，当无法直达的时候，D的值记为无穷大，到自身的值记为0</strong>。代码中的G表示图的邻接矩阵，p数组用于存储最短路径的顶点下标，V0表示源点</p><h4 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++)<span class="comment">//初始化数据</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span>[v] = <span class="number">0</span>;<span class="comment">//全部顶点初始化为未知最短路径状态</span></span><br><span class="line">D[v] = G.matrix[v0][v];<span class="comment">//将与v0有连线的顶点加上权值</span></span><br><span class="line">p[v] = <span class="number">0</span>;<span class="comment">//初始化路径数组P为0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">D[v0] = <span class="number">0</span>;<span class="comment">//v0到v0的路径为0</span></span><br><span class="line"><span class="keyword">final</span>[v0] = <span class="number">1</span>;<span class="comment">//v0到v0不需要求路径</span></span><br></pre></td></tr></tbody></table></figure><p>上面这一段代码只将源点V0的final值设置为1，表示已经确定最短路径，其最短路径D的值为0（到自身）</p><h4 id="选择最短路径"><a class="header-anchor" href="#选择最短路径">¶</a>选择最短路径</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">min = INFINITY;<span class="comment">//当前所指离V0顶点的最近距离</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[w] &lt; min)</span><br><span class="line">{</span><br><span class="line">k = w;</span><br><span class="line">min = D[w];<span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[k] = <span class="number">1</span>;<span class="comment">//将目前找到的最近的顶点置为1</span></span><br></pre></td></tr></tbody></table></figure><p>初始化完成后，先遍历与V0相关的邻接矩阵的权值，找到最小的权值的边，将其加入S集合中，如下图所示</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659452604497.png" alt=""></p><h4 id="更新"><a class="header-anchor" href="#更新">¶</a>更新</h4><p>因为S集合出现新的顶点，到某顶点可以直达，也可以中转，所以要更新最短路径</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//修正当前最短路径及距离</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//如果经过v顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (min + G.matrix[k][w]) &lt; D[w])</span><br><span class="line">{</span><br><span class="line"><span class="comment">//说明找到了更短的路径，修改D[w]和p[w]</span></span><br><span class="line">D[w] = min + G.matrix[k][w];<span class="comment">//修改当前路径长度</span></span><br><span class="line">p[w] = k;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上述例子讲解，对D中的所有元素进行修改，<strong>如果该顶点未被加入S集合并且源点V0到V2顶点V的最短路径+V2顶点与V3顶点的权值要&lt;从源点直达V3顶点的权值的话，则需要修改V0与V3顶点的最短路径值D</strong>，显然这里需要，因为V0与V3无直达路径，所以V0与V3权值为无穷大。并且将k赋值给p数组中V3对应的值，<strong>表示V3顶点所在最短路径的前一个顶点是V2</strong></p><p>如下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659453562717.png" alt=""></p><h4 id="重复"><a class="header-anchor" href="#重复">¶</a>重复</h4><p><strong>接下来就是重复上述步骤，直至final数组中的值全为1</strong></p><h3 id="弗洛伊德-Floyd算法"><a class="header-anchor" href="#弗洛伊德-Floyd算法">¶</a>弗洛伊德-Floyd算法</h3><p><strong>适用于解决所有顶点间的最短路径</strong></p><p>在Dijkstra算法中，我们知道了如何计算某个顶点到其余顶点的最短路径，但有时候我们需要求得图中所有顶点到其余顶点的最短路径，此时可以进行n次Dijkstra算法，也可以采用接下来介绍的这种算法</p><p>算法思想：</p><ol><li>逐个顶点试探</li><li>从Vi到Vj的所有可能存在的路径中</li><li>选出一条长度最短的路径</li></ol><p>求最短路径步骤：</p><ol><li>首先画出图的邻接矩阵</li><li><strong>接着逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之，否则维持原值。当所有顶点试探完毕，算法结束</strong></li></ol><p>整个过程如下图</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659461189305.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Pathmatrix[MAXVEX][MAXVEX];<span class="comment">//用于存储中间结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="comment">//Floyd算法，求网图G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortPath_Floyd</span><span class="params">(MGraph G, Pathmatrix P, ShortPathTable D)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> v, w, k;</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)<span class="comment">//初始化D与P</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//D[v][w]值即为对应点间的权值</span></span><br><span class="line">{</span><br><span class="line">D[v][w] = G.matrix[v][w];</span><br><span class="line">P[v][w] = <span class="number">-1</span>;<span class="comment">//初始化P</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.numVertexes; ++k)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (D[v][w] &gt; D[v][k] + D[k][w])</span><br><span class="line">{</span><br><span class="line"><span class="comment">//如果经过下标为k顶点路径比原两点间路径更短</span></span><br><span class="line"><span class="comment">//将当前两点间权值设置为更小的一个</span></span><br><span class="line">D[v][w] = D[v][k] + D[k][w];</span><br><span class="line">P[v][w] = k;<span class="comment">//路径设置为下标为k的顶点</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="初始化-v2"><a class="header-anchor" href="#初始化-v2">¶</a>初始化</h4><p><strong>D数组存储的是顶点之间最短路径的值，P数组存储顶点之间的中间顶点，如果是两顶点直达，则P中的值为-1，表示没有中间顶点</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)<span class="comment">//初始化D与P</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//D[v][w]值即为对应点间的权值</span></span><br><span class="line">{</span><br><span class="line">D[v][w] = G.matrix[v][w];</span><br><span class="line">P[v][w] = <span class="number">-1</span>;<span class="comment">//初始化P</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将邻接矩阵赋值到D数组进行初始化</p><p>将P中的值全部赋值为-1，因为开始时没有中间顶点，所以全部为-1</p><h4 id="遍历修改"><a class="header-anchor" href="#遍历修改">¶</a>遍历修改</h4><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.numVertexes; ++k)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (D[v][w] &gt; D[v][k] + D[k][w])</span><br><span class="line">{</span><br><span class="line"><span class="comment">//如果经过下标为k顶点路径比原两点间路径更短</span></span><br><span class="line"><span class="comment">//将当前两点间权值设置为更小的一个</span></span><br><span class="line">D[v][w] = D[v][k] + D[k][w];</span><br><span class="line">P[v][w] = k;<span class="comment">//路径设置为下标为k的顶点</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来的三层循环，就是不断在两顶点直达路径中加入中间顶点，然后与直达的权值进行比较，得到最小的权值。并且将P数组中对应位置的值改为中间顶点k，<strong>表示两顶点以该顶点k为中间顶点时路径长度最短</strong></p><h4 id="求最短路径"><a class="header-anchor" href="#求最短路径">¶</a>求最短路径</h4><p>经过上述过程，我们得到了P数组，其存储的是中间顶点的信息，我们可以通过P数组打印每个顶点的最短路径</p><p>代码如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> path[][MAXVEX])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (path[u][v] == <span class="number">-1</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//直接输出</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> mid = path[u][v];</span><br><span class="line">printPath(u, mid, path);</span><br><span class="line">printPath(mid, v, path);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当path数组的值为-1，表示两顶点可以直达，也就是无中间顶点</p><p>u、v表示通过path数组寻找u、v顶点之间的最短路径</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659462504467.png" alt=""></p><p>以上图为例手动查找从顶点1到顶点0最短路径：</p><ol><li>首先看P【1】【0】位置处为3，表示10顶点之间的最短路径存在中间顶点3，1-&gt;3-&gt;0</li><li>首先看P【1】【3】位置处为-1，表示13顶点之间的最短路径是直达的</li><li>接着是P【3】【0】位置处为2，表示30顶点之间的最短路径存在中间顶点2，1-&gt;3-&gt;2-&gt;0</li><li>首先看P【3】【2】位置处为-1，表示32顶点之间的最短路径是直达的</li><li>最后P【2】【0】位置处为-1，表示20顶点之间的最短路径是直达的，此时10顶点最短路径已确定，为1-&gt;3-&gt;2-&gt;0</li></ol><p>整个过程就是递归的过程，代入代码中理解即可</p><h2 id="拓扑排序"><a class="header-anchor" href="#拓扑排序">¶</a>拓扑排序</h2><p><strong>主要针对有向无环图</strong></p><blockquote><p>有向无环图：无环的有向图，简称DAG图</p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659379228604.png" alt="有向无环图"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659379249838.png" alt="有向无环图的实际例子"></p><blockquote><p><strong>AOV网</strong>：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<strong>顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网</strong>。<strong>AOV网中不能存在回路</strong>，举个例子：让某个活动的开始要以自己完成作为先决条件，这显然是不可能的</p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659465238751.png" alt="AOV网"></p><blockquote><p><strong>拓扑序列</strong>：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1，V2，V3……，Vn，满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必须在Vj之前，则我们成这样的顶点序列为一个拓扑序列</p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659465489274.png" alt=""></p><p><strong>拓扑排序其实就是对一个有向图构造拓朴序列的过程</strong>。构造时会有两种结果：</p><ol><li>此网的全部顶点都被输出，则<strong>说明它是不存在环的AOV网</strong></li><li>如果输出的定点少了，则<strong>说明这个网存在环，不是AOV网</strong></li></ol><h3 id="拓扑排序算法"><a class="header-anchor" href="#拓扑排序算法">¶</a>拓扑排序算法</h3><p>对AOV网进行拓朴排序的基本思路是：<strong>从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止</strong></p><p>在拓扑排序中，由于要删除顶点，<strong>所以使用邻接表更为方便</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466302538.png" alt="数据结构"></p><p><strong>其中in表示入度</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466327933.png" alt=""></p><p>对于这样的一幅图AOV网，其邻接表如下</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466387849.png" alt=""></p><h3 id="拓扑排序代码实现"><a class="header-anchor" href="#拓扑排序代码实现">¶</a>拓扑排序代码实现</h3><p><strong>栈只是用于存储入度为0的顶点，只作为容器，也可以使用其他数据结构进行存储</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>//边表结点</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line"><span class="keyword">int</span> weight;<span class="comment">//用于存储权值，对于非网图可以不需要</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span><span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">}EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> in;<span class="comment">//顶点入度</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//顶点域。存储顶点信息</span></span><br><span class="line">EdgeNode* firstedge;<span class="comment">//边表头指针</span></span><br><span class="line">}VertexNode,AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">AdjList adjList;</span><br><span class="line"><span class="keyword">int</span> numVertexes, numEdges;<span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">}qraphAdjList,*GraphAdjList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">EdgeNode* e;</span><br><span class="line"><span class="keyword">int</span> i, k, gettop;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;<span class="comment">//用于栈指针下标</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用于统计输出顶点的个数</span></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">stack</span>;<span class="comment">//建立栈存储入度为0的顶点</span></span><br><span class="line"><span class="built_in">stack</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">stack</span>[++top] = i;<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (top != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">gettop = <span class="built_in">stack</span>[top--];<span class="comment">//出栈</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d -&gt;"</span>, GL-&gt;adjList[gettop].data);</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge;e; e = e-&gt;next)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//对此顶点弧表遍历</span></span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))<span class="comment">//将k号顶点邻接点的入度减1</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">stack</span>[++top] = k;<span class="comment">//若为0则入栈，以便于下次循环输出</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (count &lt; GL-&gt;numVertexes)<span class="comment">//如果count小于顶点数，说明存在环</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们以上面的AOV网为例，跟着代码走一遍</p><p>​1.首先初始化一些数据</p><p>​2.然后将入度为0的顶点入栈</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">stack</span>[++top] = i;<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此时stack应该为{0,1,3}</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659507694259.png" alt=""></p><p>​3.while循环，当栈中有数据元素时，始终寻呼那</p><p>​4.接下来V3出栈，gettop=3，然后count+1表示输出顶点个数+1</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gettop = <span class="built_in">stack</span>[top--];<span class="comment">//出栈</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d -&gt;"</span>, GL-&gt;adjList[gettop].data);</span><br><span class="line">count++;</span><br></pre></td></tr></tbody></table></figure><p>​5.然后<strong>对V3顶点对应的弧链表进行遍历</strong>，找到V3连接的两个顶点V2和V13，<strong>并且将他们的入度减少一位</strong>，此时V2和V13的in值都为1.<strong>他的目的是为了将V3顶点上的弧删除</strong></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//对此顶点弧表遍历</span></span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))<span class="comment">//将k号顶点邻接点的入度减1</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">stack</span>[++top] = k;<span class="comment">//若为0则入栈，以便于下次循环输出</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659508159107.png" alt=""></p><p>6.再次循环，此时处理的是V1顶点。经过出栈、打印、count=2后，我们对V1到V2、V4、V8的弧进行遍历。并同样减少了它们的入度数，<strong>此时V2的入度为0</strong>，由if语句判断入度是否为0，<strong>V2入栈</strong>。<strong>如果没有在顶点表中加入in这个入度数据域，if的判断则必须是循环（循环遍历找到入度为0的结点），这显然是要消耗时间的</strong>。而引入in数据域是利用空间换取了时间</p><p>7.接下来就是重复上述步骤</p><p>8.<strong>最终拓扑排序打印结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;7-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11</strong>，<strong>当然这结果并不是唯一的一种拓扑排序方案</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659508786474.png" alt=""></p><h3 id="逆拓扑排序"><a class="header-anchor" href="#逆拓扑排序">¶</a>逆拓扑排序</h3><p>逆拓扑排序类似拓扑排序，<strong>不过将入度改为出度</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659509341995.png" alt=""></p><p><strong>可以使用深度优先遍历来进行逆拓扑排序</strong>，也可以修改拓扑排序的代码进行逆拓扑排序</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659536020777.png" alt=""></p><p>对上图进行深搜，先从0开始，接下来是1顶点，由于1顶点有后继顶点，继续进行，访问顶点3，而顶点3无后继顶点，<strong>也就是出度为0</strong>，输出顶点3，<strong>并且删除边13和23</strong>，按照深搜此时需要回溯到顶点1，<strong>由于删除了边13，所以1的出度为0</strong>，符合出度为0的顶点，输出顶点1，<strong>并且删除边01</strong>，按照深搜，接下来访问2顶点，<strong>2顶点出度为0</strong>，输出顶点2，最后输出顶点0。<strong>上述过程中每次访问顶点都需要修改visit数组中的值为1，表示已经访问</strong></p><p>同时，我们也可以在访问的时候入栈，输出时（即出度为0时）出栈</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659537159826.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659537180219.png" alt=""></p><p>逆拓扑排序：3-&gt;1-&gt;2-&gt;0</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>  v, AGraph* G)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">visit[v] = <span class="number">1</span>;</span><br><span class="line">ArcNode* q = G-&gt;adjList[v].first;</span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (visit[q-&gt;adjV] == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">DFS(q-&gt;adjV, G);</span><br><span class="line">}</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="关键路径"><a class="header-anchor" href="#关键路径">¶</a>关键路径</h2><p><strong>主要针对有向无环图</strong></p><p>拓扑排序主要是为了解决一个工程能否顺序进行的问题，但有时我们还需要解决工程完成需要的最短时间问题</p><p><strong>因此我们如果要对一个流程图获得最短时间，就必须要分析它们的拓扑关系，比能找到当中的关键路径，这个流程的时间就是最短时间</strong></p><blockquote><p><strong>AOE网:在表示一个工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网</strong>，其中，<strong>没有出边的顶点称为终点或汇点，没有入边的顶点称之为始点或源点</strong></p></blockquote><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538233859.png" alt=""></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538411703.png" alt="AOE网的特点"></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538440517.png" alt=""></p><blockquote><p><strong>我们把路径上各个活动所持续的是简直和称为路径长度，从源点到汇点足有最大长度的路径叫关键路径</strong></p></blockquote><p>在上图的AOE网中，开始-&gt;发动机完成-&gt;部件集中到位-&gt;组装完成就是关键路径，路径长度为5.5</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659539034196.png" alt="关键路径的应用"></p><h3 id="关键路径算法原理"><a class="header-anchor" href="#关键路径算法原理">¶</a>关键路径算法原理</h3><p>关键路径实例理解</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659549838521.png" alt=""></p><blockquote><p>也就是说，<strong>我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较他们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。否则不是</strong></p></blockquote><p>所以我们需要定义如下几个参数</p><blockquote><p><strong>事件既可以表示前一个活动的结束，也可以用于表示下一个活动的开始</strong>，如下图，V2既可以表示a1活动的结束，也可以表示a2活动的开始，而只有a1活动完成后a2活动才能开始，所以a2的最早开始事件（也就是V2事件最早发生时间）的值为30</p></blockquote><ol><li>事件的最早发生时间etv(earlist time of vertex)：即顶点Vk的最早发生时间</li><li>事件的最晚发生时间ltv(latesttime of vertex)：即顶点Vk的最晚发生时间，<strong>也就是每个顶点对应的事件最晚需要开始的事件</strong>，超出此事件将会延误整个工期</li><li>活动的最早开工时间ete(earlist time of edge)：即弧ak的最早发生时间</li><li>活动的最晚开工时间lte(latest time of edge)：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间</li></ol><p><strong>我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断ak是否为关键活动</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723716756.png" alt=""></p><h3 id="关键路径算法"><a class="header-anchor" href="#关键路径算法">¶</a>关键路径算法</h3><p>关于过程，可以看<a href="https://www.bilibili.com/video/BV1nJ411V7bd?p=136&amp;spm_id_from=pageDriver&amp;vd_source=673ee828d0176702765d0a486b2a4554">关键路径讲解</a></p><p>将下图的AOE网转化为邻接表的结构图，与拓扑排序时邻接表结构不同的地方在于，<strong>这里的弧链表增加了weight域，用于存储弧的权值</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659550444650.png" alt=""></p><p><strong>求事件的最早发生时间，也就是顶点的先后次序，就是我们从头到尾找拓扑序列的过程</strong>。因此在求关键路径之前，需要先调用依次拓扑序列算法的代码来计算etv和拓扑排序列表</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>//边表结点</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line"><span class="keyword">int</span> weight;<span class="comment">//用于存储权值，对于非网图可以不需要</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span><span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">}EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"><span class="keyword">int</span> in;<span class="comment">//顶点入度</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//顶点域。存储顶点信息</span></span><br><span class="line">EdgeNode* firstedge;<span class="comment">//边表头指针</span></span><br><span class="line">}VertexNode,AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">AdjList adjList;</span><br><span class="line"><span class="keyword">int</span> numVertexes, numEdges;<span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">}qraphAdjList,*GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* etv, * ltv;<span class="comment">//事件最早发生时间和最迟发生时间</span></span><br><span class="line"><span class="keyword">int</span>* stack2;<span class="comment">//用于存储拓扑序列的栈</span></span><br><span class="line"><span class="keyword">int</span> top2;<span class="comment">//用于stack2的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">EdgeNode* e;</span><br><span class="line"><span class="keyword">int</span> i, k, gettop;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;<span class="comment">//用于栈指针下标</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用于统计输出顶点的个数</span></span><br><span class="line"><span class="keyword">int</span>* <span class="built_in">stack</span>;<span class="comment">//建立栈存储入度为0的顶点</span></span><br><span class="line"><span class="built_in">stack</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">stack</span>[++top] = i;<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">top2 = <span class="number">0</span>;<span class="comment">//初始化栈指针为0</span></span><br><span class="line">etv = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//事件最早发生时间</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">{</span><br><span class="line">etv[i] = <span class="number">0</span>;<span class="comment">//初始化为0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">stack2 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//初始话</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (top != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">gettop = <span class="built_in">stack</span>[top--];<span class="comment">//出栈</span></span><br><span class="line">count++;</span><br><span class="line">stack2[++top2] = gettop;<span class="comment">//将弹出的顶点序号压入拓扑序列的栈</span></span><br><span class="line"><span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//对此顶点弧表遍历</span></span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))<span class="comment">//将k号顶点邻接点的入度减1</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">stack</span>[++top] = k;<span class="comment">//若为0则入栈，以便于下次循环输出</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> ((etv[gettop] + e-&gt;weight &gt; etv[k]))<span class="comment">//求各顶点事件最早发生时间</span></span><br><span class="line">{</span><br><span class="line">etv[k] = etv[gettop] + e-&gt;weight;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (count &lt; GL-&gt;numVertexes)<span class="comment">//如果count小于顶点数，说明存在环</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码和拓扑排序算法差不多，就是加了一些代码，在讲解这些代码之前，我们先来看看<strong>如何计算事件的最早发生时间</strong>，也就是etv的值(边是活动，顶点表示事件的开始和结束)。</p><p>事件的最早发生时间就是前一事件最早发生时间+活动持续时间的最大值——<strong>从源点开始</strong></p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659715674738.png" alt=""></p><p>这是因为需要同时满足四个条件才能到达图中的Vj，所以需要取最大值88，所以V觉得最早发生时间为0+88=88。</p><p><strong>事件的最晚发生时间计算</strong>：(后一事件的最晚发生时间-活动持续时间)的最小值</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723458435.png" alt=""></p><p>因为要保证最后一定保证这四个都完成，所以最晚从3开始</p><p><strong>活动的最早发生时间</strong>：活动的最早发生时间就是事件的最早发生事件</p><p><strong>活动的最晚发生时间</strong>：活动的最晚发生时间（边）就是事件的最晚发生时间减去活动的持续时间。</p><p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723857157.png" alt="关键路径求解步骤"></p><p>求关键路径的算法代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">EdgeNode* e;</span><br><span class="line"><span class="keyword">int</span> i, gettop, k, j;</span><br><span class="line"><span class="keyword">int</span> ete, lte;<span class="comment">//声明活动最早发生时间和最迟发生时间变量</span></span><br><span class="line">TopologicalSort(GL);<span class="comment">//求拓扑序列，计算数组etv的stack2的值</span></span><br><span class="line">ltv = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//事件最晚发生时间</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">{</span><br><span class="line">ltv[i] = etv[GL-&gt;numVertexes - <span class="number">1</span>];<span class="comment">//初始化ltv</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (top2 != <span class="number">0</span>)<span class="comment">//计算ltv</span></span><br><span class="line">{</span><br><span class="line">gettop = stack2[top2--];<span class="comment">//将拓扑序列出栈，后进先出</span></span><br><span class="line"><span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//求各顶点事件的最迟发生时间ltv值</span></span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line"><span class="keyword">if</span> (ltv[k] - e-&gt;weight &lt; ltv[gettop])</span><br><span class="line">{</span><br><span class="line">ltv[gettop] = ltv[k] - e-&gt;weight;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; GL-&gt;numVertexes; ++j)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next)</span><br><span class="line">{</span><br><span class="line">k = e-&gt;adjvex;</span><br><span class="line">ete = etv[j];<span class="comment">//活动最早发生时间</span></span><br><span class="line">lte = ltv[k] - e-&gt;weight;<span class="comment">//活动最迟发生时间</span></span><br><span class="line"><span class="keyword">if</span> (ete == lte)<span class="comment">//两者相等即在关键路径上</span></span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"&lt;v%d,v%d&gt;length:%d,"</span>, GL-&gt;adjList[j].data, GL-&gt;adjList[k].data, e-&gt;weight);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="查找-v2"><a class="header-anchor" href="#查找-v2">¶</a>查找</h1><h1 id="排序-v2"><a class="header-anchor" href="#排序-v2">¶</a>排序</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;title: 数据结构与算法&lt;/p&gt;
&lt;p&gt;数据结构与算法&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TLS和main前的初始化</title>
    <link href="https://gift1a.github.io/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://gift1a.github.io/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-06-18T09:08:22.000Z</published>
    <updated>2022-08-12T17:52:00.230Z</updated>
    
    <content type="html"><![CDATA[<p>TLS回调函数和_initterm</p><span id="more"></span><h1 id="TLS回调函数"><a class="header-anchor" href="#TLS回调函数">¶</a>TLS回调函数</h1><p>在介绍TLS回调函数之前，可以先了解一下TLS</p><p>[TLS及其分类][<a href="https://www.cnblogs.com/revercc/p/14348817.html">https://www.cnblogs.com/revercc/p/14348817.html</a>]</p><blockquote><p>Thread Local Storage（TLS），线程局部存储：各线程独立的数据存储空间。使用TLS技术可以在线程内部独立使用或修改进程的全局数据或静态数据， 就像对待自身的局部变量一样</p></blockquote><h2 id="TLS回调函数-v2"><a class="header-anchor" href="#TLS回调函数-v2">¶</a>TLS回调函数</h2><p>参考文章：</p><p><a href="https://bbs.pediy.com/thread-267175.htm">TLS_callback</a></p><p><a href="http://www.cnitblog.com/textbox/archive/2010/09/27/69239.html#Post">TLS_callback</a></p><p><a href="https://blog.csdn.net/xiao_yi_xiao/article/details/121762629">反调试和TLS回调函数</a></p><p>TLS回调函数要执行需要经历下面三个步骤</p><ol><li>在链接(link)时，链接器要在PE文件中创建TLS目录</li><li>在创建线程时，加载器(loader)会从TEB(Thread Environment Block，线程环境块，通过FS段寄存器可以获取TEB的位置)中获取一个指向TLS回调函数数组的指针</li><li>如果在TLS回调函数数组不是一个空的数组，加载器就会顺序执行这个数组中的各个回调函数</li></ol><p><strong>TLS回调函数用于反调试，主要是利用于TLS回调函数的调用要先于EP代码的执行</strong>，也就是在主线程创建之前先执行TLS回调函数。</p><blockquote><p><strong>TLS回调函数是每当创建或终止进程的线程时会自动调用执行的函数</strong>。创建进程的主线程的时候也会自动调用回调函数</p></blockquote><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/921830_NGG6PFCV4Y3JV2A.png" alt=""></p><p>从上图中，我们可以看出TLS回调函数和DllMain的定义是类似的，其中第一个参数表示模块句柄，第二个参数表示调用TLS回调函数的原因</p><p>Reason的类型有如下四种，下面是定义</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/921830_KAKMQQXZQ6CSG96.png" alt="图片描述"></p><blockquote><p>DLL_PROCESS_ATTACH-1：新进程创建时，在初始化主线程时执行</p><p>DLL_THREAD_ATTACH-2：在新线程创建时执行，但不包括主线程</p><p>DLL_THREAD_DETACH-3：指所有线程终止时执行，但不包括主线程</p><p>DLL_PROCESS_DETACH-0：进程终止时执行</p></blockquote><h3 id="TLS回调函数的实现"><a class="header-anchor" href="#TLS回调函数的实现">¶</a>TLS回调函数的实现</h3><p>下面的代码是基于Release版的X86程序。接下来说一下这个程序的问题，使用Release\X64，无法成功调用TLS回调函数，而使用Debug\X64,Debug\X86只能在主线程创建前调用，而在主线程结束之后没有调用</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI __stdcall <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD dwReason, PVOID Reserved)</span></span>;<span class="comment">//TLS回调函数的声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _M_IX86  <span class="comment">//判断当前编译模式是32位还是64位,然后通知链接器要创建TLS目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:__tls_used"</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:__tls_callback"</span>)  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:_tls_used"</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (linker, <span class="meta-string">"/INCLUDE:_tls_callback"</span>) <span class="comment">//对应64位模式，通知编译器存在tls段 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line">EXTERN_C</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个TLS段，注册TLS函数</span></span><br><span class="line"><span class="comment">.CRTXLX的作用：</span></span><br><span class="line"><span class="comment">CRT表示使用C Runtime机制</span></span><br><span class="line"><span class="comment">X表示表示名随机</span></span><br><span class="line"><span class="comment">L表示TLS CallBack Section</span></span><br><span class="line"><span class="comment">X可以换成B~Y其中任意一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _M_X64  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg (<span class="meta-string">".CRT$XLB"</span>)  </span></span><br><span class="line"><span class="keyword">const</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg (<span class="meta-string">".CRT$XLB"</span>)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> const_seg()</span></span><br><span class="line">PIMAGE_TLS_CALLBACK _tls_callback[] = { TLS_CALLBACK1,<span class="number">0</span> };<span class="comment">//TLS_CALLBACK数组存储回调函数，以0结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据TLS回调函数的定义创建TLS回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI __stdcall <span class="title">TLS_CALLBACK1</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Reserved)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Reason);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDebuggerPresent</span>())</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLS_CALLBACK: Debugger Detected!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"TLS_CALLBACK: No Debugger Present!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660156917230.png" alt=""></p><p>ida中</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660157006375.png" alt=""></p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660157017354.png" alt="ida中TLS回调函数"></p><h1 id="initterm"><a class="header-anchor" href="#initterm">¶</a>_initterm</h1><p>参考文章：</p><p><a href="https://www.dazhuanlan.com/relic256/topics/1212274">程序入口点与main函数</a></p><p><a href="https://blog.csdn.net/liu5320102/article/details/46375799">initterm</a></p><p><a href="https://blog.csdn.net/qq_41006901/article/details/107639086">在main前执行函数</a></p><p><a href="https://www.cxybb.com/article/xiaofengsheng/5367801">全局构造函数执行</a></p><p>在Windows平台中，执行我们手写的main函数之前，系统会执行一段mainCRTStartup代码，其中不同版本的实现也是不同的</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660195964084.png" alt=""></p><p>其对系统的堆栈、全局变量、命令行参数、环境变量等进行初始化操作，而_init_term就是对全局变量进行初始化的函数，其在main函数前执行</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660160685756.png" alt=""></p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660195777264.png" alt=""></p><p>并且对于函数指针数组</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660195762159.png" alt=""></p><p>其中__xc_a和__xc_z是两个函数指针</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__xc_a, __xc_z的定义</span></span><br><span class="line">_CRTALLOC(<span class="string">".CRT$XCA"</span>) _PVFV __xc_a[] = {<span class="literal">NULL</span>};</span><br><span class="line">_CRTALLOC(<span class="string">".CRT$XCZ"</span>) _PVFV __xc_z[] = {<span class="literal">NULL</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">//_CRTALLOC的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">".CRT$XCA"</span>, long, read)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">".CRT$XCZ"</span>, long, read)</span></span><br></pre></td></tr></tbody></table></figure><p>而initterm函数的内容如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __cdecl _initterm (_PVFV * pfbegin,_PVFV * pfend)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">while</span> ( pfbegin &lt; pfend )</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> ( *pfbegin != <span class="literal">NULL</span> )</span><br><span class="line">(**pfbegin)();</span><br><span class="line">++pfbegin;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>PVFV的定义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *_PVFV)</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>可以看出initterm就是遍历上面两个函数指针之间的所有函数并执行</p><p>我们有两种办法在这两个函数指针之间添加函数</p><h2 id="构造函数-v2"><a class="header-anchor" href="#构造函数-v2">¶</a>构造函数</h2><p>全局对象的构造函数会被加入到a和z之间，注意下面的例子是Release的，使用Debug模式编译出来的也是一样效果，但是在ida中a和z之间还有很多0进行填充，如下两图</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660163017555.png" alt=""></p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660163060881.png" alt=""></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">data</span>();</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">data::<span class="built_in">data</span>()</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">data test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过全局对象的构造函数在cpp的初始化中添加函数</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660162773317.png" alt=""></p><p>从ida的注释定义也可以看出是函数指针以及其含义</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (__fastcall *pre_cpp_initializer)()</span><br></pre></td></tr></tbody></table></figure><h2 id="创建段"><a class="header-anchor" href="#创建段">¶</a>创建段</h2><p>注意：以下代码只有在Debug模式下可以得到想要的效果</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECNAME <span class="meta-string">".CRT$XCG"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(SECNAME,long,read)<span class="comment">//创建段，在__xc_a和__xc_z之间</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">std::cout &lt;&lt; <span class="string">"hello"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(__cdecl* _PVFV)</span><span class="params">()</span></span>;<span class="comment">//定义和__xc_a和__xc_z一样类型的函数</span></span><br><span class="line">__declspec(<span class="built_in">allocate</span>(SECNAME)) _PVFV dummy[] = { foo };<span class="comment">//在创建的段中生成数据，我们这里将函数的地址存储进去</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"world"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>效果</p><p>因为我们添加的是xcg，所以只看对于cpp的xca和xcz之间的</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660163723641.png" alt=""></p><p>xca段的地址</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660163738434.png" alt=""></p><p>xcz段的地址</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660163775047.png" alt=""></p><p>添加的xcg段的地址</p><p><img src="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/1660163823588.png" alt=""></p><p>可以发现这是介于两函数指针之间的，所以是会被遍历到并且执行的</p><p><strong>而我们想在C的全局对象初始化数组中添加函数只需要修改段的名称为.CRT$XIG</strong></p><p>也可以按照上述链接中的代码进行</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.通过段名称“.CRT$XIU”，“.CRT$XCU”把函数表放在“C/C++初始化函数表”中</span></span><br><span class="line"><span class="comment">//通过特殊的段名称“.CRT$XIU”，“.CRT$XCU”，</span></span><br><span class="line"><span class="comment">//链接器会把before1表放在“C初始化函数表”中，类似这样</span></span><br><span class="line"><span class="comment">//[__xi_a, ..., before1(xiu), ..., __xi_z].</span></span><br><span class="line"><span class="comment">//同理，before2表会被链接器放在“C++初始化函数表”中，象这样</span></span><br><span class="line"><span class="comment">//[__xc_a, ..., before2(xcu), ..., __xc_z]，</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">before_main1</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before_main1()\n"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">before_main2</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>{  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"before_main2()\n"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">after_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"after_main()\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".CRT$XIU"</span>)  <span class="comment">//用#pragma data_seg建立一个新的数据段并定义共享数据</span></span></span><br><span class="line"><span class="comment">//static func * before1[] = { before_main1 };  </span></span><br><span class="line">func *before1 = before_main1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">".CRT$XCU"</span>)  </span></span><br><span class="line"><span class="comment">//static func * before2[] = { before_main2 };  </span></span><br><span class="line">func *before2 = before_main2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg() </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">_onexit(after_main);</span><br><span class="line">cout&lt;&lt;<span class="string">"this's main start"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是只能在Debug\X86下能得到想要的结果</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TLS回调函数和_initterm&lt;/p&gt;</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>密码学基础知识</title>
    <link href="https://gift1a.github.io/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <id>https://gift1a.github.io/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</id>
    <published>2022-05-26T10:53:53.000Z</published>
    <updated>2022-06-04T05:34:24.470Z</updated>
    
    <content type="html"><![CDATA[<p>密码学预备数学知识</p><span id="more"></span><h1 id="数论知识和markdown数学符号"><a class="header-anchor" href="#数论知识和markdown数学符号">¶</a>数论知识和markdown数学符号</h1><ul><li>欧拉函数</li><li>欧拉定理</li><li>模逆</li><li>指数</li><li>合数</li><li>有限域等</li><li>预备pyCrypto和gmpy2知识</li></ul><p>$$<br>x^2+y_3\<br>Z^+\<br>\sqrt{x}\</p><p>\frac{a}{b} \times\frac{b}{c}\</p><p>\sqrt[n]{y}\</p><p>\vec{a}\cdot\vec{b}=0\</p><p>\overline{x}\</p><p>\lim_{n\to+\infty}n or \lim n\</p><p>\int_0^nf(x)dx or \int f(x)dx\</p><p>\sum_{i=1}^n a_i or \sum a_i\</p><p>\begin{bmatrix}<br>6&amp;2&amp;10&amp;3\<br>7&amp;5&amp;4&amp;9\<br>\end{bmatrix}\</p><p>\begin{matrix}<br>1&amp;2&amp;3\<br>4&amp;5&amp;6\<br>7&amp;8&amp;9\<br>\end{matrix}<br>\tag{2}\<br>$$</p><p>$$<br>a\cdot b\<br>c \times d\<br>f \div e\<br>a \approx 5\<br>a\pm5\<br>a\leq b\<br>a\geq d\<br>\forall\<br>\infty\<br>\emptyset\<br>\exists\<br>\nabla\<br>\bot\<br>\angle\<br>\because\<br>\therefore\<br>\alpha(n)\<br>\beta\<br>\chi\<br>\delta\<br>\eta\<br>\gamma\<br>\gamma =\quad \eta\<br>a \ mod \ b<br>$$</p><h1 id="数学基础"><a class="header-anchor" href="#数学基础">¶</a>数学基础</h1><h2 id="整数和同余"><a class="header-anchor" href="#整数和同余">¶</a>整数和同余</h2><ul><li><strong>整除</strong>：设$a,b,m\in Z,\exists m$使得$a=mb$成立，则称非零整数$b$整除$a$，记作$b \mid a$，此时称$b$是$a$的因子，$a$是$b$的倍数。例：$2\mid6,3 \mid 6$等。</li></ul><blockquote><p>除数与被除数</p><p>需要熟知一个容易混淆的概念：被除数$\div$除数=余数……商，因此整除描述了除数整除被除数的情况，比如$6\div3=2……0$，描述了3整除6的情况，要注意除和除以是不同的概念</p></blockquote><p>在上面，假设$m\mid a,m\mid b$说明$m$是$a$的因子，也是$b$的因子，因此称$m$是$a$和$b$的公因子。</p><ul><li><strong>最大公因子</strong>，设$a,b,m\in Z，而且m\mid a,m\mid b,若m是整除a和b的最大整数，那么m称为a和b的最大公因子，记作m=gcd(a,b)$</li></ul><blockquote><p><strong>互素</strong></p><p>​利用最大公因子可以定义一个常用的概念，即<strong>互素</strong>：称整数$a,b$是互素的，当且仅当$gcd(a,b)=1$</p></blockquote><p>求解最大公因子有非常有效的算法——欧几里得算法(辗转相除法)。在介绍欧几里得算法前，先介绍一下余数的概念</p><ul><li><strong>带余除法</strong>：$\forall n \in  Z^+$和$\forall a\in Z$，$\exists q,r\in Z$且$0\leq r&lt;n$使得$a=qn+r$，其中$q=[a/n]$，[]为向下取整。</li></ul><p>可以看到，其中q为商，r为余数，按照上面的公式有$r=a-[a/n]\times n$，在这里用一个更加简洁的符号表示$r$，那就是模运算符号$mod$，记作$r=a \ mod \ n$，这里$n$是模数，该运算称为模$n$运算</p><p>回到求解最大公因子，对于任意整数$a$和$b$可以通过下面的方式计算$gcd(a,b)$，不断使用带余数除法，直至余数为0，此时的除数为最大公因子</p><blockquote><p><strong>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数</strong></p></blockquote><p>$$<br>gcd(a,b)=gcd(b,a\ mod\ b)<br>$$</p><p>以上的式子不停迭代直至余数为0</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> r=a%b;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;<span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        a=b;</span><br><span class="line">        b=r;</span><br><span class="line">        r=a%b;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> b; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>模$n$同余</strong>：若$a \ mod\ n=b \ mod\ n$那么称整数$a$和$b$是同余的，记作$a \equiv b(mod\ n)$。</li></ul><p>同余运算中，最重要的是模数$n$，比如6和11模5同余，而模三就不同余了。因此考虑一般情况，对于模$n$运算，考察所有整数$Z= \left{0,\pm1,\pm2,\pm3,\cdots \right},\forall\ a\in Z$，根据$a\ mod \ n \in \left{0,1,2,3,\cdots,n-1\right}$，因此<strong>对于任何整数只要进行模$n$运算后，所有整数都被限制到有限的集合中</strong>，那么必然会出现同余的情况，依据此可以定义下面两个概念：</p><ul><li><strong>剩余类集</strong>：模$n$运算的所有余数的集合，记作$Z_n=\left{ 0,1,2,3,\cdots,n-1\right}$</li><li><strong>剩余类</strong>：所有模$n$同余的整数的集合，一般用最小的非负整数作为代表，记作$[0],[1],[2],\cdots,[n-1]$</li></ul><p><img src="/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1653645853317.png" alt="例子"></p><ul><li><strong>模运算</strong>：称二元运算$a\ mod \ n=r$是模$n$运算，$r$是$a$模$n$的值，且$0\leq r &lt;n$，可以证明对于任意两个整数$a$和$b$有下面的结论</li></ul><p><img src="/2022/05/26/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/1653646093104.png" alt=""></p><p>消去律的成立与否与逆元的存在与否有很大关系，下面是加法逆元和乘法逆元的定义</p><ul><li><strong>加法逆元</strong>：$a,b\in Z_n$，若$(a+b)\ mod\ n=0$，则$a$和$b$互为加法逆元，记$a$的加法逆元为$-a$</li><li><strong>乘法逆元</strong>：$a,b\in Z_n$，若$(a+b)\ mod\ n=1$，则$a$和$b$互为乘法逆元，记$a$的乘法逆元为$a^{-1}$</li></ul><p>由于加法逆元一定存在，故加法消去律一定成立，而当且仅当$gcd(a,n)=1$时，$a$才在模$n$运算中存在逆元，故乘法消去律在该条件下才成立。</p><h2 id="素数及其定理"><a class="header-anchor" href="#素数及其定理">¶</a>素数及其定理</h2><ul><li>素数：正因子只有1和它本身的正整数称为素数，而且规定1不是素数，常记作$\rho$</li><li>合数：合数是指正整数中不是素数的数</li></ul><p>合数有一个非常重要的性质，称之为算术基本定理</p><ul><li><strong>算术基本定理</strong>：任何合数都可以唯一分解为若干个素数的乘积，即对于任何整数$a&gt;1$可以唯一分解为$a=\rho_1<sup>{a_1}\rho_2</sup>{a_2}\cdots \rho_n^{a_n},\forall i\in \left{1,2,\cdots n \right}$有$\rho_i$是素数($\rho_1&lt;\rho_2&lt;\cdots&lt;\rho_n$)，$a_i$是正整数</li><li><strong>费马小定理</strong>：</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;密码学预备数学知识&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>简单密码学入门</title>
    <link href="https://gift1a.github.io/2022/05/23/%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8/"/>
    <id>https://gift1a.github.io/2022/05/23/%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8/</id>
    <published>2022-05-23T01:14:22.000Z</published>
    <updated>2022-05-26T10:30:03.003Z</updated>
    
    <content type="html"><![CDATA[<p>算法和理解能力太差了，做题感觉自己像脑缠，先从古典密码入手</p><span id="more"></span><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/222691227">https://zhuanlan.zhihu.com/p/222691227</a></p><h1 id="凯撒密码"><a class="header-anchor" href="#凯撒密码">¶</a>凯撒密码</h1><p>凯撒加密就是将明文中的每个字母都按照其在字母表中的顺序向后或向前移动固定数目（循环移动）作为密文，这个固定数目就是key</p><p>下面给出encode和decode的实现（我这里还添加了对数字的Caesar）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//凯撒加密，对象是大小写字母和数字，字母表的位置后移key</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caesar_encode</span><span class="params">(<span class="keyword">char</span> raw[], <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(raw); ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (raw[i] &gt;= <span class="string">'A'</span> &amp;&amp; raw[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'A'</span> + key) % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'a'</span> &amp;&amp; raw[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i]= (raw[i] - <span class="string">'a'</span> + key) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'0'</span> &amp;&amp; raw[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'0'</span> + key) % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"加密后的字符串为：%s\n"</span>, raw);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//在字母表中，右移n位等于左移26-n位，此时需要左移还原，左移n位就是右移26-n位，因为左移可能小于A或者a，此时还原到z的位置比较麻烦，所以采取右移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caesar_decode</span><span class="params">(<span class="keyword">char</span> raw[], <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(raw); ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (raw[i] &gt;= <span class="string">'A'</span> &amp;&amp; raw[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'A'</span> + <span class="number">26</span> - key) % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'a'</span> &amp;&amp; raw[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'a'</span> + <span class="number">26</span> - key) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'0'</span> &amp;&amp; raw[i] &lt;= <span class="string">'9'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'0'</span> + <span class="number">10</span> - key) % <span class="number">10</span> + <span class="string">'0'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"解密后的字符串为：%s\n"</span>, raw);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> raw[] = <span class="string">"flag123123asdasdasdzxczaqw"</span>;</span><br><span class="line"><span class="comment">/*printf("Please input your raw flag\n");</span></span><br><span class="line"><span class="comment">scanf("%s", raw);*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input your key\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;key);</span><br><span class="line"><span class="keyword">char</span> encode[] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> decode[] = {<span class="number">0</span>};</span><br><span class="line">Caesar_encode(raw, key);</span><br><span class="line">Caesar_decode(raw, key);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="基于密钥的Caesar"><a class="header-anchor" href="#基于密钥的Caesar">¶</a>基于密钥的Caesar</h2><p><img src="/2022/05/23/%E7%AE%80%E5%8D%95%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%A5%E9%97%A8/1653508089916.png" alt=""></p><p>先找到密钥各个字母在字母表中的偏移，然后以此偏移作为密钥加密原文中的字母</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caesar_key_encode</span><span class="params">(<span class="keyword">char</span>* raw, <span class="keyword">char</span>* key_str)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(raw); ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (raw[i] &gt;= <span class="string">'A'</span> &amp;&amp; raw[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'A'</span> + key_str[j] - <span class="string">'a'</span>) % <span class="number">26</span> + <span class="string">'A'</span>;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (raw[i] &gt;= <span class="string">'a'</span> &amp;&amp; raw[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">{</span><br><span class="line">raw[i] = (raw[i] - <span class="string">'a'</span> + key_str[j] - <span class="string">'a'</span>) % <span class="number">26</span> + <span class="string">'a'</span>;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"密钥凯撒加密后的结果：%s\n"</span>, raw);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="仿射变换"><a class="header-anchor" href="#仿射变换">¶</a>仿射变换</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;算法和理解能力太差了，做题感觉自己像脑缠，先从古典密码入手&lt;/p&gt;</summary>
    
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/categories/Crypto/"/>
    
    
    <category term="Crypto" scheme="https://gift1a.github.io/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>CTF中32位调用64位代码</title>
    <link href="https://gift1a.github.io/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/"/>
    <id>https://gift1a.github.io/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-05T11:42:31.000Z</published>
    <updated>2022-08-11T05:49:52.482Z</updated>
    
    <content type="html"><![CDATA[<p>CTF中32位程序调用64位代码</p><span id="more"></span><h1 id="参考文章-v2"><a class="header-anchor" href="#参考文章-v2">¶</a>参考文章</h1><p><a href="https://blog.shi1011.cn/ctf/1750">https://blog.shi1011.cn/ctf/1750</a><br><a href="https://www.anquanke.com/post/id/171111">https://www.anquanke.com/post/id/171111</a></p><p><a href="https://www.psbazx.com/2022/04/06/%E5%85%B3%E4%BA%8E32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%88%87%E6%8D%A2/">https://www.psbazx.com/2022/04/06/关于32位与64位程序切换/</a></p><p><a href="https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html">https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html</a></p><p><a href="https://www.apriorit.com/dev-blog/665-win-hook-64-bit-code-from-32-bit-mode">WOW64实现</a>——未实现</p><h1 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h1><h2 id="CS和IP"><a class="header-anchor" href="#CS和IP">¶</a>CS和IP</h2><p>CS是代码段寄存器，IP是指令指针寄存器</p><blockquote><p>之所以要这样设计是因为8086CPU是16位的，而物理地址是20位的，他内存的寄存器只能表现16位的地址，因此使用ip寄存器来存放偏移地址</p></blockquote><p>我们假设CS的值为M，IP的值为N，那么8086CPU将从内存M*16+N单元开始，读取下一条指令</p><p>工作流程</p><ul><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区</li><li>IP=IP+所读取指令的长度，便于读取下一条指令</li><li>执行指令，重复第一步</li></ul><p>如果我们想修改CS:IP的值，可以使用转移指令，例如JMP指令</p><p>以上是基于16位程序中</p><p>但是32位以上段寄存器不再被用来指向段了，在本例子中CS存储的值用于判断是32位或64位工作模式</p><blockquote><p><strong>64位：CS=0x33；32位：CS=0x23</strong></p></blockquote><h2 id="WOW64"><a class="header-anchor" href="#WOW64">¶</a>WOW64</h2><blockquote><p>WOW64 (Windows-on-Windows 64-bit)是一个Windows操作系统的子系统, 它为现有的32位应用程序提供了32位的模拟，可以使大多数32 位应用程序在无需修改的情况下运行在 Windows 64 位版本上。</p></blockquote><p>在x64系统下的进程有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。32位模式时，CS = 0x23；64位模式时，CS = 0x33</p><blockquote><p><strong>这两种工作模式是可以进行转换的，一般通过retf指令，一条retf指令等效于以下两条汇编指令</strong></p></blockquote><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">ip</span><span class="comment">//当前读取指令的地址</span></span><br><span class="line"><span class="keyword">pop</span> cs<span class="comment">//cs寄存器</span></span><br></pre></td></tr></tbody></table></figure><p>如果此时栈中有0x33，retf会将0x33弹出到CS寄存器，实现32位程序转换到64位代码的过程。<strong>所以retf是识别32位程序调用64位代码的重要标志</strong></p><p>利用好这一点就可以实现64位代码和32位代码来回切换</p><h1 id="解决"><a class="header-anchor" href="#解决">¶</a>解决</h1><h2 id="dump"><a class="header-anchor" href="#dump">¶</a>dump</h2><p>使用idc将64位的代码段dump下来</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"./final"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x4011C0</span>;<span class="comment">//起始地址</span></span><br><span class="line">  end = <span class="number">0x4012A0</span>;<span class="comment">//结束地址</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用ida64打开，选择64-bit mode</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084552451.png" alt=""></p><p>如同修改基址为0x4011C0</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084623510.png" alt=""></p><p>可以看到已经基本恢复了，剩下只需对比着进行代码分析即可</p><h2 id="修改为64位程序"><a class="header-anchor" href="#修改为64位程序">¶</a>修改为64位程序</h2><p>将这里的0x10B改成0x20B，然后使用ida64打开</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084704987.png" alt=""></p><p>基址重新修改为原本程序的基址</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084801377.png" alt="恢复后"></p><h1 id="例子-v3"><a class="header-anchor" href="#例子-v3">¶</a>例子</h1><h2 id="hgame2022-week4-WOW"><a class="header-anchor" href="#hgame2022-week4-WOW">¶</a>hgame2022-week4-WOW</h2><p>在某些函数中ida无法反编译</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652077738159.png" alt=""></p><p>查看此函数的汇编，因为在此之后才无法反编译</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078266535.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078302028.png" alt="汇编"></p><p>因为retf相当于pop ip;pop cs，而ip是下一条指令的地址</p><p>所以这一段代码意思是先将64位工作模式的标志0x33压入栈中，然后通过call和add esp的值改变retf跳转的地址</p><p>然后通过retf时将0x33pop到cs中，换为64位工作模式，所以ida32无法正确反编译</p><p>再来看第二个函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078950121.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652079092143.png" alt="汇编代码"></p><p>这里是一样的，不过这里使用的是mov指令，将0x23mov到esp+4存储的地址中</p><p>通过这一段代码恢复回32位工作模式</p><h2 id="ISCC-擂台题"><a class="header-anchor" href="#ISCC-擂台题">¶</a>ISCC-擂台题</h2><h2 id="考点-v7"><a class="header-anchor" href="#考点-v7">¶</a>考点</h2><p>创建子进程和子线程、TEA、WOW64</p><h2 id="分析-v7"><a class="header-anchor" href="#分析-v7">¶</a>分析</h2><p>当命令行参数为2时进入第一个函数，否则进入第二个</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652267971329.png" alt=""></p><h3 id="第二个函数"><a class="header-anchor" href="#第二个函数">¶</a>第二个函数</h3><p>第二个函数传入的参数是命令行参数的第一个，也就是我们的程序绝对路径</p><p>进入第二个函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268136354.png" alt=""></p><p>这一段就是打开当前程序创建子进程（根据第六个参数判断进程的属性），命令行参数为我们打开程序的路径和" DIO"，然后</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652248950697.png" alt=""></p><p>然后根据调试事件判断时候break，这里当报告退出进程调试事件才会break</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652249119969.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268383536.png" alt="创建的新进程"></p><p>这样创建的子进程具有两个命令行参数，所以进入第一个函数</p><h3 id="第一个函数"><a class="header-anchor" href="#第一个函数">¶</a>第一个函数</h3><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268475082.png" alt="函数列表"></p><h4 id="CreateNewThread函数"><a class="header-anchor" href="#CreateNewThread函数">¶</a>CreateNewThread函数</h4><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268516934.png" alt=""></p><p>创建一个子线程，根据第五个参数dwCreationFlags为0可知是线程创建后立即执行，指定函数为StartAddress</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268675363.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268738053.png" alt="StartAddress函数"></p><p>就是对flag的格式进行判断，并且对最后的几个字符进行异或</p><p>但是此时我们还未输入，按理说会一直卡在while循环，但是单步步过CreateNewThread时都是正常的</p><h4 id="compare-input函数"><a class="header-anchor" href="#compare-input函数">¶</a>compare_input函数</h4><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268936181.png" alt=""></p><p>判断输入前几位是否为ISCC</p><h4 id="encode-and-compare函数"><a class="header-anchor" href="#encode-and-compare函数">¶</a>encode_and_compare函数</h4><p>通过动态调试可以知道前面的while循环是将每八个输入存储为QWORD类型，第二段就是对key，也就是命令行参数的第二个进行加密，然后传入encode()函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269032854.png" alt=""></p><h5 id="encode-函数"><a class="header-anchor" href="#encode-函数">¶</a>encode()函数</h5><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269187607.png" alt=""></p><p>这一段就是开辟空间和初始化直接动调，关键还是对该函数的调用</p><p>注意要先添加命令行参数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269289722.png" alt=""></p><p>开启调试到达该函数，发现了切换为64位工作模式的代码</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269376040.png" alt=""></p><p>将这一段dump下来</p><p>这里调用了920000地址处的函数，所以也要一起dump下来</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269739310.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"./final1"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x920000</span>;<span class="comment">//起始地址</span></span><br><span class="line">  end = <span class="number">0x93006B</span>;<span class="comment">//结束地址</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拖进ida64，可以看出来是tea加密</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269705752.png" alt=""></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269865596.png" alt="切换回32位"></p><p>经此全部分析就已经结束了，前十六个字符先转long long型，然后进行tea加密，后5个字符进行异或，tea的密钥直接在调用encode函数处提取即可</p><p>加密代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 tmp0;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 tmp1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag[<span class="number">32</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x25</span>,<span class="number">0xf</span>};</span><br><span class="line"><span class="keyword">unsigned</span> __int64 temp[<span class="number">2</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x425B1CD73C3598F1</span>, <span class="number">0x72C63C6A5ACF14BA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">tmp0 = v11[i];</span><br><span class="line">tmp1 = v11[i + <span class="number">1</span>];</span><br><span class="line">__int64 sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">{</span><br><span class="line">sum += <span class="number">0x9E3779B9</span>;</span><br><span class="line">tmp0 += (sum + tmp1) ^ (a[<span class="number">0</span>] + <span class="number">16</span> * tmp1) ^ (a[<span class="number">1</span>] + (tmp1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">tmp1 += (sum + tmp0) ^ (a[<span class="number">2</span>] + <span class="number">16</span> * tmp0) ^ (a[<span class="number">3</span>] + (tmp0 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">}</span><br><span class="line">v11[i] = tmp0;</span><br><span class="line">v11[i + <span class="number">1</span>] = tmp1;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//0x425B1CD73C3598F1, 0x72C63C6A5ACF14BA</span></span><br></pre></td></tr></tbody></table></figure><p>这里我不知道为啥我拿输入去加密得到的结果和程序的一致，但是解不出来😢</p><p>解不出来的解密代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 tmp0;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 tmp1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag[<span class="number">32</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x25</span>,<span class="number">0xf</span>};</span><br><span class="line"><span class="keyword">unsigned</span> __int64 temp[<span class="number">2</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x425B1CD73C3598F1</span>, <span class="number">0x72C63C6A5ACF14BA</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">tmp0 = v11[<span class="number">0</span>];</span><br><span class="line">tmp1 = v11[<span class="number">1</span>];</span><br><span class="line">__int64 sum = <span class="number">32</span> * <span class="number">0x9E3779B9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp1 -= (sum + tmp0) ^ (a[<span class="number">2</span>] + <span class="number">16</span> * tmp0) ^ (a[<span class="number">3</span>] + (tmp0 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">tmp0 -= (sum + tmp1) ^ (a[<span class="number">0</span>] + <span class="number">16</span> * tmp1) ^ (a[<span class="number">1</span>] + (tmp1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">sum -= <span class="number">0x9E3779B9</span>;</span><br><span class="line">}</span><br><span class="line">v11[<span class="number">0</span>]= tmp0;</span><br><span class="line">v11[<span class="number">1</span>]= tmp1;</span><br></pre></td></tr></tbody></table></figure><p>想动态调试这段汇编好像会出问题，只能单步步过</p><p>不过好像使用WINDBG可以调试</p><h2 id="linux"><a class="header-anchor" href="#linux">¶</a>linux</h2><p>代码分析</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652086069132.png" alt=""></p><p>可以知道这一段代码是在0xDEAD000开辟空间，然后赋值后再SMC解密，然后就出现了无法识别的代码，看汇编动调发现和前面是一样的</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652086040351.png" alt=""></p><p>使用retf实现jmp far</p><p>解决方法同上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CTF中32位程序调用64位代码&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>比赛和复现</title>
    <link href="https://gift1a.github.io/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/"/>
    <id>https://gift1a.github.io/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/</id>
    <published>2022-05-05T08:32:02.000Z</published>
    <updated>2022-06-18T09:07:04.594Z</updated>
    
    <content type="html"><![CDATA[<p>比赛和一些题目复现</p><span id="more"></span><h1 id="Patriotctf2022-Flowing"><a class="header-anchor" href="#Patriotctf2022-Flowing">¶</a>Patriotctf2022-Flowing</h1><p>主程序就这一段，输入一个十六进制数，然后从文件中读取flag，可以采用爆破，可能是因为linux和windows的不同，我自己模拟出来的数据不一样，所以没爆破出来，最后采用了subprocess爆破</p><p><img src="/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/1651739832426.png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">''</span><span class="comment">#绝对正确的前6个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffffffff</span>):<span class="comment">#当前爆破的位置上的字符</span></span><br><span class="line">    real_flag_arr_s=<span class="built_in">str</span>(<span class="built_in">hex</span>(i).strip(<span class="string">'0x'</span>))<span class="comment">#输入到程序中的字符串，hex自带0x所以要去除掉0x</span></span><br><span class="line">    <span class="comment">#上面都是一些初始化</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"./flowing"</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(real_flag_arr_s.encode())</span><br><span class="line">    p.stdin.close()<span class="comment">#停止输入</span></span><br><span class="line">    out = p.stdout.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b"PCTF"</span> <span class="keyword">in</span> out <span class="keyword">or</span> <span class="string">b"pctf"</span> <span class="keyword">in</span> out:</span><br><span class="line">        <span class="built_in">print</span>(out)</span><br><span class="line">        exit()</span><br></pre></td></tr></tbody></table></figure><h1 id="Patriotctf2022-Fishyfish"><a class="header-anchor" href="#Patriotctf2022-Fishyfish">¶</a>Patriotctf2022-Fishyfish</h1><p>得到.s文件，查阅后得知是gcc编译过程中生成的</p><blockquote><p><strong>生成可执行程序过程为成四个步骤： 1、由.c文件到.i文件，这个过程叫预处理。 2、由.i文件到.s文件，这个过程叫编译。 3、由.s文件到.o文件，这个过程叫汇编。 4、由.o文件到可执行文件，这个过程叫链接。</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用以下指令将.s文件生成.o文件</span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line">//使用以下指令将.o文件生成可执行文件</span><br><span class="line">gcc test.o -o test</span><br></pre></td></tr></tbody></table></figure><p>将生成的可执行文件拖入ida中</p><p><img src="/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/1651740964609.png" alt=""></p><p>可以看到这里调用了socket网络通信</p><p><a href="https://zhuanlan.zhihu.com/p/260139078">https://zhuanlan.zhihu.com/p/260139078</a></p><p>先将异或后的数据发送到目标地址中，然后读取数据并写入文件中</p><p>我们可以不使用套接字进行编程，而使用pwntools这个工具，然后模拟socket接收数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启远程端口,网址+端口</span></span><br><span class="line">p=remote(<span class="string">"chal1.pctf.competitivecyber.club"</span>,<span class="number">10015</span>)</span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line">p.send(<span class="string">b"obese dragonfish"</span>)</span><br><span class="line"><span class="comment">#接收指定长度的数据，直到timeout</span></span><br><span class="line">data=p.readn(<span class="number">0x3888</span>)</span><br><span class="line"><span class="comment">#将数据写入文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"fish.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(bin_file)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure><h1 id="Self-Reverse"><a class="header-anchor" href="#Self-Reverse">¶</a>Self-Reverse</h1><h1 id="NCTF2021-狗狗的秘密"><a class="header-anchor" href="#NCTF2021-狗狗的秘密">¶</a>NCTF2021-狗狗的秘密</h1><h2 id="考点：反调试、SMC、进制转换"><a class="header-anchor" href="#考点：反调试、SMC、进制转换">¶</a>考点：反调试、SMC、进制转换</h2><h1 id="NCTF2021-鲨鲨的秘密"><a class="header-anchor" href="#NCTF2021-鲨鲨的秘密">¶</a>NCTF2021-鲨鲨的秘密</h1><h2 id="考点：反调试、CRC32、SMC"><a class="header-anchor" href="#考点：反调试、CRC32、SMC">¶</a>考点：反调试、CRC32、SMC</h2><h1 id="ISCC2022-MYALA"><a class="header-anchor" href="#ISCC2022-MYALA">¶</a>ISCC2022-MYALA</h1><h2 id="考点：维吉尼亚加密、C"><a class="header-anchor" href="#考点：维吉尼亚加密、C">¶</a>考点：维吉尼亚加密、C++</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;比赛和一些题目复现&lt;/p&gt;</summary>
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/categories/Competition/"/>
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>MiniLctf2022</title>
    <link href="https://gift1a.github.io/2022/05/05/MiniLctf2022/"/>
    <id>https://gift1a.github.io/2022/05/05/MiniLctf2022/</id>
    <published>2022-05-05T02:42:32.000Z</published>
    <updated>2022-05-19T09:12:15.256Z</updated>
    
    <content type="html"><![CDATA[<p>题目质量很高，我也是真的菜</p><span id="more"></span><h1 id="题目和WP"><a class="header-anchor" href="#题目和WP">¶</a>题目和WP</h1><p><a href="https://github.com/XDSEC/miniLCTF_2022">https://github.com/XDSEC/miniLCTF_2022</a></p><h1 id="Twin"><a class="header-anchor" href="#Twin">¶</a>Twin</h1><h2 id="考点：TLS-CallBack函数、SMC、XXTEA-XXTEA魔改、反调试、花指令"><a class="header-anchor" href="#考点：TLS-CallBack函数、SMC、XXTEA-XXTEA魔改、反调试、花指令">¶</a>考点：TLS_CallBack函数、SMC、XXTEA+XXTEA魔改、反调试、花指令</h2><h2 id="前置知识-v3"><a class="header-anchor" href="#前置知识-v3">¶</a>前置知识</h2><h3 id="TLS-CALLBACK函数"><a class="header-anchor" href="#TLS-CALLBACK函数">¶</a>TLS_CALLBACK函数</h3><blockquote><p><strong>TLS设计的本意，是为了解决多线程程序中变量同步的问题，是Thread Local Storage的缩写，意为线程本地存储。线程本身有独立于其他线程的栈空间，因此线程中的局部变量不用考虑同步问题。多线程同步问题在于对全局变量的访问，TLS在操作系统的支持下，通过把全局变量打包到一个特殊的节，当每次创建线程时把这个节中的数据当做副本，拷贝到进程空闲的地址空间中。以后线程可以像访问局部变量一样访问该异于其他线程的全局变量的副本，而不用加同步控制。</strong></p></blockquote><p>TLS回调函数常用于反调试</p><p>每当创建或终止进程的线程时会自动调用执行的函数。当然，创建进程的主线程的时候也会自动调用回调函数，且其执行先于EP代码。反调试技术就是利用的TLS回调函数的这一特征。它是各线程独立的数据存储空间，可修改进程的全局/静态数据</p><p>而它可以注册多个TLS_CALLBACK函数</p><p><img src="/2022/05/05/MiniLctf2022/1651974115184.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651974138087.png" alt=""></p><h3 id="进程通信-共享内存CreateFileMapping-MapViewOfFile"><a class="header-anchor" href="#进程通信-共享内存CreateFileMapping-MapViewOfFile">¶</a>进程通信-共享内存CreateFileMapping+MapViewOfFile</h3><p><a href="https://www.cnblogs.com/endenvor/p/9753135.html">https://www.cnblogs.com/endenvor/p/9753135.html</a></p><p>把文件映像到内存，首先必须调用CreateFileMapping()函数，然后再调用MapViewOfFile函数，把文件视映像到进程地址空间上。这样多个子进程都可以访问该内存</p><h2 id="分析-v11"><a class="header-anchor" href="#分析-v11">¶</a>分析</h2><p>这道题所有的字符串都进行了异或加密</p><p>在main函数中逆出来得到的是fake_flag，然后去Export发现了TLS函数</p><p><a href="https://blog.csdn.net/CSNN2019/article/details/113094488">https://blog.csdn.net/CSNN2019/article/details/113094488</a></p><p><img src="/2022/05/05/MiniLctf2022/1651758278192.png" alt=""></p><p>点进去发现里面什么代码都没有，很奇怪，查看汇编</p><p><img src="/2022/05/05/MiniLctf2022/1651758334830.png" alt=""></p><p>这里加了一处花指令导致ida无法正常分析</p><blockquote><p><strong>这段花指令就是将返回地址（call后压入栈的值）加上插入字符串的长度，以跳过这段无用代码</strong></p></blockquote><p>直接改为jmp到原本指令的地址</p><p><img src="/2022/05/05/MiniLctf2022/1651975334021.png" alt=""></p><p>然后F5</p><p><img src="/2022/05/05/MiniLctf2022/1651758540000.png" alt=""></p><p>要注意的是这里面还有一处花指令很坑</p><p><img src="/2022/05/05/MiniLctf2022/1651758596649.png" alt=""></p><p>去除之后，这里就是将我们的函数注册为TLS_CALLBACK函数</p><p><img src="/2022/05/05/MiniLctf2022/1651758699171.png" alt=""></p><h3 id="将文件映射到内存中"><a class="header-anchor" href="#将文件映射到内存中">¶</a>将文件映射到内存中</h3><p><img src="/2022/05/05/MiniLctf2022/1651975828550.png" alt=""></p><p>继续往下，这里的reason是TLS_CALLBACK函数的第二个参数，因为还处于主线程，所以是1，所以不会进入这里的if</p><p><img src="/2022/05/05/MiniLctf2022/1651976154245.png" alt=""></p><p>先在注册的TLS_CALLBACK第二个函数下断点，然后F9</p><p><img src="/2022/05/05/MiniLctf2022/1651976351875.png" alt=""></p><h3 id="Hook掉WriteFile"><a class="header-anchor" href="#Hook掉WriteFile">¶</a>Hook掉WriteFile</h3><p><img src="/2022/05/05/MiniLctf2022/1651976372396.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651976527716.png" alt="Hook函数内部"></p><p>可以看到这里是遍历，然后只要地址等于WriteFile就将final函数的地址赋值过去，实现Hook</p><p><img src="/2022/05/05/MiniLctf2022/1651976683946.png" alt="Hook完成"></p><p>Hook之后ExitProcess</p><p><img src="/2022/05/05/MiniLctf2022/1651976714789.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651976845486.png" alt="结束所有进程和线程"></p><p>所以不会进入到main函数中</p><h3 id="第二次进入TLS-CALLBACK函数"><a class="header-anchor" href="#第二次进入TLS-CALLBACK函数">¶</a>第二次进入TLS_CALLBACK函数</h3><p>此时第二个参数变成了0，进入第二段</p><p>加载资源文件</p><p><img src="/2022/05/05/MiniLctf2022/1651977745611.png" alt=""></p><p>加载EXERES文件，然后xor_0x5F后创建tmp文件</p><blockquote><p>注意这里的WriteFile已经被Hook成我们的函数</p></blockquote><p><img src="/2022/05/05/MiniLctf2022/1651979822133.png" alt=""></p><p>修改值为6，其他正常写入，我们手动去文件修改</p><p><img src="/2022/05/05/MiniLctf2022/1651980030650.png" alt=""></p><p>下面这个函数是将取消Hook，也就是将WriteFile函数恢复</p><p>在Resources Hacker也可以找到资源文件</p><p><img src="/2022/05/05/MiniLctf2022/1651977808202.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651977842463.png" alt="生成tmp文件"></p><p><img src="/2022/05/05/MiniLctf2022/1651976997090.png" alt=""></p><blockquote><p><strong>CreateProcessA创建新进程，这个新进程运行指定的可执行文件tmp文件，也就是创建子进程</strong></p></blockquote><p><a href="https://baike.baidu.com/item/CreateProcess/11050419">https://baike.baidu.com/item/CreateProcess/11050419</a></p><p>这里的3代表的是新进程会被当做被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。</p><p><img src="/2022/05/05/MiniLctf2022/1651990868690.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651979411776.png" alt=""></p><p>此时也可以通过工具查看</p><p><img src="/2022/05/05/MiniLctf2022/1651977305230.png" alt=""></p><h3 id="DEBUG模式"><a class="header-anchor" href="#DEBUG模式">¶</a>DEBUG模式</h3><p><img src="/2022/05/05/MiniLctf2022/1651979468081.png" alt="进入该函数"></p><p>等待调试</p><p><img src="/2022/05/05/MiniLctf2022/1651979593455.png" alt=""></p><h3 id="子进程"><a class="header-anchor" href="#子进程">¶</a>子进程</h3><p>去tmp文件查看</p><p>注册一个异常处理函数</p><p><img src="/2022/05/05/MiniLctf2022/1651980146402.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651980174862.png" alt="异常处理函数"></p><p>当出现地址访问异常时，EIP+2</p><blockquote><p><strong>但是这里要注意因为子进程是DEBUG模式，所以优先让调试器也就是父进程处理</strong></p></blockquote><p>因为子进程是调试状态，所以这里要执行，也就是xxtea的常量进行异或，key[1]改为0x90</p><p><img src="/2022/05/05/MiniLctf2022/1651980332623.png" alt=""></p><h4 id="异常地址"><a class="header-anchor" href="#异常地址">¶</a>异常地址</h4><p><img src="/2022/05/05/MiniLctf2022/1651980405385.png" alt=""></p><p><img src="/2022/05/05/MiniLctf2022/1651980416658.png" alt="内存访问出错"></p><p>此时再去父进程看</p><p><img src="/2022/05/05/MiniLctf2022/1651980602332.png" alt=""></p><p>而EAX的值恰好是XXTEA的常量经过处理</p><p><img src="/2022/05/05/MiniLctf2022/1651980653548.png" alt="常量的处理"></p><h4 id="子进程通过文件映射通信"><a class="header-anchor" href="#子进程通过文件映射通信">¶</a>子进程通过文件映射通信</h4><p><img src="/2022/05/05/MiniLctf2022/1651980933549.png" alt=""></p><h4 id="xxtea"><a class="header-anchor" href="#xxtea">¶</a>xxtea</h4><p>最后就是xxtea，不过要注意这里的&gt;&gt;5都改成了&gt;&gt;6,也就是前面WirteFile时候改的数值</p><p><img src="/2022/05/05/MiniLctf2022/1651980951417.png" alt=""></p><p>脚本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA ((((0x9E3779B9 ^0x90909090^ 0x12345678 ^ 0x7b)+12345))^0x1b207)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;6^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(DWORD* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">int</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="comment">//unsigned int enc[155] = { 3532577106, 1472742623, 3642468664, 4193500461, 2398676029, 617653972, 1474514999, 1471783658, 1012864704, 3615627536, 993855884, 438456717, 3358938551, 3906991208, 198959101, 3317190635, 3656923078, 613157871, 2398768861, 97286225, 2336972940, 1471645170, 3233163154, 583597118, 2863776301, 3183067750, 1384330715, 2929694742, 3522431804, 2181488067, 3303062236, 3825712422, 145643141, 2148976293, 2940910035, 506798154, 994590281, 2231904779, 3389770074, 2814269052, 1105937096, 1789727804, 3757028753, 2469686072, 1162286478, 680814033, 2934024098, 2162521262, 4048876895, 2121620700, 4240287315, 2391811140, 3396611602, 3091349617, 3031523010, 2486958601, 3164065171, 1285603712, 798920280, 2337813135, 4186055520, 3523024366, 1077514121, 1436444106, 2731983230, 1507202797, 500756149, 198754565, 2382448647, 880454148, 1970517398, 3217485349, 1161840191, 560498076, 1782600856, 2643721918, 1285196205, 788797746, 1195724574, 4061612551, 103427523, 2502688387, 4147162188, 617564657, 978211984, 1781482121, 2205798970, 3939973102, 3826603515, 659557668, 2582884932, 1561884856, 2217488804, 1189296962, 169145316, 2781742156, 1323893433, 824667876, 408202876, 3759637634, 4094868412, 1508996065, 162419237, 3732146944, 3083560189, 3955940127, 2393776934, 2470191468, 3620861513, 481927014, 2756226070, 3154651143, 1261069441, 2063238535, 2222237213, 101459755, 3159774417, 1721190841, 1078395785, 176506553, 3552913423, 1566142515, 1938949000, 1499289517, 3315102456, 829714860, 3843359394, 952932374, 1283577465, 2045007203, 3957761944, 3767891405, 2917089623, 3296133521, 482297421, 1734231412, 3670478932, 2575334979, 2827842737, 3413631016, 1533519803, 4008428470, 3890643173, 272960248, 317508587, 3299937500, 2440520601, 27470488, 1666674386, 1737927609, 750987808, 2385923471, 2694339191, 562925334, 2206035395 };</span></span><br><span class="line">    DWORD enc[<span class="number">18</span>] = { <span class="number">0x6B7CE328</span>, <span class="number">0x4841D5DD</span>, <span class="number">0x963784DC</span>, <span class="number">0xEF8A3226</span>, <span class="number">0x0776B226</span> };</span><br><span class="line">    <span class="comment">//unsigned int key[4] = {0x12,0x90,0x56,0x78};</span></span><br><span class="line">    <span class="keyword">int</span> key[<span class="number">4</span>] = { <span class="number">0x12</span>,<span class="number">0x90</span>,<span class="number">0x56</span>,<span class="number">0x78</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-5</span>, key);<span class="comment">//长度为多少，解密时第二个参数就改为多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* char s[] = "3e90c91c02e9b40b78b}";</span></span><br><span class="line"><span class="comment">    printf("%d", strlen(s));*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>剩下的一部分也是xxtea，没魔改就不说了</p><h1 id="What-assembly"><a class="header-anchor" href="#What-assembly">¶</a>What assembly</h1><h2 id="考点：WASM逆向"><a class="header-anchor" href="#考点：WASM逆向">¶</a>考点：WASM逆向</h2><p><a href="https://www.52pojie.cn/thread-962068-1-1.html">https://www.52pojie.cn/thread-962068-1-1.html</a></p><p><a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a></p><p><a href="http://www.dwenzhao.cn/profession/netbuild/webassemblyfunc.html">http://www.dwenzhao.cn/profession/netbuild/webassemblyfunc.html</a></p><p>wasm动态调试</p><p>利用python3在与<code>.html</code>、<code>.js</code>、<code>.wasm</code>文件同目录下开启http服务。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8888</span></span><br></pre></td></tr></tbody></table></figure><p>然后在浏览器输入http://127.0.0.1:8888/MiniLctf-2022.html</p><p>下断点动态调试</p><h2 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h2><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wasm<span class="number">2</span><span class="keyword">c</span> flag.wasm -o flag.<span class="keyword">c</span></span><br></pre></td></tr></tbody></table></figure><p>生成flag.c和flag.h</p><p>将之前反编译出来的wasm.c，wasm.h，以及wabt项目内的wasm-rt.h，wasm-rt-impl.c，wasm-rt-impl.h三个文件放到同一个文件夹。</p><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> flag.<span class="keyword">c</span> -o final.o</span><br></pre></td></tr></tbody></table></figure><p>生成.o文件， 因为很多wasm的函数没有具体的实现，我们不需要编译链接生成elf文件</p><p>因为wasm是基于栈的，编译后的C的结构也模拟对栈的操作，所以可以模拟栈进行分析</p><h3 id="基础指令"><a class="header-anchor" href="#基础指令">¶</a>基础指令</h3><p><a href="https://juejin.cn/post/6844904069186715656">https://juejin.cn/post/6844904069186715656</a></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">load(memory,a2)<span class="comment">//出栈指令</span></span><br><span class="line">    <span class="comment">//将栈顶元素弹出至a1</span></span><br><span class="line">store(memory,a1,a2)<span class="comment">//入栈指令</span></span><br><span class="line">    <span class="comment">//a1一般是栈顶，也就是目标地址，而a2是要入栈的值</span></span><br><span class="line"><span class="comment">//当然上面的指令也是可以指定不同长度的    </span></span><br><span class="line">i32_load8_u<span class="comment">//8位无符号数</span></span><br><span class="line">i32_load8_s<span class="comment">//8位有符号数</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//数组索引取值，通过地址+索引</span></span><br><span class="line">    i32_store(&amp;w2c_memory, Stack_Pointer + <span class="number">28LL</span>, <span class="number">0</span>);<span class="comment">// 初始化为索引为0</span></span><br><span class="line">      key_addr = i32_load(&amp;w2c_memory, Stack_Pointer + <span class="number">100LL</span>);</span><br><span class="line">      tmp_key_addr = i32_load(&amp;w2c_memory, Stack_Pointer + <span class="number">28LL</span>) + key_addr;<span class="comment">// 存储key的地址+索引</span></span><br><span class="line">    </span><br></pre></td></tr></tbody></table></figure><h3 id="分析-v12"><a class="header-anchor" href="#分析-v12">¶</a>分析</h3><p>就一步一步分析</p><p>得出最终的加密过程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROL(a,b) (((a) <span class="meta-string">&lt;&lt; (b)) | ((a) &gt;</span>&gt; (8 - (b))))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qua_rou</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//直接异或即可</span></span><br><span class="line"><span class="comment">//逆着来解密就行了</span></span><br><span class="line">s[b] ^= ROL((s[a] + s[d]) &amp; <span class="number">0xff</span>, <span class="number">4</span>);</span><br><span class="line">s[d] ^= ROL((s[c] + s[b]) &amp; <span class="number">0xff</span>, <span class="number">2</span>);</span><br><span class="line">s[c] ^= ROL((s[b] + s[a]) &amp; <span class="number">0xff</span>, <span class="number">3</span>);</span><br><span class="line">s[a] ^= ROL((s[d] + s[c]) &amp; <span class="number">0xff</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"D33.B4T0"</span>;</span><br><span class="line"><span class="keyword">char</span> table[] = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line"><span class="keyword">char</span> flag[] = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> enc[] = { <span class="number">0x05</span>,<span class="number">0x77</span>,<span class="number">0x9c</span>,<span class="number">0x24</span>,<span class="number">0xd9</span>,<span class="number">0x24</span>,<span class="number">0x9e</span>,<span class="number">0x69</span>,<span class="number">0x3f</span>,<span class="number">0xa7</span>,<span class="number">0xac</span>,<span class="number">0x4a</span>,<span class="number">0x10</span>,<span class="number">0xc6</span>,<span class="number">0x8d</span>,<span class="number">0xfb</span>,<span class="number">0xd3</span>,<span class="number">0x52</span>,<span class="number">0x00</span>,<span class="number">0x83</span>,<span class="number">0xb3</span>,<span class="number">0x3f</span>,<span class="number">0x56</span>,<span class="number">0xe9</span>,<span class="number">0x0f</span>,<span class="number">0xd8</span>,<span class="number">0x49</span>,<span class="number">0x78</span>,<span class="number">0xb6</span>,<span class="number">0xa1</span>,<span class="number">0x5c</span>,<span class="number">0x97</span>,<span class="number">0x0b</span>,<span class="number">0x97</span>,<span class="number">0x67</span>,<span class="number">0x79</span>,<span class="number">0xa8</span>,<span class="number">0xfe</span>,<span class="number">0xfe</span>,<span class="number">0x91</span>,<span class="number">0xfb</span>,<span class="number">0x87</span>,<span class="number">0xd2</span>,<span class="number">0x22</span>,<span class="number">0x1c</span>,<span class="number">0x9a</span>,<span class="number">0x1f</span>,<span class="number">0x87</span>,<span class="number">0xed</span>,<span class="number">0x7e</span>,<span class="number">0xad</span>,<span class="number">0xdb</span>,<span class="number">0x8a</span>,<span class="number">0xe6</span>,<span class="number">0x37</span>,<span class="number">0x0f</span>,<span class="number">0x9d</span>,<span class="number">0xe6</span>,<span class="number">0x9e</span>,<span class="number">0x3a</span>,<span class="number">0x7a</span>,<span class="number">0x5c</span>,<span class="number">0x5c</span>,<span class="number">0x48</span>,<span class="number">0x8c</span>,<span class="number">0xde</span>,<span class="number">0x79</span>,<span class="number">0x75</span>,<span class="number">0x6b</span>,<span class="number">0x0b</span>,<span class="number">0x9f</span>,<span class="number">0x17</span>,<span class="number">0x13</span>,<span class="number">0xe7</span>,<span class="number">0x49</span>,<span class="number">0xed</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0xff</span>,<span class="number">0x04</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> s[] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//key赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">{</span><br><span class="line">s[i] = key[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i+=<span class="number">8</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">{</span><br><span class="line">s[j + <span class="number">8</span>] = flag[i + j];<span class="comment">//每次取出flag的8个字符存储到s中，而前八个是上一轮的加密结果</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">42</span>; ++j)<span class="comment">//进行42轮加密</span></span><br><span class="line">{</span><br><span class="line">qua_rou(s, <span class="number">12</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">qua_rou(s, <span class="number">13</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>);<span class="comment">//根据0-7下标的值对8-15下标的加密（也就是我们的flag）</span></span><br><span class="line">qua_rou(s, <span class="number">14</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(s, <span class="number">15</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">qua_rou(s, <span class="number">15</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">qua_rou(s, <span class="number">12</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">qua_rou(s, <span class="number">13</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(s, <span class="number">14</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> correct = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) </span><br><span class="line">{</span><br><span class="line">correct |= (enc[i * <span class="number">4</span> + j * <span class="number">2</span> + <span class="number">0</span>] != table[s[j] / <span class="number">0x10</span>]);<span class="comment">//加密一次之后，此时s数组长度为16，然后偶数取模</span></span><br><span class="line">correct |= (enc[i * <span class="number">4</span> + j * <span class="number">2</span> + <span class="number">1</span>] != table[s[j] % <span class="number">0x10</span>]);<span class="comment">//奇数取余</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以知道第一轮先把key赋值给s的前八个，将flag的前八个字符赋值给s数组，然后进行42轮的加密</p><p>求解时只需要逆着进行，每次取出密文的16个字符，因为异或过程就只有异或，但是有先后的关系，比如s[12]已经被重新赋值，再次被使用时就会出错，所以要逆着来</p><h3 id="脚本-v6"><a class="header-anchor" href="#脚本-v6">¶</a>脚本</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROL(a,b) (((a) <span class="meta-string">&lt;&lt; (b)) | ((a) &gt;</span>&gt; (8 - (b))))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qua_rou</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* s, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//直接异或即可</span></span><br><span class="line"><span class="comment">//逆着来解密就行了</span></span><br><span class="line">s[a] ^= ROL((s[d] + s[c]) &amp; <span class="number">0xff</span>, <span class="number">1</span>);</span><br><span class="line">s[c] ^= ROL((s[b] + s[a]) &amp; <span class="number">0xff</span>, <span class="number">3</span>);</span><br><span class="line">s[d] ^= ROL((s[c] + s[b]) &amp; <span class="number">0xff</span>, <span class="number">2</span>);</span><br><span class="line">s[b] ^= ROL((s[a] + s[d]) &amp; <span class="number">0xff</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"D33.B4T0"</span>;</span><br><span class="line"><span class="keyword">char</span> table[] = <span class="string">"0123456789abcdef"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> enc[] = { <span class="number">0x05</span>,<span class="number">0x77</span>,<span class="number">0x9c</span>,<span class="number">0x24</span>,<span class="number">0xd9</span>,<span class="number">0x24</span>,<span class="number">0x9e</span>,<span class="number">0x69</span>,<span class="number">0x3f</span>,<span class="number">0xa7</span>,<span class="number">0xac</span>,<span class="number">0x4a</span>,<span class="number">0x10</span>,<span class="number">0xc6</span>,<span class="number">0x8d</span>,<span class="number">0xfb</span>,<span class="number">0xd3</span>,<span class="number">0x52</span>,<span class="number">0x00</span>,<span class="number">0x83</span>,<span class="number">0xb3</span>,<span class="number">0x3f</span>,<span class="number">0x56</span>,<span class="number">0xe9</span>,<span class="number">0x0f</span>,<span class="number">0xd8</span>,<span class="number">0x49</span>,<span class="number">0x78</span>,<span class="number">0xb6</span>,<span class="number">0xa1</span>,<span class="number">0x5c</span>,<span class="number">0x97</span>,<span class="number">0x0b</span>,<span class="number">0x97</span>,<span class="number">0x67</span>,<span class="number">0x79</span>,<span class="number">0xa8</span>,<span class="number">0xfe</span>,<span class="number">0xfe</span>,<span class="number">0x91</span>,<span class="number">0xfb</span>,<span class="number">0x87</span>,<span class="number">0xd2</span>,<span class="number">0x22</span>,<span class="number">0x1c</span>,<span class="number">0x9a</span>,<span class="number">0x1f</span>,<span class="number">0x87</span>,<span class="number">0xed</span>,<span class="number">0x7e</span>,<span class="number">0xad</span>,<span class="number">0xdb</span>,<span class="number">0x8a</span>,<span class="number">0xe6</span>,<span class="number">0x37</span>,<span class="number">0x0f</span>,<span class="number">0x9d</span>,<span class="number">0xe6</span>,<span class="number">0x9e</span>,<span class="number">0x3a</span>,<span class="number">0x7a</span>,<span class="number">0x5c</span>,<span class="number">0x5c</span>,<span class="number">0x48</span>,<span class="number">0x8c</span>,<span class="number">0xde</span>,<span class="number">0x79</span>,<span class="number">0x75</span>,<span class="number">0x6b</span>,<span class="number">0x0b</span>,<span class="number">0x9f</span>,<span class="number">0x17</span>,<span class="number">0x13</span>,<span class="number">0xe7</span>,<span class="number">0x49</span>,<span class="number">0xed</span>,<span class="number">0xd4</span>,<span class="number">0x1c</span>,<span class="number">0xff</span>,<span class="number">0x04</span> };</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">17</span>] = { <span class="number">0</span> };</span><br><span class="line">buf[<span class="number">16</span>] = <span class="number">0</span>;</span><br><span class="line">memmove(buf, enc + i * <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">42</span>; ++j)</span><br><span class="line">{</span><br><span class="line">qua_rou(buf, <span class="number">14</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">qua_rou(buf, <span class="number">13</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(buf, <span class="number">12</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">qua_rou(buf, <span class="number">15</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">qua_rou(buf, <span class="number">15</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">3</span>);</span><br><span class="line">qua_rou(buf, <span class="number">14</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">qua_rou(buf, <span class="number">13</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">qua_rou(buf, <span class="number">12</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, buf+<span class="number">8</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="NotRC4"><a class="header-anchor" href="#NotRC4">¶</a>NotRC4</h1><h2 id="考点：RISV架构"><a class="header-anchor" href="#考点：RISV架构">¶</a>考点：RISV架构</h2><p>使用readelf可以知道是RISV架构</p><p><img src="/2022/05/05/MiniLctf2022/1651987423786.png" alt=""></p><h2 id="过程-v2"><a class="header-anchor" href="#过程-v2">¶</a>过程</h2><p>ida无法反编译，jeb可以反编译但是效果不太好，最好的还是Ghidra</p><p>就是一个VM题</p><p>分析完大概就是这样</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">final</span>[<span class="number">4</span>] = {</span><br><span class="line"><span class="number">0x4BC21DBB95EF82CA</span>, <span class="number">0xF57BECAE71B547BE</span>, <span class="number">0x80A1BDAB15E7F6CD</span>, <span class="number">0xA3C793D7E1776385</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> opcode[<span class="number">23</span>] = {</span><br><span class="line"><span class="number">0xF3</span>, <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0xE1</span>, <span class="number">0xF4</span>, <span class="number">0xE2</span>, <span class="number">0xF2</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0xF5</span>, <span class="number">0xF3</span>, <span class="number">0x02</span>, <span class="number">0xF4</span>, <span class="number">0xE1</span>, <span class="number">0xF4</span>, <span class="number">0xE2</span>,</span><br><span class="line"><span class="number">0xF2</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xFF</span>, <span class="number">0x00</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//F1对应的指令</span></span><br><span class="line"><span class="comment">//compare,long型的判断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F2</span></span><br><span class="line"><span class="comment">//循环的操作，和0x0B作比较，作为循环的次数，而4是指回到前四个指令的位置，实现循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F3，取出输入然后加上yyds和dbt!(小端序)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F4加密操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//F5,存储</span></span><br><span class="line"><span class="keyword">int</span> key[<span class="number">2</span>] = { <span class="number">0x64627421</span>, <span class="number">0x79796473</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp1 = <span class="keyword">final</span>[i] + key[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp2 = <span class="keyword">final</span>[i + <span class="number">1</span>] + key[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x0C</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp1 = ((tmp1 ^ tmp2) &gt;&gt; (-(<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>) | ((tmp1 ^ tmp2) &lt;&lt; ((<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>) + key[<span class="number">0</span>];</span><br><span class="line">tmp2 = ((tmp1 ^ tmp2) &gt;&gt; (-(<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>) | ((tmp1 ^ tmp2) &lt;&lt; ((<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>) + key[<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[i] = tmp1;</span><br><span class="line"><span class="keyword">final</span>[i + <span class="number">1</span>] = tmp2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>脚本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp1 = <span class="keyword">final</span>[i];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp2 = <span class="keyword">final</span>[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x0C</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp2 = ((((tmp2 - key[<span class="number">1</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &lt;&lt; ((-(<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>)) | (((tmp2 - key[<span class="number">1</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &gt;&gt; (((<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>))) ^ tmp1;</span><br><span class="line">tmp1 = ((((tmp1 - key[<span class="number">0</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &lt;&lt; ((-(<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>)) | (((tmp1 - key[<span class="number">0</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &gt;&gt; (((<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>))) ^ tmp2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[i] = tmp1 - key[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">final</span>[i+<span class="number">1</span>] = tmp2 - key[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">3</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">4</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">5</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">6</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">3</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">4</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">5</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">6</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">7</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目质量很高，我也是真的菜&lt;/p&gt;</summary>
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/categories/Competition/"/>
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>Frida-Hook</title>
    <link href="https://gift1a.github.io/2022/05/01/Frida-Hook/"/>
    <id>https://gift1a.github.io/2022/05/01/Frida-Hook/</id>
    <published>2022-04-30T21:18:23.000Z</published>
    <updated>2022-10-13T06:17:12.260Z</updated>
    
    <content type="html"><![CDATA[<p>Frida-Hook</p><span id="more"></span><h1 id="Frida"><a class="header-anchor" href="#Frida">¶</a>Frida</h1><p><a href="https://www.anquanke.com/post/id/195869#h3-21">Frida常用模块</a></p><p><a href="https://learnfrida.info/basic_usage/">Frida文档</a></p><blockquote><p><strong>Frida是一种动态插桩工具，可以插入一些代码到原生App的内存空间去动态地监视和修改其行为</strong>，但是持久化还是要依靠Xposed和HookZz开发框架。使用Frida导出的API和方法堆内存空间里的对象方法进行监视、修改或者替换的一段代码</p></blockquote><p>我们可以直接编写JS脚本，然后命令行模式(CLI)运行，也可以使用Python进行JS脚本的注入工作(RPC模式)</p><p><img src="/2022/05/01/Frida-Hook/1663487401127.png" alt=""></p><p><a href="https://blog.csdn.net/qq_38851536/article/details/104895878">Frida命令行提示</a></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{<span class="comment">//匿名函数</span></span><br><span class="line">        Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{<span class="comment">//调用Frida的API函数Java.perform()，然后这个API函数又接受了一个匿名方法，匿名方法调用打印函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用setTimeout()方法将函数注册到JS运行库，然后在JS运行库中调用Java.perform()方法将函数注册到APP的Java运行库并在这之中执行该函数</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>首先保证frida-server在手机上运行，然后使用frida-ps -U查看手机上正在运行的进程，接着在计算机的shell中执行frida -U -l testFrida.js Easy_Xor命令以attach模式注入指定应用</strong>，-l表示脚本路径</p></blockquote><p><img src="/2022/05/01/Frida-Hook/1663490820359.png" alt=""></p><p><a href="https://zhuanlan.zhihu.com/p/366240343">JS匿名函数</a></p><h2 id="Frida-Hook-Java类"><a class="header-anchor" href="#Frida-Hook-Java类">¶</a>Frida Hook Java类</h2><p>首先我们编写一个简单的APK</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            func(<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        String TAG=<span class="string">"MainActivity"</span>;</span><br><span class="line">        Log.d(TAG, String.valueOf(x+y));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每隔一秒就打印一次50+30的结果</p><p><strong>我们的目标是编写Hook func()函数并打印出func()函数的参数值</strong>，也就是Hook到func函数之后执行我们的Hook代码，然后再调用func函数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Script Loaded Successfully"</span>)</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Inside Java Perform Function"</span>)</span><br><span class="line">        <span class="keyword">var</span> MainActivity=Java.use(<span class="string">'com.flag.test1.MainActivity'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Find Class"</span>)<span class="comment">//定位类成功</span></span><br><span class="line">        MainActivity.func.implementation=<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"x =&gt; "</span>,x,<span class="string">"y =&gt; "</span>,y)</span><br><span class="line">            <span class="keyword">var</span> ret_value=<span class="built_in">this</span>.func(x,y);</span><br><span class="line">            <span class="keyword">return</span> ret_value</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></tbody></table></figure><p>下面截图可以看到参数值被成功打印</p><p><img src="/2022/05/01/Frida-Hook/1663498192780.png" alt=""></p><blockquote><p><strong>使用main函数存放Hook脚本，然后调用Frida的API函数Java.perfrom()将脚本的内容注入到Java运行库，匿名函数内容是监控和修改Java函数逻辑的主体内容，所有对App中Java层的操作都必须包裹在Java.perfrom()函数</strong>。</p><p>匿名函数中，<strong>调用Frida的API函数Java.use()，这个函数饿参数是Hook的函数所在类的全类名路径，参数的类型是一个字符串类型。这个函数的返回值 动态 地为相应Java类获取一个JavaScript Wrapper，可以通俗地理解为一个JavaScript对象</strong>。当获取到JavaScript对象之后，通过".“来获取我们要Hook的方法，<strong>implementation关键字表示实现MainActivity对象的func()方法</strong>。通过”="连接一个匿名函数，<strong>参数内容和原Java内容一致，JS不需要指明参数类型，匿名函数的内容取决于想要修改这个Hook函数的逻辑</strong>。通过this.fun()函数再次调用原函数，然后把原来的参数传递进这个func()函数，最后通过return返回</p><p><strong>setImmediate（Frida的API函数）函数传递的参数是要被执行 的函数，比如传入main参数，表示当Frida注入App后立即执行 main()函数，而setTimeout一般用于延时注入</strong></p><p><strong>在Hook一个函数时，还有一个地方需要注意，那就是最好不要 修改被Hook的函数的返回值类型，否则可能会引起程序崩溃等问 题，比如直接通过调用原函数将原函数的返回值返回</strong></p></blockquote><p>我们可以在调用函数时修改参数，此时使用<strong>adb logcat</strong>即可发现Log.d结果改变</p><p><img src="/2022/05/01/Frida-Hook/1663500121157.png" alt=""></p><h3 id="重载方法的Hook实现"><a class="header-anchor" href="#重载方法的Hook实现">¶</a>重载方法的Hook实现</h3><p>方法重载</p><p><img src="/2022/05/01/Frida-Hook/1663500896104.png" alt=""></p><p>Hook时只需要<strong>指定函数签名即可</strong></p><p><img src="/2022/05/01/Frida-Hook/1663500864313.png" alt=""></p><p><img src="/2022/05/01/Frida-Hook/1663500818900.png" alt=""></p><p>对于Hook另一个方法</p><p><img src="/2022/05/01/Frida-Hook/1663501014956.png" alt=""></p><p><img src="/2022/05/01/Frida-Hook/1663500994308.png" alt=""></p><h2 id="Java层主动调用"><a class="header-anchor" href="#Java层主动调用">¶</a>Java层主动调用</h2><p>主动调用<strong>分为实例方法和类函数</strong></p><blockquote><p><strong>类函数和实例方法通俗地讲就是静态的方法和动态的方法，类函数使用关键字static修饰，和对应类是绑定的，也就是当类的字节码文件加载到内存时，类函数的入口地址就会分配完成。而实例方法只有当类对象创建之后才分配入口地址。从而实例方法可以被类创建的对象调用</strong></p><p>如果是类函数主动调用，直接<strong>使用Java.use()函数找到类进行调用</strong>即可，如果是实例方法的主动调用，则需要再找到对应的实例后对方法进行调用，<strong>Java.close()函数可以在Java的堆中寻找指定类的实例</strong></p></blockquote><p>我们在APK中写一个类方法和实例方法</p><p><img src="/2022/05/01/Frida-Hook/1663506456940.png" alt=""></p><p>接下来写代码即可</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Script Run Successfully"</span>)</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Java Internal"</span>)</span><br><span class="line">        <span class="comment">//静态方法主动调用</span></span><br><span class="line">        <span class="comment">//找到要主动调用静态方法所在的类</span></span><br><span class="line">        <span class="keyword">var</span> MainActivity=Java.use(<span class="string">'com.flag.test1.MainActivity'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Find Class"</span>)</span><br><span class="line">        MainActivity.secret()</span><br><span class="line">        <span class="comment">//实例方法主动调用</span></span><br><span class="line">        <span class="comment">//第一个参数是类的全包名、第二个参数是相应类的对象，然后进行主动调用、第三个表示调用完成</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种方法</span></span><br><span class="line">        <span class="comment">//获取到类之后直接new一个实例</span></span><br><span class="line">        <span class="comment">//let object=Class.$new()</span></span><br><span class="line">        <span class="comment">//调用实例方法</span></span><br><span class="line">        <span class="comment">//object.method()</span></span><br><span class="line">        Java.choose(<span class="string">'com.flag.test1.MainActivity'</span>,{</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"instance found"</span>,instance)</span><br><span class="line">                instance.secret_instance()</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onComplete</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'search Complete'</span>)</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></tbody></table></figure><p>类方法主动调用</p><p><img src="/2022/05/01/Frida-Hook/1663505859398.png" alt=""></p><p>实例方法主动调用，<strong>我们也可以直接new一个实例然后进行调用实例方法</strong></p><p><img src="/2022/05/01/Frida-Hook/1663506156723.png" alt=""></p><h2 id="Frida-Hook-Native层"><a class="header-anchor" href="#Frida-Hook-Native层">¶</a>Frida Hook Native层</h2><p>也是分为两种情况</p><p><strong>一种是静态注册，一种是动态注册</strong>，**在JNI逆向过程中首先需要找到Java层函数在native层中对应的函数地址，然后再进行Hook。 Android系统为了快速找到JNI函数在native层的对应函数， 因而其命名规则都是固定的，并且在内存中也是不会发生变化的 **</p><h3 id="逆向流程"><a class="header-anchor" href="#逆向流程">¶</a>逆向流程</h3><p>使用Objection注入进程之后，使用<strong>memory list modules</strong>查看so文件是否被注入，<strong>so文件在内存中的加载基址、文件大小以及文件目录</strong>都打印出来了</p><p><img src="/2022/05/01/Frida-Hook/1663564863585.png" alt=""></p><p>接下来查看所有导出符号 <strong>memory list exports libfrida_so.so</strong>，其中有<strong>类型、符号以及起始地址</strong></p><p><img src="/2022/05/01/Frida-Hook/1663564994822.png" alt=""></p><p>我们可以找到StringFromJNI这个函数的起始地址，**在Android中每次加载模块时基地址都是变化的，最终会导致每 次加载后的函数地址也是不同的，真正可靠的是函数地址相对于模块基地址的偏移 **，使用当前函数起始地址减去模块加载地址即可</p><p><img src="/2022/05/01/Frida-Hook/1663565200368.png" alt=""></p><blockquote><p><strong>如果在cpp文件中没有声明函数为extern “C”</strong>，导出时会进行重载，我们可以使用C++ filt工具对函数名进行还原</p></blockquote><p><img src="/2022/05/01/Frida-Hook/1663565509310.png" alt=""></p><h3 id="native层Hook基础"><a class="header-anchor" href="#native层Hook基础">¶</a>native层Hook基础</h3><p><a href="https://www.anquanke.com/post/id/195215#h3-31">so层常用API</a></p><p><a href="https://bbs.pediy.com/thread-266419.htm">ida结构体创建和导入</a></p><p><a href="https://blog.csdn.net/lilongsy/article/details/122260341?spm=1001.2014.3001.5506">ida对so层的分析</a></p><p><a href="https://blog.csdn.net/Qiled/article/details/115235485">so层分析</a></p><h4 id="native层导出函数"><a class="header-anchor" href="#native层导出函数">¶</a>native层导出函数</h4><p>下面是Frida Hook native层函数的模板</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(addr,{</span><br><span class="line">        <span class="function"><span class="title">onEnter</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            <span class="comment">//do something with args</span></span><br><span class="line">        },</span><br><span class="line">        <span class="function"><span class="title">onLeave</span>(<span class="params">ret</span>)</span>{</span><br><span class="line">            <span class="comment">//do something with ret</span></span><br><span class="line">        }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>实现native层Hook得API函数是Interceptor.attach()函数，他的第一个参数是要Hook得函数地址，第二个参数是callback回调，在这个函数中存在两个函数，onEnter()函数是在函数调用前产生的回调，在这个函数中可以处理函数参数的相关内容，被Hook的函数参数内容以数组的方式存储在onEnter()函数的参数args中，onLeave()函数则是在被Hook的目标函数执行完成之后执行的函数，被Hook的函数返回值用onLeave()函数中的ret变量来表示</strong>，简单来说就是一个处理函数参数，一个处理返回值</p></blockquote><p>关键的一步就是要获取Hook函数的首地址</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是导出函数，那么可以通过下面两个API函数获得相应函数的首地址，第一个参数是模块名或者null(如果为null，会在所有模块扫描导出符号名)，第二个参数是目标函数的导出符号名</span></span><br><span class="line">Module.getExportByName(moduleName|<span class="literal">null</span>,exportName)</span><br><span class="line">Module.findExportByName(moduleName|<span class="literal">null</span>,exportName)</span><br><span class="line"></span><br><span class="line">Mudule.enumearteExports();<span class="comment">//获取导出函数表</span></span><br><span class="line"> <span class="comment">//获取导入表和导出表都是可以的</span></span><br><span class="line"><span class="keyword">var</span> Exports=Module.enumerateExports();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;Exports.length;++i){</span><br><span class="line">    <span class="built_in">console</span>.log(Exports[i].name+<span class="string">" "</span>+Exports[i].address);<span class="comment">//获取导出函数</span></span><br><span class="line">         }</span><br><span class="line">        <span class="comment">//获取到函数的基址之后即可完成Hook和调用</span></span><br><span class="line">        <span class="comment">//也可以通过getExportByName传入函数名进行获取</span></span><br><span class="line"></span><br><span class="line">Process.enumerateModules();<span class="comment">//获取所有apk加载的so文件</span></span><br><span class="line"></span><br><span class="line">hexdump(addr);<span class="comment">//获取内存中的值</span></span><br></pre></td></tr></tbody></table></figure><p>为了将返回值的内容打印出来，调用了</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hook_native</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"=====Hooking Native====="</span>)</span><br><span class="line">    <span class="comment">//get exportFunction Addr</span></span><br><span class="line">    <span class="keyword">var</span> addr=Module.getExportByName(<span class="string">"libfrida_so.so"</span>,<span class="string">"Java_com_flag_frida_1so_MainActivity_stringFromJNI"</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(addr)</span><br><span class="line">    <span class="comment">//Hook Function</span></span><br><span class="line">    Interceptor.attach(addr,{</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//print args</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"JniEnv pointer =&gt; "</span>,args[<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Jobj pointer =&gt; "</span>,args[<span class="number">1</span>])</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">            <span class="comment">//get return value</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Retutn Value =&gt; "</span>,Java.vm.getEnv().getStringUtfChars(retval,<span class="literal">null</span>).readCString())</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"===================="</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>{</span><br><span class="line">    hook_native()</span><br><span class="line">}</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></tbody></table></figure><p>首先使用Java.vm.getEnv()获取当前线程的JNIEnv结构，并参照JNI函数GetStringUtfChars()获取到的Java的字符串对用的C字符首地址，获取到C字符串指针后，通过readCString()这个API函数读取内存中的C字符串</p><p><img src="/2022/05/01/Frida-Hook/1663580703086.png" alt=""></p><p>为了能够保证stringFromJNI()函数的执行在完成Hook后执行， 这 里 先 在 MainActivity 类 的 onCreate() 函 数 中 加 上 一 个 对 stringFromJNI()函数的循环调用</p><p><img src="/2022/05/01/Frida-Hook/1663580908173.png" alt=""></p><h4 id="native未导出函数"><a class="header-anchor" href="#native未导出函数">¶</a>native未导出函数</h4><blockquote><p><strong>由于每次App重新运行后native函数加载的绝对地址，而Frida也为我们提供了获取基址的函数，Module.findBaseAddress(name)或者Module.getBaseAddress(name)获取对应模块的及地址，然后通过add(offset)函数传入固定的便宜来获取最后函数的绝对地址</strong></p></blockquote><p>下面是动态注册的代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jstring JNICALL <span class="title">stringFromJNI</span><span class="params">(JNIEnv*env,jobject MainActivity)</span></span>{</span><br><span class="line">    std::string hello=<span class="string">"Hello from C++ Firda_so"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());<span class="comment">//返回字符串</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM*vm,<span class="keyword">void</span>*reserved)</span></span>{</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    vm-&gt;<span class="built_in">GetEnv</span>((<span class="keyword">void</span>**)&amp;env,JNI_VERSION_1_6);<span class="comment">//获取JVM中的线程信息</span></span><br><span class="line">    <span class="comment">//创建一一对应的函数表</span></span><br><span class="line">    JNINativeMethod methods[]={</span><br><span class="line">            {<span class="string">"stringFromJNI"</span>,<span class="string">"()Ljava/lang/String;"</span>,(<span class="keyword">void</span>*)stringFromJNI},</span><br><span class="line">    };</span><br><span class="line">    env-&gt;<span class="built_in">RegisterNatives</span>(env-&gt;<span class="built_in">FindClass</span>(<span class="string">"com/flag/frida_so/MainActivity"</span>),methods,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;<span class="comment">//返回JNI版本</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://github.com/lasting-yang/frida_hook_libart">frida_hook_libart</a>，这个项目包含着对JNI函数和art相关函数的Frida_Hook脚本，这里要使用的是RegisterNatives()函数的Hook脚本</p><p>在github下载下来发现不会打印偏移，去网上找了一个可以打印offset的代码</p><p><a href="https://blog.csdn.net/weixin_38927522/article/details/120033269">计算offset的代码</a></p><p><strong>也可以直接通过so文件获取</strong></p><p>为了能顺利地在RegisterNatives()函数未被调用前Hook到，需要使用spwan模式(即将APP的启动权限交给Frida，Frida会重启程序)注入进程</p><p><img src="/2022/05/01/Frida-Hook/1663650879573.png" alt=""></p><p>此时StringFromJNI函相对so文件的偏移为</p><p><img src="/2022/05/01/Frida-Hook/1663653830410.png" alt=""></p><p>获取到函数偏移之后即可使用查找函数地址的方式获取相应函数地址进行Hook，代码如下</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="comment">//获取so文件的模块基址</span></span><br><span class="line">    <span class="keyword">var</span> native_addr=Module.findBaseAddress(<span class="string">'libfrida_so.so'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'native_addr is =&gt;'</span>,native_addr)</span><br><span class="line">    <span class="keyword">var</span> stringfromJNi=native_addr.add(<span class="number">0xf11c</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"StringFromJNI address =&gt; "</span>,stringfromJNi)</span><br><span class="line">    <span class="comment">//获取函数的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到之后即可进行Hook</span></span><br><span class="line">    Interceptor.attach(stringfromJNi,{</span><br><span class="line">        <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"jnienv pointer =&gt; "</span>,args[<span class="number">0</span>])</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"jobj pointer =&gt; "</span>,args[<span class="number">1</span>])</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"retval =&gt; "</span>,Java.vm.getEnv().getStringUtfChars(retval,<span class="literal">null</span>).readCString())</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"================="</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></tbody></table></figure><h3 id="native主动调用和替代函数"><a class="header-anchor" href="#native主动调用和替代函数">¶</a>native主动调用和替代函数</h3><h4 id="native函数替代"><a class="header-anchor" href="#native函数替代">¶</a>native函数替代</h4><p><strong>Interceptor.replace</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.replace(addr,NativeCallback);</span><br><span class="line"><span class="comment">//其中addr是替换函数的地址</span></span><br><span class="line"><span class="comment">//NativeCallback是一个回调函数</span></span><br><span class="line"></span><br><span class="line">Interceptor.replace(<span class="built_in">this</span>.context.x2,<span class="keyword">new</span> NativeCallback(<span class="function"><span class="keyword">function</span>(<span class="params">a1</span>)</span>{</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Replace Success"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">},<span class="string">'void'</span>,[]));</span><br><span class="line"></span><br><span class="line"><span class="comment">//NativeCallBack(replace_function,Return_Type,Arrgument_List);第一个参数是替换之后的函数，第二个参数是函数的返回值类型，第三个参数是参数列表，[]表示为空</span></span><br><span class="line"><span class="comment">//addr必须是一个NativePointer</span></span><br></pre></td></tr></tbody></table></figure><h4 id="主动调用"><a class="header-anchor" href="#主动调用">¶</a>主动调用</h4><p>感觉和replace差不多，得到需要主动调用的函数的地址之后通过**NativeFunction()**创建一个函数后调用</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NativeFunction(addr,Return_Type,Arrgument_List);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add_method = <span class="keyword">new</span> NativeFunction(Module.findExportByName(<span class="string">'libhello.so'</span>, <span class="string">'c_getSum'</span>), <span class="string">'int'</span>,[<span class="string">'int'</span>,<span class="string">'int'</span>]);</span><br><span class="line"><span class="comment">//输出结果 那结果肯定就是 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"result:"</span>,add_method(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></tbody></table></figure><p>如果传入的参数是结构体</p><p><img src="/2022/05/01/Frida-Hook/1665401600482.png" alt=""></p><h3 id="native修改函数的参数和返回值"><a class="header-anchor" href="#native修改函数的参数和返回值">¶</a>native修改函数的参数和返回值</h3><h4 id="修改函数的返回值"><a class="header-anchor" href="#修改函数的返回值">¶</a>修改函数的返回值</h4><p>使用**.replace()**</p><p>首先使用Interceptor.attach()拦截到我们想要修改的函数，</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(connect,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line"><span class="comment">//args是参数数组，使用args[0]等即可访问</span></span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"Change Success!!"</span>);</span><br><span class="line">                <span class="comment">//使用replace修改参数和返回值</span></span><br><span class="line">                retval.replace(<span class="number">1</span>);<span class="comment">//将返回值修改为1表示连接端口成功</span></span><br><span class="line">  }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h4 id="修改数值参数"><a class="header-anchor" href="#修改数值参数">¶</a>修改数值参数</h4><p>使用<strong>ptr()<strong>即可，ptr可以将数值转为</strong>NativePointer</strong>类型</p><p>**toInt32()**将参数转为int型数据</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(nativePointer, {</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">            send(args[<span class="number">0</span>]);</span><br><span class="line">            send(args[<span class="number">1</span>]);</span><br><span class="line">            send(args[<span class="number">2</span>].toInt32());</span><br><span class="line">            send(args[<span class="number">3</span>].toInt32());</span><br><span class="line">            send(args[<span class="number">4</span>].toInt32());</span><br><span class="line">            args[<span class="number">4</span>] = ptr(<span class="number">1000</span>);   <span class="comment">//new NativePointer</span></span><br><span class="line">            send(args[<span class="number">4</span>].toInt32());</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">onLeave</span>: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">            send(retval.toInt32());</span><br><span class="line">            retval.replace(<span class="number">10000</span>);</span><br><span class="line">            send(retval.toInt32());</span><br><span class="line">        }</span><br><span class="line">    })</span><br></pre></td></tr></tbody></table></figure><h4 id="修改字符串参数"><a class="header-anchor" href="#修改字符串参数">¶</a>修改字符串参数</h4><p>有多种办法，这里采用将字符串写入内存中的办法来修改</p><p>主要用到<strong>Memory.allocUtf8String(str)</strong>,然后直接将地址赋值给参数即可</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newStr=<span class="string">"new String"</span>;</span><br><span class="line">        <span class="keyword">var</span> newstraddr=Memory.allocUtf8String(newStr);<span class="comment">//写入内存，返回字符串第一个字符的地址</span></span><br><span class="line">        <span class="keyword">var</span> strcpy=Module.findExportByName(<span class="string">"libc.so"</span>,<span class="string">"strcpy"</span>);</span><br><span class="line">        Interceptor.attach(strcpy,{</span><br><span class="line">            <span class="comment">//对于数值参数的修改，使用ptr()即可</span></span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                args[<span class="number">1</span>]=newstraddr;</span><br><span class="line">                <span class="built_in">console</span>.log(args[<span class="number">1</span>].readCString());</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><h2 id="libssl和libc库的Hook"><a class="header-anchor" href="#libssl和libc库的Hook">¶</a>libssl和libc库的Hook</h2><p>其中会使用到<strong>frida-trace</strong></p><h2 id="RPC及其自动化"><a class="header-anchor" href="#RPC及其自动化">¶</a>RPC及其自动化</h2><p>可以使用Python完成JS脚本对进程的注入以及相应的Hook</p><p>首先先修改APK代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String total=<span class="string">"hello"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            func(<span class="number">50</span>,<span class="number">30</span>);</span><br><span class="line">            func(<span class="string">"Jack"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line">        String TAG=<span class="string">"MainActivity"</span>;</span><br><span class="line">        Log.d(TAG, String.valueOf(x+y));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(String name)</span></span>{</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>,name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secret</span><span class="params">()</span></span>{</span><br><span class="line">        total+=<span class="string">" secretFunc"</span>;</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>,<span class="string">"Call Static Secret Method"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">secret_instance</span><span class="params">()</span></span>{</span><br><span class="line">        Log.d(<span class="string">"MainActivity"</span>,<span class="string">"Call Static Secret_Instance Method"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编写JS脚本获取值(instance.total.<strong>value</strong>)和主动调用实例方法</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RunMethod</span>(<span class="params"></span>)</span>{</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        Java.choose(<span class="string">'com.flag.test1.MainActivity'</span>,{</span><br><span class="line">        <span class="attr">onMatch</span>: <span class="function"><span class="keyword">function</span>(<span class="params">instance</span>)</span>{</span><br><span class="line">            instance.secret()</span><br><span class="line">        },</span><br><span class="line">        <span class="attr">onComplete</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        }}</span><br><span class="line">        )</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Script Run Successfully"</span>)</span><br><span class="line">    Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Java Internal"</span>)</span><br><span class="line">        <span class="keyword">var</span> MainActivity=Java.use(<span class="string">'com.flag.test1.MainActivity'</span>)</span><br><span class="line">        <span class="comment">//动态函数主动调用</span></span><br><span class="line">        RunMethod()</span><br><span class="line">        Java.choose(<span class="string">'com.flag.test1.MainActivity'</span>,{</span><br><span class="line">            <span class="attr">onMatch</span>:<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>)</span>{</span><br><span class="line">                <span class="comment">//由于是类变量，必须通过对象来获取</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'total value='</span>,instance.total.value);</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onComplete</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"search Complete"</span>)</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line"></span><br><span class="line">    })</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/05/01/Frida-Hook/1663508018519.png" alt=""></p><p><img src="/2022/05/01/Frida-Hook/1663508782781.png" alt=""></p><p>接下来我们<strong>使用RPC远程调用，首先将两个函数导出，使得外部可以调用，在JS代码末尾加上RPC相关代码</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message,data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>]==<span class="string">'send'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"[*] {0}"</span>.<span class="built_in">format</span>(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"><span class="comment">#需要设置timeout时间，attach中的内容看firda-ps -U进程内容</span></span><br><span class="line"><span class="comment">#使用get_usb_device获取usb设备句柄，然后attach到需要hook的进程上</span></span><br><span class="line">process = frida.get_usb_device(<span class="number">3000</span>).attach(<span class="string">'test1'</span>)</span><br><span class="line"><span class="comment">#最好不要有中文，否则GBK编码无法通过</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'get_value.js'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    jscode=f.read()</span><br><span class="line"><span class="comment">#读取js脚本文件之后加载编写的JS代码</span></span><br><span class="line">script=process.create_script(jscode)</span><br><span class="line"><span class="comment">#注册了自己的消息对应的函数，每当JS需要输出是都会经过这里指定的on_message进行</span></span><br><span class="line">script.on(<span class="string">'message'</span>,on_message)</span><br><span class="line"><span class="comment">#加载</span></span><br><span class="line">script.load()</span><br><span class="line"></span><br><span class="line">command=<span class="string">""</span></span><br><span class="line"><span class="comment">#通过script.exports访问在JS中定义的导出名，进而对齐进行调用</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>==<span class="number">1</span>:</span><br><span class="line">    command=<span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">if</span> command==<span class="string">"1"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> command==<span class="string">"2"</span>:</span><br><span class="line">        script.exports.getvalue()</span><br><span class="line">    <span class="keyword">elif</span> command==<span class="string">"3"</span>:</span><br><span class="line">        script.exports.runmethod()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="Frida-InlineHook"><a class="header-anchor" href="#Frida-InlineHook">¶</a>Frida-InlineHook</h3><p>也就是Hook一条汇编指令</p><p>实际上和Hook函数差不多，都是使用<strong>Interceptor.attach</strong>，获取到指令地址就可以对其进行操作</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.attach(func2,{</span><br><span class="line">            <span class="attr">onEnter</span>:<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.x11);</span><br><span class="line">                <span class="built_in">this</span>.context.x11=<span class="number">0x45</span>;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.x11);</span><br><span class="line">            },</span><br><span class="line">            <span class="attr">onLeave</span>:<span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>{</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.context.x11);</span><br><span class="line">            }</span><br><span class="line">        })</span><br></pre></td></tr></tbody></table></figure><h4 id="修改汇编指令"><a class="header-anchor" href="#修改汇编指令">¶</a>修改汇编指令</h4><p>首先我们要将地址的权限修改为可读可写可执行(不然有时候会有bug)，使用的是<strong>Memory.protect()</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Memory.protect(addr,size,<span class="string">'rwx'</span>);</span><br><span class="line"><span class="comment">//表示将addr处size个字节的属性修改为可读可写可执行</span></span><br></pre></td></tr></tbody></table></figure><p>接下来就需要使用写入内存的函数<strong>writeByteArray</strong></p><h2 id="Frida其他用法"><a class="header-anchor" href="#Frida其他用法">¶</a>Frida其他用法</h2><ul><li><p><strong>hexdump打印内存的数据</strong>——<strong>可以用于打印加密后的结果和函数参数</strong></p>  <figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hexdump</span><span class="params">(address)</span></span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>打印调用栈(也可以使用Objection)</strong></p></li><li><p><strong>Frida创建Java数组</strong></p><p>使用<strong>Java.array()</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objArray = Java.array(<span class="string">"Ljava.lang.String;"</span>,[<span class="string">"12"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"4"</span>]);</span><br><span class="line"><span class="comment">//第一个参数表示数组的类型，第二个参数表示数组中的内容</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>Frida读取内存数据并转为字节数组并转为字符串</strong></p><p>有时候我们需要将内存中的数据读取到Hook代码中并进行运算</p><p>使用到的是<strong>readByteArray(size)</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addr.readByteArray(size);</span><br><span class="line"><span class="comment">//从addr处读取size大小的字节数组</span></span><br></pre></td></tr></tbody></table></figure><p>接下来使用js自带的<strong>Uint8Array</strong>来接收</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bytes= <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(addr.readByteArray(size));</span><br></pre></td></tr></tbody></table></figure><p>接下来可以使用JS自带的**String.fromCharCode()**将字节转为字符</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> final=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">24</span>;++i){</span><br><span class="line">            final+=<span class="built_in">String</span>.fromCharCode(encodeanwser[i]^xorkey[i]);</span><br><span class="line">        }</span><br><span class="line"><span class="built_in">console</span>.log(final);</span><br></pre></td></tr></tbody></table></figure><p>这样就可以将xor后的结果转为字符串后打印出来</p></li><li><p><strong>Frida从内存中读取字符串</strong></p><p>使用<strong>addr.readCString()</strong></p>  <figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xorkey = addr1.readCString();</span><br></pre></td></tr></tbody></table></figure><p>这样读取到的即为字符串，读取到’\0’为止</p></li><li><p><strong>JS中将字符串转为字节数组</strong></p></li><li></li></ul><pre><code>​    </code></pre><h2 id="Python实现常见加密"><a class="header-anchor" href="#Python实现常见加密">¶</a>Python实现常见加密</h2><h3 id="Python中bytes和String的转换"><a class="header-anchor" href="#Python中bytes和String的转换">¶</a>Python中bytes和String的转换</h3><p>因为加密的数据都需要为字节流，所以要先转为bytes型数据</p><p>对于数组直接使用<strong>bytes</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = [<span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x56</span>, <span class="number">0x99</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(b))</span><br></pre></td></tr></tbody></table></figure><p><strong>bytes转为String使用decode()方法即可</strong></p><p><strong>String转为bytes使用encode()方法即可</strong></p><h3 id="Hash"><a class="header-anchor" href="#Hash">¶</a>Hash</h3><p>主要用到的是<strong>hashlib</strong>，Python自带的</p><p>直接通过hashlib.md5()等即可进行加密</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">enc1 = hashlib.md5(flag)</span><br><span class="line"><span class="comment"># hexdigest()转为十六进制格式的字符串</span></span><br><span class="line"><span class="built_in">print</span>(enc1.digest())</span><br><span class="line"><span class="comment">#degiest()可以将密文转为bytes型数据</span></span><br></pre></td></tr></tbody></table></figure><p>提供的加密有</p><p><img src="/2022/05/01/Frida-Hook/1665640297232.png" alt=""></p><p>使用起来也是比较方便的，这里以md5为例</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(hashlib.md5(<span class="string">b'helloworld'</span>).hexdigest())</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/05/01/Frida-Hook/1665640397026.png" alt=""></p><p>如果想得到字节流，只需要将hexdigest()改为**digest()**即可</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashlib.md5(<span class="string">b'helloworld'</span>).digest()</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/05/01/Frida-Hook/1665640478425.png" alt=""></p><h3 id="对称加密"><a class="header-anchor" href="#对称加密">¶</a>对称加密</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> Blowfish</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> Salsa20</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br></pre></td></tr></tbody></table></figure><p>使用的方法也是一致的，首先先<strong>new</strong>一个对象，<strong>需要传入key、指定的Mode、IV</strong></p><p>然后通过**.encrypt(flag)，.decrypt(enc)**进行解密，注意必须是字节流</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个AES对象</span></span><br><span class="line">aes = AES.new(password, AES.MODE_ECB)</span><br><span class="line"><span class="comment"># 接着通过aes对象进行加密</span></span><br><span class="line">enc = aes.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span>(enc)</span><br><span class="line"><span class="built_in">print</span>(aes.decrypt(enc).decode())</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/05/01/Frida-Hook/1665640773714.png" alt=""></p><p>下面使用AES的CBC模式进行加密</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aes1 = AES.new(password, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line">enc2 = aes1.encrypt(flag)</span><br><span class="line"><span class="built_in">print</span>(enc2)</span><br><span class="line"><span class="comment"># CBC模式下解密需要重新new一个AES对象</span></span><br><span class="line">aes2 = AES.new(password, AES.MODE_CBC, iv)</span><br><span class="line"><span class="comment"># decode将bytes转为String</span></span><br><span class="line"><span class="built_in">print</span>((aes2.decrypt(enc2)).decode())</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/05/01/Frida-Hook/1665640843316.png" alt=""></p><p><strong>需要注意的是CBC模式下解密需要重新new一个AES对象</strong></p><h3 id="Base64编码解码"><a class="header-anchor" href="#Base64编码解码">¶</a>Base64编码解码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(<span class="string">b'123123'</span>))</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/05/01/Frida-Hook/1665641035780.png" alt=""></p><p>也可以指定其他base家族的</p><p><img src="/2022/05/01/Frida-Hook/1665641085688.png" alt=""></p><h2 id="Java实现常见加密、编码"><a class="header-anchor" href="#Java实现常见加密、编码">¶</a>Java实现常见加密、编码</h2><h3 id="bytes和String的互相转换"><a class="header-anchor" href="#bytes和String的互相转换">¶</a>bytes和String的互相转换</h3><p><a href="https://www.jianshu.com/p/9985ac9bc6f6">参考</a></p><h3 id="Base64编码解码-v2"><a class="header-anchor" href="#Base64编码解码-v2">¶</a>Base64编码解码</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;Frida-Hook&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF-FATE-Reverse</title>
    <link href="https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/"/>
    <id>https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/</id>
    <published>2022-04-23T12:40:54.000Z</published>
    <updated>2022-04-24T07:53:15.696Z</updated>
    
    <content type="html"><![CDATA[<p>DASCTF-FATE-Reverse</p><span id="more"></span> <h1 id="0x00-Crackme"><a class="header-anchor" href="#0x00-Crackme">¶</a>0x00-Crackme</h1><h2 id="考点-v8"><a class="header-anchor" href="#考点-v8">¶</a>考点</h2><p>MFC逆向、反调试、Wincrypt</p><h2 id="分析-v8"><a class="header-anchor" href="#分析-v8">¶</a>分析</h2><p>看exe文件的图标是MFC，于是去网上搜了一下MFC逆向，发现了这篇文章</p><p><a href="https://blog.csdn.net/Sanky0u/article/details/81568483">https://blog.csdn.net/Sanky0u/article/details/81568483</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650718980990.png" alt=""></p><p>1000和1001对应两个输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719074057.png" alt=""></p><p>能定位到输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719123440.png" alt=""></p><p>对函数交叉引用发现找不到，因为这里使用的是this指针调用（可能）</p><blockquote><p><strong>MFC主函数是WinMain</strong></p></blockquote><p>然后动调半天看晕了</p><p>字符串搜索回显的字符串Wrong，直接明文存储</p><p>如果下次有机会出这样的题一定把回显字符串加密（</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719281899.png" alt=""></p><p>流程分析</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719629400.png" alt=""></p><p>这里都是一些API函数，就不过多介绍了</p><h3 id="key加密"><a class="header-anchor" href="#key加密">¶</a>key加密</h3><p>关键的是</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719692346.png" alt=""></p><p>不同的值对应了不同的加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719799678.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719826383.png" alt=""></p><p>所以就是将我们输入的key分为两个长度为四的字符串，然后分别进行MD5和SHA1加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719927941.png" alt="最终的加密"></p><h3 id="flag加密"><a class="header-anchor" href="#flag加密">¶</a>flag加密</h3><p>先把整段key进行md5加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720029530.png" alt=""></p><p>然后将加密后的key传入最终的加密函数中，生成MD5的哈希值，传入生成Key</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720157885.png" alt=""></p><p>看到这个参数，查了一下</p><p><a href="https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN">https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN</a></p><p>发现对应AES-128，也就是生成AES-128的密钥</p><p>然后调用CryptEncrypt函数加密</p><h3 id="反调试-ZwSetInformationThread"><a class="header-anchor" href="#反调试-ZwSetInformationThread">¶</a>反调试-ZwSetInformationThread</h3><p>我们需要动态调试提取数据，但是在刚才的位置设置断点会发现输入后直接结束，应该是有反调试</p><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/">https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/</a></p><p>对比各种反调试和去IMPORT找导入函数，最终确定是ZwSetInformationThread</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720722604.png" alt=""></p><p>反反调试在该文中也有介绍，就不再多说了</p><p>绕过后就可以提取数据进行解密了</p><h3 id="得到key"><a class="header-anchor" href="#得到key">¶</a>得到key</h3><p>MD5</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650761698008.png" alt=""></p><p>SHA1</p><p><a href="https://crackstation.net/">https://crackstation.net/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762007404.png" alt=""></p><h3 id="解密flag"><a class="header-anchor" href="#解密flag">¶</a>解密flag</h3><p>这里直接提取数据拿去AES解密有问题（提取出来调用CryptDecrypt也不行），还是FallW1nd师傅强，想到直接模拟生成哈希值的过程，然后最后调用CryptDecrypt即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762204848.png" alt=""></p><p>EXP如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HCRYPTKEY phKey; <span class="comment">// [esp+Ch] [ebp-10h] BYREF</span></span><br><span class="line">    HCRYPTPROV phProv; <span class="comment">// [esp+10h] [ebp-Ch] BYREF</span></span><br><span class="line">    HCRYPTHASH phHash; <span class="comment">// [esp+14h] [ebp-8h] BYREF</span></span><br><span class="line">    BOOL retValue;</span><br><span class="line"></span><br><span class="line">    BYTE flag_data[<span class="number">0x104</span>] = { <span class="number">0x5B</span>, <span class="number">0x9C</span>, <span class="number">0xEE</span>, <span class="number">0xB2</span>, <span class="number">0x3B</span>, <span class="number">0xB7</span>, <span class="number">0xD7</span>, <span class="number">0x34</span>, <span class="number">0xF3</span>, <span class="number">0x1B</span>, <span class="number">0x75</span>, <span class="number">0x14</span>, <span class="number">0xC6</span>, <span class="number">0xB2</span>, <span class="number">0x1F</span>, <span class="number">0xE8</span>, <span class="number">0xDE</span>, <span class="number">0x33</span>, <span class="number">0x44</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x1B</span>, <span class="number">0x47</span>, <span class="number">0x6A</span>, <span class="number">0xD4</span>, <span class="number">0x37</span>, <span class="number">0x51</span>, <span class="number">0x88</span>, <span class="number">0xFC</span>, <span class="number">0x67</span>, <span class="number">0xE6</span>, <span class="number">0x60</span>, <span class="number">0xDA</span>, <span class="number">0x0D</span>, <span class="number">0x58</span>, <span class="number">0x07</span>, <span class="number">0x81</span>, <span class="number">0x43</span>, <span class="number">0x53</span>, <span class="number">0xEA</span>, <span class="number">0x7B</span>, <span class="number">0x52</span>, <span class="number">0x85</span>, <span class="number">0x6C</span>, <span class="number">0x86</span>, <span class="number">0x65</span>, <span class="number">0xAF</span>, <span class="number">0xB4</span> };</span><br><span class="line">    BYTE keyBuf[] = { <span class="number">0x5c</span>,<span class="number">0x53</span>,<span class="number">0xa4</span>,<span class="number">0xa4</span>,<span class="number">0x1d</span>,<span class="number">0x52</span>,<span class="number">0x43</span>,<span class="number">0x7a</span>,<span class="number">0x9f</span>,<span class="number">0xa1</span>,<span class="number">0xe9</span>,<span class="number">0xc2</span>,<span class="number">0x6c</span>,<span class="number">0xa5</span>,<span class="number">0x90</span>,<span class="number">0x90</span> };</span><br><span class="line">    DWORD dwDataLen = <span class="number">0x10</span>;</span><br><span class="line">    DWORD dwBufLen = <span class="number">0x104</span>;</span><br><span class="line">    DWORD dwDataLen_2;</span><br><span class="line">    DWORD* pdwDataLen = &amp;dwDataLen_2;</span><br><span class="line">    *pdwDataLen = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    phProv = <span class="number">0</span>;</span><br><span class="line">    phHash = <span class="number">0</span>;</span><br><span class="line">    phKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retValue = CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x18</span>u, <span class="number">0xF0000000</span>);</span><br><span class="line">    <span class="keyword">if</span> (retValue)</span><br><span class="line">    {</span><br><span class="line">        retValue = CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash);</span><br><span class="line">        <span class="keyword">if</span> (retValue)</span><br><span class="line">        {</span><br><span class="line">            retValue = CryptHashData(phHash, keyBuf, dwDataLen, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (retValue)</span><br><span class="line">            {</span><br><span class="line">                retValue = CryptDeriveKey(phProv, <span class="number">0x660E</span>u, phHash, <span class="number">1u</span>, &amp;phKey);</span><br><span class="line">                <span class="keyword">if</span> (retValue)</span><br><span class="line">                    retValue = CryptDecrypt(phKey, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, flag_data, pdwDataLen);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phKey)</span><br><span class="line">        CryptDestroyKey(phKey);</span><br><span class="line">    <span class="keyword">if</span> (phHash)</span><br><span class="line">        CryptDestroyHash(phHash);</span><br><span class="line">    <span class="keyword">if</span> (phProv)</span><br><span class="line">        CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h3><p>还有这种调用加密，有兴趣可以去看看-<a href="http://ctf.hsc2019.site/challenges#DRIVER-58">http://ctf.hsc2019.site/challenges#DRIVER-58</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762364038.png" alt=""></p><h1 id="0x01-FakePica"><a class="header-anchor" href="#0x01-FakePica">¶</a>0x01-FakePica</h1><h2 id="考点-v9"><a class="header-anchor" href="#考点-v9">¶</a>考点</h2><p>安卓加壳、AES</p><h2 id="分析-v9"><a class="header-anchor" href="#分析-v9">¶</a>分析</h2><p>hgame-week3-re也有脱壳，这里把工具链接贴一下</p><p><a href="https://github.com/CodingGay/BlackDex">https://github.com/CodingGay/BlackDex</a></p><p>具体分析加壳与脱壳直接看我之前写的文章</p><p><a href="https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=%E6%A2%86">https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=梆</a></p><h3 id="加密分析"><a class="header-anchor" href="#加密分析">¶</a>加密分析</h3><p>找到Mainactivity</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762932688.png" alt=""></p><p>数据提取</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content[] = {<span class="number">-114</span>, <span class="number">95</span>, <span class="number">-37</span>, <span class="number">127</span>, <span class="number">-110</span>, <span class="number">113</span>, <span class="number">41</span>, <span class="number">74</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">19</span>, <span class="number">124</span>, <span class="number">-57</span>, <span class="number">-88</span>, <span class="number">39</span>, <span class="number">-116</span>, <span class="number">-16</span>, <span class="number">-75</span>, <span class="number">-3</span>, <span class="number">-45</span>, <span class="number">-73</span>, <span class="number">-6</span>, <span class="number">-104</span>, <span class="number">-6</span>, <span class="number">-78</span>, <span class="number">121</span>, <span class="number">110</span>, <span class="number">74</span>, <span class="number">-90</span>, <span class="number">-47</span>, <span class="number">-28</span>, <span class="number">-28</span>};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content1[] = {<span class="number">-40</span>, <span class="number">26</span>, <span class="number">95</span>, <span class="number">-49</span>, <span class="number">-40</span>, <span class="number">-123</span>, <span class="number">72</span>, <span class="number">-90</span>, <span class="number">-100</span>, <span class="number">-41</span>, <span class="number">122</span>, <span class="number">-4</span>, <span class="number">25</span>, <span class="number">-101</span>, <span class="number">-58</span>, <span class="number">116</span>};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, content1[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解密直接去在线网站即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763024950.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763086950.png" alt="get flag"></p><h1 id="0x02-奇怪的交易"><a class="header-anchor" href="#0x02-奇怪的交易">¶</a>0x02-奇怪的交易</h1><h2 id="考点-v10"><a class="header-anchor" href="#考点-v10">¶</a>考点</h2><p>ELF-python打包、算法</p><h2 id="分析-v10"><a class="header-anchor" href="#分析-v10">¶</a>分析</h2><p>还好加了Lu1u师傅，刚好看到</p><p><a href="https://lu1u.xyz/2022/03/28/RE_Challenge/">https://lu1u.xyz/2022/03/28/RE_Challenge/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763204421.png" alt=""></p><blockquote><p><strong>objcopy --dump-section pydata=pydata.dump 1</strong></p><p><strong>sudo snap install pyinstxtractor</strong></p><p><strong>pyinstxtractor pydata.dump</strong></p></blockquote><p>得到pyc文件，修补好文件头发现uncompyle6不了（因为是3.10的），寄，只能嗯读python字节码</p><h3 id="翻译字节码"><a class="header-anchor" href="#翻译字节码">¶</a>翻译字节码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cup <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">pub_key=[<span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,<span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">pp=[<span class="number">0</span>]</span><br><span class="line">dd=[<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>]</span><br><span class="line">oo=[<span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">        <span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,</span><br><span class="line">        <span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">    flag=<span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    m=libnum.s2n(flag)<span class="comment">#字符串转为数字</span></span><br><span class="line">    c=<span class="built_in">str</span>(<span class="built_in">pow</span>(m,pub_key[<span class="number">1</span>],pub_key[<span class="number">0</span>]))<span class="comment">#简单算法并且进行转为字符串</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">        kk=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> c[<span class="built_in">slice</span>(i,i+<span class="number">4</span>)]:</span><br><span class="line">            kk=(kk&lt;&lt;<span class="number">8</span>)+<span class="built_in">ord</span>(ii)</span><br><span class="line">            pp.append(kk)</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">            ww=<span class="built_in">len</span>(pp)</span><br><span class="line">            res=encrypt(ww,pp,dd)</span><br><span class="line">    <span class="keyword">if</span> pp==oo:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are right!!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"gg"</span>)</span><br><span class="line">        quit()</span><br></pre></td></tr></tbody></table></figure><p>翻译出来大概是这样的</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785245624.png" alt=""></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785253078.png" alt=""></p><p>这里要关注跳转的条件是not还是true</p><blockquote><p><em><em>encrypt函数是cup库里面的一个函数，当时我忽略了from cup import</em>，导致一直识别不出来encrypt函数是什么</em>*</p></blockquote><p>过程差不多都可以读出来，那个for循环就是将每四个字符转为一个int，由于不会python，很多都是自己写代码试出来的（,剩下的蹲wp了</p><blockquote><p>整个过程就是先进行RSA加密，然后调用encrypt函数加密</p></blockquote><h4 id="tip"><a class="header-anchor" href="#tip">¶</a>tip</h4><p>看了https://blog.t0hka.top/index.php/archives/36/才知道可以使用在线工具</p><p><a href="https://tool.lu/pyc/%EF%BC%8C%E6%95%88%E6%9E%9C%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E4%BF%AE%E5%A4%8D%E4%B8%80%E4%B8%8B">https://tool.lu/pyc/，效果差不多，不过还是需要自己修复一下</a></p><h3 id="pyinstaller加密"><a class="header-anchor" href="#pyinstaller加密">¶</a>pyinstaller加密</h3><p><a href="https://bbs.pediy.com/thread-271253.htm">https://bbs.pediy.com/thread-271253.htm</a></p><p>我们可以在解包的时候发现两个文件，一个是加密的密钥，一个是加密的过程</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785638921.png" alt=""></p><p>接下来只需要对PYZ文件解包（同样使用pyinxtxtractor），得到加密后的cup库即可</p><p>解密脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> tinyaes</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从crypt_key.pyc获取key，也可自行反编译获取</span></span><br><span class="line">key = <span class="built_in">bytes</span>(<span class="string">'0000000000000tea'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">'cup.pyc.encrypted'</span>, <span class="string">'rb'</span>)  <span class="comment"># 打开加密文件</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">'cup.pyc'</span>, <span class="string">'wb'</span>)  <span class="comment"># 输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按加密块大小进行读取</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line"></span><br><span class="line">cipher = tinyaes.AES(key, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补pyc头(最后自己补也行)</span></span><br><span class="line">outf.write(<span class="string">b'\x6f\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入解密数据</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line"></span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>反编译得到cup库的内容</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MX</span>(<span class="params">z, y, total, key, p, e</span>):</span></span><br><span class="line">    temp1 = (z.value &gt;&gt; <span class="number">5</span> ^ y.value &lt;&lt; <span class="number">2</span>) + (y.value &gt;&gt; <span class="number">3</span> ^ z.value &lt;&lt; <span class="number">4</span>)</span><br><span class="line">    temp2 = (total.value ^ y.value) + (key[p &amp; <span class="number">3</span> ^ e.value] ^ z.value)</span><br><span class="line">    <span class="keyword">return</span> c_uint32(temp1 ^ temp2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">ᘗ, ᘖ, ᘘ</span>):</span></span><br><span class="line">    ᘜ = <span class="number">0x9E3779B9L</span></span><br><span class="line">    ᘛ = <span class="number">6</span> + <span class="number">52</span> // ᘗ</span><br><span class="line">    total = c_uint32(<span class="number">0</span>)</span><br><span class="line">    ᘔ = c_uint32(ᘖ[ᘗ - <span class="number">1</span>])</span><br><span class="line">    ᘕ = c_uint32(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ᘛ &gt; <span class="number">0</span>:</span><br><span class="line">        total.value += ᘜ</span><br><span class="line">        ᘕ.value = total.value &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        ᘚ = c_uint32(ᘖ[<span class="number">0</span>])</span><br><span class="line">        ᘖ[ᘗ - <span class="number">1</span>] = c_uint32(ᘖ[ᘗ - <span class="number">1</span>] + MX(ᘔ, ᘚ, total, ᘘ, ᘗ - <span class="number">1</span>, ᘕ).value).value</span><br><span class="line">        ᘔ.value = ᘖ[ᘗ - <span class="number">1</span>]</span><br><span class="line">        ᘛ -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ᘛ &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ᘖ</span><br></pre></td></tr></tbody></table></figure><p>可以看出是xxtea加密</p><h2 id="解密-v2"><a class="header-anchor" href="#解密-v2">¶</a>解密</h2><p>得到rsa的密文c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">uint32_t</span>* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">uint32_t</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> enc[<span class="number">155</span>] = { <span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = { (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-155</span>, key);<span class="comment">//长度为多少，解密时第二个参数就改为多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">155</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, (((enc[i]) &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0xff</span>));</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解RSA，怪我不是密码🤠,直接贴t0hka师傅的脚本了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_hack</span>(<span class="params">e, n</span>):</span></span><br><span class="line">    <span class="comment"># firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git !</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span> <span class="keyword">and</span> (e * d - <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            discr = s * s - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> (discr &gt;= <span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t != -<span class="number">1</span> <span class="keyword">and</span> (s + t) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">    <span class="number">0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25</span>,</span><br><span class="line">    <span class="number">0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68B</span>]</span><br><span class="line">    <span class="comment"># 0-&gt;n,1-&gt;e</span></span><br><span class="line"></span><br><span class="line">    n = pub_key[<span class="number">0</span>]</span><br><span class="line">    e = pub_key[<span class="number">1</span>]</span><br><span class="line">    c = <span class="number">10610336534759505889607399322387179316771488492347274741918862678692508953185876570981227584004676580623553664818853686933004290078153620168054665086468417541382824708104480882577200529822968531743002301934310349005341104696887943182074473298650903541494918266823037984054778903666406545980557074219162536057146090758158128189406073809226361445046225524917089434897957301396534515964547462425719205819342172669899546965221084098690893672595962129879041507903210851706793788311452973769358455761907303633956322972510500253009083922781934406731633755418753858930476576720874219359466503538931371444470303193503733920039</span></span><br><span class="line">    d = wiener_hack(e, n)</span><br><span class="line">    m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m)) <span class="comment">#  flag{You_Need_Some_Tea} </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;DASCTF-FATE-Reverse&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>安卓动调</title>
    <link href="https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/"/>
    <id>https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/</id>
    <published>2022-04-23T00:53:44.000Z</published>
    <updated>2022-04-27T01:02:14.296Z</updated>
    
    <content type="html"><![CDATA[<p>安卓动态调试</p><span id="more"></span> <h1 id="0x00-IDA调试so文件"><a class="header-anchor" href="#0x00-IDA调试so文件">¶</a>0x00-IDA调试so文件</h1><h2 id="参考文章-v7"><a class="header-anchor" href="#参考文章-v7">¶</a>参考文章</h2><p><a href="https://bbs.pediy.com/thread-262524.htm">https://bbs.pediy.com/thread-262524.htm</a></p><h2 id="实操"><a class="header-anchor" href="#实操">¶</a>实操</h2><blockquote><p><strong>注意：手机要先ROOT，调试的so文件根据系统版本来选择</strong></p></blockquote><p>我的是arm64，所以选择这个</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937243317.png" alt=""></p><h3 id="打开手机的USB调试功能"><a class="header-anchor" href="#打开手机的USB调试功能">¶</a>打开手机的USB调试功能</h3><p>首先打开开发者选项，然后进入开发者选项打开USB调试</p><h3 id="adb连接手机"><a class="header-anchor" href="#adb连接手机">¶</a>adb连接手机</h3><blockquote><p>adb devices</p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866742532.png" alt=""></p><h3 id="adb进入手机"><a class="header-anchor" href="#adb进入手机">¶</a>adb进入手机</h3><blockquote><p>adb shell</p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866794822.png" alt=""></p><h3 id="查看手机ro-debuggable"><a class="header-anchor" href="#查看手机ro-debuggable">¶</a>查看手机ro.debuggable</h3><p>ro.debuggable是rom级别的调试，如果ro.debuggable的值是1说明你的手机已经打开了调试功能，如果为0的话需要安装的安卓app已经打开了android:debuggable属性方可调试，通常正式发布出来的apk默认android:debuggable属性都是关闭的</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866865200.png" alt=""></p><blockquote><p><strong>值为0，所以需要去让安装的app开启android:debuggable属性</strong></p></blockquote><h3 id="开启被调试APK的debuggable属性"><a class="header-anchor" href="#开启被调试APK的debuggable属性">¶</a>开启被调试APK的debuggable属性</h3><p>使用APK Editor Studio查看android:debuggable属性，没有的话就需要自行添加</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867048124.png" alt=""></p><p>这里我已经修改好了</p><h3 id="重新签名打包"><a class="header-anchor" href="#重新签名打包">¶</a>重新签名打包</h3><p>因为修改之后签名需要更新</p><p>在APK Editor Studio中按下Ctrl+Alt+S重新打包</p><h3 id="安装APK文件到手机中"><a class="header-anchor" href="#安装APK文件到手机中">¶</a>安装APK文件到手机中</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867221276.png" alt=""></p><p>此时手机中会弹出安装提示，确认即可安装</p><p>也可以使用adb安装</p><p><a href="https://blog.csdn.net/qq_43203586/article/details/104881919">https://blog.csdn.net/qq_43203586/article/details/104881919</a></p><h3 id="上传ida的远程工具"><a class="header-anchor" href="#上传ida的远程工具">¶</a>上传ida的远程工具</h3><p>在ida的dbgsrv目录下，将android_server64传入手机目录中</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867343056.png" alt=""></p><blockquote><p><strong>使用命令：adb push android_server64 /data/local/tmp</strong></p></blockquote><p>使用chmod提升权限</p><p>此时在该目录下我们可以找到该文件</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867613473.png" alt=""></p><h3 id="启动android-server64"><a class="header-anchor" href="#启动android-server64">¶</a>启动android_server64</h3><p>在data/local/tmp目录下直接运行</p><h3 id="启动adb端口转发"><a class="header-anchor" href="#启动adb端口转发">¶</a>启动adb端口转发</h3><blockquote><p><strong>adb forward tcp:23946 tcp:23946</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868122288.png" alt=""></p><h3 id="以调试模式启动APK"><a class="header-anchor" href="#以调试模式启动APK">¶</a>以调试模式启动APK</h3><p>启动前我们先获取Mainactivity</p><blockquote><p><strong>adb shell am start -D -n 包名路径/.Activity</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868216815.png" alt=""></p><p>以调试模式启动APK</p><blockquote><p><strong>adb shell am start -D -n com.j.hiddendata/.MainActivity</strong></p></blockquote><p>此时真机已经进入Waiting For Debugger界面了</p><h3 id="ida下断点"><a class="header-anchor" href="#ida下断点">¶</a>ida下断点</h3><p>在我们要调试的地方设置断点</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937076837.png" alt=""></p><h3 id="ida进行动态调试"><a class="header-anchor" href="#ida进行动态调试">¶</a>ida进行动态调试</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868333739.png" alt=""></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868368483.png" alt=""></p><p>attach上我们的程序</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868402833.png" alt=""></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868433623.png" alt=""></p><p>此时已经停下，F9一下，让其处于运行状态</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868487721.png" alt=""></p><h3 id="启动monitor并使用jdb连接端口"><a class="header-anchor" href="#启动monitor并使用jdb连接端口">¶</a>启动monitor并使用jdb连接端口</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868567690.png" alt=""></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868595091.png" alt=""></p><p>端口号为8600，接下来使用jdb连接</p><blockquote><p><strong>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8600</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868659975.png" alt=""></p><p>此时真机的等待调试窗口关闭</p><p>ida中提示已经加载，会问你包中的so文件是否和你的一致，选择same即可，接下来就是等待时间</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937277662.png" alt=""></p><p>然后就可以调试了</p><h1 id="0x01-JEB调试"><a class="header-anchor" href="#0x01-JEB调试">¶</a>0x01-JEB调试</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓动态调试&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
