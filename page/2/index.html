<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Welcome">
<meta property="og:url" content="https://gift1a.github.io/page/2/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gift1a">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://gift1a.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Welcome</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Welcome" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Welcome</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">勿在浮沙建高塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Gift1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gift1a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2973414642@qq.com" title="E-Mail → mailto:2973414642@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://1.12.239.117:8090/" title="http:&#x2F;&#x2F;1.12.239.117:8090&#x2F;" rel="noopener" target="_blank">Fallwind</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">逆向工程核心原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 17:19:45" itemprop="dateCreated datePublished" datetime="2022-04-07T17:19:45+08:00">2022-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-15 14:33:10" itemprop="dateModified" datetime="2022-04-15T14:33:10+08:00">2022-04-15</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0x00-调试Helloworld程序"><a href="#0x00-调试Helloworld程序" class="headerlink" title="0x00-调试Helloworld程序"></a>0x00-调试Helloworld程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326083343.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326142470.png"></p>
<p>选择Release模式生成的可执行文件能使程序代码更简洁，方便调试-之前我都是debug模式的，难怪有一堆初始化操作</p>
<blockquote>
<p>OD指令-Ctrl+F2，重新开始调试</p>
<p>​                Ctrl+F9，一直在函数代码内部运行，知道遇到retn，跳出函数</p>
<p>​                :可以给地址添加标签</p>
<p>​                Ctrl+E，编辑数据</p>
<p>​                空格，编写汇编代码</p>
</blockquote>
<h1 id="0x01-小端序标记法"><a href="#0x01-小端序标记法" class="headerlink" title="0x01-小端序标记法"></a>0x01-小端序标记法</h1><p>采用小端序时，地址高位存储数据的高位，地址低位存储数据的低位，我们知道一个地址最多存储一个字节的单元，也就是两个十六进制，那么0x12345678在内存存储中时则为78 56 34 12</p>
<h1 id="0x02-IA-32寄存器基本讲解"><a href="#0x02-IA-32寄存器基本讲解" class="headerlink" title="0x02-IA-32寄存器基本讲解"></a>0x02-IA-32寄存器基本讲解</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328781711.png" alt="通用寄存器"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328919424.png" alt="寄存器作用"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328950871.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333035627.png" alt="段寄存器"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333102096.png"></p>
<p>其中FS寄存器比较重要，用于计算SEH、TEB、PEB等地址</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333204894.png" alt="重要标志位"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333235729.png"></p>
<h1 id="0x03-栈"><a href="#0x03-栈" class="headerlink" title="0x03-栈"></a>0x03-栈</h1><p>栈的特征</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333398152.png" alt="栈的特征"></p>
<p>函数调用入栈顺序</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333596093.png"></p>
<h1 id="0x04-栈帧"><a href="#0x04-栈帧" class="headerlink" title="0x04-栈帧"></a>0x04-栈帧</h1><p>通过EBP-栈帧指针寄存器访问局部变量、参数、函数返回地址</p>
<p>函数开始时要先把已有值保存到栈中</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333832316.png"></p>
<p>指出相关内存属于哪个段</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334137175.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334312797.png" alt="返回值"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334395974.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334452555.png" alt="外平栈和内平栈"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334531491.png" alt="xor eax,eax"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334591186.png" alt="关闭段显示"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334796214.png" alt="函数的间接调用"></p>
<p>Test相当于&amp;命令，改变ZF的值</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334897963.png" alt="TEST指令"></p>
<h1 id="0x05-Process-Explorer"><a href="#0x05-Process-Explorer" class="headerlink" title="0x05-Process Explorer"></a>0x05-Process Explorer</h1><p>安装Peocess Explorer、sysinternals</p>
<h1 id="0x06-函数调用约定"><a href="#0x06-函数调用约定" class="headerlink" title="0x06-函数调用约定"></a>0x06-函数调用约定</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336046853.png" alt="cdecl"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336074342.png" alt="stdcall"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336102197.png" alt="stdcall"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336128921.png" alt="fastcall"></p>
<h1 id="0x07-鸡汤"><a href="#0x07-鸡汤" class="headerlink" title="0x07-鸡汤"></a>0x07-鸡汤</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336265323.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336281377.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336312616.png"></p>
<h1 id="0x08-PE文件格式"><a href="#0x08-PE文件格式" class="headerlink" title="0x08-PE文件格式"></a>0x08-PE文件格式</h1><p>相当于复习了</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649337195834.png" alt="RVA与VA"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342412672.png" alt="映像"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342725432.png" alt="显式链接与隐式链接"></p>
<h2 id="为什么要有导入表"><a href="#为什么要有导入表" class="headerlink" title="为什么要有导入表"></a>为什么要有导入表</h2><p>1、是因为不同版本的dll函数存放的地址也不同，为了能正常调用函数，编译器准备了存放函数实际地址的位置</p>
<p>2、重定位，多个dll无法同时装载到1000000h</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649343048380.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377368994.png" alt="导入表"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377721063.png" alt="导入表结构"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377867593.png" alt="IAT输入顺序"></p>
<p>因为存在按序号导入也有按名称导入，所以获取函数起始地址的时候有两种方式</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649378338899.png" alt="程序运行中的IAT表"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379766533.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379898617.png" alt="导出表"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380029780.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380146114.png" alt="获取函数地址"></p>
<p>即通过函数名称导出：先去函数名称表依次比较，找到相同时，得到索引index，去导出序号表根据index取出里面的值作为新的索引index_new，再去函数地址表找到函数地址</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380438215.png" alt="按序号导出"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380791104.png" alt="patched PE"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381026465.png"></p>
<h1 id="0x09-运行时压缩"><a href="#0x09-运行时压缩" class="headerlink" title="0x09-运行时压缩"></a>0x09-运行时压缩</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381576476.png" alt="压缩器"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381637551.png" alt="保护器"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382063431.png" alt="保护器种类"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382125254.png" alt="upx加壳后的notepad.exe"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382165657.png"></p>
<h1 id="0x0A-调试UPX压缩的notepad程序"><a href="#0x0A-调试UPX压缩的notepad程序" class="headerlink" title="0x0A-调试UPX压缩的notepad程序"></a>0x0A-调试UPX压缩的notepad程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382397337.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382481059.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382514246.png" alt="OD跟踪命令"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382717431.png" alt="解码循环"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382768527.png" alt="恢复地址"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382833291.png" alt="IAT"></p>
<h1 id="0x0B-基址重定位表"><a href="#0x0B-基址重定位表" class="headerlink" title="0x0B-基址重定位表"></a>0x0B-基址重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391242570.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391309699.png" alt="ASLR"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391324972.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391676854.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470225805.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470309143.png" alt="重定位表中的地址计算"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470391830.png" alt="重定位表分块大小原因"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470561427.png" alt="重定位"></p>
<h1 id="0x0C-从可执行文件中删除重定位表"><a href="#0x0C-从可执行文件中删除重定位表" class="headerlink" title="0x0C-从可执行文件中删除重定位表"></a>0x0C-从可执行文件中删除重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470715916.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470727996.png" alt="步骤"></p>
<h1 id="0x0D-Upack-PE文件头详细分析"><a href="#0x0D-Upack-PE文件头详细分析" class="headerlink" title="0x0D-Upack PE文件头详细分析"></a>0x0D-Upack PE文件头详细分析</h1><h2 id="重叠文件头"><a href="#重叠文件头" class="headerlink" title="重叠文件头"></a>重叠文件头</h2><p>因为DOS头尾部有一堆垃圾数据，所以将其修改并去除垃圾数据并修改e_lfanew，可以实现文件头重叠</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471521418.png"></p>
<h2 id="IMAGE-FILE-HEADER-SizeofOptionalHeader"><a href="#IMAGE-FILE-HEADER-SizeofOptionalHeader" class="headerlink" title="IMAGE_FILE_HEADER.SizeofOptionalHeader"></a>IMAGE_FILE_HEADER.SizeofOptionalHeader</h2><p>通过修改可选PE头的大小，可以向文件头插入解码代码。</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471656793.png" alt="可选PE头存在的原因"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471692584.png"></p>
<h2 id="IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes"><a href="#IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes" class="headerlink" title="IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes"></a>IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471789389.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471971897.png"></p>
<h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472047897.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472187949.png" alt="UPcak的重叠特征"></p>
<p>也就是说Upack先将notepad.exe压缩至第二个节区，运行时将第二个节区的代码解压至第一个节区</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472217512.png" alt="解压后的第一个节区"></p>
<h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472407155.png"></p>
<h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472531391.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472588438.png"></p>
<h2 id="导入地址表"><a href="#导入地址表" class="headerlink" title="导入地址表"></a>导入地址表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472781271.png"></p>
<h1 id="0x0E-Upack调试-查找OEP"><a href="#0x0E-Upack调试-查找OEP" class="headerlink" title="0x0E-Upack调试-查找OEP"></a>0x0E-Upack调试-查找OEP</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473884976.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473962763.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473977290.png"></p>
<h1 id="0x0F-内嵌补丁"><a href="#0x0F-内嵌补丁" class="headerlink" title="0x0F-内嵌补丁"></a>0x0F-内嵌补丁</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474031264.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474156707.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474124006.png" alt="内嵌补丁与代码补丁的区别"></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>先对附件进行分析</p>
<p>弹出的对话框要求解压其本身</p>
<p>对地址4010F5的第一次异或</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482257261.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482352736.png" alt="401007地址的值异或7"></p>
<p>再次对4010F5进行异或操作，解密</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482387580.png"></p>
<p>可以看到这里对地址的值进行校验，每次取出四个字节相加，所以当我们修改了内容时需要对校验部分修改</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482453215.png" alt="校验"></p>
<p>所以解码完的部分存在我们要找的字符串</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482646487.png"></p>
<p>对401090地址的值进行异或</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482685919.png" alt="异或"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482728534.png" alt="大致流程"></p>
<h2 id="内嵌补丁练习"><a href="#内嵌补丁练习" class="headerlink" title="内嵌补丁练习"></a>内嵌补丁练习</h2><p>因为我们要打补丁的字符串位于B区，而B区进行了双重加密，而且对其内容进行了校验，所以采用内嵌补丁</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482908373.png" alt="内嵌补丁"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649483145646.png"></p>
<p>因为节区要对齐，所以可能存在空白节区，那我们就可以在节区末尾添加我们的洞穴代码</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484195488.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484706889.png"></p>
<p>然后让程序先跳转到我们这个地址，再在这段代码最后一句，加上跳回原本程序的代码</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484859772.png" alt="程序原本的跳转"></p>
<p>但是要注意一点，就是我们插入的是已经解完密的jmp，而实际在文件中，这里的jmp是被加密的，所以要先对我们的修改进行加密，也就是xor 7</p>
<h1 id="0x10-Windows消息钩取"><a href="#0x10-Windows消息钩取" class="headerlink" title="0x10-Windows消息钩取"></a>0x10-Windows消息钩取</h1><p>windows消息机制</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/alzzw/article/details/108217879">https://blog.csdn.net/alzzw/article/details/108217879</a></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486465228.png" alt="windows消息流"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486637330.png" alt="消息钩取工作原理"></p>
<p>我们设置的钩子能在应用程序之前获取到OS相应信息</p>
<blockquote>
<p>SetwindowsHookEx()</p>
<p>HHOOK SetWindowsHookExA(<br>  [in] int       idHook,// 要安装的挂钩过程的类型<br>  [in] HOOKPROC  lpfn,// 指向挂钩过程的指针<br>  [in] HINSTANCE hmod,// 所指向的挂钩过程的 DLL 的句柄<br>  [in] DWORD     dwThreadId<br>);</p>
</blockquote>
<p>main.cpp</p>
<pre class="language-c" data-language="c"><code class="language-c">#include "stdio.h"
#include "conio.h"
#include "windows.h"

#define    DEF_DLL_NAME        "KeyHook.dll"
#define    DEF_HOOKSTART        "HookStart"
#define    DEF_HOOKSTOP        "HookStop"

typedef void (*PFN_HOOKSTART)();
typedef void (*PFN_HOOKSTOP)();

void main()
{
    HMODULE    hDll = NULL;
    PFN_HOOKSTART    HookStart = NULL;
    PFN_HOOKSTOP    HookStop = NULL;
    char    ch = 0;

    // 加载KeyHook.dll
    hDll = LoadLibraryA(DEF_DLL_NAME);
    if (hDll == NULL)
    {
        printf("LoadLibrary(%s) failed!!! [%d]", DEF_DLL_NAME, GetLastError());
        return;
    }

    // 获取导出函数地址
    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);
    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);

    // 开始钩取
    HookStart();

    // 等待，直到用户输入“q”
    printf("press 'q' to quit!\n");
    while (_getch() != 'q');

    // 终止钩子
    HookStop();

    // 卸载KeyHook.dll
    FreeLibrary(hDll);
}</code></pre>

<p>KeyHook.dll</p>
<pre class="language-c" data-language="c"><code class="language-c">//KeyHook.cpp
 
#include "stdio.h"
#include "windows.h"
 
//定义目标进程名为notepad.exe
#define DEF_PROCESS_NAME "notepad.exe"
 
//定义全局变量
HINSTANCE g_hInstance = NULL;
HHOOK g_hHook = NULL;
 
//DllMain()函数在DLL被加载到进程后会自动执行
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved){
	switch( dwReason ){
		case DLL_PROCESS_ATTACH:
			g_hInstance = hinstDLL;
			break;
 
		case DLL_PROCESS_DETACH:
			break;
	}
 
	return TRUE;
}
 
//
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam){
	char szPath[MAX_PATH] = {0,};
	char *p = NULL;
	
	if( nCode &gt;= 0 ){
 
		//释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; release
		if( !(lParam &amp; 0x80000000) ){
			GetModuleFileNameA(NULL, szPath, MAX_PATH);
			p = strrchr(szPath, '\\');
 
			//比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数
			//_stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0
			if( !_stricmp(p + 1, DEF_PROCESS_NAME) ){
				return 1;
			}
		}
	}
 
	//比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数
	return CallNextHookEx(g_hHook, nCode, wParam, lParam);
}
 
//在C++中调用C的库文件，用extern "C"告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同
#ifdef __cplusplus
extern "C"{
#endif
	//__declspec，针对编译器的关键字，用于指出导出函数
	//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链
	__declspec(dllexport) void HookStart(){
		g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);
	}
 
	__declspec(dllexport) void HookStop(){
		if(g_hHook){
			UnhookWindowsHookEx(g_hHook);
			g_hHook = NULL;
		}
	}
#ifdef __cplusplus
}
#endif</code></pre>

<p>调用导出函数HookStart()时，SetWindowsHookEx()函数就会把KeyboardProc()添加到键盘钩链</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649491980722.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492021056.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492216354.png" alt="调试过程"></p>
<h1 id="0x11-恶意键盘记录器"><a href="#0x11-恶意键盘记录器" class="headerlink" title="0x11-恶意键盘记录器"></a>0x11-恶意键盘记录器</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492949992.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493348476.png" alt="DLL注入"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493419347.png" alt="DLL_Main函数"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiandao2009/article/details/79839182">https://blog.csdn.net/tiandao2009/article/details/79839182</a>  dllmain函数的不同情形</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649494188248.png" alt="DLL注入方法"></p>
<h1 id="0x12-DLL卸载"><a href="#0x12-DLL卸载" class="headerlink" title="0x12-DLL卸载"></a>0x12-DLL卸载</h1><h2 id="获取目标进程的句柄"><a href="#获取目标进程的句柄" class="headerlink" title="获取目标进程的句柄"></a>获取目标进程的句柄</h2><pre class="language-c" data-language="c"><code class="language-c">hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID);</code></pre>

<p>该语句使用进程ID来获取目标进程的进程句柄，下面用获得的进程句柄调用CreateRemoteThread()</p>
<h2 id="获取FreeLibrary-地址"><a href="#获取FreeLibrary-地址" class="headerlink" title="获取FreeLibrary()地址"></a>获取FreeLibrary()地址</h2><pre class="language-c" data-language="c"><code class="language-c">hModule=GetModule(L"kernel32.dll);
pThreadProc=(LPTHREAD_START_ROUTINE)GetProcAddress(hModule,"FreeLibrary");</code></pre>

<p>若要使目标进程自己调用FreeLibrary()，需要先获得FreeLibrary()的地址。然而上述代码获得的不是加载到目标进程中的FreeLibrary()的地址，而是EjectDll.exe进程中FreeLibrary()的地址，但是FreeLibrary在所有进程中地址是相同的</p>
<h2 id="在目标进程中运行线程"><a href="#在目标进程中运行线程" class="headerlink" title="在目标进程中运行线程"></a>在目标进程中运行线程</h2><pre class="language-c" data-language="c"><code class="language-c">hThread=CreateRemoteThread(hProcess,NULL,0,pThreadProc,me.modBaseAddr,0,NULL);</code></pre>

<p>pThreadProc参数是FreeLibrary()的地址，me.modBaseAddr参数是要卸载的DLL的加载地址。将线程函数指定为FreeLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p>
<blockquote>
<p>CreateRemoteThread()原意是在外部线程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649660793447.png"></p>
<h1 id="0x13-通过修改PE加载DLL"><a href="#0x13-通过修改PE加载DLL" class="headerlink" title="0x13-通过修改PE加载DLL"></a>0x13-通过修改PE加载DLL</h1><p>也就是修改导入表来使得PE文件运行时直接加载dll</p>
<p>晚点看</p>
<h1 id="0x14-代码注入"><a href="#0x14-代码注入" class="headerlink" title="0x14-代码注入"></a>0x14-代码注入</h1><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术，他一般调用CreateRemoteThread()以远程线程形式运行插入的代码，所以也被称为线程注入</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662082787.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662157677.png"></p>
<p>也就是说DLL是将整个DLL注入进程中，而代码注入只是注入必要的代码，所以同时也要报要操作的数据进行注入</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662257437.png" alt="使用代码注入的原因"></p>
<h1 id="0x15-汇编代码注入"><a href="#0x15-汇编代码注入" class="headerlink" title="0x15-汇编代码注入"></a>0x15-汇编代码注入</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649924174583.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925196328.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925229842.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925283278.png" alt="关闭自动填充nop"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649926423283.png"></p>
<p>接下来将插入的asm的机器码进行复制，并修改格式</p>
<p>得到</p>
<pre class="language-c" data-language="c"><code class="language-c">char shellcode[] = {
0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64
,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67
,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C
,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8
,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63
,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5
,0x5D,0xC3
};</code></pre>

<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649985152689.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650001282882.png"></p>
<h1 id="0x16-API钩取"><a href="#0x16-API钩取" class="headerlink" title="0x16-API钩取"></a>0x16-API钩取</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003507541.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003531886.png" alt="钩取流程"></p>
<p>因为在用户模式下要访问系统资源时，我们没有办法直接访问到，所以为了运行实际的应用程序代码，需要加载许多系统库，也就是DLL</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003724601.png" alt="用户代码访问系统资源"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003764098.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003805976.png"></p>
<p>实际就是对API调用时进行钩取，获得控制权</p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004065936.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004108572.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004149588.png"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004326551.png" alt="实现API钩取的方法"></p>
<p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004361901.png"></p>
<h1 id="0x17-记事本WriteFIle-API钩取"><a href="#0x17-记事本WriteFIle-API钩取" class="headerlink" title="0x17-记事本WriteFIle()API钩取"></a>0x17-记事本WriteFIle()API钩取</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/06/BlockChain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/06/BlockChain/" class="post-title-link" itemprop="url">BlockChain</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-06 20:44:16" itemprop="dateCreated datePublished" datetime="2022-04-06T20:44:16+08:00">2022-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:22:50" itemprop="dateModified" datetime="2022-04-20T09:22:50+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>BlockChain</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/04/06/BlockChain/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">PWN基本工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-06 10:25:58" itemprop="dateCreated datePublished" datetime="2022-04-06T10:25:58+08:00">2022-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-07 16:43:08" itemprop="dateModified" datetime="2022-04-07T16:43:08+08:00">2022-04-07</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0x00-GDB工具安装"><a href="#0x00-GDB工具安装" class="headerlink" title="0x00-GDB工具安装"></a>0x00-GDB工具安装</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/129837931">https://zhuanlan.zhihu.com/p/129837931</a></p>
<p>gdb这三个插件不能同时运行，可以使用命令</p>
<pre class="language-none"><code class="language-none">vim ~/.gdbinit</code></pre>

<p><img src="/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/1649212326580.png" alt="gdbinit"></p>
<p>不需要使用哪个就注释掉哪个</p>
<h1 id="0x01-GDB基本使用"><a href="#0x01-GDB基本使用" class="headerlink" title="0x01-GDB基本使用"></a>0x01-GDB基本使用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先先使用gcc生成elf文件，-g表示可以debug</p>
<pre class="language-none"><code class="language-none">gcc inputfile -o outputfile -g</code></pre>

<p>使用下面命令打开</p>
<pre class="language-none"><code class="language-none">gdb file</code></pre>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">https://blog.csdn.net/Breeze_CAT/article/details/103789233</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhwer/p/12494317.html">https://www.cnblogs.com/zhwer/p/12494317.html</a></p>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre class="language-c" data-language="c"><code class="language-c">help//帮助
i//info
	i b//info break查看所有断点信息
	i r//info registers 查看各个寄存器当前的值
	i f//info function 查看所有函数名，保留符号
show //和info相似，但是是查看调试器的基本信息
	show args//查看参数
	
backtrace//查看调用堆栈
q//quit退出</code></pre>

<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><pre class="language-c" data-language="c"><code class="language-c">s//step，单步步入，跟进函数中，也就是step into，源码层面的一步，F7
	si//同s，汇编层面的一步
n//next，单步补过，F8，源码层面的一步
	ni//同n，汇编层面的一步
c//continue，F9，继续执行到断点
r//run，重新开始执行</code></pre>

<h3 id="断点指令-break"><a href="#断点指令-break" class="headerlink" title="断点指令-break"></a>断点指令-break</h3><pre class="language-c" data-language="c"><code class="language-c">b*(0x123456)//给0x123456地址的指令下断点
	b*$rebase(0x123456)//$rebase在调试开PIE的程序的时候可以直接加上程序的随即地址
b func_name//给函数func_name下断点，目标文件要保留符号才行
    b file_name:func_name
b file_name:15//给file_name的15行下断点，需要有源码
    b 15
b +0x10//在程序当前停住的位置下0x10的位置下断点，也可以-0x10，就是前0x10
break fun if $rdi==5//条件断点，rdi的值为5的时候才断</code></pre>

<p>删除、禁用断点的指令</p>
<pre class="language-c" data-language="c"><code class="language-c">//先使用i b查看断点编号
delete 5//删除5号断点，如果直接delete不加数字，表示删除所有断点
disable 5//禁用5号断点
    enable 5//启用5号断点
clear//清除下面的所有断点</code></pre>

<p>内存断点指令</p>
<pre class="language-c" data-language="c"><code class="language-c">watch 0x123456//0x123456地址的数据改变的时候会断
watch a//变量a改变的时候会断
info watchpoints//查看watch断点信息</code></pre>

<h3 id="打印指令"><a href="#打印指令" class="headerlink" title="打印指令"></a>打印指令</h3><p>查看内存指令x</p>
<pre class="language-c" data-language="c"><code class="language-c">x /nuf 0x123456//x指令的格式是：x /nfu，nfu代表三个参数
    n//代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在'/'后面
    u//代表一个单元几个字节，b(一个字节),h(两个字节)，w(四字节)，g(八字节)
    f//代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n
    	x 按十六进制格式显示变量。
		d 按十进制格式显示变量。
		u 按十六进制格式显示无符号整型。
		o 按八进制格式显示变量。
        t 按二进制格式显示变量。
        a 按十六进制格式显示变量。
        c 按字符格式显示变量。
        f 按浮点数格式显示变量。
        s 按字符串显示。
        b 按字符显示。
        i 显示汇编指令。
x /10gx 0x123456//从0x123456开始每个单元八个字节，十六进制显示十个单元的数据
x /10xd $rdi//从rdi指向的地址向后打印十个单元，每个单元四字节的十进制数
x /10i 0x123456//从0x123456处向后显示十条汇编指令</code></pre>

<p>打印指令p(print)</p>
<pre class="language-c" data-language="c"><code class="language-c">p func_name//打印func_name的地址，需要保留符号
p 0x10-0x8//计算0x10-0x8的结果
p &amp;a//查看变量a的地址
p *(0x123456)//查看0x123456的值
p $rdi//显示rdi寄存器的值
    p *($rdi)//显示rdi指向的值</code></pre>

<p>打印汇编指令disass(disassemble)</p>
<pre class="language-c" data-language="c"><code class="language-c">disass 0x123456//显示0x123456前后的汇编指令
x /10i //前面说过了</code></pre>

<p>打印源代码list</p>
<pre class="language-c" data-language="c"><code class="language-c">list//查看当前附近10行的代码
    list 38//查看28行附近10行的代码
    list 1,10//查看1-10行代码
    list main//查看main函数的开始10行</code></pre>

<h3 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h3><pre class="language-c" data-language="c"><code class="language-c">search rdi//从当前位置向后查找包含rdi的指令
find "hello"//查找hello字符串，pwndbg独有</code></pre>

<h3 id="修改数据指令-set"><a href="#修改数据指令-set" class="headerlink" title="修改数据指令-set"></a>修改数据指令-set</h3><pre class="language-c" data-language="c"><code class="language-c">set $rdi=0x10//把寄存器的值变为0x10
set *(0x123456)=0x10//把0x123456地址的值变为0x10，注意带星号
set args "abc" "def" "gh"//给参数123赋值</code></pre>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class="language-c" data-language="c"><code class="language-c">堆操作指令（pwndbg插件独有）
arena //显示arena的详细信息
arenas //显示所有arena的基本信息
arenainfo //好看的显示所有arena的信息
bins //常用，查看所有种类的堆块的链表情况
fastbins //单独查看fastbins的链表情况
largebins //同上，单独查看largebins的链表情况
smallbins //同上，单独查看smallbins的链表情况
unsortedbin //同上，单独查看unsortedbin链表情况
tcachebins //同上，单独查看tcachebins的链表情况
tcache //查看tcache详细信息
heap //数据结构的形式显示所有堆块，会显示一大堆
heapbase //查看堆起始地址
heapinfo、heapinfoall //显示堆得信息，和bins的挺像的，没bins好用
parseheap //显示堆结构，很好用
tracemalloc //好用，会跟提示所有操作堆的地方
其他pwndbg插件独有指令
cyclc 50 //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama

$reabse //开启PIE的情况的地址偏移

b *$reabse(0x123456) //断住PIE状态下的二进制文件中0x123456的地方
codebase //打印PIE偏移，与rebase不同，这是打印，rebase是使用
stack //查看栈

retaddr //打印包含返回地址的栈地址
canary //直接看canary的值

plt //查看plt表

got //查看got表
hexdump //像IDA那样显示数据，带字符串</code></pre>






      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">动态链接库创建与使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-04 16:59:59" itemprop="dateCreated datePublished" datetime="2022-04-04T16:59:59+08:00">2022-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-06 13:48:00" itemprop="dateModified" datetime="2022-04-06T13:48:00+08:00">2022-04-06</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0x00-参考文章"><a href="#0x00-参考文章" class="headerlink" title="0x00-参考文章"></a>0x00-参考文章</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LyRics1996/article/details/120246497">https://blog.csdn.net/LyRics1996/article/details/120246497</a></p>
<h1 id="0x01-创建动态链接库"><a href="#0x01-创建动态链接库" class="headerlink" title="0x01-创建动态链接库"></a>0x01-创建动态链接库</h1><p>下面以VS为例</p>
<p>在创建新项目找到动态链接库DLL</p>
<p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068184192.png"></p>
<p>创建之后是这样的</p>
<p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068250968.png"></p>
<p>替换成我们待会要调用的函数</p>
<p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070264273.png" alt="替换之后"></p>
<p>之所以要在函数前面加上extern “C” __declspec(dllexport)</p>
<p>是因为在导出的时候可能会增加一些符号，这样的话函数的名称会被修改，待会GetProcAddress就无法调用了</p>
<p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070418832.png" alt="说明"></p>
<h1 id="0x03-调用动态链接库"><a href="#0x03-调用动态链接库" class="headerlink" title="0x03-调用动态链接库"></a>0x03-调用动态链接库</h1><p>首先先要加载动态链接库，使用LoadLibrary，有两种方式</p>
<pre class="language-c" data-language="c"><code class="language-c">handle = LoadLibrary(L"Dll1.dll");
handle = LoadLibrary(_TEXT("D:\\new\\AD\\C语言\\Dll1\\Debug\\Dll1.dll"));</code></pre>

<p>使用下面这种方式的话需要#include&lt;tcahr.h&gt;</p>
<p>GetProcAddress调用DLL文件中的函数</p>
<p>我们需要使用typedef为函数指针创建匹配类型的指针</p>
<p>因为函数名就是函数的地址，所以可以直接赋值和调用，下面两种都可以调用函数，震惊！C语言白学了</p>
<p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649072130088.png"></p>
<p>代码如下</p>
<pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;
#include&lt;string.h&gt;
#include&lt;iostream&gt;
#include &lt;tchar.h&gt;

typedef int(*Lpfunc)(int a,int b);//先定义函数指针
int main()
{
	HMODULE handle;
	handle = LoadLibrary(L"Dll1.dll");
	handle = LoadLibrary(_TEXT("Dll1.dll"));
	Lpfunc add = NULL;
	add = (Lpfunc)GetProcAddress(handle, "add");
	printf("%d\n", add(3, 4));
	FreeLibrary(handle);//释放资源
	return 0;
}</code></pre>

<p>typedef声明函数指针</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/82011613">https://blog.csdn.net/afei__/article/details/82011613</a></p>
<p>当然我们也可以多层调用</p>
<p>dll文件中</p>
<pre class="language-c" data-language="c"><code class="language-c">// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include "pch.h"
#include&lt;stdio.h&gt;
extern "C" _declspec (dllexport)void Print(int k)
{
    printf("%d\n", k);
}
extern "C" _declspec (dllexport)int add(int a, char b)
{
    int c = a + b;
    Print(c);
    return c;
}</code></pre>

<p>python调用dll-ctype</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/" class="post-title-link" itemprop="url">近期题目复现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-04 15:15:00" itemprop="dateCreated datePublished" datetime="2022-04-04T15:15:00+08:00">2022-04-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:15:28" itemprop="dateModified" datetime="2022-04-20T09:15:28+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0x00-Zer0pts2022-service"><a href="#0x00-Zer0pts2022-service" class="headerlink" title="0x00-Zer0pts2022-service"></a>0x00-Zer0pts2022-service</h1><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>先定位到正确的判断，进入加密函数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057498918.png"></p>
<p>可以看到有几个api函数，并且只有所有的值都相等，才能实现return的值为1</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057543911.png"></p>
<p>但是动调的时候很多函数看不到，而且这里面有很多东西未被正确识别，所以使用X64DBG打开并定位到加密函数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057759455.png" alt="加密函数"></p>
<p>首先我们要知道x64的函数调用机制</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057831750.png"></p>
<p>所以在call前的那几个mov就是函数的参数</p>
<p>先看循环的次数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057937520.png" alt="rbp-0x44"></p>
<p>很明显这段就是循环的判断</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057978804.png" alt="循环判断"></p>
<p>循环内部，可以看到有三个api函数，先不管</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058022189.png"></p>
<p>因为刚才在ida看到，最后是有一个比较的，我们先确定存储加密后字符串的位置，根据这个跳转和0x1F也就是31，确定这就是判断</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058122264.png"></p>
<p>可以看到在这之前先把两个地址存放的一个byte放入edx和eax中，我们就可以定位过去，先运行到这</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058190552.png" alt="关键判断"></p>
<p>可以看到，我们通过64FD80-0x40得到了存放加密字符串的地址，那么这一段就是循环判断</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058453221.png"></p>
<p>接下来我们重新运行一下，然后这次我们先右键锁定堆栈，观察他的变化</p>
<p>先来看一下第一个API函数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058638150.png" alt="CryptCreateHash"></p>
<pre class="language-c" data-language="c"><code class="language-c">BOOL CryptCreateHash(
  [in]  HCRYPTPROV hProv,
  [in]  ALG_ID     Algid,
  [in]  HCRYPTKEY  hKey,
  [in]  DWORD      dwFlags,
  [out] HCRYPTHASH *phHash
);</code></pre>

<p>而前面的一些是函数的参数，关键的是下面这个，我们点进这个链接</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058819510.png" alt="关键参数"></p>
<p>0x800C，和我们的参数对应上了，那么这个应该就是加密的方式</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058866139.png"></p>
<p>再看第二个函数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058990852.png" alt="CryptHashData"></p>
<pre class="language-c" data-language="c"><code class="language-c">BOOL CryptHashData(
  [in] HCRYPTHASH hHash,
  [in] const BYTE *pbData,
  [in] DWORD      dwDataLen,
  [in] DWORD      dwFlags
);</code></pre>

<p>关键是是我们加密的数据和数据的长度，也就是说每次取出2长度的字符串生成hashdata</p>
<p>再看第三个</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059153629.png" alt="CryptGetHashParam"></p>
<pre class="language-c" data-language="c"><code class="language-c">BOOL CryptGetHashParam(
  [in]      HCRYPTHASH hHash,
  [in]      DWORD      dwParam,
  [out]     BYTE       *pbData,
  [in, out] DWORD      *pdwDataLen,
  [in]      DWORD      dwFlags
);</code></pre>

<p>具体的可以不用细看，只需知道这一段是真正的加密，因为在执行前，目标地址没有数据</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059338076.png"></p>
<p>执行后</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059375141.png"></p>
<p>所以整个过程就是将我们输入的每两位进行sha256加密，然后和他给我们的hash表进行表，那我们就可以先生成两字符的sha256彩虹表，然后反查</p>
<p>验证一下</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059489991.png" alt="sha256表"></p>
<p>flag格式是zer0pts，取前两个字符进行sha256加密，正好对应</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059547681.png"></p>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-python" data-language="python"><code class="language-python">hash = [
  "33129567e0bd787efb15a26307e5311e06ba66e3b8dbc2206ad59f99780a4d78",
  "dd191696e15e2ee293410d02454c5f9461a2249dee6d57c75f264eaeb83a3782",
  "e75b11da693d7bb5273985dcf9f02729455da7e7c80e54a0615e00ec2ae76d8e",
  "04249e0c258e1a4e43cfdae291a835cd15735f650bbbba0465ada1cd9846622a",
  "e4223ed20d7ea5740a326e2b268ca6db91d041cf5194f577e393a8ba3b85d8e9",
  "8b53639f152c8fc6ef30802fde462ba0be9cf085f7580dc69efd72e002abbb35",
  "0117834bf60dcf977229bf1e982cf9bc63b60ef42052f7ce7e800ce1216a9af6",
  "741d14df730e53a5a019a710116f696db4ec23a132b74cf6fbb3cf7617e68313",
  "e30e580a4c2916bcff30ca047f2d6a494168ceaf8fb9171037a773a9f8e7268e",
  "294763754a8efd4c739d9f679bfca3ab510106f42ddb5dc0216ba8bc98ba3158",
  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",
  "68dbf73d03d3a5107edad3b05676eee240e68c280296e52b6986873c54cef3cb",
  "c1818d580d8c8bc111302f4a5e6903ef2d32b11a5613efba507693de8060fb8c",
  "44ad63f60af0f6db6fdde6d5186ef78176367df261fa06be3079b6c80c8adba4",
  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",
  "5e07d6fdc602b0f9b99f6ea24c39e65835992faac400264c52449bc409cf4efa",
  "e4dcd6d313af71559596d3009c12d025301842d8c7f888c2850333e91a9bda68",
  "fffdff4b07a9d973fd1c3a6be443851bc13e82c4af94c88325244694e352aa31",
  "3fffd018d2223020be85670d93f565b63df54a9ce3ed2cdf6347a61df016938c",
  "b2941852282562cc3d813e8bf1705d0480a7a008ffa2475501d7c5161165a7fb",
  "635ca73d00d4f28b5f573b16eea56e9e4579d77e561c32aa68189d9769fa1753",
  "a4d0ef23161b5b7c6a8d5b287543fd74e16b3bf313d71aa187c24cdd728a7b1e",
  "e0b9a8799f32453a478c9122f8b83cee68e16db18f493ac81bc1d474594b5df4",
  "564999cbbfea80170ba068dcf961d9914625f3be951b2c1fe163bae0f8156c24",
  "4a44dc15364204a80fe80e9039455cc1608281820fe2b24f1e5233ade6af1dd5",
  "e91787068a3c60e9712a7abeb6a67f518a40723c1b89c11d6070fe5f9389ebf9",
  "7eb70257593da06f682a3ddda54a9d260d4fc514f645237f5ca74b08f8da61a6",
  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",
  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",
  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",
  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",
  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",
]

import hashlib
import itertools

def dec(h):
  for l in range(2,3):
    for p in itertools.product(range(128), repeat=l):
      if hashlib.sha256(bytes(p)).hexdigest()==h:
        return bytes(p)

flag = b""
for h in hash:
  flag += dec(h)
print(flag.decode())</code></pre>

<p>zer0pts{m0d1fy1ng_PE_1mp0rts_1s_4n_34sy_0bfusc4t10n}</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xxxxxxxxx/p/11544432.html">https://www.cnblogs.com/xxxxxxxxx/p/11544432.html</a></p>
<p>这里介绍了itertools.product，其实目的就是生成2位字符的彩虹表，然后和密文对比</p>
<h1 id="SpaceHeroesCtf2022-Shai-Hulud"><a href="#SpaceHeroesCtf2022-Shai-Hulud" class="headerlink" title="SpaceHeroesCtf2022-Shai-Hulud"></a>SpaceHeroesCtf2022-Shai-Hulud</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p>比较有趣的一道题，当时专注于改源码搞定游戏，然后一直失败，主要是自己写的C语言生成的随机数和调试得到的不同（其实是没注意linux和windows生成随机数的不同），所以就想玩游戏得到flag</p>
<p>另外的解法</p>
<p><a target="_blank" rel="noopener" href="https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud">https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud</a></p>
<h2 id="0x01-分析过程"><a href="#0x01-分析过程" class="headerlink" title="0x01-分析过程"></a>0x01-分析过程</h2><p>运行程序知道这是个贪吃蛇小游戏，通过不等于0x295判断这就是贪吃蛇长度，然后SHA256_Init可以看出这是sha256加密</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148254617.png"></p>
<p>前面的一些函数就是生成地图，初始化游戏等操作</p>
<p>主要看下面这个函数，是随机生成需要吃掉的点的</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148425600.png" alt="vibration"></p>
<p>这两个函数是一些规则，告诉你wasd是移动</p>
<p>主要看frame函数</p>
<p>下面这个函数是说不能碰到尾巴，继续往下看</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148585642.png" alt="判定退出"></p>
<p>可以看到等于-2的时候，而-2刚好对应随机生产点函数的-2，然后对该值进行sha256加密，并且重新生成-2的点，然后长度+1</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148702003.png"></p>
<p>所以我们接下来只需要跑到最后的长度即可得到最后的sha256加密值，然后在print_flag函数中，最后进行了一次异或</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148830700.png" alt="print_flag"></p>
<p>本来修改好规则打算玩到0x294的，但是在长度为195的时候随机点找不到。所以只能老实做</p>
<p>在导入表可以看到SHA256_Init，SHA256_Update，SHA256_Final函数，可以知道调用了OPENSSL，版本为1.1.0</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148953206.png" alt="导入表"></p>
<p>安装好之后，模仿该过程生成SHA256加密，注意因为每次都会Update，所以不能将最后一次生成的值直接SHA256加密，这样得到的结果不一样</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649153105553.png" alt="函数说明"></p>
<p>这也就是前面说的，每加密完一次，hash初始值都会被改变</p>
<pre class="language-c" data-language="c"><code class="language-c">#include &lt;openssl/sha.h&gt;
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(int argc, char const* argv[])
{
	SHA256_CTX ctx;
	srand(0x2454);
	char output[256];
	__int64_t buffer;
	int x, y;
	SHA256_Init(&amp;ctx);
	for (int i = 0; i &lt; 0x294; ++i)
	{
		x = rand() % 33;
		y = rand() % 20;
		buffer = 16 * x + y;
		SHA256_Update(&amp;ctx, &amp;buffer, 8);
		SHA256_Final(output, &amp;ctx);
	}
	for(int i = 0; i&lt;32; i++) //将SHA256以16进制输出
	{
         printf("%02x", (int)output[i]&amp;0xff);
    }
     puts("\n");
	return 0;
</code></pre>

<p>编译</p>
<blockquote>
<p>g++ -o openssl-sha256 openssl-sha256.c -std=c++11 -lssl -lcrypto</p>
</blockquote>
<p>也可以动调得到最后的sha256值</p>
<p>最后异或一下即可</p>
<pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char const* argv[])
{
	char data[33] = {
	0xC2, 0x98, 0xD1, 0x8E, 0xC8, 0xBF, 0x99, 0x75, 0x50, 0x41, 0x54, 0x5D, 0x3C, 0x39, 0xA8, 0x05,
	0x73, 0x7B, 0xDE, 0xEA, 0xA3, 0xBE, 0x4C, 0x40, 0x2B, 0xE2, 0x48, 0x90, 0x80, 0x7F, 0x7B, 0x8D };
	unsigned char magic_bytes[32] = {
	0xB2, 0xEA, 0xE5, 0xBF, 0xBB, 0x8C, 0xC6, 0x01, 0x38, 0x72, 0x0B, 0x2F, 0x0F, 0x54, 0x9C, 0x6E,
	0x40, 0x24, 0xEA, 0x84, 0xC7, 0xE1, 0x7D, 0x34, 0x58, 0xBD, 0x2E, 0xE2, 0xB4, 0x12, 0x48, 0xFE
	};
	for (int i = 0; i &lt; strlen(data); ++i)
	{
		data[i] ^= magic_bytes[i];
	}
	printf("%s", data);
	return 0;
}</code></pre>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2</a></p>
<p>上面介绍了openssl的一些加密算法使用，下面这个是函数说明</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c59291f8f98">https://www.jianshu.com/p/3c59291f8f98</a></p>
<h1 id="SpaceHeroesCtf2022-Timesup"><a href="#SpaceHeroesCtf2022-Timesup" class="headerlink" title="SpaceHeroesCtf2022-Timesup"></a>SpaceHeroesCtf2022-Timesup</h1><p>进去就是输入三个数满足一个方程式</p>
<p>计算方法就不多说了，可以看这篇wp</p>
<p><a target="_blank" rel="noopener" href="https://ctftime.org/writeup/32973">https://ctftime.org/writeup/32973</a></p>
<p>主要看第二个限制，可以看到这里有个限制应该是在16到17秒之间，但是wp里说的是17分，我自己写了代码发现第一个参数是秒，这里也有说明</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-localtime.html">https://www.runoob.com/cprogramming/c-function-localtime.html</a></p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649157668565.png"></p>
<p>那么我们就需要借助工具来进行传送参数，需要pwntools</p>
<pre class="language-none"><code class="language-none">process是连接本地连接
remote是连接远端的，格式t=remote('网址',端口)

我们可以发送数据过去，也可以接受数据</code></pre>

<pre class="language-python" data-language="python"><code class="language-python">val = 0xa4c570

a = 1
b = (val * 7 - 4) // 2
c = 1
def testfunc(a, b, c):
    return (a + b + c &lt;&lt; ((a % b) &amp; 0x1f)) // ((2 &lt;&lt; (a &amp; 0x1f) ^ 3) * c)

result = testfunc(a, b, c)

print(val)
print(result, hex(result))

print(hex(a), hex(b), hex(c))

from pwn import *

#s = process('./timesup')
s = remote('0.cloud.chals.io', 26020)

print(s.readuntil(b'&gt;&gt;&gt; ').decode())

s.writeline('{} {} {}'.format(hex(a), hex(b), hex(c)).encode())

s.interactive()</code></pre>

<p>直接贴代码吧，感觉需要系统学pwntools</p>
<h1 id="Hgame2022-week4-hardasm"><a href="#Hgame2022-week4-hardasm" class="headerlink" title="Hgame2022-week4-hardasm"></a>Hgame2022-week4-hardasm</h1><p>一打开有几千行的汇编代码，先定位到关键判断</p>
<p>可以看到有很多的比较+跳转，而跳转的位置都是error</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300239189.png"></p>
<p>那么只需要保证不符合等于0即可</p>
<p>构造flag：hgame{12345678901234567890}动调</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300476017.png" alt="比较内容"></p>
<p>可以看到只要输入正确，最后得到的值是0xFF，不正确则为0，可以采取爆破的方式爆破出flag</p>
<p>可以看到printf的参数是通过rcx传入的，所以我们可以patch程序，让他打印[rsp+70h+var_50]的值，而不是success或error</p>
<p> <img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1c8291f15811477c8fbbd7d6a480bca0.png" alt="asm-print"> </p>
<p>edit-&gt;patch Program-&gt;Assemble，不知道为什么KeyPatch改不了</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649301043777.png"></p>
<h2 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h2><p> subprocess模块可以生成新的进程，连接到它们的input/output/error管道，同时获取它们的返回值</p>
<p>我们可以使用该模块进行爆破</p>
<pre class="language-python" data-language="python"><code class="language-python">import subprocess
real_flag="hgame{"#绝对正确的前6个字符
cur_index=6#当前爆破的位置
while cur_index&lt;32:
    for i in range(32,128):#当前爆破的位置上的字符
        real_flag_arr = [0] * 32
        for j in range(len(real_flag)):#正确的先复制一下
            real_flag_arr[j]=ord(real_flag[j])

        real_flag_arr[cur_index]=i#设置当前爆破的位置上的字符
        real_flag_arr_s="".join(chr(k) for k in real_flag_arr)#输入到程序中的字符串
        #上面都是一些初始化
        p = subprocess.Popen(["D:\\new\\AD\\game\\hgame2022\\week4\\hardasm.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.stdin.write(real_flag_arr_s.encode())
        p.stdin.close()#停止输入
        out = p.stdout.read()
        if len(out)&gt;cur_index:#判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置上的字符设置的是正确的，因为存储的内容为0时，printf不打印
            real_flag+=chr(i)
            cur_index+=1
            print(real_flag)
            break
# hgame{r
# hgame{ri
# hgame{rig
# hgame{righ
# hgame{right
# hgame{right_
# hgame{right_y
# hgame{right_yo
# hgame{right_you
# hgame{right_your
# hgame{right_your_
# hgame{right_your_a
# hgame{right_your_as
# hgame{right_your_asm
# hgame{right_your_asm_
# hgame{right_your_asm_i
# hgame{right_your_asm_is
# hgame{right_your_asm_is_
# hgame{right_your_asm_is_g
# hgame{right_your_asm_is_go
# hgame{right_your_asm_is_goo
# hgame{right_your_asm_is_good
# hgame{right_your_asm_is_good!
# hgame{right_your_asm_is_good!!
# hgame{right_your_asm_is_good!!}
# hgame{right_your_asm_is_good!!}</code></pre>

<p>代码来源-<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45582916/article/details/122909419">https://blog.csdn.net/weixin_45582916/article/details/122909419</a></p>
<p>POpen参数说明</p>
<pre class="language-none"><code class="language-none">stdin stdout和stderr：

stdin stdout和stderr，分别表示子程序的标准输入、标准输出和标准错误。可选的值有PIPE或者一个有效的文件描述符（其实是个正整数）或者一个文件对象，还有None。如果是PIPE，则表示需要创建一个新的管道，如果是None，不会做任何重定向工作，子进程的文件描述符会继承父进程的。另外，stderr的值还可以是STDOUT，表示子进程的标准错误也输出到标准输出。</code></pre>

<pre class="language-python" data-language="python"><code class="language-python">stdin.write()#输入
stdin.close()#关闭输入
stout.read()#获取输出</code></pre>

<h1 id="Foobarctf2022-Matrix"><a href="#Foobarctf2022-Matrix" class="headerlink" title="Foobarctf2022-Matrix"></a>Foobarctf2022-Matrix</h1><p>一道vm题+angr求解</p>
<p>vm分析部分</p>
<pre class="language-c" data-language="c"><code class="language-c">unsigned char opcode[124] = {
    0x04, 0x0B, 0x1D, 0x1C, 0x1B, 0x1A, 
	0x04, 0x0A, 0x5A, 0x50, 0x4E, 0x5D, //先把mov后面四个进行异或，然后将异或后的值与我们的输入异或 
	0x00, 0x0A, 0x0B, 
	0x00, 0x00, 0x0A, //0x00存的是我们的输入 
	0x04, 0x0B, 0x2D, 0x2C, 0x2B, 0x2A, 
	0x04, 0x0A, 0x56, 0x69, 0x58, 0x49, 
	0x00, 0x0A, 0x0B, 
	0x00, 0x01, 0x0A, 
	0x04, 0x0B, 0x3D, 0x3C, 0x3B, 0x3A, 
	0x04, 0x0A, 0x5C, 0x6C, 0x08, 0x65, 
    0x00, 0x0A, 0x0B, 
	0x00, 0x02, 0x0A, 
	0x04, 0x0B, 0x4D, 0x4C, 0x4B, 0x4A, 
	0x04, 0x0A, 0x7A, 0x04, 0x2E, 0x15, 
	0x00, 0x0A, 0x0B, 
	0x00, 0x03, 0x0A, 
	0x04, 0x0B, 0x5D, 0x5C, 0x5B, 0x5A, 
	0x04, 0x0A, 0x30, 0x1C, 0x0F, 0x08, 
	0x00, 0x0A, 0x0B, 
	0x00, 0x04, 0x0A, 
	0x04, 0x0B, 0x6D, 0x6C, 0x6B, 0x6A, 
    0x04, 0x0A, 0x24, 0x14, 0x16, 0x6A, 
	0x00, 0x0A, 0x0B, 
	0x00, 0x05, 0x0A, 
	
	0x02, 0x00, 0x01, 					//将我们异或后的值|=其后面一个值 
	0x02, 0x00, 0x02, 
	0x02, 0x00, 0x03, 
	0x02, 0x00, 0x04, 
	0x02, 0x00, 0x05, 
	0xFF</code></pre>

<p>angr求解，因为最后的结果字符串存在GLUG，所以直接angr</p>
<pre class="language-python" data-language="python"><code class="language-python">import angr
import claripy
import sys



proj = angr.Project("./matrix")#创建文件
state = proj.factory.entry_state()

simgr = proj.factory.simgr()
simgr.run()


if simgr.deadended:
    for s in simgr.deadended:
        tmp = s.posix.dumps(0)#获取最终结果
        if b"glug" in tmp.lower():
            print(tmp)</code></pre>

<p>不知道为啥只能在linux跑，在windows跑会报错</p>
<h1 id="CTF2022-Simplefs"><a href="#CTF2022-Simplefs" class="headerlink" title="*CTF2022-Simplefs"></a>*CTF2022-Simplefs</h1><p>根据附件里的描述，可以知道这是关键函数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367401948.png"></p>
<p>这三段都很类似，不同的在于这里传入的参数</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367476520.png"></p>
<p>进去看看，根据不同的参数产生不同的结果，然后写入</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367528880.png"></p>
<p>当传入2时，生成的是随机数，而且以时间为种子，所以我们不可逆</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367550826.png"></p>
<p>当传入1时，移位和异或操作，通过动调可以得到异或的值</p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367588110.png"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历文件所有字节流，进行解密，然后和*CTF比较，比对成功就打印其后面的32位</p>
<p>也可以先将*CTF进行加密，然后将得到的十六进制去加密的文件搜索，取出之后爆破即可（NU1L的题解就是爆破的）</p>
<p>下面贴一下我的脚本，调试了挺久emmm，太菜了</p>
<pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;malloc.h&gt;
#include&lt;stdlib.h&gt;

#define FilePath "D:\\new\\AD\\game\\星ctf2022\\dcacb9c0054e4a4695b2f373f255ac8e\\image.flag"
int main()
{
	char xor_table[4] = { 0xEF,0xBE,0xED,0xDE };
	FILE* pfile = fopen(FilePath, "r");
	fseek(pfile, 0 , SEEK_END);
	int filesize = ftell(pfile);
	fseek(pfile, 0, SEEK_SET);
	unsigned char *Buffer = { 0 };

	Buffer = (unsigned char*)malloc(filesize);
	memset(Buffer, 0, filesize);
	fread(Buffer, filesize, 1, pfile);
	int j = 0;
	int i = 0;
	int count = 0;
	while (1)
	{
		
		for (i=j;count&lt;32; ++i,count++)
		{
			Buffer[i] = ((Buffer[i] &lt;&lt; 5) | (Buffer[i] &gt;&gt; 3)) &amp; 0xff;
			Buffer[i] ^= xor_table[3];
			Buffer[i] = ((Buffer[i] &lt;&lt; 4) | (Buffer[i] &gt;&gt; 4)) &amp; 0xff;
			Buffer[i] ^= xor_table[2];
			Buffer[i] = ((Buffer[i] &lt;&lt; 3) | (Buffer[i] &gt;&gt; 5)) &amp; 0xff;
			Buffer[i] ^= xor_table[1];
			Buffer[i] = ((Buffer[i] &lt;&lt; 2) | (Buffer[i] &gt;&gt; 6)) &amp; 0xff;
			Buffer[i] ^= xor_table[0];
			Buffer[i] = ((Buffer[i] &lt;&lt; 1) | (Buffer[i] &gt;&gt; 7)) &amp; 0xff;
		}
		if ((Buffer[j] == '*') &amp;&amp; (Buffer[j+1] == 'C') &amp;&amp; (Buffer[j+2] == 'T') &amp;&amp; (Buffer[j+3] == 'F'))
		{
			for (int k = j; k &lt; 32+j; ++k)
			{
				printf("%c", Buffer[k]);
			}
			break;
		}
		j += 32;
		count = 0;
		
	}
	
	//fclose(pfile);
	/*unsigned char Buffer[] = { 0x00,0xD2,0xFC,0xD8,0xA2 };
	for (int i = 0; i &lt; 5; ++i)
	{
		Buffer[i] = ((Buffer[i] &lt;&lt; 5) | (Buffer[i] &gt;&gt; 3)) &amp; 0xff;
		Buffer[i] ^= xor_table[3];
		Buffer[i] = ((Buffer[i] &lt;&lt; 4) | (Buffer[i] &gt;&gt; 4)) &amp; 0xff;
		Buffer[i] ^= xor_table[2];
		Buffer[i] = ((Buffer[i] &lt;&lt; 3) | (Buffer[i] &gt;&gt; 5)) &amp; 0xff;
		Buffer[i] ^= xor_table[1];
		Buffer[i] = ((Buffer[i] &lt;&lt; 2) | (Buffer[i] &gt;&gt; 6)) &amp; 0xff;
		Buffer[i] ^= xor_table[0];
		Buffer[i] = ((Buffer[i] &lt;&lt; 1) | (Buffer[i] &gt;&gt; 7)) &amp; 0xff;
		
	}*/
	return 0;
}

</code></pre>

<p>要注意的是</p>
<blockquote>
<p><strong>BYTE是unsigned char型</strong></p>
</blockquote>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367843687.png"></p>
<p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367884507.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/03/Crackme%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Crackme算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-03 11:27:49" itemprop="dateCreated datePublished" datetime="2022-04-03T11:27:49+08:00">2022-04-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:18:49" itemprop="dateModified" datetime="2022-04-20T09:18:49+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>因为汇编太水了，所以决定做一下CrackMe练习，可能不会一直弄，精力有限</p>
<h1 id="0x01-笔记"><a href="#0x01-笔记" class="headerlink" title="0x01-笔记"></a>0x01-笔记</h1><blockquote>
<p> XCHG（交换数据）指令交换两个操作数内容 </p>
</blockquote>
<blockquote>
<p>mov和lea的区别</p>
<p>mov:当mov eax,[]表示将[]中地址存储的值存放到eax中，当然也可以直接mov地址到eax中，如mov eax,地址</p>
<p>lea:当lea eax,[]，表示将[]中的地址存放到eax中，相当于指针，主要是计算地址</p>
</blockquote>
<h1 id="002-abexcm5"><a href="#002-abexcm5" class="headerlink" title="002-abexcm5"></a>002-abexcm5</h1><p>首先先通过字符串引用定位到正确判断的位置</p>
<blockquote>
<p>调用函数前需要将参数压入堆栈中，并且靠前的参数后压入栈中</p>
</blockquote>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964360285.png" alt="正确判断"></p>
<p>接下来可以按x寻找调用位置，红色框中的就是跳转的位置</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964520801.png" alt="调用位置"></p>
<p>再往上找比较函数</p>
<p>可以看到这里调用了cmp函数，而且压入了两个参数，第一个是真正的注册码，第二个是我们的输入</p>
<blockquote>
<p>cmp:比较两个操作数，根据相减结果来改变零标志位，结果为0时，零标志位为1（Z位）</p>
<p>当第一位小于第二位时，S位为1</p>
</blockquote>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964586990.png" alt="比较函数"></p>
<p>寻找对注册码的操作</p>
<p>可以看到这里进行了两次拼接操作</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964780202.png" alt="两次拼接"></p>
<p>这个拼接的字符串是已知的，再看另一个</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964832766.png"></p>
<p>可以看到先通过GetVolumeInformationA获取驱动器信息，并生成字符串存储到aData4562Abex中，然后将字符串String2拼接到生成的字符串后</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964910270.png" alt="aData4562Abex操作"></p>
<p>接下来重点讲讲ds段寄存器和重要的操作数</p>
<blockquote>
<p>ds:[地址]就相当于ds:地址，而且取出的是里面的内容，然后进行加一，</p>
<p>dec dl是dl的值–，并且除了CF标志位，其他都会改变。</p>
<p>dec dl对ZF标志位的影响，jnz跳转的条件是ZF==0，当dl的值为0时，设置ZF=1；否则设置为0</p>
<p>而一开始mov dl,2就是初始化迭代的次数，那么从mov到jnz这一段就是一个循环。</p>
</blockquote>
<p>总的加密就是取出aData字符串的前四位进行两次+1</p>
<p>所以我们还原一下过程即可得到注册码，但是我不明白GetVolumeInformationA生成的字符串，所以动调了</p>
<p>最后注册码L2C-5781Fcvc4562-ABEX</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648965721476.png" alt="注册成功"></p>
<h1 id="003-Cruehead-CrackMe-3"><a href="#003-Cruehead-CrackMe-3" class="headerlink" title="003-Cruehead-CrackMe-3"></a>003-Cruehead-CrackMe-3</h1><p>运行时发现是未cracked的</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648979391664.png" alt="运行时"></p>
<p>了解到这是需要KEY文件才能正确crack的，我们从头开始分析</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648980725152.png" alt="CreateFileA"></p>
<pre class="language-c" data-language="c"><code class="language-c">HANDLE CreateFileA(
  [in]           LPCSTR                lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);</code></pre>

<p>具体参数参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea</a></p>
<p>注意压入栈的顺序即可，这里根据参数应该是打开CRACKME3.KEY文件，如果没有的话返回值设置为-1</p>
<blockquote>
<p>返回值一般存储在eax寄存器中</p>
</blockquote>
<blockquote>
<p>CMP汇编指令会修改ZF和CF标志寄存器，如果相同的话设置ZF为1，否则为0</p>
</blockquote>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981137536.png" alt="跳转"></p>
<p>如果不相等，就跳转到401043，这里我们默认打开了</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981237587.png" alt="ReadFile"></p>
<p>可以看到先把0x12存入eax，把字符串地址放入ebx中</p>
<blockquote>
<p>offset存储的是字符串的地址</p>
</blockquote>
<p>接下来调用ReadFile读取文件内容，长度是0x12，位置是字符串地址存储的内容</p>
<pre class="language-c" data-language="c"><code class="language-c">BOOL ReadFile(
    HANDLE hFile,            //文件的句柄
    LPVOID lpBuffer,          //用于保存读入数据的一个缓冲区
    DWORD nNumberOfBytesToRead,    //要读入的字节数
    LPDWORD lpNumberOfBytesRead,    //指向实际读取字节数的指针
    LPOVERLAPPED lpOverlapped
    //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。
    //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL
);</code></pre>

<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981665617.png" alt="加密函数之一"></p>
<p>先来看加密函数的初始化操作</p>
<p>两个xor是将ecx和eax的值清空</p>
<p>将esp+arg_0存储的值赋值到esi中，也就是读取字符串的地址</p>
<blockquote>
<p>这里可以看到arg_0=DWORD 4，esp+4就是我们压入栈中的参数，因为call会让ESP往低地址移动</p>
</blockquote>
<p>再将0x41赋值给bl</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981700071.png" alt="初始化操作"></p>
<p>接下来看加密的操作，首先先将esi的存储的值看作地址，取出里面的内容放到al中，再将al异或上bl的值，再存放回原来的地址</p>
<blockquote>
<p>inc实现的是自增1</p>
</blockquote>
<p>esi存放的是地址，+1就相当于指针后移</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981955860.png" alt="加密操作"></p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982311802.png" alt="指针移动"></p>
<p>然后将异或后的结果加到ds:dword_4020F9存储的内容中</p>
<p>判断al的值是否为0，如果是的话，跳转到</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982477054.png" alt="当al为0时跳转的地址"></p>
<p>接着就是cl++，然后判断bl的值是否为0x4F，因为初始时bl的值为0x41，所以加密数据的长度是0x4f-0x41</p>
<p>最后，函数loc_401335结束前把ecx的值存放到ds段寄存器地址的内容中</p>
<p>因为异或后相加的结果存储在dword_4020F9中，这里将它和0x12345678异或</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982757718.png"></p>
<blockquote>
<p>add esp,4是因为call的时候将其下一条指令压入栈中，所以需要add esp,4</p>
</blockquote>
<p>接下来又将我们加密后的内容压入栈，进行下一个函数的操作</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983002897.png" alt="第二轮操作"></p>
<p>先把esp+4存储的内容也就是存储字符串的首地址存放到esi中，然后esi+0xE，也就是地址后移0xE，再将其存储的值放入eax中，0x12-0xE=4，也就是将最后四个存放到eax寄存器中</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983018786.png" alt="第二轮操作"></p>
<p>将最后四位与dword_4020F9，也就是刚才和0x12345678异或后的值比较</p>
<blockquote>
<p>setz al；如果ZF=1，则设置目标数为1，否则则为0</p>
<p>test al,al;如果al&amp;al==0，也就是al的值为0，那么ZF会被设置为1，否则则为0</p>
</blockquote>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983201869.png" alt="比较"></p>
<p>接下来是一些创建窗口和弹出窗口的代码</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983983571.png" alt="窗口代码"></p>
<p>看一下成功的部分代码</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984022368.png" alt="成功部分"></p>
<p>主要看一下这个</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984126580.png" alt="移动字符串"></p>
<blockquote>
<p> 即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。 </p>
</blockquote>
<p>先把DWORD_402149，也就是前面说的加密的长度</p>
<p>也就是先把传入的两个参数的地址分别存入esi和edi中</p>
<p>而第一个参数也就是arg_0(后压入栈)，被存放到esi中</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984644479.png"></p>
<p>同时，第一个参数也是前面存放我们字符串的地址</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984708951.png"></p>
<p>然后edi指向的地址后移</p>
<p>再循环将esi的值存入edi中，循环次数为ecx的值</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984226522.png"></p>
<p>这段话就是将我们最后加密的字符串拼接到Cracked By:后面</p>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>先打开CRACKME3.KEY文件，读取前十八个字符，然后对前14个字符异或加密，并且将异或后的值和0x12345678异或后与最后四位进行比较，前十四个密文为<a href="mailto:wanao@yahoo.cn">wanao@yahoo.cn</a>，然后动调得到最后四位字符，填充进去即可，注意大小端序</p>
<p>前十四位字符脚本</p>
<pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
	char name[]="wanao@yahoo.cn";
	char key='A';
	int num=0;
	for(int i=0;i&lt;strlen(name);++i)
	{
		name[i]^=key++;
		num+=name[i];
	}
	printf("%s\n",name);
	printf("%d\n",num);
	int key2=0x12345678;
	return 0;
	
 } </code></pre>

<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985143096.png" alt="最后四位字符"></p>
<p>最终效果</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985203991.png"></p>
<h1 id="004-Acid-Bytes-2"><a href="#004-Acid-Bytes-2" class="headerlink" title="004-Acid Bytes.2"></a>004-Acid Bytes.2</h1><p>upx壳，去掉后很快就能找到比较</p>
<h1 id="006-ArturDents-CrackMe-2"><a href="#006-ArturDents-CrackMe-2" class="headerlink" title="006-ArturDents-CrackMe#2"></a>006-ArturDents-CrackMe#2</h1><p>先找到成功的函数</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033728711.png" alt="验证正确的函数"></p>
<p>然后找到关键比较</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033782005.png" alt="关键函数和跳转"></p>
<p>根据程序运行知道我们需要输入name和序列号，找到获取输入的函数</p>
<pre class="language-c" data-language="c"><code class="language-c">UINT GetDlgItemTextA(
  [in]  HWND  hDlg,
  [in]  int   nIDDlgItem,
  [out] LPSTR lpString,
  [in]  int   cchMax
);
//返回值是字符串的长度</code></pre>

<p>lpstring就是我们的输入</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034100647.png" alt="关键函数"></p>
<p>箭头处可以看到cmp esi,5，而前面将函数的返回值也就是eax的值存储到esi中，所以这是长度比较，可以看到jge下一段是说name长度必须大于5。</p>
<p>再看下面红色框，获取我们的输入密码后，将input和password的地址存放到eax和ebx中，再把esi也就是name的长度存入ecx中</p>
<p>看加密函数</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034490927.png" alt="关键加密函数"></p>
<p>先把eax存储的值取出，然后减去cl的值，再与ebx存放的值作比较</p>
<p>下面那个跳转是跳转到离开的函数</p>
<p>inc是自增，也就是让寄存器指向password和input下一个字符</p>
<blockquote>
<pre class="language-c" data-language="c"><code class="language-c">    mov cx, 循环的次数 (当遇到Loop标号时 cx就代表循环的次数)
标号: (标明后面就是需要循环的循环体)
    循环执行的程序代码
    Loop 标号//注意：每执行一次loop，ecx的值都会减1</code></pre>
</blockquote>
<p>每执行一次loop，ecx的值都会减1</p>
<p>所以注意这一点即可</p>
<h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>name为99999，序列号为45678即可满足</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034817650.png" alt="成功"></p>
<h1 id="007-reg"><a href="#007-reg" class="headerlink" title="007-reg"></a>007-reg</h1><p>这是一个共享软件，打开时需要我们输入UserName和SN，然后生成reg.dll，再打开软件验证。</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040536751.png" alt="reg.dll内容"></p>
<p>先定位到关键的字符串</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040650078.png" alt="关键字符串"></p>
<p>定位过去</p>
<p>可以看到先把字符串也就是reg.dll移动到eax中，然后call，再对al进行验证，所以这个函数应该是打开这个文件，没有这个文件的话就返回0</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040684329.png"></p>
<p>接下来这一段应该是将dll文件的username和sn读取出来</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040844910.png" alt="读取函数"></p>
<p>可以看到先把刚才读取的username和sn存放到edx和eax中，然后调用函数，调用结束后进行test和跳转，所以这个函数应该是加密函数</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040977142.png" alt="加密函数"></p>
<p>加密函数中，先将变量的值清0，并且将username和sn存放到第一个和第二个参数中</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041483499.png"></p>
<p>往下看，这里先把第二个参数（序列号）的地址读取到eax中，然后返回值和0x10作比较，那么这段应该就是计算序列号的长度</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041704450.png" alt="关键比较"></p>
<p>在函数出事的地方，可以看到var_8=-8，然后ebp-8就是存放的序列号</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042026513.png" alt="计算位置"></p>
<p>看一下函数调用的堆栈图，EBP+x就是压入的参数</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042190963.png" alt="堆栈图"></p>
<p>下面这一段应该是对序列号验证，因为sub会让标志寄存器改变</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042492337.png" alt="验证"></p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042642683.png"></p>
<p>FTSP汇编指令</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liujiayu2/article/details/77711838">https://blog.csdn.net/liujiayu2/article/details/77711838</a></p>
<p>最后在这里的堆栈图找到了正确的序列号，长度正好是0x10</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042753681.png"></p>
<p>先把两个参数存放的内容以及第三个参数也就是var_10的地址存储到ecx中，那么这个应该就是正确的序列号</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042840725.png" alt="在调用前面的函数前"></p>
<p>函数有点复杂，有时间再看，据说后面有md5</p>
<p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649043390270.png" alt="ZF标志位"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/31/C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/31/C/" class="post-title-link" itemprop="url">C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-31 14:08:13" itemprop="dateCreated datePublished" datetime="2022-03-31T14:08:13+08:00">2022-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:22:38" itemprop="dateModified" datetime="2022-04-20T09:22:38+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>C++学习</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/31/C/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">AES-C语言实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-29 14:57:00" itemprop="dateCreated datePublished" datetime="2022-03-29T14:57:00+08:00">2022-03-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:21:19" itemprop="dateModified" datetime="2022-04-20T09:21:19+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>AES-128-None-C语言</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/27/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%A4%A7%E6%9D%82%E7%83%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/27/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%A4%A7%E6%9D%82%E7%83%A9/" class="post-title-link" itemprop="url">反调试大杂烩</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-27 15:09:14 / 修改时间：15:20:58" itemprop="dateCreated datePublished" datetime="2022-03-27T15:09:14+08:00">2022-03-27</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>114</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/reverse/windows/anti-debug/example/">https://ctf-wiki.org/reverse/windows/anti-debug/example/</a> </p>
<p><a target="_blank" rel="noopener" href="https://anti-debug.checkpoint.com/techniques/assembly.html">https://anti-debug.checkpoint.com/techniques/assembly.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">压缩壳的学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-26 16:00:50" itemprop="dateCreated datePublished" datetime="2022-03-26T16:00:50+08:00">2022-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-27 14:57:50" itemprop="dateModified" datetime="2022-03-27T14:57:50+08:00">2022-03-27</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/iBinary/p/7764483.html">https://www.cnblogs.com/iBinary/p/7764483.html</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-265766.htm">https://bbs.pediy.com/thread-265766.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-727090-1-1.html">https://www.52pojie.cn/thread-727090-1-1.html</a></p>
<p>upx源码</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ichunqiu/p/7245329.html">https://www.cnblogs.com/ichunqiu/p/7245329.html</a></p>
<h1 id="壳的介绍"><a href="#壳的介绍" class="headerlink" title="壳的介绍"></a>壳的介绍</h1><p>壳根据不同可以分成压缩壳、加密壳、其他</p>
<h2 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h2><p>压缩壳，顾名思义，就是让程序变小，但是程序执行是没有问题的，主要有UPX和Aspack等</p>
<h2 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h2><p>加密壳就是为了保护程序而设计的，主要用于商业程序，主要有ASProtect、Armadillo、EXECryptor、Themida</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>主要是一些病毒的壳</p>
<h1 id="UPX压缩壳"><a href="#UPX压缩壳" class="headerlink" title="UPX压缩壳"></a>UPX压缩壳</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>压缩能让我们程序的体积变小，就类似于123456使用%x替换，672324ADB使用%C替换，这样程序代码体积就变小了</p>
<p>压缩壳的工作原理首先在程序开头或者其他合适的地方插入一段代码（包括解压缩的代码），然后再将程序的其他地方进行压缩</p>
<p>压缩的数据主要是PE文件的节的数据</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/vv0bcog94g.png" alt="压缩"></p>
<p>当程序执行时，实现对程序的解压缩，所以不会影响程序的执行</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344699085.png" alt="正常程序"></p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344795798.png" alt="加壳后的程序"></p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344833463.png" alt="程序解压缩"></p>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/v3o2hqc77w.png"></p>
<p>因为程序需要解压缩，但是原来的节的位置已经被占据，那么壳是怎么恢复数据的呢</p>
<p>首先我们知道原PE的节的个数以及大小，那么此时我们生成的新的带壳PE，则会获得大小。然后在其带壳PE的下面申请怎么大小的节用来占位置即可，也就是说运行时，shell会进行偏移，不会占用解压缩的节的位置</p>
<p>那么此时我们解压的数据，则会写到我们占位置的地方。</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/wbx7n8dg8k.png"></p>
<h1 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h1><h2 id="1、保存入口参数"><a href="#1、保存入口参数" class="headerlink" title="1、保存入口参数"></a>1、保存入口参数</h2><p>加壳程序在初始化时会保存各寄存器的值，等到外壳执行完毕，再恢复各个寄存器的值，最后跳转到原程序执行。通常使用Push ad/pop ad、pushfd/popfd指令来保存和恢复现场</p>
<h2 id="2、获取壳本身需要使用的API地址"><a href="#2、获取壳本身需要使用的API地址" class="headerlink" title="2、获取壳本身需要使用的API地址"></a>2、获取壳本身需要使用的API地址</h2><p>在一般情况下，外壳的输入表只有GetProcAddress、GetModuleHandle和LoadLibary这三个API函数，甚至只有Kernel32.dll及GetProcAddress。如果需要使用其他API函数，可以通过LoadLibaryA或者LoadLibaryExA将DLL文件映像映射到调用进程的地址空间中，函数返回的HINSTANCE值用于标识文件映像所映射的虚拟内存地址。也就相当于DLL的基址</p>
<h3 id="LoadLibrary函数"><a href="#LoadLibrary函数" class="headerlink" title="LoadLibrary函数"></a>LoadLibrary函数</h3><p>原型如下</p>
<pre class="language-c" data-language="c"><code class="language-c">HINSTANCE LoadLibary{
	LPCTSTR lpLibFIlenam;//DLL文件名地址
}</code></pre>

<p>返回值：成功则返回模块的句柄，失败则返回”NULL”。</p>
<h2 id="GetModuleHandle函数"><a href="#GetModuleHandle函数" class="headerlink" title="GetModuleHandle函数"></a>GetModuleHandle函数</h2><p>如果DLL文件已被映射到调用进程的地址空间中，可以调用GetModuleHandleA函数获取DLL模块的句柄，函数原型如下</p>
<pre class="language-c" data-language="c"><code class="language-c">HMODULE GetModuleHandle{
	LPCTSTR lpModuleName//DLL文件名地址
}</code></pre>

<h2 id="GetProcAddress函数"><a href="#GetProcAddress函数" class="headerlink" title="GetProcAddress函数"></a>GetProcAddress函数</h2><p>一旦DLL模块被加载，线程就可以调用GetProcAddress函数来获取输入函数的地址了，该函数原型如下</p>
<pre class="language-c" data-language="c"><code class="language-c">FARPROC GetProcAddress{
	HMODULE hModule,//DLL模块句柄
	LPCSTR lpProName //函数名
}</code></pre>

<p>但是有些壳为了提高强度，不使用系统提供的GetProcAddress函数，而是自己编写函数来替代这个API函数，以提高函数调用的隐蔽性</p>
<h2 id="3、解密原程序的各个区块的数据"><a href="#3、解密原程序的各个区块的数据" class="headerlink" title="3、解密原程序的各个区块的数据"></a>3、解密原程序的各个区块的数据</h2><p>为了保护原程序代码和数据，壳一般会加密原程序文件的各个区块。在执行时进行解密，因为壳一般是按区块进行加密的，所以在解密的时候也是按照区块解密的，并且将解密的区块数据按照区块的定义放入内存中合适的位置</p>
<h2 id="4、IAT的初始化"><a href="#4、IAT的初始化" class="headerlink" title="4、IAT的初始化"></a>4、IAT的初始化</h2><p>IAT的填写本来是由 PE装载器实现，但是由于在加壳时构造了一个自建输入表，并且让PE文件头数据目录表的输入表指针指向新建的输入表，PE装载器就会对自建输入表进行填写。而程序的原始输入表被被外壳变形后储存，所以IAT表的填写需要外壳程序来实现。外壳需要做的就是将这个变形输入表从头到尾扫描一遍，重新获取每一个DLL引入的所有函数的地址，并将其填写在IAT表中</p>
<h2 id="5、重定位项的处理"><a href="#5、重定位项的处理" class="headerlink" title="5、重定位项的处理"></a>5、重定位项的处理</h2><p>对于EXE文件，Windows会尽量满足其需求。比如EXE文件的基址一般是4000000h，那么加载到内存中就是4000000，这种情况下就不需要进行重定位。</p>
<p>但是对DLL就不一样了，因为Windows系统没办法保证每次运行时都提供相同的基地址，所以需要重定位，所以加壳的DLL一般会多一个重定位表</p>
<h2 id="6、Hook-API"><a href="#6、Hook-API" class="headerlink" title="6、Hook API"></a>6、Hook API</h2><p>在程序文件中，输入表的作用是让windows操作系统在程序运行时将API的实际地址提供给程序使用。在程序第一行代码被执行前，Windows操作系统就完成了这个操作。</p>
<p>而壳大多在修改原程序文件的输入表之后自己模仿Windows操作系统的工作流程，向输入表填充相关数据，在填充过程中，外壳可以Hook API代码的地址，从而间接获得程序的控制权</p>
<h2 id="7、跳转到原程序入口-OEP"><a href="#7、跳转到原程序入口-OEP" class="headerlink" title="7、跳转到原程序入口-OEP"></a>7、跳转到原程序入口-OEP</h2><p>从这个时候开始，壳将控制权还给原程序</p>
<h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p>引用了别人的图，看起来比较清晰，不过这个是x64下的</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/842206_VKJXADJYNEQVSUQ.jpg"></p>
<p>可以发现在磁盘文件中，upx0是不存在的，使用工具也可以看到</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648358178362.png"></p>
<p>但是看UPX1的VirtualAddress可以知道这两个节中间有很大的空余区域，这些区域是存放解压缩后的原程序数据的</p>
<h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>这里以UPX壳为例</p>
<p>首先我们知道压缩壳会修改程序入口，拖进OD发现断在了push ad</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648345714976.png"></p>
<h2 id="寻找OEP"><a href="#寻找OEP" class="headerlink" title="寻找OEP"></a>寻找OEP</h2><h3 id="根据跨段指令寻找OEP"><a href="#根据跨段指令寻找OEP" class="headerlink" title="根据跨段指令寻找OEP"></a>根据跨段指令寻找OEP</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dilex/p/5547241.html">https://www.cnblogs.com/dilex/p/5547241.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-294773-1-1.html">https://www.52pojie.cn/thread-294773-1-1.html</a></p>
<h3 id="用内存访问断点寻找OEP"><a href="#用内存访问断点寻找OEP" class="headerlink" title="用内存访问断点寻找OEP"></a>用内存访问断点寻找OEP</h3><p>先码着</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jyk764717697/article/details/7306621?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;utm_relevant_index=1">https://blog.csdn.net/jyk764717697/article/details/7306621?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1</a></p>
<h3 id="根据栈平衡寻找OEP-ESP定律"><a href="#根据栈平衡寻找OEP-ESP定律" class="headerlink" title="根据栈平衡寻找OEP-ESP定律"></a>根据栈平衡寻找OEP-ESP定律</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>首先，我们知道壳相当于一个子程序，它在程序运行时首先获得控制权并对程序进行压缩，同时隐藏程序的OEP。</p>
<p>在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是一致的（主要是ESP、EBP等重要的寄存器）。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复现场环境。通常用的指令前面也介绍了。</p>
<p>在脱壳时，根据栈平衡原理（因为壳相当于子程序嘛，所以我们要保证壳运行完，将控制权交换程序的时候堆栈要平衡）对ESP下断，很快就能找到OEP</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>可以看到刚载入时断在了push ad，这时候我们F8</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361229454.png" alt="刚载入"></p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361410288.png" alt="F8前寄存器和堆栈"></p>
<p>F8之后，ESP发生改变，寄存器的值也被压入了栈中</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361564539.png" alt="F8之后"></p>
<p>对ESP下硬件访问断点</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361685665.png"></p>
<p>也可以现在右键ESP，在数据窗口跟随，然后选中前四个字节右键-&gt;断点-&gt;硬件访问-&gt;DWORD</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361790656.png" alt="数据窗口设置断点"></p>
<p>设置好断点后F9</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361835848.png" alt="F9之后"></p>
<p>然后一直单步到jmp</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361889146.png"></p>
<p>这里有个往上跳的，只需要在jnz下一行处按F4即可</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361978941.png" alt="jmp之后"></p>
<p>这时候已经到达OEP了，可以发现堆栈和刚载入时一样</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648362682513.png" alt="对比"></p>
<p>dump下来即可-&gt;右键-&gt;使用OllyDump脱壳调试进程即可</p>
<p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648362058903.png" alt="Dump"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Gcc中在main前和后执行的函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-25 20:38:43" itemprop="dateCreated datePublished" datetime="2022-03-25T20:38:43+08:00">2022-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:27:51" itemprop="dateModified" datetime="2022-04-20T09:27:51+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>548</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>gcc在主函数前后运行的函数</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Vim编辑器使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-25 16:24:35" itemprop="dateCreated datePublished" datetime="2022-03-25T16:24:35+08:00">2022-03-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-26 15:57:43" itemprop="dateModified" datetime="2022-03-26T15:57:43+08:00">2022-03-26</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>881</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Vim键盘图"><a href="#Vim键盘图" class="headerlink" title="Vim键盘图"></a>Vim键盘图</h1><p><img src="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/1648206284939.png" alt="Vim键盘图"></p>
<h1 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h1><p>vim分成三种模式，分别是命令模式、输入模式、底线命令模式</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>用户刚进入vim，便进入命令模式</p>
<p>这时我们敲击键盘的动作被识别为命令</p>
<p>以下是常用的几个命令</p>
<p>i：进入输入模式</p>
<p>x：删除当前光标所在处的字符</p>
<p>：：切换到底线命令模式，这样我们就可以在最底一行输入命令</p>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>1、字符按键和shift组合：输入字符</p>
<p>2、ENTER：回车键，换行</p>
<p>3、BaceSpace：退格键，删除光标前一个字符</p>
<p>4、DEL：删除键，删除光标后一个字符</p>
<p>5、方向键：移动光标</p>
<p>6、HOME/END：移动光标到行首、行尾</p>
<p>7、Page Up/Page Down：上/下翻页</p>
<p>8、Insert： 切换光标为输入/替换模式，光标将变成竖线/下划线 </p>
<p>9、 退出输入模式，切换到命令模式 </p>
<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>省略掉冒号的基本命令</p>
<p>1、q：退出程序</p>
<p>2、w：保存文件</p>
<p>3、命令末尾加上!表示强制执行</p>
<h1 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p>
<p>vim复制粘贴-这里wo</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/huahuayu/p/12235242.html">https://www.cnblogs.com/huahuayu/p/12235242.html</a></p>
<p>Vim配置</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Doctor_xiong/article/details/78663590">https://blog.csdn.net/Doctor_xiong/article/details/78663590</a></p>
<h1 id="GCC生成可执行文件"><a href="#GCC生成可执行文件" class="headerlink" title="GCC生成可执行文件"></a>GCC生成可执行文件</h1><h2 id="Vim生成-c文件"><a href="#Vim生成-c文件" class="headerlink" title="Vim生成.c文件"></a>Vim生成.c文件</h2><p>vim 文件名.c即可生成.c文件</p>
<h2 id="GCC编译成可执行文件"><a href="#GCC编译成可执行文件" class="headerlink" title="GCC编译成可执行文件"></a>GCC编译成可执行文件</h2><p>gcc 文件名.c -o 输入文件名</p>
<p><img src="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/1648209669071.png"></p>
<h1 id="Vim复制和粘贴"><a href="#Vim复制和粘贴" class="headerlink" title="Vim复制和粘贴"></a>Vim复制和粘贴</h1><p>这个链接解决了系统粘贴板和vim粘贴板的共通</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Biiigwang/p/12086514.html">https://www.cnblogs.com/Biiigwang/p/12086514.html</a></p>
<p>我们先把光标移动到我们需要复制数据的起始位置，然后在命令模式中按v进入可视模式，然后移动光标来选中，按v就可以实现复制，按p粘贴</p>
<h1 id="Vim的撤销与恢复撤销"><a href="#Vim的撤销与恢复撤销" class="headerlink" title="Vim的撤销与恢复撤销"></a>Vim的撤销与恢复撤销</h1><p>在命令模式中，我们按u可以撤销插入模式中的操作，而Ctrl+r可以恢复我们的撤销</p>
<h1 id="Vim直接编译C"><a href="#Vim直接编译C" class="headerlink" title="Vim直接编译C"></a>Vim直接编译C</h1><p>配置好之后按F5即可运行，并生成可执行文件</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33505303/article/details/66473907">https://blog.csdn.net/qq_33505303/article/details/66473907</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">278k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:13</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
