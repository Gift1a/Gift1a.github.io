<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://gift1a.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gift1a">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://gift1a.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Gift1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gift1a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2973414642@qq.com" title="E-Mail → mailto:2973414642@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://1.12.239.117:8090/" title="http:&#x2F;&#x2F;1.12.239.117:8090&#x2F;" rel="noopener" target="_blank">Fallwind</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/" class="post-title-link" itemprop="url">LLVM程序集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-24 18:36:01" itemprop="dateCreated datePublished" datetime="2022-03-24T18:36:01+08:00">2022-03-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-25 20:40:42" itemprop="dateModified" datetime="2022-03-25T20:40:42+08:00">2022-03-25</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>321</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h1><p>这里我没办法细讲，因为也是第一次接触，后续深入了解后再补</p>
<p><a target="_blank" rel="noopener" href="https://www.1024sou.com/article/387833.html">https://www.1024sou.com/article/387833.html</a></p>
<p>clang常用编译命令</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/pc153262603/article/details/89553688">https://blog.csdn.net/pc153262603/article/details/89553688</a></p>
<p>指令集</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37206105/article/details/115274241">https://blog.csdn.net/qq_37206105/article/details/115274241</a></p>
<h1 id="LLVM程序集转为ELF可执行文件"><a href="#LLVM程序集转为ELF可执行文件" class="headerlink" title="LLVM程序集转为ELF可执行文件"></a>LLVM程序集转为ELF可执行文件</h1><p>打开附件发现有点难看懂，搜索其中一段指令集后发现是LLVM指令集</p>
<p><img src="/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/1648121627952.png"></p>
<h2 id="转为ELF可执行文件"><a href="#转为ELF可执行文件" class="headerlink" title="转为ELF可执行文件"></a>转为ELF可执行文件</h2><p> clang task.ll -mllvm -W -g -W1,-pie -o task.out </p>
<p>使用上面的命令即可生成elf文件</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/23/sha256/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/23/sha256/" class="post-title-link" itemprop="url">sha256</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-23 19:15:53" itemprop="dateCreated datePublished" datetime="2022-03-23T19:15:53+08:00">2022-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-01 20:52:07" itemprop="dateModified" datetime="2022-04-01T20:52:07+08:00">2022-04-01</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94619052">https://zhuanlan.zhihu.com/p/94619052</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php">https://www.52pojie.cn/forum.php</a></p>
<h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="符号替换-使用函数"><a href="#符号替换-使用函数" class="headerlink" title="符号替换-使用函数"></a>符号替换-使用函数</h2><ul>
<li><img src="https://www.zhihu.com/equation?tex=%5Coplus" alt="[公式]">: 按位异或</li>
<li><img src="https://www.zhihu.com/equation?tex=%5Cwedge" alt="[公式]">: 按位与</li>
<li><img src="https://www.zhihu.com/equation?tex=%5Cvee" alt="[公式]">: 按位或</li>
<li><img src="https://www.zhihu.com/equation?tex=%5Clnot" alt="[公式]">: 补位</li>
<li><img src="https://www.zhihu.com/equation?tex=+" alt="[公式]">: 相加以后对<img src="https://www.zhihu.com/equation?tex=2%5E%7B32%7D" alt="[公式]">求余</li>
<li><img src="https://www.zhihu.com/equation?tex=R%5En" alt="[公式]">: 右移n位</li>
<li><img src="https://www.zhihu.com/equation?tex=S%5En" alt="[公式]">: 循环右移n位</li>
</ul>
<p> <img src="/2022/03/23/sha256/equation-1648645011885.svg" alt="使用到的函数"> </p>
<h2 id="消息预处理"><a href="#消息预处理" class="headerlink" title="消息预处理"></a>消息预处理</h2><h3 id="消息补位"><a href="#消息补位" class="headerlink" title="消息补位"></a>消息补位</h3><p>先对消息摘要实现补码，假设消息M的二进制编码长度为l位。那么我们现在消息末尾补上一位1，然后再补上k个0，其中k为下列方程的最小非负整数</p>
<p> <img src="/2022/03/23/sha256/equation-1648645283142.svg" alt="计算K的公式"> </p>
<blockquote>
<p>特殊情况：当l长度为448时要填充加上512bits，449的话就填充511bits</p>
<p>447的话直接填充一个1即可</p>
</blockquote>
<p>最后填充64位，这64位是l的二进制编码</p>
<p>补完位的消息长度为512的倍数</p>
<h3 id="将补位完的消息进行分组"><a href="#将补位完的消息进行分组" class="headerlink" title="将补位完的消息进行分组"></a>将补位完的消息进行分组</h3><p> 将补码处理后的消息以512位为单位分块为: <img src="/2022/03/23/sha256/equation-1648645770037.svg" alt="[公式]"> </p>
<p>将每个消息块分为16×32bits， 前32位表示为: <img src="/2022/03/23/sha256/equation-1648645804943.svg" alt="[公式]">, 后面32位为: <img src="/2022/03/23/sha256/equation-1648645804934.svg" alt="[公式]">, 以此类推, 最后32位的消息块可表示为: <img src="/2022/03/23/sha256/equation-1648645804929.svg" alt="[公式]"> ，而在C语言中，32位正好对应unsigned int</p>
<h3 id="消息块扩充"><a href="#消息块扩充" class="headerlink" title="消息块扩充"></a>消息块扩充</h3><p>这里我们得到的是16个32bits消息块，要把其扩展为64个32bits的消息块</p>
<p>扩展代码</p>
<pre class="language-c" data-language="c"><code class="language-c">for i from 16 to 63
    s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)
    s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)
    w[i] := w[i-16] + s0 + w[i-7] + s1</code></pre>

<h2 id="Hash主要加密流程"><a href="#Hash主要加密流程" class="headerlink" title="Hash主要加密流程"></a>Hash主要加密流程</h2><h3 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h3><p>初始哈希值取自自然数前8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位的十六进制表示，比如：</p>
<p><img src="/2022/03/23/sha256/equation-1648646228740.svg" alt="[公式]">小数部分约为0.414213562373095048 </p>
<p> <img src="/2022/03/23/sha256/equation-1648646248870.svg" alt="根号2的十六进制表示"> </p>
<p>于是，取出前32位对应0x6a09e667</p>
<p>依次得到初始化的H值</p>
<p> <img src="/2022/03/23/sha256/equation-1648646313831.svg" alt="初始化H值"> </p>
<h3 id="sha256的64个常数"><a href="#sha256的64个常数" class="headerlink" title="sha256的64个常数"></a>sha256的64个常数</h3><p> 取自自然数中前面64个素数的立方根的小数部分的前32位的十六进制表示</p>
<pre class="language-c" data-language="c"><code class="language-c">428a2f98 71374491 b5c0fbcf e9b5dba5
3956c25b 59f111f1 923f82a4 ab1c5ed5
d807aa98 12835b01 243185be 550c7dc3
72be5d74 80deb1fe 9bdc06a7 c19bf174
e49b69c1 efbe4786 0fc19dc6 240ca1cc
2de92c6f 4a7484aa 5cb0a9dc 76f988da
983e5152 a831c66d b00327c8 bf597fc7
c6e00bf3 d5a79147 06ca6351 14292967
27b70a85 2e1b2138 4d2c6dfc 53380d13
650a7354 766a0abb 81c2c92e 92722c85
a2bfe8a1 a81a664b c24b8b70 c76c51a3
d192e819 d6990624 f40e3585 106aa070
19a4c116 1e376c08 2748774c 34b0bcb5
391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
748f82ee 78a5636f 84c87814 8cc70208
90befffa a4506ceb bef9a3f7 c67178f2</code></pre>

<p>进行64次循环加密，流程图如下：</p>
<p><img src="/2022/03/23/sha256/600px-SHA-2.svg.png" alt="主要加密"></p>
<p>这里介绍一下ABCDEFGH的值以及K数组，W是我们扩展后的消息块</p>
<p>先把第一个W块和K相加后mod2^32，但是在C语言中，会进行截断，超过32位直接不管超过的那一位</p>
<p>接着先把H7和前一个得到的结果相加后mod2^32</p>
<p>再把H4、H5、H6取出进行Ch加密，再和前一个结果相加后mod2^32</p>
<p>将H4取出进行什么1操作，再和前一步的结果相加后mod2^32</p>
<p>接下来分为两步，第一步把前一个的结果和H3相加后mod2^32并存储在H4，第二步，先把H0、H1、H2进行Ma操作，再和前一步的结果相加再mod2^32</p>
<p>然后把H0取出进行什么0操作，再和前面第二步的结果相加后mod32后存储在H0</p>
<p>最后进行移位存储操作，就是除了H0和H4，剩下的H值存入前一个的H值</p>
<p>这个步骤循环64步就是加密后的H值，这个H值会被用于下一个512bits消息块的初始H值，最后的H数组加上原来的中间Hash值就是该消息区块的Hash值</p>
<h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;Windows.h&gt;
#define SHA256_ROTL(a,b) (((a&gt;&gt;(32-b))&amp;(0x7fffffff&gt;&gt;(31-b)))|(a&lt;&lt;b))
#define SHA256_SR(a,b) ((a&gt;&gt;b)&amp;(0x7fffffff&gt;&gt;(b-1)))
#define SHA256_CH(x,y,z) ((x&amp;y)^((~x)&amp;z))
#define SHA256_Maj(x,y,z) ((x&amp;y)^(x&amp;z)^(y&amp;z))
#define SHA256_E0(x) (SHA256_ROTL(x,30)^SHA256_ROTL(x,19)^SHA256_ROTL(x,10))
#define SHA256_E1(x) (SHA256_ROTL(x,26)^SHA256_ROTL(x,21)^SHA256_ROTL(x,7))
#define SHA256_O0(x) (SHA256_ROTL(x,25)^SHA256_ROTL(x,14)^SHA256_SR(x,3))
#define SHA256_O1(x) (SHA256_ROTL(x,15)^SHA256_ROTL(x,13)^SHA256_SR(x,10)) 

void SHA256_ENCODE(char* input, int len)
{
	int i;
	char* pos,*posend;
	long A, B, C, D, E, F, G, I;
	long W[64] = { 0 };
	//初始化常量数据
	long long H[8] = {
		0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
		0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19
	};
	unsigned int K[64] = {
		0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
		0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
		0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
		0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
		0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
		0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
		0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
		0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
	};
	//消息补位,一个字符8位，而448位为56个字符,128个字符是1024位，512的两倍
	long long len_final = len + ((len % 64 &gt;= 56) ? (128 - len % 64) : (64 - len % 64));
	//printf("%d", len_final);
	//开辟空间
	if (!(pos = (char*)malloc(len_final)))
	{
		printf("开辟空间失败！\n");
		exit(0);
	}
	//将字符串赋值到堆中，注意因为后面需要转为long类型运算，所以赋值时要注意大小端序的问题
	for ( i = 0; i &lt; len; ++i)
	{
		pos[i + 3 - 2 * (i % 4)] = input[i];
	}
	//字符串后面的1和填充0
	pos[i + 3 - 2 * (i % 4)] = 0x80;
	i++;
	for (; i &lt; len_final; ++i)
	{
		pos[i + 3 - 2 * (i % 4)] = 0;
	}
	//填充字符串的真实长度，并扩展为64位,64位也就是8个字符
	*((long*)(pos + len_final - 4)) = len &lt;&lt; 3;
	*((long*)(pos + len_final - 8)) = len &gt;&gt; 29;
	//每512位进行加密
	for (posend = pos + len_final; pos &lt; posend; pos += 64)
	{
		//先分组为16*32bit
		for (int j = 0; j &lt; 16; ++j)
		{
			W[j] = ((long*)pos)[j];
		}
		//扩展为64*32bit
		for (int j = 16; j &lt; 64; ++j)
		{
			W[j] = (SHA256_O1(W[j - 2]) + W[j - 7] + SHA256_O0(W[j - 15]) + W[j - 16]);
		}
		//下面开始进行64轮加密
		//因为中间哈希值最后时为原来的+加密的哈希值，所以先储存
		A = H[0], B = H[1], C = H[2], D = H[3], E = H[4], F = H[5], G = H[6], I = H[7];
		for (i = 0; i &lt; 64; ++i)
		{
			//T1存储加密的前一部分,T2存储加密的后一部分
			long T1 = I + SHA256_CH(E, F, G) + K[i] + W[i]+SHA256_E1(E);
			long T2 = SHA256_Maj(A, B, C) + SHA256_E0(A);
			//只能从后往前赋值，否则会覆盖
			I = G;
			G = F;
			F = E;
			E = D + T1;
			D = C;
			C = B;
			B = A;
			A = T1 + T2;
		}
		H[0] += A; H[1] += B;
		H[2] += C; H[3] += D;
		H[4] += E; H[5] += F;
		H[6] += G; H[7] += I;
		for (i = 0; i &lt; 8; ++i)
		{
			printf("%X", H[i]);
		}
	}
	return;
}
int main()
{
	char input[] = "ze";
	SHA256_ENCODE(input, strlen(input));
	return 0;
}</code></pre>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">PE-滴水逆向-手动实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-11 20:03:07" itemprop="dateCreated datePublished" datetime="2022-03-11T20:03:07+08:00">2022-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 16:59:25" itemprop="dateModified" datetime="2022-04-08T16:59:25+08:00">2022-04-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="代码节空白节区添加代码"><a href="#代码节空白节区添加代码" class="headerlink" title="代码节空白节区添加代码"></a>代码节空白节区添加代码</h1><p>这里我们在notepad++增加MessageBoxA函数，保证先调用我们的函数再运行notepad++</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在代码区先加入对函数的调用，再将原来的OEP修改为我们插入代码在内存中的位置</p>
<h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p> ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。 所以我们要先关闭</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr">https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr</a></p>
<p>在标准PE头属性中的第一个值改为1即可</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647081337731.png"></p>
<p>这样PE文件加载到内存中就不会随机化了</p>
<h2 id="提取关键数据"><a href="#提取关键数据" class="headerlink" title="提取关键数据"></a>提取关键数据</h2><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>DWORD AddressOfEntryPoint-10E5DBh</p>
<p>DWORD ImageBase-400000h</p>
<h3 id="节表信息"><a href="#节表信息" class="headerlink" title="节表信息"></a>节表信息</h3><p>MIsc.DWORD VirtualSize-17C51Eh</p>
<p>DWORD VirtualAddress-1000h</p>
<p>DWORD PointerToRawData-400h</p>
<p>DWORD SizeOfRawData-17C600h</p>
<h2 id="判断能否添加"><a href="#判断能否添加" class="headerlink" title="判断能否添加"></a>判断能否添加</h2><p>如果SizeOfRawData-MIsc.DWORD VirtualSize&gt;=0x12，即可添加，这里是可以的</p>
<h2 id="找到在文件中代码结束的位置"><a href="#找到在文件中代码结束的位置" class="headerlink" title="找到在文件中代码结束的位置"></a>找到在文件中代码结束的位置</h2><p>先找到在文件中的偏移PointerToRawData，再找到数据段大小MIsc.DWORD VirtualSize，两者相加就是真实数据段的结束位置</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082425978.png"></p>
<h2 id="添加硬编码"><a href="#添加硬编码" class="headerlink" title="添加硬编码"></a>添加硬编码</h2><p>MessageBoxA需要四个参数</p>
<p>call指令长度为5</p>
<p>jmp指令长度为5</p>
<blockquote>
<p>真正要跳转的地址=E8/E9指令的下一条指令在内存中的地址+X（X就是E8后边跟着的四个字节）</p>
</blockquote>
<p>所以我们需要添加的硬编码为6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082868490.png"></p>
<h2 id="计算E8和E9的后四个字节"><a href="#计算E8和E9的后四个字节" class="headerlink" title="计算E8和E9的后四个字节"></a>计算E8和E9的后四个字节</h2><p>先找到E8对应的真实地址，也就是MessageBoxA的地址，在od里面command-&gt;输入bp MessageBoxA-&gt;状态栏b-&gt;找到MessageBoxA的地址</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083046046.png"></p>
<h3 id="E8后四字节计算"><a href="#E8后四字节计算" class="headerlink" title="E8后四字节计算"></a>E8后四字节计算</h3><p>真实地址为MessageBoxA的地址</p>
<p>X为MessageBoxA地址-VirtualAddress+ImageBase+8+5+Misc.VirtualSize</p>
<p>76BA5865</p>
<h3 id="E9后四字节计算"><a href="#E9后四字节计算" class="headerlink" title="E9后四字节计算"></a>E9后四字节计算</h3><p>真实地址为原来的OEP</p>
<p>X为ImageBase+AddressOfEntryPoint-VirtualAddress+ImageBase+8+5+5+Misc.VirtualSize</p>
<p>为FFF910AB</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083638028.png"></p>
<h2 id="修改AddressOfPoint"><a href="#修改AddressOfPoint" class="headerlink" title="修改AddressOfPoint"></a>修改AddressOfPoint</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083743309.png"></p>
<p>让他先执行我们的代码，也就是修改其为插入硬编码的地址</p>
<p>VirtualAddress+Misc.VirtualSize=17D51Eh</p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>先执行MessageBoxA</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084038464.png"></p>
<p>再运行程序</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084072618.png"></p>
<h1 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h1><h2 id="大小判断"><a href="#大小判断" class="headerlink" title="大小判断"></a>大小判断</h2><p>首先我们需要知道能否新增节SizeofHeaders-最后一个节表 的位置，如果大于或等于两个节表的大小（因为节表最后必须有长度为一个节表的00填充），则可以插入</p>
<h2 id="修改节表数量"><a href="#修改节表数量" class="headerlink" title="修改节表数量"></a>修改节表数量</h2><p>标准PE头-&gt;WORD NumberOfSections，+1即可</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647140787003.png"></p>
<h2 id="添加节表信息"><a href="#添加节表信息" class="headerlink" title="添加节表信息"></a>添加节表信息</h2><p>这里直接复制.text段的信息，因为其可读可写可执行，后续可以不用再去修改节表属性</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141001170.png"></p>
<h2 id="确定插入的大小"><a href="#确定插入的大小" class="headerlink" title="确定插入的大小"></a>确定插入的大小</h2><p>根据情况自行选择，这里假设我们插入0x1000字节</p>
<h2 id="修改内存对齐后的大小"><a href="#修改内存对齐后的大小" class="headerlink" title="修改内存对齐后的大小"></a>修改内存对齐后的大小</h2><p>SizeOfImage+插入的大小（按照内存对齐）</p>
<h2 id="修正节表信息"><a href="#修正节表信息" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>先看关键数据</p>
<p>DWORD VirtualAddress</p>
<p>DWORD SizeOfRawData</p>
<p>Misc.DWORD VirtualSize</p>
<p>DWORD PointerToRawData</p>
<p>这里为了方便将Misc.DWORD VirtualSize和DWORD SizeOfRawData都改为0x1000，注意如果插入的是其他字节数，需要计算按照文件和内存对齐来调整</p>
<h3 id="计算VirtualAddress"><a href="#计算VirtualAddress" class="headerlink" title="计算VirtualAddress"></a>计算VirtualAddress</h3><p>前面一个节表的VirtualAddress+Max(Misc.DWORD VirtualSize,SizeOfRawData)-按内存对齐后的</p>
<p>这里SizeOfRawData大于前者，按内存对齐后是15000h，加上该节表的VirtualAddress就是我们插入节表在内存中的偏移地址</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141493979.png"></p>
<h3 id="计算PointerToRawData"><a href="#计算PointerToRawData" class="headerlink" title="计算PointerToRawData"></a>计算PointerToRawData</h3><p>和前面类似SizeOfRawData（文件对齐）+PointerToRawData</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141658195.png"></p>
<h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141708469.png"></p>
<h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p>在PointerToRawData插入0x1000字节</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141776493.png"></p>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>在PE解析工具可以看到插入的节表</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141801656.png"></p>
<h1 id="新增节-节表信息后不够位置"><a href="#新增节-节表信息后不够位置" class="headerlink" title="新增节-节表信息后不够位置"></a>新增节-节表信息后不够位置</h1><p>我们直到DOS和NT头之前有一段垃圾数据，当节表末尾没位置插入80个字节，我们需要将NT头和节表信息前移，这样就可以空出一段无用字节，长度为垃圾数据长度</p>
<blockquote>
<p>注意要修改LONG AddressOfNewExeHeader-NT头的位置</p>
</blockquote>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142922682.png"></p>
<p>直接复制到垃圾数据的起始地址</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142986819.png"></p>
<p>这就是空出来的节表，后续操作和前面新增节一样，就不赘述了</p>
<h1 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h1><p>当前面两种做法都不能满足，我们采取扩大节的办法，可以在任意节区末尾添加，但是如果不是在最后一个节添加，后面的节表偏移都要修改，所以我们扩大最后一个节</p>
<p>需要修改的数据</p>
<p>DWORD SizeOfRawData</p>
<p>Misc.DWORD VirtualSize</p>
<p>DWORD SizeOfImage</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol>
<li>将最后一个节的SizeOfRawData和VirtualSize改成N，N = 节内存对齐后的大小 + 要扩大的大小</li>
<li>修改 SizeOfImage大小=SizeOfImage大小+要扩大的大小</li>
<li>分配一块新的空间，大小为：节内存对齐增加的大小+要扩大的大小</li>
</ol>
<h2 id="修正节表信息-1"><a href="#修正节表信息-1" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>这里我们假设扩大0x1000个字节</p>
<p>要改为Max(DWORD VirtualSize,DWORD SizeOfRawData)内存对齐的大小+我们扩大的大小=16000h</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147742819.png"></p>
<h2 id="修正SizeOfImage"><a href="#修正SizeOfImage" class="headerlink" title="修正SizeOfImage"></a>修正SizeOfImage</h2><p>直接加上0x1000即可</p>
<h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>节内存对齐增加的大小=N-DWORD SizeOfRawData，即C00</p>
<p>在节区尾部增加即可，有时候最后一个节区尾部之后还有别的程序，那么就需要计算最后一个节区的结束地址</p>
<p>求和得到2B6C00h</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147968238.png"></p>
<h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647148042480.png"></p>
<h1 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h1><h2 id="修改节表个数"><a href="#修改节表个数" class="headerlink" title="修改节表个数"></a>修改节表个数</h2><p>合并之后节数量-1，这里改为7</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149630089.png"></p>
<h2 id="修改节表信息"><a href="#修改节表信息" class="headerlink" title="修改节表信息"></a>修改节表信息</h2><p>要将节进行合并，就需要修改节表信息</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149670756.png"></p>
<h3 id="DWORD-SizeOfRawData和DWORD-VirtualSize"><a href="#DWORD-SizeOfRawData和DWORD-VirtualSize" class="headerlink" title="DWORD SizeOfRawData和DWORD VirtualSize"></a>DWORD SizeOfRawData和DWORD VirtualSize</h3><p>将这两个值改为该节的Max(SizeOfRawData,VirtualSize)+下一个节的Max(SizeOfRawData,VirtualSize)</p>
<p>最后保存即可</p>
<p>那么剩下的节表信息没用了，我们可以再次新增节</p>
<h2 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150089815.png"></p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150123108.png"></p>
<h1 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h1><p> <img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/729aff211907434689134a78e18f2a0b.png" alt="导出表结构"> </p>
<p>移动前，我们需要先开辟节区，先将后面三个表指向的数据复制到新的节区中，再复制那三个表的信息过去，最后将数据目录指向导出表开始的地方</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647219750918.png" alt="移动前"></p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647220007029.png" alt="移动后"></p>
<h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>在数据目录找到导出表的RVA</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228628138.png"></p>
<p>根据节的RVA和大小确定在哪个表</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228686574.png"></p>
<p>计算FOA=Export.RVA-rdata.RVA+rdata. PointerToRawData</p>
<p>计算得到F2270，跳转，根据Export.Size确定大小</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228914109.png"></p>
<h2 id="新增节-1"><a href="#新增节-1" class="headerlink" title="新增节"></a>新增节</h2><p>前面说过，就不细🔒了</p>
<h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2><p>前面四个是DWORD函数地址，DWORD函数名称表，WORD函数序号-这里比较少，就一个函数</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229009740.png"></p>
<p>这两个分别是dll名字和函数名称</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229076116.png"></p>
<p>直接复制剩下的导出表信息</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229244730.png"></p>
<h2 id="修改RVA"><a href="#修改RVA" class="headerlink" title="修改RVA"></a>修改RVA</h2><p>这里我已经改好了，因为该节的RVA-PointOfRawData=1600，所以修改的时候将FOA+1600h=RVA</p>
<p>要修改的有</p>
<p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229408065.png"></p>
<h2 id="数据目录修改"><a href="#数据目录修改" class="headerlink" title="数据目录修改"></a>数据目录修改</h2><p>将Export.RVA指向我们复制导出表的初始位置</p>
<h1 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h1><p>新增节-&gt;复制数据-&gt;数据目录修改重定位表位置</p>
<h2 id="修改ImageBase"><a href="#修改ImageBase" class="headerlink" title="修改ImageBase"></a>修改ImageBase</h2><p>我们修改ImageBase时，重定位表也需要修改，其他不用改，因为其他节表信息映射到内存中时，都是按照ImageBase进行的</p>
<p>而重定位表是按照VirtualAddress+小表进行修复的，所以ImageBase修改了，重定位表的VirtualAddress也需要修改</p>
<p>假如ImageBase+1000，重定位表的VirtualAddress也需要+1000</p>
<h1 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h1><p>每个DLL对应一个导入表，DLL存放着我们的函数</p>
<p>导入表后面还有一堆数据，我们不能直接添加，所以要新开辟节区，然后复制原来的导入表之后再在末尾添加导入表</p>
<h2 id="新增节区"><a href="#新增节区" class="headerlink" title="新增节区"></a>新增节区</h2><h2 id="复制导入表信息"><a href="#复制导入表信息" class="headerlink" title="复制导入表信息"></a>复制导入表信息</h2><p> 拷贝原来的导入表到新节中 </p>
<h2 id="新增导入表"><a href="#新增导入表" class="headerlink" title="新增导入表"></a>新增导入表</h2><h2 id="新增INT表和IAT表"><a href="#新增INT表和IAT表" class="headerlink" title="新增INT表和IAT表"></a>新增INT表和IAT表</h2><p>至少八字节</p>
<h2 id="修改Name"><a href="#修改Name" class="headerlink" title="修改Name"></a>修改Name</h2><p> 存储要注入的dll的名称 ，并且将DLL名称的RVA赋值给新增导入表的Name</p>
<h2 id="创建struct-IMAGE-IMPORT-BY-NAME"><a href="#创建struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="创建struct _IMAGE_IMPORT_BY_NAME"></a>创建struct _IMAGE_IMPORT_BY_NAME</h2><p>将函数名称赋值给结构体的第二个变量</p>
<h2 id="修改INT和IAT指向的地址"><a href="#修改INT和IAT指向的地址" class="headerlink" title="修改INT和IAT指向的地址"></a>修改INT和IAT指向的地址</h2><p>将IMAGE_IMPORT_BY_NAME的RVA赋值给INT和IAT的第一项，因为INT和IAT都指向_IMAGE_IMPORT_BY_NAME</p>
<h2 id="修改数据目录"><a href="#修改数据目录" class="headerlink" title="修改数据目录"></a>修改数据目录</h2><p>指向我们的新增位置， 修改IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">PE解析代码实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-11 13:19:10" itemprop="dateCreated datePublished" datetime="2022-03-11T13:19:10+08:00">2022-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 16:44:01" itemprop="dateModified" datetime="2022-04-08T16:44:01+08:00">2022-04-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="打印PE文件头部和节区信息"><a href="#打印PE文件头部和节区信息" class="headerlink" title="打印PE文件头部和节区信息"></a>打印PE文件头部和节区信息</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;malloc.h&gt;
#include&lt;Windows.h&gt;

//宏定义，方便后续使用

//定义变量
IMAGE_DOS_HEADER myDOS;
LONG elf_new;
IMAGE_NT_HEADERS32 myNTheader;
IMAGE_OPTIONAL_HEADER32 myOPTIONheader;
IMAGE_SECTION_HEADER mysection[100];

int NUM_SECTION;

int main()
{
	FILE* pfile;
	pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");//打开文件
	fseek(pfile, 0, SEEK_SET);//参数说明，将fp指针从文件开头移动到0的位置
	fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);//表示从fp开始的地方读取一次长度为sizeof(IMAGE_DOS_HEADER)的字节，存储到myDOS中
	//DOS
	printf("==============IMAGE_DOS_HEADER==============\n");
	printf("DOS头：          %08X\n", myDOS.e_magic);
	printf("NT头所在位置：   %08X\n", myDOS.e_lfanew);
	elf_new = myDOS.e_lfanew;//将NT头的偏移存储起来

	//NT头
	fseek(pfile, elf_new, SEEK_SET);//注意不是sizeof(elf_new)
	fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS), 1, pfile);
	printf("==============IMAGE_NT_HEADERS==============\n");
	//打印PE标志
	printf("PE标志：         %08X\n", myNTheader.Signature);

	//打印标准PE头信息
	printf("==============IMAGE_FILE_HEADERS==============\n");
	printf("节区数量：       %08X\n", myNTheader.FileHeader.NumberOfSections);
	NUM_SECTION = myNTheader.FileHeader.NumberOfSections;
	printf("可选PE头大小：   %08X\n", myNTheader.FileHeader.SizeOfOptionalHeader);
	//打印ASLR的信息，方便查看和修改
	printf("ASLR属性：       %08X\n", (myNTheader.FileHeader.Characteristics ) &amp; 1);

	//打印可选PE头信息
	printf("==============IMAGE_OPTIONAL_HEADERS==============\n");
	fseek(pfile, elf_new+sizeof(IMAGE_FILE_HEADER)+sizeof(myNTheader.Signature), SEEK_SET);//因为标准PE头长度为20
	fread(&amp;myOPTIONheader, sizeof(IMAGE_OPTIONAL_HEADER), 1, pfile);
	printf("DWORD AddressOfEntryPoint：   %08llX\n", myOPTIONheader.AddressOfEntryPoint);
	printf("基址：				%08X\n", myOPTIONheader.ImageBase);//注意这里的可选PE头类型必须是IMAGE_OPTIONAL_HEADER32
	printf("文件对齐大小：		%08X\n", myOPTIONheader.FileAlignment);
	printf("内存对齐大小：		%08X\n", myOPTIONheader.SectionAlignment);
	printf("文件头和节表大小：  %08X\n", myOPTIONheader.SizeOfHeaders);
	printf("内存拉伸大小：		%08X\n", myOPTIONheader.SizeOfImage);

	//打印节表信息，前面我们已经存储了节表数量了
	printf("==============IMAGE_SECTION_HEADER SectionHeaders==============\n");
	fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);
	fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);
	for (int i = 0; i &lt; NUM_SECTION; ++i)
	{
		printf("NAME：        %s\n", mysection[i].Name);
		printf("DWORD VirtualAddress：        %08X\n", mysection[i].VirtualAddress);
		printf("DWORD SizeOfRawData：        %08X\n", mysection[i].SizeOfRawData);
		printf("DWORD PointerToRawData：        %08X\n", mysection[i].PointerToRawData);
		printf("DWORD VirtualSize：        %08X\n", mysection[i].Misc.VirtualSize);
	}
	fclose(pfile);//关闭文件
	return 0;
}</code></pre>

<h1 id="RVA转FOA"><a href="#RVA转FOA" class="headerlink" title="RVA转FOA"></a>RVA转FOA</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
/*
* RVA转FOA的思路
* 1、先判断所在节区，设计思路：首先我们必须拿的是内存对齐后的来比较大小，先把RVA-virtualaddress，再和max(MISC,SizeofRawData)按照内存对齐的值作比较
* 2、循环判断节区
* 3、计算FOA，偏移是一样的，那就是RVA-virtualaddress+节区的PointerOfdata
*/
IMAGE_NT_HEADERS32 myNTheader;
IMAGE_DOS_HEADER myDOS;//因为PE头长度不变，所以我们只需要找到elf_new的内容就可以知道节区的起始地址
IMAGE_SECTION_HEADER mysection[10];
int NUM_SECTION;//我们还需要知道节区的数量
int elf_new;
int RVA = 0x20d000;
long long MAX(DWORD a, DWORD b)
{//计算MISC和SizeOFRAWDATA，并返回按照内存对齐后的值
	if (a &gt; b)
	{
		return (a%myNTheader.OptionalHeader.SectionAlignment)?((a / myNTheader.OptionalHeader.SectionAlignment)+1) * myNTheader.OptionalHeader.SectionAlignment : ((a / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;
	}
	else
		return (b % myNTheader.OptionalHeader.SectionAlignment) ? ((b / myNTheader.OptionalHeader.SectionAlignment) + 1) * myNTheader.OptionalHeader.SectionAlignment : ((b / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;;
}
int main()
{
	FILE* pfile;
	pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");
	fseek(pfile,0, SEEK_SET);
	fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);
	elf_new = myDOS.e_lfanew;
	fseek(pfile, elf_new, SEEK_SET);
	fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS32), 1, pfile);
	NUM_SECTION = myNTheader.FileHeader.NumberOfSections;
	
	//得到节区
	fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);
	fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);
	for (int i = 0; i &lt; NUM_SECTION; ++i)
	{
		if (RVA - mysection[i].VirtualAddress &lt; MAX(mysection[i].Misc.VirtualSize, mysection[i].SizeOfRawData))
		{
			printf("所在节区为：%s\n", mysection[i].Name);
			printf("FOA为：%08X", RVA - mysection[i].VirtualAddress + mysection[i].PointerToRawData);
		}
	}
	fclose(pfile);
	return 0;
}</code></pre>

<h1 id="PE插入shellcode"><a href="#PE插入shellcode" class="headerlink" title="PE插入shellcode"></a>PE插入shellcode</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;Windows.h&gt;
#include&lt;malloc.h&gt;
#include&lt;stdlib.h&gt;

#define MessageBoxA_ADDR 0x76C20F40//MessageBoxA的地址
#define shellcode_len 0x12//定义shellcode的长度
//输入路径和输出路径
char file_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe";
char final_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\5.exe";

//插入的shellcode
BYTE shellcode[] = {
	0x6A,0x00,0x6A,0x00,0x6A,0x00,0x6A,0x00,
	0xE8,0x00,0x00,0x00,0x00,
	0xE9,0x00,0x00,0x00,0x00
};
int LoadPE(LPVOID*pFileBuffer)//二级指针存储的是一级指针的地址
{
	FILE* pfile;
	DWORD FileSize = 0;
	LPVOID pTempBuffer;
	pfile = fopen(file_path, "rb");
	//通过fseek和ftell返回文件长度，fseek将fp指针设置在文件尾，ftell获取当前fp指针的位置与文件首的偏移
	fseek(pfile, 0, SEEK_END);
	FileSize = ftell(pfile);

	//重新设置回开头
	fseek(pfile, 0, SEEK_SET);
	//开辟空间，malloc函数返回开辟空间的起始地址
	pTempBuffer = malloc(FileSize);

	//将文件中的内容读取到临时Buffer中
	fread(pTempBuffer, FileSize, 1, pfile);

	//将分配返回的地址存储到FileBuffer中
	*pFileBuffer = pTempBuffer;
	//temp指针指向空
	pTempBuffer = NULL;
	fclose(pfile);
	return FileSize;
}

int CopyFileBufferToImageBuffer(LPVOID pFileBuffer,LPVOID* pImageBuffer)//pImageBuffer是void类型指针，指向的是读取到内存中的文件内容首地址
{
	//初始化PE结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	//初始化tempBuffer
	LPVOID pTempBuffer = NULL;
	//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息
	pDOSHeader = PIMAGE_DOS_HEADER(pFileBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);
	
	//分配ImageBuffer内存
	pTempBuffer = malloc(pOptionalHeader-&gt;SizeOfImage);
	//初始化ImageBuffer内存
	memset(pTempBuffer, 0, pOptionalHeader-&gt;SizeOfImage);
	//拷贝数据
	memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//参数说明，目标数据、被使用数据，长度
	
	//循环拷贝节表信息
	PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;
	for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++,pTempSectionHeader++)
	{
		//因为memcpy只接受void类型的指针，所以要先强制转换
		memcpy((void*)((DWORD)pTempBuffer + pTempSectionHeader-&gt;VirtualAddress), (void*)((DWORD)pFileBuffer + pTempSectionHeader-&gt;PointerToRawData), pTempSectionHeader-&gt;SizeOfRawData);
	}
	//赋值给pImageBuffer
	*pImageBuffer = pTempBuffer;
	pTempBuffer = NULL;
	return pOptionalHeader-&gt;SizeOfImage;
}

int CopyImageBufferToNewBuffer(LPVOID pImageBuffer,LPVOID* pNewBuffer)
{
	//初始化PE结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	//初始化TempBuffer
	LPVOID pTempBuffer = NULL;

	//结构体强制转换
	pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);

	//计算NewBuffer大小
	DWORD new_buffer_size = pOptionalHeader-&gt;SizeOfHeaders;
	//节表大小计算
	PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;
	//注意这里要使用临时变量，否则循环的时候，结构体指针后移，指向改变
	for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pTempSectionHeader++)
	{
		new_buffer_size += pTempSectionHeader-&gt;SizeOfRawData;
		//printf("%X\n", pSectionHeader-&gt;SizeOfRawData);
	}
	printf("%X\n", new_buffer_size);
	//开辟空间并且设置为0
	pTempBuffer = malloc(new_buffer_size);
	memset(pTempBuffer, 0, new_buffer_size);
	//复制ImageBuffer信息
	memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);
	//复制节表信息
	pTempSectionHeader = pSectionHeader;
	for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, ++pTempSectionHeader)
	{
		//因为memcpy只接受void类型的指针，所以要先强制转换
		memcpy((PWORD)((DWORD)pTempBuffer + pTempSectionHeader-&gt;PointerToRawData), (PWORD)((DWORD)pImageBuffer + pTempSectionHeader-&gt;VirtualAddress), pTempSectionHeader-&gt;SizeOfRawData);
	}
	//赋值给pImageBuffer
	*pNewBuffer = pTempBuffer;
	pTempBuffer = NULL;
	return new_buffer_size;
}
void newbuffer_write2_exe(PVOID NewFileBuffer, DWORD FileSize, char* FilePath)
{
	FILE* fp1 = fopen(FilePath, "wb");
	if (fp1 != NULL)
	{
		fwrite(NewFileBuffer, FileSize, 1, fp1);
		printf("成功存盘");
	}
	fclose(fp1);
	return ;

}
void ADD_Opcode(LPVOID pImageBuffer, LPVOID* pNewBuffer)
{
	//初始化PE结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息
	pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);
	//判断能否插入
	if (shellcode_len &gt; pSectionHeader-&gt;SizeOfRawData - pSectionHeader-&gt;Misc.VirtualSize)
	{
		printf("长度不足，无法插入\n");
		free(pImageBuffer);
	}

	//计算空白位置，转为char*指针
	PBYTE code_begin = (PBYTE)((DWORD)pImageBuffer + pSectionHeader-&gt;VirtualAddress+ pSectionHeader-&gt;Misc.VirtualSize);
	//插入shellcode
	memcpy(code_begin, shellcode, shellcode_len);
	//计算E8地址
	DWORD callADDr = (MessageBoxA_ADDR - (pOptionalHeader-&gt;ImageBase + pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize + 0xD));
	//将callADDR插入到E8之后,填充数据
	*(PDWORD)((DWORD)code_begin + 0x09) = callADDr;

	//计算jmp地址,跳转的值=真实地址-下一条指令地址
	DWORD jmpADDr = pOptionalHeader-&gt;ImageBase + pOptionalHeader-&gt;AddressOfEntryPoint - ((DWORD)code_begin + pOptionalHeader-&gt;ImageBase + shellcode_len-(DWORD)pImageBuffer);
	*(PDWORD)((code_begin + 14)) = jmpADDr;

	//修改OEP
	pOptionalHeader-&gt;AddressOfEntryPoint = ((DWORD)code_begin - (DWORD)pImageBuffer);//也可以使用VirtualAddress+VirtualSize

	//还原为NewBuffer
	DWORD ret2=CopyImageBufferToNewBuffer(pImageBuffer, pNewBuffer);
	
	//存盘
	newbuffer_write2_exe(*pNewBuffer,ret2, final_path);
	return ;
}
void operate_pe()
{
	LPVOID pFileBuffer = NULL;//LPVOID相当于void*
	LPVOID pNewBuffer = NULL;
	LPVOID pImageBuffer = NULL;
	//读取文件内容到FileBuffer中d
	DWORD file_size = LoadPE(&amp;pFileBuffer);//二级指针void**,将存储指针的地址传过去
	printf("文件长度为：  %08X\n", file_size);

	//将FileBuffer拉伸为ImageBuffer
	DWORD Image_Size = CopyFileBufferToImageBuffer(pFileBuffer,&amp;pImageBuffer);
	printf("拉伸后的大小为：  %08X\n",Image_Size);

	//添加opcode
	ADD_Opcode(pImageBuffer, &amp;pNewBuffer);

	//开辟的内存需要free掉
	free(pFileBuffer);
	free(pNewBuffer);
	free(pImageBuffer);
	return;
}
int main()
{
	operate_pe();
	return 0;
}</code></pre>

<h1 id="PE文件新增节"><a href="#PE文件新增节" class="headerlink" title="PE文件新增节"></a>PE文件新增节</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;windows.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;


/*
思路：
1、读取文件信息到buffer中
判断节区信息够不够大小，两个节表的大小
2、找到节区的最后位置，开辟指定大小的空间
3、修改信息-NumberOfSection、SizeOfRawData、VirtualSize（注意要对齐）
*/
#define New_Buffer_Size 0x1000
#define File_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe"
#define Final_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\6++.exe"
int Open_File(LPVOID *pFileBuffer)
{
	FILE* pfile = NULL;
	
	LPVOID TempBuffer = NULL;
	pfile = fopen(File_Path, "rb");
	fseek(pfile, 0, SEEK_END);
	DWORD file_size = ftell(pfile);
	//设置文件指针到文件头
	fseek(pfile, 0, SEEK_SET);
	TempBuffer = malloc(file_size);
	fread(TempBuffer , file_size, 1, pfile);
	
	*pFileBuffer = TempBuffer;
	TempBuffer = NULL;
	fclose(pfile);
	return file_size;
}
int Add_Section(LPVOID FileBuffer, LPVOID* pNewBuffer,DWORD file_size)
{
	//定义结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS32 pNTHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSection = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PVOID pNewTempBuffer = NULL;
	DWORD New_File_Size = 0;
	
	
	//新增节
	New_File_Size = file_size + 0x1000;
	pNewTempBuffer = (PVOID)malloc(New_File_Size);
	// 判断开辟空间是否成功
	if (!pNewTempBuffer)
	{
		printf("pNewTempBuffer开辟空间失败!\n");
		return 0;
	}
	// 初始化内存
	memset(pNewTempBuffer, 0, New_File_Size);
	// 将旧空间的内容copy到新的空间
	memcpy(pNewTempBuffer, FileBuffer, file_size);

	//读取信息
	pDOSHeader = (PIMAGE_DOS_HEADER)(pNewTempBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS32)((DWORD)pNewTempBuffer + pDOSHeader-&gt;e_lfanew);
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));
	pSection = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));

	//找到节表的最后位置
	PIMAGE_SECTION_HEADER pfinal_Section = &amp;(pSection[pFileHeader-&gt;NumberOfSections - 1]);

	//判断能否插入节表,因为在文件和内存中PE头和DOS头大小不变，直接计算即可
	DWORD remain_size = (pOptionalHeader-&gt;SizeOfHeaders - pDOSHeader-&gt;e_lfanew - 4 - sizeof(IMAGE_FILE_HEADER) - sizeof(IMAGE_OPTIONAL_HEADER32) - sizeof(IMAGE_SECTION_HEADER) * pFileHeader-&gt;NumberOfSections);
	if (remain_size &lt; 2 * sizeof(IMAGE_SECTION_HEADER))
	{
		printf("位置不够捏，想想其他办法吧~\n");
	}
	

	//修改信息
	// 初始化新增节信息
	PVOID pSecName = &amp;pSection[pFileHeader-&gt;NumberOfSections].Name;
	PDWORD pSecMisc = &amp;pSection[pFileHeader-&gt;NumberOfSections].Misc.VirtualSize;
	PDWORD pSecVirtualAddress = &amp;pSection[pFileHeader-&gt;NumberOfSections].VirtualAddress;
	PDWORD pSecSizeofRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].SizeOfRawData;
	PDWORD pSecPointerToRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].PointerToRawData;
	PDWORD pSecCharacteristic = &amp;pSection[pFileHeader-&gt;NumberOfSections].Characteristics;
	//名字
	memcpy(pSecName, ".mycode", 8);
	//Misc
	*pSecMisc = 0x1000;
	//计算VirtualAddress=前一个节的VA+sizeofrawdata或者virtualSize内存对齐大小
	DWORD Sec_Size = (pfinal_Section-&gt;SizeOfRawData &gt; pfinal_Section-&gt;Misc.VirtualSize) ? pfinal_Section-&gt;SizeOfRawData : pfinal_Section-&gt;Misc.VirtualSize;
	//内存对齐
	Sec_Size= (Sec_Size % pOptionalHeader-&gt;SectionAlignment) ? ((Sec_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : Sec_Size;
	//修改VirtualAddress
	*pSecVirtualAddress = pfinal_Section-&gt;VirtualAddress + Sec_Size;
	//修改sizeofRawData
	*pSecSizeofRawData = 0x1000;
	//修改Pointer
	DWORD size = pfinal_Section-&gt;SizeOfRawData;
	DWORD File_Size= (size % pOptionalHeader-&gt;FileAlignment) ? ((size / pOptionalHeader-&gt;FileAlignment) + 1) * pOptionalHeader-&gt;FileAlignment : size;
	*pSecPointerToRawData = pfinal_Section-&gt;PointerToRawData + File_Size;

	*pSecCharacteristic = 0xFFFFFFFF;

	//头部信息,先计算增加的长度在内存和文件拉伸的长度
	DWORD Sec_ADD = (New_Buffer_Size % pOptionalHeader-&gt;SectionAlignment) ? ((New_Buffer_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : New_Buffer_Size;
	DWORD File_ADD = 
	pOptionalHeader-&gt;SizeOfImage += Sec_ADD;
	pFileHeader-&gt;NumberOfSections += 1;

	*pNewBuffer = pNewTempBuffer;
	pNewTempBuffer = NULL;
	return New_File_Size;
}
void Write_To_Newfile(DWORD New_File_Size, LPVOID pNewBuffer)
{
	FILE* fp;
	fp = fopen(Final_Path, "wb");
	fwrite(pNewBuffer, New_File_Size, 1, fp);
	fclose(fp);
	return ;
}
void PE_operate()
{
	DWORD new_file_size = 0;
	PVOID pNewBuffer = NULL;
	PVOID FileBuffer = NULL;
	DWORD file_size = 0;
	DWORD New_File_Size = 0;
	//打开文件读取信息
	file_size = Open_File(&amp;FileBuffer);
	//新增节并且修改信息
	New_File_Size=Add_Section(FileBuffer,&amp;pNewBuffer,file_size);

	Write_To_Newfile(New_File_Size, pNewBuffer);
}
int main()
{
	PE_operate();
	return 0;
}</code></pre>

<h1 id="打印导出表信息-按名称导出"><a href="#打印导出表信息-按名称导出" class="headerlink" title="打印导出表信息-按名称导出"></a>打印导出表信息-按名称导出</h1><pre class="language-c" data-language="c"><code class="language-c">#define  _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define FilePath "D:\\OneDrive\\桌面\\reverse\\吾爱破解专用版Ollydbg\\DBGHELP.DLL"

void ReadFileToBuffer(LPVOID *FileBuffer)
{
	LPVOID pTempBuffer;
	//打开文件并读取到Buffer中
	FILE* pfile = NULL;
	pfile = fopen(FilePath, "r");
	fseek(pfile, 0, SEEK_END);
	//读取文件大小
	DWORD file_size = ftell(pfile);
	//设置到开头进行读取
	fseek(pfile, 0, SEEK_SET);
	//先开辟空间
	pTempBuffer = (void*)malloc(file_size);
	//读取信息
	fread(pTempBuffer, file_size, 1, pfile);
	//如果是一级指针，读取完之后就会被释放掉
	*FileBuffer = pTempBuffer;
	pTempBuffer = NULL;
	fclose(pfile);
	return ;
}

/*
* RVA转FOA
* 先看在哪个节区，减去该节区的RVA+该节区的PointerOfRawData
*/
DWORD RVATOFOA(PIMAGE_SECTION_HEADER pSectionHeader, DWORD RVA,DWORD NumberOfSection)
{
	DWORD FOA = 0;
	for (int i = 0; i &lt; NumberOfSection; i++, pSectionHeader++)
	{
		//如果小于RVA+节区的大小，说明在节区内
		if (RVA &lt; pSectionHeader-&gt;VirtualAddress + max(pSectionHeader-&gt;SizeOfRawData, pSectionHeader-&gt;Misc.VirtualSize))
		{
			FOA = RVA - pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;PointerToRawData;
			return FOA;
		}
	}
}

void PrintExportTable(LPVOID FileBuffer)
{
	PIMAGE_DOS_HEADER pDosHeader = NULL;
	PIMAGE_NT_HEADERS32 pNtHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	PIMAGE_EXPORT_DIRECTORY pExportTable = NULL;
	PIMAGE_DATA_DIRECTORY pDataTable= NULL;
	//读取DLL信息
	pDosHeader = (PIMAGE_DOS_HEADER)(FileBuffer);
	pNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)FileBuffer + pDosHeader-&gt;e_lfanew);
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNtHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));
	//获取导出表基本信息
	pDataTable = (PIMAGE_DATA_DIRECTORY)(pOptionalHeader-&gt;DataDirectory);
	printf("导出表的RVA为：%X\n", pDataTable[0].VirtualAddress);
	printf("导出表的大小为：%X\n", pDataTable[0].Size);
	//打印导出表
	DWORD ExportTable_FOA = RVATOFOA(pSectionHeader, pDataTable[0].VirtualAddress,pFileHeader-&gt;NumberOfSections);
	printf("导出表在文件中的位置为：%X\n", ExportTable_FOA);
	//获取导出表信息
	pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + ExportTable_FOA);

	//打印导出表信息，获取DLL名称，导出函数名称表，导出函数地址表，导出函数序号表
	//先打印导出表按名字导出函数的个数
	printf("按名称导出的函数个数为：%X\n", pExportTable-&gt;NumberOfFunctions);
	printf("按名称导出的函数个数为：%X\n", pExportTable-&gt;NumberOfNames);

	//打印DLL名称，导出函数名称表，导出函数地址表，导出函数序号表
	DWORD NameFOA = RVATOFOA(pSectionHeader, pExportTable-&gt;Name, pFileHeader-&gt;NumberOfSections);
	char* nameofdll = (char*)((DWORD)pDosHeader + NameFOA);
	printf("DLL的名称为：%s\n", nameofdll);
	DWORD FOAOfName= RVATOFOA(pSectionHeader,pExportTable-&gt;AddressOfNames, pFileHeader-&gt;NumberOfSections);
	DWORD FOAOfNameOdinals= RVATOFOA(pSectionHeader, pExportTable-&gt;AddressOfNameOrdinals, pFileHeader-&gt;NumberOfSections);
	DWORD FOAOfFunctions= RVATOFOA(pSectionHeader, pExportTable-&gt;AddressOfFunctions, pFileHeader-&gt;NumberOfSections);
	printf("文件中导出函数地址表为：%X\n文件中函数名称地址表为：%X\n文件中函数序号地址表为：%X\n", FOAOfFunctions, FOAOfName, FOAOfNameOdinals);
	int * FuncTable = (int*)((DWORD)pDosHeader + FOAOfFunctions);
	int* NameTable = (int*)((DWORD)pDosHeader + FOAOfName);
	short* Ordinals = (short*)((DWORD)pDosHeader + FOAOfNameOdinals);

	////注意下面是随机打印的
	//for(int i = 0; i &lt; pExportTable-&gt;NumberOfNames; ++i)
	//{
	//	printf("导出函数地址为：%X ", RVATOFOA(pSectionHeader, *FuncTable, pFileHeader-&gt;NumberOfSections));
	//	
	//	char*name=(char*)pDosHeader + (RVATOFOA(pSectionHeader, *NameTable, pFileHeader-&gt;NumberOfSections));
	//	printf("名称为：%s ", name);
	//	//函数序号存储的不是RVA，而是序号,直接解引用即可，但是要注意是short型
	//	printf("函数序号为：%X\n", *Ordinals);
	//	NameTable++;
	//	FuncTable++;
	//	Ordinals++;
	//}
	

	//按函数名称导出
	char funcname[] = "WinDbgExtensionDllInit";
	for (int i = 0; i &lt; pExportTable-&gt;NumberOfNames; ++i)
	{
		char* name = (char*)pDosHeader + (RVATOFOA(pSectionHeader, *NameTable, pFileHeader-&gt;NumberOfSections));
		//printf("函数名称为：%s\n", name);
		//如果找到我们的函数名时，先把下标去序号表找，然后取出里面的值，再拿去函数地址表找
		if (strcmp(funcname, name) == 0)
		{
			Ordinals += i;
			printf("函数名称为：%s\n", name);
			printf("函数序号为：%X\n", *Ordinals);
			printf("导出函数地址为：%X ", RVATOFOA(pSectionHeader, *(FuncTable+*Ordinals), pFileHeader-&gt;NumberOfSections));
			break;
		}
		else//否则就是按照序号导出的，只需要将
		{

		}
		NameTable++;
	}
	return;
}
void oprate_pe()
{
	LPVOID FileBuffer = NULL;
	ReadFileToBuffer(&amp;FileBuffer);
	PrintExportTable(FileBuffer);
	return ;
}
int main()
{
	oprate_pe();
	return 0;
}</code></pre>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">PE文件结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-03 14:13:58" itemprop="dateCreated datePublished" datetime="2022-03-03T14:13:58+08:00">2022-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-09 17:39:51" itemprop="dateModified" datetime="2022-04-09T17:39:51+08:00">2022-04-09</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>主要有exe、dll、sys文件，这些都是可执行文件</p>
<p>exe由多个exe文件组成，dll之类的</p>
<h1 id="PE文件头解析"><a href="#PE文件头解析" class="headerlink" title="PE文件头解析"></a>PE文件头解析</h1><p>在内存中和硬盘中数据几乎是一样的，但是存在差异，且程序开始的位置不同，所以可以知道存储信息的位置是可以改变的</p>
<p>根据不同的功能分了不同的节，也就是程序不同的块，这样做1、可以节省硬盘空间，在内存中占用空间大于硬盘占用空间（节之间的间隔较小）</p>
<p>2、节省内存，当程序需要多开的时候，只需要将可读可写的数据段重新复制一份即可，不需要对只读的数据进行复制</p>
<h2 id="硬盘（文件）对齐和内存对齐"><a href="#硬盘（文件）对齐和内存对齐" class="headerlink" title="硬盘（文件）对齐和内存对齐"></a>硬盘（文件）对齐和内存对齐</h2><p>目的都是为了提升读写的速度</p>
<p>老的编译器，硬盘对齐是200h个字节<strong>（当不够200h字节，会自动填充）</strong>，内存对齐是1000h个字节，所以PE结构执行（<strong>操作系统运行exe文件</strong>）时会发生拉伸的过程，即在内存中占用空间大于硬盘占用空间</p>
<p>新的编译器在硬盘和内存都采用1000h，这是因为编译器发展，这样内存和硬盘对齐一样，运行时可以减少运算，这样虽然牺牲了空间，但是缩短了时间</p>
<h2 id="PE磁盘文件与内存映像结构图"><a href="#PE磁盘文件与内存映像结构图" class="headerlink" title="PE磁盘文件与内存映像结构图"></a>PE磁盘文件与内存映像结构图</h2><p>块表（节表）概括节的基本信息（起始和终止位置，节的大小），DOS头和PE头对当前exe文件做的概要性描述（拉伸完后的大小，堆栈大小），节表存储信息</p>
<p> <img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/19100019-8692ac67434949cb9ec42764cab75468-1646313270630.jpg"> </p>
<h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>DOS长度确定</p>
<p>解析exe文件时，先解析前两个字节，并通过DOS头找到exe文件真正开始的地方</p>
<p>第一个WORD MZSignature（e_magic）-MZ标记</p>
<p>最后一个LONG AddressOfNewExeHeader（e_lfanew）-指向了PE文件的真正开始地址</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646292642401.png"></p>
<p>这里的0108表示从文件开始的地方计算0108个字节就是PE结构开始的地方</p>
<h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>DOS头和NT头中间是一段空间，可以自由发挥，多与少不确定，我们可以在这一段写入shellcode（ <strong>利用软件漏洞而执行的代码</strong> ），在程序中调用。有地址我们就可以访问和执行</p>
<p>PE的标记-DWORD Signature-四个字节</p>
<h3 id="标准PE头-20字节"><a href="#标准PE头-20字节" class="headerlink" title="标准PE头-20字节"></a>标准PE头-20字节</h3><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646295409969.png"></p>
<p>关键信息</p>
<p>enum IMAGE_MACHINE Machine-程序运行的CPU型号：0x0 任何处理器 /0x14C 386及后续处理器</p>
<p>WORD NumberOfSections-文件中存在的节的数量，如果需要新增或者合并节，就要修改这个值</p>
<p>time_t TimeDateStamp-文件创建时间，编译器填写</p>
<p><strong>WORD SizeOfOptionalHeader</strong>-可选PE头的大小，32位PE文件默认E0h、64位PE文件默认为F0h  大小可以自定义.</p>
<p>struct FILE_CHARACTERISTICS Characteristics-每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 </p>
<p>这里的102拆成二进制</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296388161.png"></p>
<p>勾中即为1</p>
<h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>结构</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296662617.png"></p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296680675.png"></p>
<p>关键信息</p>
<p>enum OPTIONAL_MAGIC Magic-说明文件类型：10B 32位下的PE文件、20B 64位下的PE文件</p>
<p>DWORD SectionAlignment-内存对齐</p>
<p>DWORD FileAlignment-文件对齐</p>
<p>DWORD SizeOfCode-所有代码节的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p>
<p>DWORD SizeOfInitializedData-已初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p>
<p>DWORD SizeOfUninitializedData-未初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p>
<p><em><strong>DWORD AddressOfEntryPoint-程序入口</strong></em></p>
<p>DWORD BaseOfCode-代码开始的基址，编译器填的，不会被使用</p>
<p>DWORD BaseOfData-数据开始的基址，编译器填的，不会被使用</p>
<p>！！<em><strong>DWORD ImageBase-内存镜像基址</strong></em>（不从0开始是因为需要内存保护）</p>
<p><em><strong>把文件拖入OD时会断在ImageBase+AddressOfEntryPoint这个地址，也就是OEP</strong></em></p>
<blockquote>
<p>程序入口可以修改-加壳</p>
<p>加壳之后入口点EP（RVA）和OEP（RAW）都会改变，但是内存镜像基址不变</p>
</blockquote>
<blockquote>
<p>内核重载：（有一些软件会通过hook技术，检测是否调用函数）相当于PEloader（加载）-把硬盘文件拷贝到内存中进而执行exe文件，但是在拷贝过程中还会有一个文件的缓冲区，这个缓冲区也是在内存中的。装载到内存时是以ImageBase为起点的</p>
</blockquote>
<p>DWORD SizeOfImage-内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍，也就是PE文件在内存中被拉伸后的大小</p>
<p>DWORD SizeOfHeaders-所有头+节表按照文件对齐后的大小，否则加载会出错</p>
<p>DWORD CheckSum-校验和，一些系统文件有要求，用来判断文件是否被修改</p>
<p>DWORD SizeOfStackReserve-初始化时保留的堆栈大小</p>
<p>DWORD SizeOfStackCommit-初始化时实际提交的大小</p>
<p>DWORD SizeOfHeapReserve-初始化时保留的堆的大小</p>
<p>DWORD SizeOfHeapCommit-初始化时实际提交的大小</p>
<p>DWORD NumberOfRvaAndSizes-目录项数目</p>
<h1 id="节表-每个节有28字节的信息"><a href="#节表-每个节有28字节的信息" class="headerlink" title="节表-每个节有28字节的信息"></a>节表-每个节有28字节的信息</h1><p>节表定位-DOS+PE+OPTIONPE</p>
<p>描述每个节的信息</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306378425.png"></p>
<p>节的结构</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306828500.png"></p>
<p>BYTE Name[8]是八个字节，不够补’\0’，在内存是0，所以不能使用char*，而要用char [9]，且可以随便改</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306924262.png"></p>
<p>第二个成员是union Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确（可能被别的软件加工过），但是不会妨碍运行，<strong>里面的成员DWORD VirtualSize-存放PE文件放入内存时的数据宽度，他的值可能大于文件对齐后的数据宽度（SizeofRawData），这是因为未初始化的变量不会被存入文件中</strong></p>
<p>第三个成员-DWORD VirtualAddress-节区在内存中的相对偏移（拉伸-内存对齐后的），加上ImageBase才是在内存中的真正地址（跟文件中无关）</p>
<p>第四个成员-DWORD SizeOfRawData-节在文件中对齐后的尺寸</p>
<p>第五个成员-DWORD PointerToRawData-节区在文件中的偏移,所以.text是从400h开始的（跟内存中无关）</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646309678678.png"></p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646308057578.png"></p>
<p>第二个和第四个是在调试时使用的，编译完这四个默认为0</p>
<p>struct SECTION_CHARACTERISTICS Characteristics-节的属性</p>
<p>最后一个成员struct SECTION_CHARACTERISTICS Characteristics-里面有32位，但不是每一位都用</p>
<pre class="language-c" data-language="c"><code class="language-c">--&gt; 标志(属性块) 常用特征值对照表：&lt;--
[值:00000020h](*包含可执行代码)
[值:00000040h](*该块包含已初始化的数据)
[值:00000080h](*该块包含未初始化的数据)
[值:00000200h][Section contains comments or some other type of information.]
[值:00000800h][Section contents will not become part of image.]
[值:00001000h][Section contents comdat.]
[值:00004000h][Reset speculative exceptions handling bits in the TLB entries for this section.]
[值:00008000h][Section content can be accessed relative to GP.]
[值:00500000h][Default alignment if no others are specified.]
[值:01000000h][Section contains extended relocations.]
[值:02000000h][Section can be discarded.]
[值:04000000h][Section is not cachable.]
[值:08000000h][Section is not pageable.]
[值:10000000h](*该块为共享块).
[值:20000000h](*该块可执行)
[值:40000000h](*该块可读)
[值:80000000h](*该块可写)</code></pre>

<h1 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h1><p>拉伸完之后还需要进行一些准备步骤</p>
<p>先把文件对齐后的数据拷贝到内存中，根据SizeofHeades，直接copy，因为头和节表是不会变化的，但是节表后面不一定是节区，这是因为文件对齐和内存对齐不同</p>
<p>循环赋值节的内容，复制到内存的地方由节表信息里面的VirtualAddress决定，PointerToRawData决定了文件复制到内存的起始位置</p>
<p>复制数据的大小根据SizeofRawData（Misc也可以，但是如果MIsc存在大量未初始化数据，会变得很大，可能将下一节的信息也copy到内存中）</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646548848907.png"></p>
<h2 id="根据内存数据存储的位置查找在文件中的位置"><a href="#根据内存数据存储的位置查找在文件中的位置" class="headerlink" title="根据内存数据存储的位置查找在文件中的位置"></a>根据内存数据存储的位置查找在文件中的位置</h2><p>假设内存开始位置是500000，数据在内存存储位置是501234</p>
<p>1、确定节</p>
<p>先确定偏移501234-500000</p>
<p>根据节的不同偏移（VirtualAddress）</p>
<p>1234&gt;VirtualAddress</p>
<p>1234&lt;VirtualAddress+Misc.VirtualSize</p>
<p>2、计算距离节初始位置的长度</p>
<p>1234-1000=234h</p>
<p>3、在文件中寻找</p>
<p>因为在文件中和在内存中距离节初始位置的长度相同，所以地址为400+234h</p>
<h1 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h1><p>MessageBoxA-四个参数，执行后会出现弹窗-一般exe都有这个函数-user32.dll里面</p>
<p>让程序执行我们的代码，需要先找到OEP，修改为call我们函数的地址，然后再jmp回到原程序的OEP</p>
<p>call=E8+四个字节，jmp=E9+四个字节</p>
<p>但是这四个字节不是直接的地址，需要进行计算</p>
<blockquote>
<p>真正要跳转的地址=E8这条指令的下一行地址（当前指令地址+5，因为call长度是5）+X（X就是E8后边跟着的四个字节）</p>
</blockquote>
<p>push=0x6A</p>
<p>所以我们要加的程序硬编码 = 6A 00  6A 00  6A 00  6A 00  E8 00 00 00 00 E9 00 00 00 00</p>
<p>我们加入的代码必须加在拉伸后的文件中，也就是内存中的，因为我们计算的地址是拉伸后的地址</p>
<h2 id="添加代码过程-文件注入"><a href="#添加代码过程-文件注入" class="headerlink" title="添加代码过程-文件注入"></a>添加代码过程-文件注入</h2><p>1、先看代码空白区能不能填充那十八个字节——（SizeofRawData-VirtualSize）</p>
<p>2、找到添加的地方，假设我们开始是从1000h开始的，而SizeofRawData是1a0000，所以两者相加就是当前节结束的地址，而在1b0000之前为0的部分是代码块的空白部分</p>
<p>3、开始填充我们的那十八个字节</p>
<p>4、算地址，要计算内存对齐的地址，而不是文件对齐的，因为我们需要的是运行时的地址（内存对齐和文件对齐不同）</p>
<p>先找到MessageBoxA在内存中的地址，在OD里面使用命令bp MessageBoxA，按状态栏的B可以找到内存的地址</p>
<p>5、填充，注意小端序，E8跟着计算后的地址，E9跟着计算后的OEP（ImageBase+EntryPoint）</p>
<p>6、将原本的EntryOfPoint改为我们填充数据在内存中的地址</p>
<h1 id="任意代码节空白区添加代码"><a href="#任意代码节空白区添加代码" class="headerlink" title="任意代码节空白区添加代码"></a>任意代码节空白区添加代码</h1><p>从内存转为硬盘文件计算大小-最后一个节的初始位置+最后一个节的大小</p>
<h1 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h1><p>新增之后，修改NumberOfSections，节表信息，节表后面必须跟着一定长度的00数据（空白区），所以要计算增加之后SizeofHeaders会不会大于PointerOfRawData，并且在新增节最后加上一个节表信息长度的00</p>
<p>计算内存偏移VirtualAddress（RVA）时，根据上一个节区的VirtualAddress+（SizofRawData/VirtualSize[谁大加谁]）按照内存对齐后的数</p>
<p>如果编译器在节表中加入一些数据，而我们不能修改，节表又不能断，只能将NT头前移（加入数据之前的），这样再去添加新的节表信息，就不会占用编译器加入的数据</p>
<p>当DOS到NT头大小不够开辟一个节表的信息，只能扩充最后一个节</p>
<h1 id="扩大节-合并节-数据目录"><a href="#扩大节-合并节-数据目录" class="headerlink" title="扩大节-合并节-数据目录"></a>扩大节-合并节-数据目录</h1><p>扩大节：在内存中进行扩大，然后再还原回文件中，还原的时候要修改参数</p>
<p>1、拉伸到内存</p>
<p>2、分配新空间N=SizeofImage+Ex</p>
<p>3、将最后一个节的SizeOfRawdata和VirtualSize改为N</p>
<p>4、修改SizeofImage</p>
<p>合并节：合并之后节表有空间进行添加节区</p>
<p>VirtualSize=SizeofImage-VIrtualAddress</p>
<blockquote>
<p>数据目录-里面存储各种表的信息</p>
</blockquote>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646564515662.png"></p>
<p>下面介绍几种比较重要的</p>
<h1 id="DLL-动态链接库和静态链接库"><a href="#DLL-动态链接库和静态链接库" class="headerlink" title="DLL-动态链接库和静态链接库"></a>DLL-动态链接库和静态链接库</h1><p>使用的时候都需要include</p>
<p>程序编译的过程为将.h和.cpp等文件进行预编译，然后进行编译，再进行汇编，最后链接上（.a/.lib/.so/.dll）成为可执行文件</p>
<p>静态库、动态库区别来自【链接阶段】如何处理库（处理方式不同来区分），链接成可执行程序。分别称为静态链接方式、动态链接方式</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>使用的时候需要include和#pragma comment(lib,”xxx.lib”)</p>
<p>因为头文件只包含函数声明，函数实现在lib文件中</p>
<p>即在链接阶段，将源文件用到的库函数与汇编生成的文件.o等合并（即函数被包含在exe文件中）生成可执行文件</p>
<p>好处：方便程序移植，因为可执行程序与库函数再无关系，放入任何环境当中都可以执行</p>
<p>缺点：可执行文件太大（因为包含了库函数），每次库文件升级都需要重新编译源文件，每个可执行程序都会合并库函数，存在很大的重复性，占用空间大</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>两个程序应用一个库，目标文件在内存中只有一份，供所有程序使用，但是可移植性太差，如果两台电脑运行环境不同，动态库存放位置不同，可能会导致程序运行失败</p>
<h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>1、将dll，lib文件添加到调用文件中</p>
<p>2、将#pragma comment(lib,”xxx.lib”)添加到调用文件中</p>
<p>3、加入函数的声明</p>
<p>extern “C” _declspec(dllimport) _stdcall int Plus(int x,int y);</p>
<p>导出则为dllexport，dll导出和导入的方式必须一致，即导出的时候使用了_stdcall，导入的时候也应该是__stdcall</p>
<p>这样的话如果需要修改函数，只需要在dll文件修改即可，程序不用编译</p>
<h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>1、定义函数指针</p>
<p>typedef int (__stdcall *lpPlus)(int,int);</p>
<p>2、声明函数指针变量</p>
<p>lpPlus myPlus</p>
<p>3、动态加载dll到内存中</p>
<p>HINSTANCE hModule=LoadLibrary(“DllDemo.dll”);</p>
<p>4、获取函数地址</p>
<p>myPlus=(lpPlus)GetProcAddress(hModule,”_Plus@8”);(__stdcall为了区分会自动加符号)，如果导入的时候没加stdcall就不需要加符号，即myPlus=(lpPlus)GetProcAddress(hModule,”Plus”);</p>
<p>5、调用函数</p>
<p>int a=myPlus(1,2);</p>
<h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>Handle是代表系统内核的对象，如文件句柄、线程句柄、进程句柄</p>
<p>HMODULE代表应用程序载入的模块-在内存中拉伸的起始位置</p>
<p>HINSTANCE在win32是和前一个一样的 win16遗留</p>
<p>HWND是窗口句柄</p>
<blockquote>
<p>上面的都是无符号整数，四个字节</p>
</blockquote>
<p>这样做是为了方便区分，操作系统给的</p>
<h3 id="def文件导出"><a href="#def文件导出" class="headerlink" title="def文件导出"></a>def文件导出</h3><p>为了隐藏函数的名字</p>
<p>和前面的类似，先创建动态链接库，头文件只需要函数声明</p>
<p>创建def文件后，在def文件中写入</p>
<blockquote>
<p>EXPORTS</p>
<p>(函数名)                编号</p>
<p>Plus                    @12——导出序号是12</p>
<p>在编号后面+NONAME 可以隐藏函数名</p>
</blockquote>
<h2 id="dll导出函数的方式"><a href="#dll导出函数的方式" class="headerlink" title="dll导出函数的方式"></a>dll导出函数的方式</h2><p>extern表示是个全局函数，可以供各个其他的函数调用</p>
<p>声明导出：_declspec(dllexport)</p>
<p>def文件导出</p>
<p>dll函数调用</p>
<p>隐式链接</p>
<p>包含头文件，载入lib库</p>
<p>显式链接</p>
<p>LoadLibary，GetProAddress</p>
<h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><p>作用：记载我们写的dll或者exe导出的函数</p>
<h2 id="导出表重要成员"><a href="#导出表重要成员" class="headerlink" title="导出表重要成员"></a>导出表重要成员</h2><p>1、指向导出表文件名的字符串-DWORD Name</p>
<p>2、导出函数的起始序号-DWORD Base</p>
<p>3、导出函数地址表RVA-DWORD AddressOfFunctions</p>
<p>4、函数名称地址表RVA-DWORD AddressOfNames</p>
<p>5、函数序号地址表RVA-DWORD AddressOfNameOrdinals</p>
<h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>1、找出导出表RVA的偏移</p>
<p>首先我们要在数据目录的导出表信息的第一项，也就是导出表地址的RVA偏移是多少</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621065982.png"></p>
<p>可以看出c000h是RVA偏移，大小是164个字节</p>
<h3 id="判断属于哪一个节"><a href="#判断属于哪一个节" class="headerlink" title="判断属于哪一个节"></a>判断属于哪一个节</h3><p>根据节区的VIrtualAddress判断</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621026524.png"></p>
<p>所以可以知道在.edata节</p>
<h3 id="算出FOA位置"><a href="#算出FOA位置" class="headerlink" title="算出FOA位置"></a>算出FOA位置</h3><p>我们知道是在.rdata节的，可以算出FOA</p>
<p>FOA=RVA-节区的RVA（VirtualAddress）+节.PointerOfRawData</p>
<p>计算发现为8200h</p>
<h3 id="通过FOA找到导出表位置"><a href="#通过FOA找到导出表位置" class="headerlink" title="通过FOA找到导出表位置"></a>通过FOA找到导出表位置</h3><p>找到后根据前面的导出表大小可以知道导出表的范围</p>
<p>跳转过去即可</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621157564.png"></p>
<h2 id="导出表的存储方式"><a href="#导出表的存储方式" class="headerlink" title="导出表的存储方式"></a>导出表的存储方式</h2><p>一个导出表大小为0x28个字节，也就是两行半</p>
<p>分段讲解</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621661598.png"></p>
<p>前面十二个字节没用，就不讲了</p>
<h3 id="Dword-Name"><a href="#Dword-Name" class="headerlink" title="Dword Name"></a>Dword Name</h3><p>绿框的4个字节存储的是dll名称的RVA，想查看的话，可以计算FOA，和前面一样的，得到8250地址存储的是我们的dll名称，以00结尾</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621843130.png"></p>
<h3 id="Dword-Base"><a href="#Dword-Base" class="headerlink" title="Dword Base"></a>Dword Base</h3><p>导出函数的起始序号</p>
<p> DLL导出的函数如果给序号了，那么就从这个序号开始</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622459296.png"></p>
<h3 id="Dword-NumberOfFunctions-所有的导出函数的个数"><a href="#Dword-NumberOfFunctions-所有的导出函数的个数" class="headerlink" title="Dword NumberOfFunctions-所有的导出函数的个数"></a>Dword NumberOfFunctions-所有的导出函数的个数</h3><p>前四个</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622410901.png"></p>
<h3 id="DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数"><a href="#DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数" class="headerlink" title="DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数"></a>DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数</h3><p>可以将两个不同的名字指向相同的地址</p>
<p>有一些是无名函数不会在里面</p>
<p>后四个</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622415877.png"></p>
<p>下面就是子表了，三个子表都是RVA，要转为FOA</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622483098.png"></p>
<p>分别是函数地址表0x8228，函数名称表0x8238，函数序号表0x8248</p>
<blockquote>
<p>先去找函数名称表，根据名称的下标再去序号表找对应，然后再去函数地址表找</p>
</blockquote>
<h4 id="函数地址表-AddressOfFunctions"><a href="#函数地址表-AddressOfFunctions" class="headerlink" title="函数地址表-AddressOfFunctions"></a>函数地址表-AddressOfFunctions</h4><p>函数地址表指向一个偏移，这个偏移存放了所有导出函数的地址，每个地址占四个字节，存放的是RVA地址</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622927186.png"></p>
<p>ImageBase+函数偏移就是函数在内存中的实际地址</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646623978690.png"></p>
<p>可以看到这就是函数</p>
<p> 还需要注意的就是，如果你按照序号导出1 3 4 5这4个函数，在导入表中我们的函数地址表中的地址会有5个，原因就是：中断的序号会给我们用0填充，２虽然没有，但是也会给我们导出. </p>
<h4 id="函数名称表-AddressOfNames"><a href="#函数名称表-AddressOfNames" class="headerlink" title="函数名称表-AddressOfNames"></a>函数名称表-AddressOfNames</h4><p>函数名称表也是存储名称的RVA，四个字节存储一个，RVA的个数由以函数名称导出函数个数来决定（DWORD  NumberOfNames）</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625166524.png"></p>
<p>转为FOA就是0x805e，0x8071,0x8082,0x8093</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625255683.png"></p>
<p>排序的时候是按照字母顺序排列的，而不是按照导出时函数的顺序进行排序的</p>
<p>例如:</p>
<p>　　EXPORT</p>
<p>　　　　SUB</p>
<p>　　　　ADD</p>
<p>　　　　MUL</p>
<p>导出三个函数，那么第一项就为 ADD，因为按照字母排序，A在前边，后面依次类推，所以我们上面看到的函数名称 ACquireSRW 这个函数名称，并不是第一个导出的函数.</p>
<h4 id="函数序号表-AddressOfNumberOrdinals－存储的是RVA"><a href="#函数序号表-AddressOfNumberOrdinals－存储的是RVA" class="headerlink" title="函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ"></a>函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ</h4><p>给名称用的中转表</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625803927.png"></p>
<p>和函数名称表大小相同</p>
<h4 id="按名称导出"><a href="#按名称导出" class="headerlink" title="按名称导出"></a>按名称导出</h4><p>得到函数名称后去AddressOfNames中的函数名称对比，得到索引后根据索引取出AddressOfNameOrdinals存储的值，以此为索引去函数地址表找到函数的地址</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647329750554.png" alt="按名称导出过程"></p>
<p>函数数量计算方式=最大序号-最小序号+1，（连续的算得准）不连续的话在函数地址表会留有多余的地址，但是多余的地址没有被使用</p>
<h4 id="按序号导出"><a href="#按序号导出" class="headerlink" title="按序号导出"></a>按序号导出</h4><blockquote>
<p>当使用序号导出的时候不需要使用序号表，直接将序号-Base作为索引去函数地址表找即可</p>
</blockquote>
<h4 id="导出的过程"><a href="#导出的过程" class="headerlink" title="导出的过程"></a>导出的过程</h4><p>系统和我们前面说的不一样</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724098510.png" alt="1"></p>
<p>根据函数地址表找，如果索引在序号表中，说明是按名字导出的，再去名称表找对应，索引和序号表中的相同</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724264502.png"></p>
<p>这里的100a索引是3，在序号表中没有，所以不是按照序号导出的，序号可算，为索引+Base=005</p>
<h1 id="重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable"><a href="#重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable" class="headerlink" title="重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable"></a>重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable</h1><h2 id="程序的加载过程"><a href="#程序的加载过程" class="headerlink" title="程序的加载过程"></a>程序的加载过程</h2><p>系统加载的dll一般在高空间运行，一般是71**************</p>
<p>先像贴图一样把dll贴在内存中，最后指向exe文件的入口点，exe开始运行</p>
<p>我们自己写的dll的imageBase都是1000000，所以当多个dll同时使用，会存在地址已经被占用的问题，所以dl只能往后放，但是：</p>
<p>编译器生成的地址=ImageBase+RVA，这个地址在程序编译完成后，已经写入文件了。但是如果当程序加载时没有按照原来的ImageBase载入，但是此时程序还是会按照前面生成的地址进行使用</p>
<p>所以一般exe不存在重定位表，而dll一般都有，用于记录需要修改的地方</p>
<h2 id="重定位表解析"><a href="#重定位表解析" class="headerlink" title="重定位表解析"></a>重定位表解析</h2><p>重定位表是分块，根据RVA计算得到FOA，跳转过去发现有几个重定位表</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727831045.png"></p>
<p>这两个数据分别存储RVA和大小</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727910599.png"></p>
<p>下面的数据中，每两个字节代表这一段有多少个数据需要修复，一般是绝对地址需要修改</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646728080337.png"></p>
<p>只需要基础地址加上小表的值就可以定位到需要修改的地方，而不用四个字节来存储地址，节省了空间，而这个基础地址就是前面记录的RVA</p>
<p>而基础地址可以不同，所以才需要分块操作</p>
<p>可以发现每一块的间隔是1000h，也就是内存对齐的大小</p>
<p>一个页是1000h，所以只需要1000个十六进制的地址就可以记录完一页的每个位置，对应十进制的4096个</p>
<p>2^12=4096，所以只需要十二个二进制位就可以表示完所有可能，两个字节有十六位，所以最后找地址的时候，只用取低十二位，高四位有别的用处-如果高四位的值是3就说明这个地方需要修改</p>
<h3 id="判断块数"><a href="#判断块数" class="headerlink" title="判断块数"></a>判断块数</h3><p>下一块的开始地址都可以通过RVA+SizeOfBlock来得到</p>
<p>直到遇到全为零的块</p>
<p>计算需要修改的数据个数：(SizeOfBlock-8)/2，因为前面两个数据是8个字节，剩下的两个字节为1组</p>
<h1 id="移动导出表-重定位表"><a href="#移动导出表-重定位表" class="headerlink" title="移动导出表-重定位表"></a>移动导出表-重定位表</h1><p>表的数据也在节区中，加密代码时，表的信息也会被加密，这样程序无法初始化，所以要先增节，再移动表，学会移动各种表是对程序加密和破解的基础</p>
<h2 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h2><p>比较繁琐，因为要移动多张表</p>
<h3 id="在DLL文件中新增节"><a href="#在DLL文件中新增节" class="headerlink" title="在DLL文件中新增节"></a>在DLL文件中新增节</h3><p>先计算大小</p>
<p>并且返回新增节的FOA，因为后面的数据还要从新增节的开头开始</p>
<h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>需要复制的数据类型和长度</p>
<h4 id="复制AddressOfFunctions"><a href="#复制AddressOfFunctions" class="headerlink" title="复制AddressOfFunctions"></a>复制AddressOfFunctions</h4><p>长度：4×NumberOfFunctions</p>
<h4 id="复制AddressOfNameOrdinals"><a href="#复制AddressOfNameOrdinals" class="headerlink" title="复制AddressOfNameOrdinals"></a>复制AddressOfNameOrdinals</h4><p>长度：2×NumberOfNames</p>
<h4 id="复制AddressOfNames"><a href="#复制AddressOfNames" class="headerlink" title="复制AddressOfNames"></a>复制AddressOfNames</h4><p>长度：4×NumberOfNames</p>
<h4 id="复制所有函数名"><a href="#复制所有函数名" class="headerlink" title="复制所有函数名"></a>复制所有函数名</h4><p>长度不确定，复制时直接修复AddressOfName（因为名字的地址也改变了），每复制完一个名字，都需要计算下一个复制的地方</p>
<h4 id="复制导出表的整体结构"><a href="#复制导出表的整体结构" class="headerlink" title="复制导出表的整体结构"></a>复制导出表的整体结构</h4><h3 id="修复地址"><a href="#修复地址" class="headerlink" title="修复地址"></a>修复地址</h3><p>AddressOfName</p>
<p>目录项指向新的导出表的位置</p>
<p>函数地址表、序号表、名称表都需要修复</p>
<h3 id="将目录项中的RVA修正"><a href="#将目录项中的RVA修正" class="headerlink" title="将目录项中的RVA修正"></a>将目录项中的RVA修正</h3><p>指向我们新的导出表的位置</p>
<h2 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h2><p>直接复制过去，修改RVA即可</p>
<p>加载程序：（当前面已经有DLL被加载）</p>
<p>1、将新的DLL复制到新的位置</p>
<p>2、修复重定位表，修改每一个重定位表的偏移</p>
<h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>作用：从其他第三方程序导入API，以供本程序调用</p>
<p>在exe运行的时候加载器会遍历导入表，将导入表中所有dll加载到进程中，被加载的DLL的DLLMain就会被调用</p>
<p>通过导入表可以知道程序使用了哪些函数</p>
<p> 导入表，是为了提供的要导入的dll的函数的地址，只不过由于dll地址不固定，所以每次都会重新修正 </p>
<h2 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h2><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><pre class="language-c" data-language="c"><code class="language-c">DWORD OriginalFirstThunk;</code></pre>

<p>指向导入名称表（INT）的RVA</p>
<pre class="language-c" data-language="c"><code class="language-c">DWORD   FirstThunk;</code></pre>

<p>指向导入地址表（IAT）的RVA</p>
<pre class="language-c" data-language="c"><code class="language-c">DWORD   Name;</code></pre>

<p>指向导入映像文件的名字</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788456499.png"></p>
<p>计算后跳转过去，注意要算的是FOA，但是这里RVA和FOA一样 </p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788490238.png"></p>
<p>其中IAT与INT都指向 IMAGE_THUNK_DATA32（虽然二者的地址不同）</p>
<p>INT-以全0结尾</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788999608.png">          函数名数组(对应IMAGE_THUNK_DATA32结构体数组,每一个结构体就是一个联合体-4字节) </p>
<pre class="language-c" data-language="c"><code class="language-c">typedef struct  _IMAGE_THUNK_DATA32{
union{//联合体，实际是4字节
DWORD ForwarderString;
DWORD Function;//导入函数的地址,在加载到内存之后,这里才起作用
DWORD Ordinal;//假如是序号导入的,会用到这里
DWORD AddressOfData;//假如是函数名导入,会用到这里,它指向另外一个结构体PIMAGE_IMPORT_BY_NAME
}u1;
}IMAGE_THUNK_DATA32;

//如果是函数名导入的,AddressOfData会指向下面这个结构体
typedef struct _IMAGE_IMPORT_BY_NAME{
WORD  Hint;//序号
CHAR Name[1];//不定长,字符串

}</code></pre>

<h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><p>在可选PE头最后的十六个数组的导入表结构，这里存放的是RVA</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646998855451.png"></p>
<p>跳转过去发现存储的是struct IMAGE_IMPORT_DESCRIPTOR ImportDescriptor[0]，这里存放的是真正的导入表结构</p>
<p>有多少个DLL，对应的结构体数组就有几个</p>
<p>关键的数据有下面三个，也要注意这里的TimeDateStamp-时间戳</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999149540.png"></p>
<h3 id="INT表"><a href="#INT表" class="headerlink" title="INT表"></a>INT表</h3><p><em><strong>ULONG OriginalFirstThunk-RVA</strong></em>，存放的是IMAGE_THUNK_DATA这个结构体数组，四字节数，以0结尾</p>
<p>跳转过去</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999423139.png"></p>
<p> 但是之前学导出表有了解到，导出函数可以以名字导出，亦可以序号导出。所以为了方便区分，就将这INT表的每个值做了细微调整。</p>
<blockquote>
<p> 如果这个4字节数的最高位（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。 </p>
</blockquote>
<p>根据INT存储的RVA进行跳转</p>
<h4 id="struct-IMAGE-IMPORT-BY-NAME"><a href="#struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="struct _IMAGE_IMPORT_BY_NAME"></a>struct _IMAGE_IMPORT_BY_NAME</h4><p>1、WORD Hint，可能为0，编译器决定，如果不为0，则是函数在导出表中的索引</p>
<p>2、BYTE Name[1]，函数名称，以0结尾</p>
<h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>DLL的名字，以0结尾</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999638790.png"></p>
<h3 id="ULONG-FirstThunk"><a href="#ULONG-FirstThunk" class="headerlink" title="ULONG FirstThunk"></a>ULONG FirstThunk</h3><p>根据RVA跳转，发现存储的值和INT的一样，这个存储的是IAT，当文件加载后，会发现IAT会改变</p>
<h4 id="IAT表-导入地址表"><a href="#IAT表-导入地址表" class="headerlink" title="IAT表-导入地址表"></a>IAT表-导入地址表</h4><p> 记录程序正在使用哪些库中的哪些函数 </p>
<p>分为两个过程，在文件中存储的是存放函数的地址，在内存中存放函数</p>
<p>在文件运行前类似于call [地址]</p>
<p>在文件运行时类似于call [上面地址存放的值，也就是函数]</p>
<h4 id="IAT表存在的原因"><a href="#IAT表存在的原因" class="headerlink" title="IAT表存在的原因"></a>IAT表存在的原因</h4><p> 一般程序在调用自身函数的时候，自身函数地址RVA是固定的；但是当程序在调用dll里的函数的时候，由于dll的地址会发生重定位，导致dll里的函数地址每次都会发生变化。 </p>
<p>为了准确调用dll函数的地址，构造了IAT表来存储程序运行时，即DLL文件重定位之后的dll函数的位置。</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1649497133114.png"></p>
<h2 id="导入表加载过程"><a href="#导入表加载过程" class="headerlink" title="导入表加载过程"></a>导入表加载过程</h2><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAzMjg0Ni5wbmc-1647000237348.png" alt="PE文件加载前"></p>
<p>加载过程</p>
<p>先找DLL，再确定使用的函数</p>
<h3 id="寻找DLL"><a href="#寻找DLL" class="headerlink" title="寻找DLL"></a>寻找DLL</h3><p>先根据导入表的NAME找到DLL名称和DLL的INT和IAT表，开始的时候INT和IAT数据相同，但是存储位置不同，INT和IAT表都指向IMAGE_THUNK_DATA</p>
<h3 id="查INT表"><a href="#查INT表" class="headerlink" title="查ＩＮＴ表"></a>查ＩＮＴ表</h3><p>因为导出的时候可以按序号导出也可以按函数名称导出，所以为了区分，ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ最高位为１时，表示其存储的是序号，而剩下的３１位表示序号，否则ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ存储的是IMAGE_BY_NAME的ＲＶＡ</p>
<p>因为GetProc可以通过序号找到函数地址，也可以使用名称找到，所以通过这种方式找到函数的地址，然后填充至IAT中</p>
<h3 id="修改IAT"><a href="#修改IAT" class="headerlink" title="修改ＩＡＴ"></a>修改ＩＡＴ</h3><p>使用ＧＥＴＰｒｏＡｄｄｒ（ｍｏｄｕｌｅ）</p>
<p>将前面查找到的函数地址填充进ＩＡＴ表中</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAyNTEwMy5wbmc.png" alt="PE文件加载后"> </p>
<p>可以看到IAT表变成了函数的地址</p>
<p> IAT表会存储dll的函数的地址，方便调用该函数时，直接取IAT表这个地址内的值，作为函数地址，去CALL。</p>
<h1 id="绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR"><a href="#绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR" class="headerlink" title="绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR"></a>绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR</h1><p>可选NT头里的结构</p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647001593786.png"></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 有些windows程序，如notepad，为了提高加载速度，会直接把DLL中的函数地址写入到IAT表，省去了加载时的计算。 </p>
<h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p> 第一，当DLL没有占住ImageBase时，IAT中的地址就是错的；第二，当链接的DLL被修改了，那IAT里写的地址也是错的。遇到这两种情形之一，加载时就必须修复IAT了。 </p>
<p>对于第二种情形，DLL是否被修改，是根据比较DLL的时间戳和绑定导入表中的记录的DLL时间戳来判断的，如果不一致，说明DLL被修改了。</p>
<p>加载程序时，操作系统根据导入表中的时间戳来判断程序是否使用了绑定导入。当时间戳为0，表示不使用绑定导入表；当时间戳为0xFFFFFFFF，说明该程序使用绑定导入。</p>
<h2 id="绑定导入表结构"><a href="#绑定导入表结构" class="headerlink" title="绑定导入表结构"></a>绑定导入表结构</h2><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></pre>

<p> TimeDateStamp 是时间戳，用于和DLL中的时间戳比较，判断DLL是否已经发生变化； </p>
<p> OffsetModuleName 是当前模块名距离第一个 _IMAGE_BOUND_IMPORT_DESCRIPTOR 的偏移。</p>
<p>  NumberOfModuleForwarderRefs 是该模块依赖的模块数量； </p>
<h3 id="依赖模块结构"><a href="#依赖模块结构" class="headerlink" title="依赖模块结构"></a>依赖模块结构</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;</code></pre>

<p> 除了第三个属性保留，其他与 _IMAGE_BOUND_IMPORT_DESCRIPTOR 相同。 </p>
<p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647049008006.png" alt="绑定导入表"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/" class="post-title-link" itemprop="url">hgame2022-WOW-patch数据段</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-22 19:57:59" itemprop="dateCreated datePublished" datetime="2022-02-22T19:57:59+08:00">2022-02-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:29:40" itemprop="dateModified" datetime="2022-04-20T09:29:40+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>250</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>patch-ida数据</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/19/hgame-misc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/19/hgame-misc/" class="post-title-link" itemprop="url">hgame-misc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-19 03:05:16" itemprop="dateCreated datePublished" datetime="2022-02-19T03:05:16+08:00">2022-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:30:12" itemprop="dateModified" datetime="2022-04-20T09:30:12+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Misc复现</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/19/hgame-misc/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/" class="post-title-link" itemprop="url">pyc加花指令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-14 20:10:12" itemprop="dateCreated datePublished" datetime="2022-02-14T20:10:12+08:00">2022-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-11 13:12:19" itemprop="dateModified" datetime="2022-03-11T13:12:19+08:00">2022-03-11</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="VNCTF2022-BabyMaze"><a href="#VNCTF2022-BabyMaze" class="headerlink" title="VNCTF2022-BabyMaze"></a>VNCTF2022-BabyMaze</h1><p>pyc相关知识-<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145811103">https://zhuanlan.zhihu.com/p/145811103</a></p>
<p>使用uncompyle6发现无法反编译，应该是添加了花指令</p>
<p>先查看字节码</p>
<p>脚本</p>
<pre class="language-python" data-language="python"><code class="language-python">import marshal, dis
f = open("D:\\new\\AD\\game\\vnctf2022\\re\\BabyMaze.pyc", "rb").read()
code = marshal.loads(f[16:]) #这边从16位开始取因为是python3 python2从8位开始取
dis.dis(code)</code></pre>

<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848858641.png"></p>
<p>发现这一段就是花指令</p>
<p>去python的包里面搜索opcode.h，找到对应的字节码</p>
<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848986760.png"></p>
<p>转为十六进制后去010editor修改，去掉即可</p>
<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849226023.png"></p>
<p>但是发现还是不行，这是因为</p>
<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849421077.png"></p>
<p>pyc文件有co_code，所以修改长度之后要修改它</p>
<p>先打印出来长度，然后计算后修改</p>
<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849766935.png"></p>
<p>2030-6=7E8</p>
<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849849453.png"></p>
<p>重新uncompyle6</p>
<p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849958666.png"></p>
<p>反编译成功，接下来就是maze图，打印出来之后手打</p>
<h1 id="Pyc字节码阅读-unctf2021-pytrade"><a href="#Pyc字节码阅读-unctf2021-pytrade" class="headerlink" title="Pyc字节码阅读-unctf2021-pytrade"></a>Pyc字节码阅读-unctf2021-pytrade</h1><p>得到两个txt文件，一个是py的字节码，一个是输出</p>
<p>对字节码进行分析</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/557cfe36f0f0">https://www.jianshu.com/p/557cfe36f0f0</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-246683.htm">https://bbs.pediy.com/thread-246683.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/dis.html">https://docs.python.org/zh-cn/3/library/dis.html</a>  这是python3的</p>
<pre class="language-python" data-language="python"><code class="language-python">0 LOAD_CONST               1 ('XXXXXX')       //This is flag,try to figure it out ! Don't forget to fill it in flag{} !
             2 STORE_FAST               0 (flag)</code></pre>

<p>LOAD_CONST加载const变量，比如数值、字符串等，一般用于传给函数参数</p>
<p>STORE_FAST 一般用于保存值到局部变量</p>
<p>这句话意思是</p>
<pre class="language-none"><code class="language-none">flag='XXXXXXXX'</code></pre>

<p>第二段</p>
<pre class="language-python" data-language="python"><code class="language-python">4 LOAD_CONST               2 (0) const变量，一般用于传给函数的参数
             6 BUILD_LIST               1  创建列表
             8 LOAD_CONST               3 (18)   const变量  num=[0]*18
            10 BINARY_MULTIPLY    	
            12 STORE_FAST               1 (num) 保存值到局部变量中</code></pre>

<p>BINARY_MULTIPLY 是二元运算，即将栈顶的前两个元素取出进行计算，结果压回栈中 </p>
<p>BUILD_LIST 创建列表</p>
<pre class="language-none"><code class="language-none">num=[0]*18</code></pre>

<p>第三段</p>
<pre class="language-python" data-language="python"><code class="language-python">14 LOAD_CONST               2 (0)
             16 STORE_FAST               2 (k)</code></pre>

<pre class="language-python" data-language="python"><code class="language-python">k=0</code></pre>

<p>第四段</p>
<pre class="language-python" data-language="python"><code class="language-python">18 LOAD_GLOBAL              0 (range) 加载全局变量
             20 LOAD_GLOBAL              1 (len) 
             22 LOAD_FAST                0 (flag) 
             24 CALL_FUNCTION            1	调用一个函数，在此之前要先赋值 len(flag)
             26 CALL_FUNCTION            1  range(len(flag))
             28 GET_ITER		取迭代器
        &gt;&gt;   30 FOR_ITER               112 (to 144)  一直到144都是for循环
             32 STORE_FAST               3 (i) </code></pre>

<p> LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。当和函数搭配时，要注意有CALL_FUNCTION</p>
<p>LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。这里调用完len之后，要使用其传值，这里传入flag</p>
<p>前半段意思是</p>
<pre class="language-python" data-language="python"><code class="language-python">range(len(flag))</code></pre>

<p>GET_ITER创建迭代器，一般是for循环</p>
<p>FOR_ITER(to 144)表示迭代器一直到144</p>
<p>STORE_FAST 创建局部变量，这里作为for循环的索引</p>
<pre class="language-python" data-language="python"><code class="language-python">for i in range(len(flag)):</code></pre>

<p>第五段</p>
<pre class="language-python" data-language="python"><code class="language-python">7          34 LOAD_GLOBAL              2 (ord) 			
            36 LOAD_FAST                0 (flag)
            38 LOAD_FAST                3 (i)
            40 BINARY_SUBSCR		索引运算
            42 CALL_FUNCTION            1	ord(flag[i])
            44 LOAD_FAST                3 (i)
            46 BINARY_ADD		+i
            48 LOAD_FAST                2 (k)	
            50 LOAD_CONST               4 (3)	
            52 BINARY_MODULO		//取模运算 k%3
            54 LOAD_CONST               5 (1) 
            56 BINARY_ADD		(k%3)+1
            58 BINARY_XOR		(ord(flag[i])+i)^(k%3+1)
            60 LOAD_FAST                1 (num)
            62 LOAD_FAST                3 (i)
            64 STORE_SUBSCR 		num[i]</code></pre>

<p>BINARY_SUBSCR下标 访问操作</p>
<p>BINARY_ADD也是二元运算，相加</p>
<p>BINARY_MODULO，二元运算取模</p>
<p>BINARY_XOR二元运算异或</p>
<p>STORE_SUBSCR下标访问操作</p>
<pre class="language-python" data-language="python"><code class="language-python">num[i]= (ord(flag[i]) + i) ^ (k % 3 + 1)</code></pre>

<p>第六段</p>
<pre class="language-python" data-language="python"><code class="language-python">8          66 LOAD_GLOBAL              2 (ord)
             68 LOAD_FAST                0 (flag)
             70 LOAD_GLOBAL              1 (len)
             72 LOAD_FAST                0 (flag)
             74 CALL_FUNCTION            1	len(flag)
             76 LOAD_FAST                3 (i)	len(flag)-i
             78 BINARY_SUBTRACT	
             80 LOAD_CONST               5 (1)
             82 BINARY_SUBTRACT	减法	len(flag)-i-1
             84 BINARY_SUBSCR		索引运算	flag[len(flag)-i-1]
             86 CALL_FUNCTION            1		ord(flag[len(flag)-i-1])
             88 LOAD_GLOBAL              1 (len)
             90 LOAD_FAST                0 (flag)
             92 CALL_FUNCTION            1	len(flag)
             94 BINARY_ADD		ord(flag[len(flag)-i-1])+len(flag)-i-1
             96 LOAD_FAST                3 (i)	
             98 BINARY_SUBTRACT
            100 LOAD_CONST               5 (1)
            102 BINARY_SUBTRACT
            104 LOAD_FAST                2 (k)
            106 LOAD_CONST               4 (3)
            108 BINARY_MODULO	k%3
            110 LOAD_CONST               5 (1)
            112 BINARY_ADD		k%3+1
            114 BINARY_XOR		ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)
            116 LOAD_FAST                1 (num)
            118 LOAD_GLOBAL              1 (len)
            120 LOAD_FAST                0 (flag)	len(flag)
            122 CALL_FUNCTION            1
            124 LOAD_FAST                3 (i)
            126 BINARY_SUBTRACT	len(flag)-i
            128 LOAD_CONST               5 (1)	
            130 BINARY_SUBTRACT	len(flag)-i-1
            132 STORE_SUBSCR		num[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre>

<p>BINARY_SUBTRACT二元运算减法</p>
<pre class="language-python" data-language="python"><code class="language-python">num[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre>

<p>第七段</p>
<pre class="language-python" data-language="python"><code class="language-python">9         134 LOAD_FAST                2 (k)
            136 LOAD_CONST               5 (1)
            138 INPLACE_ADD	k++
            140 STORE_FAST               2 (k)
            142 JUMP_ABSOLUTE           30//循环结束
</code></pre>

<p>JUMP_ABSOLUTE绝对跳转，结束循环</p>
<p>INPLACE_ADD  计算结果可以被操作数引用的到，每一个 二元运算，都对应一个inplace 运算 </p>
<pre class="language-python" data-language="python"><code class="language-python">k+=1</code></pre>

<p>第八段</p>
<pre class="language-python" data-language="python"><code class="language-python">10     &gt;&gt;  144 LOAD_GLOBAL              3 (print)
            146 LOAD_FAST                1 (num)
            148 CALL_FUNCTION            1 print(num)
            150 POP_TOP
            152 LOAD_CONST               0 (None)
            154 RETURN_VALUE</code></pre>

<pre class="language-none"><code class="language-none">print(num)</code></pre>

<h1 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h1><p>python3.9，无法uncompyle6，使用pycdc翻译成字节码</p>
<pre class="language-python" data-language="python"><code class="language-python">main.pyc (Python 3.9)
[Code]
    File Name: main.py
    Object Name: &lt;module&gt;
    Arg Count: 0
    Pos Only Arg Count: 0
    KW Only Arg Count: 0
    Locals: 0
    Stack Size: 4
    Flags: 0x00000040 (CO_NOFREE)
    [Names]
        'base64'
        'encode'
        'enCodeAgain'
        'correct'
        'flag'
        'print'
        'input'
    [Var Names]
    [Free Vars]
    [Cell Vars]
    [Constants]
        0
        None
        [Code]
            File Name: main.py
            Object Name: encode
            Arg Count: 1
            Pos Only Arg Count: 0
            KW Only Arg Count: 0
            Locals: 4
            Stack Size: 5
            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)
            [Names]
                'chr'
                'base64'
                'b64encode'
                'encode'
            [Var Names]
                'message'
                's'
                'i'
                'x'
            [Free Vars]
            [Cell Vars]
            [Constants]
                None
                ''
                32
                16
                'utf-8'
 [Disassembly]
                0       LOAD_CONST              1: ''
                2       STORE_FAST              1: s       s=''
                4       LOAD_FAST               0: message
                6       GET_ITER                
                8       FOR_ITER                32 (to 42) for i in message:
                10      STORE_FAST              2: i   
                12      LOAD_FAST               2: i  
                14      LOAD_CONST              2: 32
                16      BINARY_XOR              		 i^32
                18      STORE_FAST              3: x	x=i^32
                20      LOAD_FAST               3: x	
                22      LOAD_CONST              3: 16
                24      BINARY_ADD              		x+16
                26      STORE_FAST              3: x	x=x+16
                28      LOAD_FAST               1: s	
                30      LOAD_GLOBAL             0: chr
                32      LOAD_FAST               3: x    
                34      CALL_FUNCTION           1  chr(x)
                36      INPLACE_ADD             s+chr(x)
                38      STORE_FAST              1: s	s=s+chr(x)
                40      JUMP_ABSOLUTE           8    循环结束
                42      LOAD_GLOBAL             1: base64
                44      LOAD_METHOD             2: b64encode	base64.b64
                46      LOAD_FAST               1: s		
                48      LOAD_METHOD             3: encode   LOAD_METHOD是加载类，CALL调用
                50      LOAD_CONST              4: 'utf-8' 
                52      CALL_METHOD             1  
                54      CALL_METHOD             1 base64.b64(s.encode('utf-8'))
                56      RETURN_VALUE            return  base64.b64(s.encode('utf-8'))
        'encode'
        [Code]
            File Name: main.py
            Object Name: enCodeAgain
            Arg Count: 2
            Pos Only Arg Count: 0
            KW Only Arg Count: 0
            Locals: 5
            Stack Size: 5
            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)
            [Names]
                'str'
                'range'
                'len'
            [Var Names]
                'string'
                'space'
                's'
                'i'
                'j'
            [Free Vars]
            [Cell Vars]
            [Constants]
                None
                ''
                'utf-8'
                0
            [Disassembly]
                0       LOAD_CONST              1: ''  
                2       STORE_FAST              2: s	s=''
                4       LOAD_GLOBAL             0: str	
                6       LOAD_FAST               0: string
                8       LOAD_CONST              2: 'utf-8' 
                10      CALL_FUNCTION           2//参数个数 str(string,'utf-8')
                12      STORE_FAST              0: string string=str(string,'utf-8')
                14      LOAD_GLOBAL             1: range 
                16      LOAD_CONST              3: 0
                18      LOAD_FAST               1: space
                20      CALL_FUNCTION           2 range(0,space)
                22      GET_ITER                //创建迭代器
                24      FOR_ITER                50 (to 76) 
                26      STORE_FAST              3: i	for i range(0,space):
                28      LOAD_GLOBAL             1: range 	
                30      LOAD_FAST               3: i
                32      LOAD_GLOBAL             2: len
                34      LOAD_FAST               0: string
                36      CALL_FUNCTION           1	len(string)
                38      LOAD_FAST               1: space
                40      CALL_FUNCTION           3 
                42      GET_ITER                
                44      FOR_ITER                28 (to 74)
                46      STORE_FAST              4: j  for j in range(i,len(string),space)
                48      LOAD_FAST               4: j 
                50      LOAD_GLOBAL             2: len
                52      LOAD_FAST               0: string
                54      CALL_FUNCTION           1  	len(string)
                56      COMPARE_OP              0 (&lt;)	if(j&lt;len(string))
                58      POP_JUMP_IF_FALSE       44	跳转
                60      LOAD_FAST               2: s	
                62      LOAD_FAST               0: string
                64      LOAD_FAST               4: j
                66      BINARY_SUBSCR           	string[j]
                68      INPLACE_ADD             
                70      STORE_FAST              2: s      s+=string[j]
                72      JUMP_ABSOLUTE           44	第二个循环
                74      JUMP_ABSOLUTE           24	第一个循环
                76      LOAD_FAST               2: s
                78      RETURN_VALUE             return s
        'enCodeAgain'
        'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='
        ''
        'Input flag:'
        'utf-8'
        2
        'correct'
        'wrong'
    [Disassembly]
        0       LOAD_CONST              0: 0
        2       LOAD_CONST              1: None
        4       IMPORT_NAME             0: base64	
        6       STORE_NAME              0: base64	import base64
        8       LOAD_CONST              2: &lt;CODE&gt; encode
        10      LOAD_CONST              3: 'encode' //函数
        12      MAKE_FUNCTION           0
        14      STORE_NAME              1: encode
        16      LOAD_CONST              4: &lt;CODE&gt; enCodeAgain
        18      LOAD_CONST              5: 'enCodeAgain'
        20      MAKE_FUNCTION           0	//第二个函数
        22      STORE_NAME              2: enCodeAgain
        24      LOAD_CONST              6: 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='
        26      STORE_NAME              3: correct	correct=VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ=
        28      LOAD_CONST              7: ''
        30      STORE_NAME              4: flag	flag=''
        32      LOAD_NAME               5: print
        34      LOAD_CONST              8: 'Input flag:'	
        36      CALL_FUNCTION           1	print('Int flag:')
        38      POP_TOP                 
        40      LOAD_NAME               6: input
        42      CALL_FUNCTION           0	input()
        44      STORE_NAME              4: flag	flag=input()
        46      LOAD_NAME               4: flag		
        48      LOAD_METHOD             1: encode	
        50      LOAD_CONST              9: 'utf-8'
        52      CALL_METHOD             1
        54      STORE_NAME              4: flag	flag=flag.encode('utf-8')
        56      LOAD_NAME               5: print	
        58      LOAD_NAME               2: enCodeAgain
        60      LOAD_NAME               1: encode
        62      LOAD_NAME               4: flag
        64      CALL_FUNCTION           1	
        66      LOAD_CONST              10: 2 其中一个参数
        68      CALL_FUNCTION           2//两个参数
        70      CALL_FUNCTION           1	print(enCodeAgain(encodee(flag),2))
        72      POP_TOP                 	函数栈顶元素出栈
        74      LOAD_NAME               2: enCodeAgain
        76      LOAD_NAME               1: encode
        78      LOAD_NAME               4: flag
        80      CALL_FUNCTION           1
        82      LOAD_CONST              10: 2
        84      CALL_FUNCTION           2	(enCodeAgain(encodee(flag),2))
        86      LOAD_NAME               3: correct
        88      COMPARE_OP              2 (==)	//比较
        90      POP_JUMP_IF_FALSE       102		跳转
        92      LOAD_NAME               5: print	
        94      LOAD_CONST              11: 'correct'
        96      CALL_FUNCTION           1		print('correct')
        98      POP_TOP                 
        100     JUMP_FORWARD            8 (to 110)	结束
        102     LOAD_NAME               5: print
        104     LOAD_CONST              12: 'wrong'
        106     CALL_FUNCTION           1		print('wrong)
        108     POP_TOP                 
        110     LOAD_CONST              1: None
        112     RETURN_VALUE            
</code></pre>

<pre class="language-python" data-language="python"><code class="language-python">import base64


def encode(message):
    s = ''
    for i in message:
        x = i ^ 32
        x += 16
        s += chr(x)
        return (base64.b64encode(s.encode('utf-8')))


def enCodeAgain(string, space):
    s = ''
    string = str(string, 'utf-8')
    for i in range(0, space):
        for j in range(i, len(string), space):
            if j &lt; len(string):
                s += string[j]
    return s


correct = 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='
flag = ''
print('Input flag:')
flag = input()
flag = flag.encode('utf-8')
print(enCodeAgain(encode(flag), 2))
if enCodeAgain(encode(flag), 2) == correct:
    print(correct)
else:
    print('wrong')
</code></pre>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/13/hgame2022-week3-re/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/13/hgame2022-week3-re/" class="post-title-link" itemprop="url">hgame2022-week3-re</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-13 23:49:18" itemprop="dateCreated datePublished" datetime="2022-02-13T23:49:18+08:00">2022-02-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:28:54" itemprop="dateModified" datetime="2022-04-20T09:28:54+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>42k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>39 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>复现</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/13/hgame2022-week3-re/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/08/AES/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/08/AES/" class="post-title-link" itemprop="url">AES</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-08 12:10:56" itemprop="dateCreated datePublished" datetime="2022-02-08T12:10:56+08:00">2022-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-20 09:20:53" itemprop="dateModified" datetime="2022-04-20T09:20:53+08:00">2022-04-20</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>AES加密算法</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2022/02/08/AES/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Tea、XTea、XXTea原理和实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-07 14:39:10" itemprop="dateCreated datePublished" datetime="2022-02-07T14:39:10+08:00">2022-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-11 13:12:53" itemprop="dateModified" datetime="2022-03-11T13:12:53+08:00">2022-03-11</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h1><p>1、特征量（一般是0x9e3779b9，它是黄金分割数和232的乘积），可以替换成其他的值，但是可能会出现问题</p>
<p>2、主要加密部分进行异或和移位操作（一般都存在&lt;&lt;4、&gt;&gt;5）</p>
<p>3、key为128bit</p>
<h1 id="Tea"><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h1><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p>数组的奇数下标元素从右侧传入后进行了移位异或和相加操作，最后偶数下标加上上面操作完的值，所以可以把等式右边看成一个常数，这样写逆向脚本好理解</p>
<p>结束第一步之后，奇数下标元素的偶数下标元素进行置换，再对奇数下标进行相同的加密</p>
<p>第三步就是sum+=Delta</p>
<p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/OIP-C.jfif"> </p>
<h2 id="加密代码"><a href="#加密代码" class="headerlink" title="加密代码"></a>加密代码</h2><pre class="language-c" data-language="c"><code class="language-c">int main()
{
	unsigned int Data[8] = { 0 };
	unsigned int key[4] = { 0 };
	unsigned int tmp[2] = { 0 };
	unsigned int sum = 0;
	unsigned int delta = 0x9e3779b9;
	for (int i = 0; i &lt; 8; i += 2)
	{
		tmp[0] = Data[i];
		tmp[1] = Data[i + 1];
        sum=0;
		for (int i = 0; i &lt; 32; ++i)
		{
			sum += delta;
			tmp[0] += ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);
			tmp[1] += ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);
		}
		Data[i] = tmp[i];
		Data[i + 1] = tmp[i + 1];
	}
	return 0;
}</code></pre>

<h3 id="解密代码"><a href="#解密代码" class="headerlink" title="解密代码"></a>解密代码</h3><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;
#include &lt;stdio.h&gt;

int main()
{
	unsigned int Data[8] = { 0 };
	unsigned int key[4] = { 0 };
	unsigned int tmp[2] = { 0 };
	unsigned int sum = 0;
	unsigned int delta = 0x9e3779b9;
	for (int i = 0; i &lt; 8; i += 2)
	{
		tmp[0] = Data[i];
		tmp[1] = Data[i + 1];
		sum = delta*32;
		for (int i = 0; i &lt; 32; ++i)
		{
			tmp[1] -= ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);
			tmp[0] -= ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);
			sum -= delta;
		}
		Data[i] = tmp[i];
		Data[i + 1] = tmp[i + 1];
	}
	return 0;
}</code></pre>

<p>解密的时候主要是要找到Key和密文，并且可能会有大小端序的问题</p>
<h1 id="XTea"><a href="#XTea" class="headerlink" title="XTea"></a>XTea</h1><p>Xtea是Tea的升级版，添加了一些移位和异或操作</p>
<h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/20190112131633-3a396138-1629-1.png"> </p>
<p>因为加密过程实际上没发生太多变化，就不贴加密和解密的代码了</p>
<h1 id="XXTea"><a href="#XXTea" class="headerlink" title="XXTea"></a>XXTea</h1><h2 id="加密流程-2"><a href="#加密流程-2" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/921830_48K7JHRW383FZWR.jpg"> </p>
<h2 id="加解密代码"><a href="#加解密代码" class="headerlink" title="加解密代码"></a>加解密代码</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#define DELTA 0x9e3779b9            //固定的一个常量
#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算
void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组
{                                                      //n为数组的长度
    uint32_t y, z, sum;                                //无符号整型     
    unsigned p, rounds, e;                            
    if (n &gt; 1)            /* Coding Part */   
    {
        rounds = 6 + 52/n;               //固定的得出轮数
        sum = 0;                        
        z = v[n-1];                     
        do
        {
            sum += DELTA;                //每次进行叠加
            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算
            for (p=0; p&lt;n-1; p++)       
            {
                y = v[p+1];
                v[p] += MX;
                      z = v[p];     
                        }
            y = v[0];
            z = v[n-1] += MX;
        }
        while (--rounds);
    }
    else if (n &lt; -1)      /* Decoding Part */
    {
        n = -n;
        rounds = 6 + 52/n;
        sum = rounds*DELTA;
        y = v[0];
        do
        {
            e = (sum &gt;&gt; 2) &amp; 3;
            for (p=n-1; p&gt;0; p--)
            {
                z = v[p-1];
                y = v[p] -= MX;
            }
            z = v[n-1];
            y = v[0] -= MX;
            sum -= DELTA;
        }
        while (--rounds);
    }
}
 
int main()
{
    uint32_t v[2]= {1,2};
    uint32_t const k[4]= {2,2,3,4};
    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密
    // v为要加密的数据是两个32位无符号整数
  // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位
    printf("加密前原始数据：%u %u\n",v[0],v[1]);
    btea(v, n, k);
    printf("加密后的数据：%u %u\n",v[0],v[1]);
    btea(v, -n, k);
    printf("解密后的数据：%u %u\n",v[0],v[1]);
    return 0;
}</code></pre>

<p>还没实现过，看着流程图不知道怎么入手</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">RC4原理和实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-06 22:23:15" itemprop="dateCreated datePublished" datetime="2022-02-06T22:23:15+08:00">2022-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-11 13:12:26" itemprop="dateModified" datetime="2022-03-11T13:12:26+08:00">2022-03-11</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>RC4属于对称密码算法中的流密码加密算法</p>
<p>密钥长度可变，面向字节操作</p>
<p>以一个足够大的S表为基础，对表进行非线性变换，产生密钥流</p>
<p>两次交换过程是为了增加随机性</p>
<h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><h2 id="初始化S表"><a href="#初始化S表" class="headerlink" title="初始化S表"></a>初始化S表</h2><p>1、对S表进行先行填充，一般为256字节，且为unsigned类型</p>
<p>2、用种子密钥填充另一个256字节的K表</p>
<p>如果种子密钥长度不为256，将循环使用种子密钥对K表进行填充</p>
<p>3、用 K表对S表进行初始置换</p>
<h3 id="样例展示"><a href="#样例展示" class="headerlink" title="样例展示"></a>样例展示</h3><p>这里我们假设S表和K表都是7个字节的，密钥为345，填充结果如下</p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168199163.png"></p>
<p>使用K表对S表进行置换</p>
<pre class="language-c" data-language="c"><code class="language-c">int j = 0;
	for (int i = 0; i &lt; 7; ++i)
	{
		j = (j + S[i] + K[i]) % 7;
		Swap(S[i], S[j]);
	}</code></pre>

<p>得到被置换后的S表</p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168394862.png"></p>
<h2 id="生成密钥流"><a href="#生成密钥流" class="headerlink" title="生成密钥流"></a>生成密钥流</h2><p>作用：为每个待价密的字节生成一个伪随机数，用来异或</p>
<p>注：S表完成初始化之后，种子密钥将不会再被使用</p>
<p>使用置换后的S表生成密钥流</p>
<pre class="language-c" data-language="c"><code class="language-c">int i, j = 0;
for (int k = 0; k &lt; strlen(raw); ++k)
{
	i = (i + 1) % 7;
	j = (j + S[i]) % 7;
	Swap(S[i], S[j]);
	int t = (S[i] + S[j]) % 7;
	K[k] = S[t];
}</code></pre>

<h1 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h1><p>密钥流和明文进行异或得到密文</p>
<h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>加密部分的j是用来打乱的，实现伪随机</p>
<pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
void Rc4_init(unsigned char* S, unsigned char*K,unsigned char* key, unsigned long len)
{
	unsigned char  tmp = 0;
	for (int i = 0; i &lt; 256; ++i)
	{
		S[i] = i;
		K[i] = key[i % len];
	}
	int j = 0;
	for (int i = 0; i &lt; 256; ++i)
	{
		j = (j + S[i] + K[i]) % 256;
		tmp = S[i];
		S[i] = S[j];
		S[j] = tmp;
	}
	return;
}
void Rc4_encrypt(unsigned char* S, unsigned  char* flag,int len)
{
	int i = 0, j = 0,t = 0 ;
	unsigned char key_liu[len] = { 0 };
	unsigned char tmp = 0;
	for (unsigned long k = 0; k &lt; len; ++k)
	{
		i = (i + 1) % 256;
		j = (j + S[i]) % 256;
		tmp = S[i];
		S[i] = S[j];
		S[j] = tmp;
		t = (S[i] + S[j]) % 256;
		key_liu[k] = S[t];
	}
	for (int i = 0; i &lt; len; ++i)
	{
		flag[i] ^= key_liu[i];
	}
}
int main()
{
	unsigned char S[256] = { 0 };
	unsigned char K[256] = { 0 };
	char flag[512] = { 0xB6, 0x94, 0xFA, 0x8F, 0x3D, 0x5F, 0xB2, 0xE0,
	0xEA, 0x0F, 0xD2, 0x66, 0x98, 0x6C, 0x9D, 0xE7,
	0x1B, 0x08, 0x40, 0x71, 0xC5, 0xBE, 0x6F, 0x6D,
	0x7C, 0x7B, 0x09, 0x8D, 0xA8, 0xBD, 0xF3, 0xF6};
	char key[] = "w0wy0ugot1t";
	unsigned long Len = strlen(flag);
	Rc4_init(S, K,(unsigned char*)key, strlen(key));
	Rc4_encrypt(S, (unsigned char*)flag, Len);
	printf("%s", flag);
	return 0;
}</code></pre>

<p>可以不保存密钥流，直接进行异或，逆向的时候我们可以动调得到密钥流，再与密文进行异或就可以得到明文了</p>
<pre class="language-c" data-language="c"><code class="language-c">void Rc4_encrypt(unsigned char* S, unsigned  char* flag,char*flag1)
{
	int len = strlen(flag1);
	int i = 0, j = 0,t = 0 ;
	unsigned char tmp = 0;
	for (unsigned long k = 0; k &lt; len; ++k)
	{
		i = (i + 1) % 256;
		j = (j + S[i]) % 256;
		tmp = S[i];
		S[i] = S[j];
		S[j] = tmp;
		t = (S[i] + S[j]) % 256;
		flag[k] ^= S[t];
	}
}</code></pre>

<p>分别看一下加密过程的逆向代码</p>
<p>直接异或，动调根据存储的寄存器进行提取</p>
<pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, char *a3)
{
  unsigned int v3; // eax
  unsigned __int8 v4; // ST2B_1
  __int64 result; // rax
  unsigned int v6; // [rsp+30h] [rbp-10h]
  unsigned int i; // [rsp+34h] [rbp-Ch]
  int v8; // [rsp+38h] [rbp-8h]
  signed int v9; // [rsp+3Ch] [rbp-4h]
  unsigned __int8 *v10; // [rsp+50h] [rbp+10h]
  unsigned __int8 *v11; // [rsp+58h] [rbp+18h]

  v10 = a1;
  v11 = a2;
  v6 = strlen(a3);
  v9 = 0;
  v8 = 0;
  for ( i = 0; ; ++i )
  {
    result = v6;
    if ( v6 &lt;= i )
      break;
    v9 = (unsigned __int8)(((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24) + v9 + 1) - ((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24);
    v3 = (unsigned int)((v8 + v10[v9]) &gt;&gt; 31) &gt;&gt; 24;
    v8 = (unsigned __int8)(v3 + v8 + v10[v9]) - v3;
    v4 = v10[v9];
    v10[v9] = v10[v8];
    v10[v8] = v4;
    v11[i] ^= v10[(unsigned __int8)(v10[v9] + v10[v8])];
  }
  return result;
}</code></pre>

<p>先保存再异或</p>
<pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3)
{
  void *v3; // rsp
  char *v4; // rax
  signed __int64 i; // rdx
  unsigned int v6; // eax
  __int64 result; // rax
  __int64 v8; // [rsp+0h] [rbp-30h]
  __int64 *v9; // [rsp+8h] [rbp-28h]
  __int64 v10; // [rsp+10h] [rbp-20h]
  int v11; // [rsp+1Ch] [rbp-14h]
  unsigned int k; // [rsp+20h] [rbp-10h]
  unsigned int j; // [rsp+24h] [rbp-Ch]
  unsigned int v14; // [rsp+28h] [rbp-8h]
  unsigned int v15; // [rsp+2Ch] [rbp-4h]
  unsigned __int8 *v16; // [rsp+58h] [rbp+28h]

  v16 = a2;
  v15 = 0;
  v14 = 0;
  v11 = 0;
  v10 = a3 - 1i64;
  v3 = alloca(16 * ((unsigned __int64)(a3 + 15i64) &gt;&gt; 4));
  v9 = &amp;v8;
  LOBYTE(v8) = 0;
  v4 = (char *)&amp;v8 + 1;
  for ( i = a3 - 2i64; i != -1; --i )
    *v4++ = 0;
  HIBYTE(v8) = 0;
  for ( j = 0; a3 &gt; j; ++j )
  {
    v15 = (unsigned __int8)(((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24) + v15 + 1)
        - ((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24);
    v6 = (unsigned int)((signed int)(v14 + a1[v15]) &gt;&gt; 31) &gt;&gt; 24;
    v14 = (unsigned __int8)(v6 + v14 + a1[v15]) - v6;
    HIBYTE(v8) = a1[v15];
    a1[v15] = a1[v14];
    a1[v14] = HIBYTE(v8);
    v11 = (unsigned __int8)(a1[v15] + a1[v14]);
    *((_BYTE *)v9 + j) = a1[v11];
  }
  for ( k = 0; ; ++k )
  {
    result = k;
    if ( (signed int)k &gt;= a3 )
      break;
    v16[k] ^= *((_BYTE *)v9 + (signed int)k);
  }
  return result;
}</code></pre>

<p>可以看到密钥流存储在v9，动调之后可以直接提取</p>
<p>Vs2022生成的exe文件反编译</p>
<pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall sub_140015E30(__int64 a1, __int64 a2, char *a3)
{
  __int64 result; // rax
  __int64 v4; // kr00_8
  unsigned __int8 v5; // dl
  char v6; // STA4_1
  int v7; // edx
  unsigned int v8; // [rsp+24h] [rbp+4h]
  int v9; // [rsp+44h] [rbp+24h]
  int v10; // [rsp+64h] [rbp+44h]
  unsigned int i; // [rsp+C4h] [rbp+A4h]
  __int64 v12; // [rsp+1C0h] [rbp+1A0h]
  __int64 v13; // [rsp+1C8h] [rbp+1A8h]
  const char *Str; // [rsp+1D0h] [rbp+1B0h]

  Str = a3;
  v13 = a2;
  v12 = a1;
  sub_140011361(&amp;unk_14002200E);
  v8 = j_strlen(Str);
  v9 = 0;
  v10 = 0;
  for ( i = 0; ; ++i )
  {
    result = v8;
    if ( i &gt;= v8 )
      break;
    v4 = v9 + 1;
    v9 = (BYTE4(v4) + v9 + 1) - BYTE4(v4);
    v5 = (*(v12 + v9) + v10) &gt;&gt; 31;
    v10 = (v5 + *(v12 + v9) + v10) - v5;
    v6 = *(v12 + v9);
    *(v12 + v9) = *(v12 + v10);
    *(v12 + v10) = v6;
    v7 = (*(v12 + v10) + *(v12 + v9)) &gt;&gt; 31;
    *(v13 + i) ^= *(v12 + (v7 + *(v12 + v10) + *(v12 + v9)) - v7);
  }
  return result;
}</code></pre>

<p>看着跟别的不一样</p>
<h1 id="题目——BUU-GUET-CTF2019-encrypt"><a href="#题目——BUU-GUET-CTF2019-encrypt" class="headerlink" title="题目——BUU-[GUET-CTF2019]encrypt"></a>题目——BUU-[GUET-CTF2019]encrypt</h1><p>拖进ida，对一些变量和函数名进行识别和改名</p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644325364867.png"></p>
<p>点进加密函数进行查看</p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339350075.png"></p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339358773.png"></p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339366532.png"></p>
<p>整体就是先RC4，然后将加密后的三个字符变为四个字符</p>
<p>逆向过来先将四个字符转为三个字符，然后直接将转换后的结果和密钥流进行异或得到明文</p>
<p>密钥流可以通过动调得到</p>
<p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339479964.png"></p>
<p>脚本</p>
<pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
	char raw[52]={0x5a,
    0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C,
    0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C,
    0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76,
    0x5A, 0x45, 0x3D};
	char decode[39]={0};
	for(int i=0;i&lt;52;++i)
	{
		raw[i]-=61;
	}
	for(int i=0,i_=0;i&lt;52;i+=4,i_+=3)
	{
		decode[i_]=((raw[i])&lt;&lt;2)|((raw[i+1])&gt;&gt;4);
		decode[i_+1]=((raw[i+1]&amp;0xf)&lt;&lt;4)|((raw[i+2]&amp;0x3c)&gt;&gt;2);
		decode[i_+2]=((raw[i+2]&amp;0xF)&lt;&lt;6)|(raw[i+3]);
	}
	char v[90]={0x10,0x59,0x9C,0x92,0x06,0x22,0xCF,0xA5,
	0x72,0x1E,0x45,0x6A,0x06,0xCB,0x08,0xC3,
	0xE4,0x49,0x5A,0x63,0x0C,0xDF,0xF6,0x5F,
	0x08,0x28,0xBD,0xE2,0x10,0x15,0x1F,0x6E,
	0xAA,0x5A,0xCA,0xEC,0x80,0xAF,0x9B,0x16,
	0xBB,0x3D,0x13,0x2F,0x6A,0xA4,0xC7,0x2E,
	0xBC,0x4B,0x60,0x9A,0xAF,0xE9,0xCE,0xDA,
	0x67,0x39,0xBA,0x3B,0x85,0xEB,0xD2,0x6B,
	0xAB,0x06,0x6B,0x10,0x57,0x2C,0x88,0x70,
	0xF7,0x4F,0xAA,0x7F,0x12,0x47,0xD6,0xDE,
	0x74,0xB2,0x1D,0xA4,0xD7,0x76,0x9A,0xE0
	};
	for(int i=0;i&lt;39;++i)
	{
		decode[i]^=v[i];
	}
	printf("%s",decode);
	return 0;
}</code></pre>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">278k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:13</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
