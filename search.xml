<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PE-滴水逆向-手动实现</title>
      <link href="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="代码节空白节区添加代码"><a href="#代码节空白节区添加代码" class="headerlink" title="代码节空白节区添加代码"></a>代码节空白节区添加代码</h1><p>这里我们在notepad++增加MessageBoxA函数，保证先调用我们的函数再运行notepad++</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在代码区先加入对函数的调用，再将原来的OEP修改为我们插入代码在内存中的位置</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p> ASLR技术会使PE文件每次加载到内存的起始地址随机变化，并且进程的栈和堆的起始地址也会随机改变。 所以我们要先关闭</p><p><a href="https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr">https://baijiahao.baidu.com/s?id=1681048472768096428&amp;wfr=spider&amp;for=pc&amp;searchword=aslr</a></p><p>在标准PE头属性中的第一个值改为1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647081337731.png"></p><p>这样PE文件加载到内存中就不会随机化了</p><h2 id="提取关键数据"><a href="#提取关键数据" class="headerlink" title="提取关键数据"></a>提取关键数据</h2><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>DWORD AddressOfEntryPoint-10E5DBh</p><p>DWORD ImageBase-400000h</p><h3 id="节表信息"><a href="#节表信息" class="headerlink" title="节表信息"></a>节表信息</h3><p>MIsc.DWORD VirtualSize-17C51Eh</p><p>DWORD VirtualAddress-1000h</p><p>DWORD PointerToRawData-400h</p><p>DWORD SizeOfRawData-17C600h</p><h2 id="判断能否添加"><a href="#判断能否添加" class="headerlink" title="判断能否添加"></a>判断能否添加</h2><p>如果SizeOfRawData-MIsc.DWORD VirtualSize&gt;=0x12，即可添加，这里是可以的</p><h2 id="找到在文件中代码结束的位置"><a href="#找到在文件中代码结束的位置" class="headerlink" title="找到在文件中代码结束的位置"></a>找到在文件中代码结束的位置</h2><p>先找到在文件中的偏移PointerToRawData，再找到数据段大小MIsc.DWORD VirtualSize，两者相加就是真实数据段的结束位置</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082425978.png"></p><h2 id="添加硬编码"><a href="#添加硬编码" class="headerlink" title="添加硬编码"></a>添加硬编码</h2><p>MessageBoxA需要四个参数</p><p>call指令长度为5</p><p>jmp指令长度为5</p><blockquote><p>真正要跳转的地址=E8/E9指令的下一条指令在内存中的地址+X（X就是E8后边跟着的四个字节）</p></blockquote><p>所以我们需要添加的硬编码为6A 00 6A 00 6A 00 6A 00 E8 00 00 00 00 E9 00 00 00 00</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647082868490.png"></p><h2 id="计算E8和E9的后四个字节"><a href="#计算E8和E9的后四个字节" class="headerlink" title="计算E8和E9的后四个字节"></a>计算E8和E9的后四个字节</h2><p>先找到E8对应的真实地址，也就是MessageBoxA的地址，在od里面command-&gt;输入bp MessageBoxA-&gt;状态栏b-&gt;找到MessageBoxA的地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083046046.png"></p><h3 id="E8后四字节计算"><a href="#E8后四字节计算" class="headerlink" title="E8后四字节计算"></a>E8后四字节计算</h3><p>真实地址为MessageBoxA的地址</p><p>X为MessageBoxA地址-VirtualAddress+ImageBase+8+5+Misc.VirtualSize</p><p>76BA5865</p><h3 id="E9后四字节计算"><a href="#E9后四字节计算" class="headerlink" title="E9后四字节计算"></a>E9后四字节计算</h3><p>真实地址为原来的OEP</p><p>X为ImageBase+AddressOfEntryPoint-VirtualAddress+ImageBase+8+5+5+Misc.VirtualSize</p><p>为FFF910AB</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083638028.png"></p><h2 id="修改AddressOfPoint"><a href="#修改AddressOfPoint" class="headerlink" title="修改AddressOfPoint"></a>修改AddressOfPoint</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647083743309.png"></p><p>让他先执行我们的代码，也就是修改其为插入硬编码的地址</p><p>VirtualAddress+Misc.VirtualSize=17D51Eh</p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>先执行MessageBoxA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084038464.png"></p><p>再运行程序</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647084072618.png"></p><h1 id="新增节"><a href="#新增节" class="headerlink" title="新增节"></a>新增节</h1><h2 id="大小判断"><a href="#大小判断" class="headerlink" title="大小判断"></a>大小判断</h2><p>首先我们需要知道能否新增节SizeofHeaders-最后一个节表 的位置，如果大于或等于两个节表的大小（因为节表最后必须有长度为一个节表的00填充），则可以插入</p><h2 id="修改节表数量"><a href="#修改节表数量" class="headerlink" title="修改节表数量"></a>修改节表数量</h2><p>标准PE头-&gt;WORD NumberOfSections，+1即可</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647140787003.png"></p><h2 id="添加节表信息"><a href="#添加节表信息" class="headerlink" title="添加节表信息"></a>添加节表信息</h2><p>这里直接复制.text段的信息，因为其可读可写可执行，后续可以不用再去修改节表属性</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141001170.png"></p><h2 id="确定插入的大小"><a href="#确定插入的大小" class="headerlink" title="确定插入的大小"></a>确定插入的大小</h2><p>根据情况自行选择，这里假设我们插入0x1000字节</p><h2 id="修改内存对齐后的大小"><a href="#修改内存对齐后的大小" class="headerlink" title="修改内存对齐后的大小"></a>修改内存对齐后的大小</h2><p>SizeOfImage+插入的大小（按照内存对齐）</p><h2 id="修正节表信息"><a href="#修正节表信息" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>先看关键数据</p><p>DWORD VirtualAddress</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD PointerToRawData</p><p>这里为了方便将Misc.DWORD VirtualSize和DWORD SizeOfRawData都改为0x1000，注意如果插入的是其他字节数，需要计算按照文件和内存对齐来调整</p><h3 id="计算VirtualAddress"><a href="#计算VirtualAddress" class="headerlink" title="计算VirtualAddress"></a>计算VirtualAddress</h3><p>前面一个节表的VirtualAddress+Max(Misc.DWORD VirtualSize,SizeOfRawData)-按内存对齐后的</p><p>这里SizeOfRawData大于前者，按内存对齐后是15000h，加上该节表的VirtualAddress就是我们插入节表在内存中的偏移地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141493979.png"></p><h3 id="计算PointerToRawData"><a href="#计算PointerToRawData" class="headerlink" title="计算PointerToRawData"></a>计算PointerToRawData</h3><p>和前面类似SizeOfRawData（文件对齐）+PointerToRawData</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141658195.png"></p><h3 id="最终修改"><a href="#最终修改" class="headerlink" title="最终修改"></a>最终修改</h3><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141708469.png"></p><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><p>在PointerToRawData插入0x1000字节</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141776493.png"></p><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>在PE解析工具可以看到插入的节表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647141801656.png"></p><h1 id="新增节-节表信息后不够位置"><a href="#新增节-节表信息后不够位置" class="headerlink" title="新增节-节表信息后不够位置"></a>新增节-节表信息后不够位置</h1><p>我们直到DOS和NT头之前有一段垃圾数据，当节表末尾没位置插入80个字节，我们需要将NT头和节表信息前移，这样就可以空出一段无用字节，长度为垃圾数据长度</p><blockquote><p>注意要修改LONG AddressOfNewExeHeader-NT头的位置</p></blockquote><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142922682.png"></p><p>直接复制到垃圾数据的起始地址</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647142986819.png"></p><p>这就是空出来的节表，后续操作和前面新增节一样，就不赘述了</p><h1 id="扩大节"><a href="#扩大节" class="headerlink" title="扩大节"></a>扩大节</h1><p>当前面两种做法都不能满足，我们采取扩大节的办法，可以在任意节区末尾添加，但是如果不是在最后一个节添加，后面的节表偏移都要修改，所以我们扩大最后一个节</p><p>需要修改的数据</p><p>DWORD SizeOfRawData</p><p>Misc.DWORD VirtualSize</p><p>DWORD SizeOfImage</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>将最后一个节的SizeOfRawData和VirtualSize改成N，N = 节内存对齐后的大小 + 要扩大的大小</li><li>修改 SizeOfImage大小=SizeOfImage大小+要扩大的大小</li><li>分配一块新的空间，大小为：节内存对齐增加的大小+要扩大的大小</li></ol><h2 id="修正节表信息-1"><a href="#修正节表信息-1" class="headerlink" title="修正节表信息"></a>修正节表信息</h2><p>这里我们假设扩大0x1000个字节</p><p>要改为Max(DWORD VirtualSize,DWORD SizeOfRawData)内存对齐的大小+我们扩大的大小=16000h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147742819.png"></p><h2 id="修正SizeOfImage"><a href="#修正SizeOfImage" class="headerlink" title="修正SizeOfImage"></a>修正SizeOfImage</h2><p>直接加上0x1000即可</p><h2 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h2><p>节内存对齐增加的大小=N-DWORD SizeOfRawData，即C00</p><p>在节区尾部增加即可，有时候最后一个节区尾部之后还有别的程序，那么就需要计算最后一个节区的结束地址</p><p>求和得到2B6C00h</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647147968238.png"></p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647148042480.png"></p><h1 id="合并节"><a href="#合并节" class="headerlink" title="合并节"></a>合并节</h1><h2 id="修改节表个数"><a href="#修改节表个数" class="headerlink" title="修改节表个数"></a>修改节表个数</h2><p>合并之后节数量-1，这里改为7</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149630089.png"></p><h2 id="修改节表信息"><a href="#修改节表信息" class="headerlink" title="修改节表信息"></a>修改节表信息</h2><p>要将节进行合并，就需要修改节表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647149670756.png"></p><h3 id="DWORD-SizeOfRawData和DWORD-VirtualSize"><a href="#DWORD-SizeOfRawData和DWORD-VirtualSize" class="headerlink" title="DWORD SizeOfRawData和DWORD VirtualSize"></a>DWORD SizeOfRawData和DWORD VirtualSize</h3><p>将这两个值改为该节的Max(SizeOfRawData,VirtualSize)+下一个节的Max(SizeOfRawData,VirtualSize)</p><p>最后保存即可</p><p>那么剩下的节表信息没用了，我们可以再次新增节</p><h2 id="最终效果-1"><a href="#最终效果-1" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150089815.png"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647150123108.png"></p><h1 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h1><p>移动前，我们需要先开辟节区，先将后面三个表指向的数据复制到新的节区中，再复制那三个表的信息过去，最后将数据目录指向导出表开始的地方</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647219750918.png" alt="移动前"></p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647220007029.png" alt="移动后"></p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>在数据目录找到导入表的RVA</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228628138.png"></p><p>根据节的RVA和大小确定在哪个表</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228686574.png"></p><p>计算FOA=Export .RVA-rdata.RVA+rdata. PointerToRawData</p><p>计算得到F2270，跳转，根据Export.Size确定大小</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647228914109.png"></p><h2 id="新增节-1"><a href="#新增节-1" class="headerlink" title="新增节"></a>新增节</h2><p>前面说过，就不细🔒了</p><h2 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h2><p>前面四个是DWORD函数地址，DWORD函数名称表，WORD函数序号-这里比较少，就一个函数</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229009740.png"></p><p>这两个分别是dll名字和函数名称</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229076116.png"></p><p>直接复制剩下的导出表信息</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229244730.png"></p><h2 id="修改RVA"><a href="#修改RVA" class="headerlink" title="修改RVA"></a>修改RVA</h2><p>这里我已经改好了，因为该节的RVA-PointOfRawData=1600，所以修改的时候将FOA+1600h=RVA</p><p>要修改的有</p><p><img src="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/1647229408065.png"></p><h2 id="数据目录修改"><a href="#数据目录修改" class="headerlink" title="数据目录修改"></a>数据目录修改</h2><p>将Export.RVA指向我们复制导出表的初始位置</p><h1 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h1><p>新增节-&gt;复制数据-&gt;数据目录修改重定位表位置</p><h2 id="修改ImageBase"><a href="#修改ImageBase" class="headerlink" title="修改ImageBase"></a>修改ImageBase</h2><p>我们修改ImageBase时，重定位表也需要修改，其他不用改，因为其他节表信息映射到内存中时，都是按照ImageBase进行的</p><p>而重定位表是按照VirtualAddress+小表进行修复的，所以ImageBase修改了，重定位表的VirtualAddress也需要修改</p><p>假如ImageBase+1000，重定位表的VirtualAddress也需要+1000</p><h1 id="导入表注入"><a href="#导入表注入" class="headerlink" title="导入表注入"></a>导入表注入</h1><p>每个DLL对应一个导入表，DLL存放着我们的函数</p><p>导入表后面还有一堆数据，我们不能直接添加，所以要新开辟节区，然后复制原来的导入表之后再在末尾添加导入表</p><h2 id="新增节区"><a href="#新增节区" class="headerlink" title="新增节区"></a>新增节区</h2><h2 id="复制导入表信息"><a href="#复制导入表信息" class="headerlink" title="复制导入表信息"></a>复制导入表信息</h2><p> 拷贝原来的导入表到新节中 </p><h2 id="新增导入表"><a href="#新增导入表" class="headerlink" title="新增导入表"></a>新增导入表</h2><h2 id="新增INT表和IAT表"><a href="#新增INT表和IAT表" class="headerlink" title="新增INT表和IAT表"></a>新增INT表和IAT表</h2><p>至少八字节</p><h2 id="修改Name"><a href="#修改Name" class="headerlink" title="修改Name"></a>修改Name</h2><p> 存储要注入的dll的名称 ，并且将DLL名称的RVA赋值给新增导入表的Name</p><h2 id="创建struct-IMAGE-IMPORT-BY-NAME"><a href="#创建struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="创建struct _IMAGE_IMPORT_BY_NAME"></a>创建struct _IMAGE_IMPORT_BY_NAME</h2><p>将函数名称赋值给结构体的第二个变量</p><h2 id="修改INT和IAT指向的地址"><a href="#修改INT和IAT指向的地址" class="headerlink" title="修改INT和IAT指向的地址"></a>修改INT和IAT指向的地址</h2><p>将IMAGE_IMPORT_BY_NAME的RVA赋值给INT和IAT的第一项，因为INT和IAT都指向_IMAGE_IMPORT_BY_NAME</p><h2 id="修改数据目录"><a href="#修改数据目录" class="headerlink" title="修改数据目录"></a>修改数据目录</h2><p>指向我们的新增位置， 修改IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size </p>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE解析代码实现</title>
      <link href="/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="打印PE文件头部和节区信息"><a href="#打印PE文件头部和节区信息" class="headerlink" title="打印PE文件头部和节区信息"></a>打印PE文件头部和节区信息</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;malloc.h&gt;#include&lt;Windows.h&gt;//宏定义，方便后续使用//定义变量IMAGE_DOS_HEADER myDOS;LONG elf_new;IMAGE_NT_HEADERS32 myNTheader;IMAGE_OPTIONAL_HEADER32 myOPTIONheader;IMAGE_SECTION_HEADER mysection[100];int NUM_SECTION;int main(){FILE* pfile;pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");//打开文件fseek(pfile, 0, SEEK_SET);//参数说明，将fp指针从文件开头移动到0的位置fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);//表示从fp开始的地方读取一次长度为sizeof(IMAGE_DOS_HEADER)的字节，存储到myDOS中//DOSprintf("==============IMAGE_DOS_HEADER==============\n");printf("DOS头：          %08X\n", myDOS.e_magic);printf("NT头所在位置：   %08X\n", myDOS.e_lfanew);elf_new = myDOS.e_lfanew;//将NT头的偏移存储起来//NT头fseek(pfile, elf_new, SEEK_SET);//注意不是sizeof(elf_new)fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS), 1, pfile);printf("==============IMAGE_NT_HEADERS==============\n");//打印PE标志printf("PE标志：         %08X\n", myNTheader.Signature);//打印标准PE头信息printf("==============IMAGE_FILE_HEADERS==============\n");printf("节区数量：       %08X\n", myNTheader.FileHeader.NumberOfSections);NUM_SECTION = myNTheader.FileHeader.NumberOfSections;printf("可选PE头大小：   %08X\n", myNTheader.FileHeader.SizeOfOptionalHeader);//打印ASLR的信息，方便查看和修改printf("ASLR属性：       %08X\n", (myNTheader.FileHeader.Characteristics ) &amp; 1);//打印可选PE头信息printf("==============IMAGE_OPTIONAL_HEADERS==============\n");fseek(pfile, elf_new+sizeof(IMAGE_FILE_HEADER)+sizeof(myNTheader.Signature), SEEK_SET);//因为标准PE头长度为20fread(&amp;myOPTIONheader, sizeof(IMAGE_OPTIONAL_HEADER), 1, pfile);printf("DWORD AddressOfEntryPoint：   %08llX\n", myOPTIONheader.AddressOfEntryPoint);printf("基址：%08X\n", myOPTIONheader.ImageBase);//注意这里的可选PE头类型必须是IMAGE_OPTIONAL_HEADER32printf("文件对齐大小：%08X\n", myOPTIONheader.FileAlignment);printf("内存对齐大小：%08X\n", myOPTIONheader.SectionAlignment);printf("文件头和节表大小：  %08X\n", myOPTIONheader.SizeOfHeaders);printf("内存拉伸大小：%08X\n", myOPTIONheader.SizeOfImage);//打印节表信息，前面我们已经存储了节表数量了printf("==============IMAGE_SECTION_HEADER SectionHeaders==============\n");fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);for (int i = 0; i &lt; NUM_SECTION; ++i){printf("NAME：        %s\n", mysection[i].Name);printf("DWORD VirtualAddress：        %08X\n", mysection[i].VirtualAddress);printf("DWORD SizeOfRawData：        %08X\n", mysection[i].SizeOfRawData);printf("DWORD PointerToRawData：        %08X\n", mysection[i].PointerToRawData);printf("DWORD VirtualSize：        %08X\n", mysection[i].Misc.VirtualSize);}fclose(pfile);//关闭文件return 0;}</code></pre><h1 id="RVA转FOA"><a href="#RVA转FOA" class="headerlink" title="RVA转FOA"></a>RVA转FOA</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;windows.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;/** RVA转FOA的思路* 1、先判断所在节区，设计思路：首先我们必须拿的是内存对齐后的来比较大小，先把RVA-virtualaddress，再和max(MISC,SizeofRawData)按照内存对齐的值作比较* 2、循环判断节区* 3、计算FOA，偏移是一样的，那就是RVA-virtualaddress+节区的PointerOfdata*/IMAGE_NT_HEADERS32 myNTheader;IMAGE_DOS_HEADER myDOS;//因为PE头长度不变，所以我们只需要找到elf_new的内容就可以知道节区的起始地址IMAGE_SECTION_HEADER mysection[10];int NUM_SECTION;//我们还需要知道节区的数量int elf_new;int RVA = 0x20d000;long long MAX(DWORD a, DWORD b){//计算MISC和SizeOFRAWDATA，并返回按照内存对齐后的值if (a &gt; b){return (a%myNTheader.OptionalHeader.SectionAlignment)?((a / myNTheader.OptionalHeader.SectionAlignment)+1) * myNTheader.OptionalHeader.SectionAlignment : ((a / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;}elsereturn (b % myNTheader.OptionalHeader.SectionAlignment) ? ((b / myNTheader.OptionalHeader.SectionAlignment) + 1) * myNTheader.OptionalHeader.SectionAlignment : ((b / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;;}int main(){FILE* pfile;pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");fseek(pfile,0, SEEK_SET);fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);elf_new = myDOS.e_lfanew;fseek(pfile, elf_new, SEEK_SET);fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS32), 1, pfile);NUM_SECTION = myNTheader.FileHeader.NumberOfSections;//得到节区fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);for (int i = 0; i &lt; NUM_SECTION; ++i){if (RVA - mysection[i].VirtualAddress &lt; MAX(mysection[i].Misc.VirtualSize, mysection[i].SizeOfRawData)){printf("所在节区为：%s\n", mysection[i].Name);printf("FOA为：%08X", RVA - mysection[i].VirtualAddress + mysection[i].PointerToRawData);}}fclose(pfile);return 0;}</code></pre><h1 id="PE插入shellcode"><a href="#PE插入shellcode" class="headerlink" title="PE插入shellcode"></a>PE插入shellcode</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;Windows.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;#define MessageBoxA_ADDR 0x76C20F40//MessageBoxA的地址#define shellcode_len 0x12//定义shellcode的长度//输入路径和输出路径char file_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe";char final_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\5.exe";//插入的shellcodeBYTE shellcode[] = {0x6A,0x00,0x6A,0x00,0x6A,0x00,0x6A,0x00,0xE8,0x00,0x00,0x00,0x00,0xE9,0x00,0x00,0x00,0x00};int LoadPE(LPVOID*pFileBuffer)//二级指针存储的是一级指针的地址{FILE* pfile;DWORD FileSize = 0;LPVOID pTempBuffer;pfile = fopen(file_path, "rb");//通过fseek和ftell返回文件长度，fseek将fp指针设置在文件尾，ftell获取当前fp指针的位置与文件首的偏移fseek(pfile, 0, SEEK_END);FileSize = ftell(pfile);//重新设置回开头fseek(pfile, 0, SEEK_SET);//开辟空间，malloc函数返回开辟空间的起始地址pTempBuffer = malloc(FileSize);//将文件中的内容读取到临时Buffer中fread(pTempBuffer, FileSize, 1, pfile);//将分配返回的地址存储到FileBuffer中*pFileBuffer = pTempBuffer;//temp指针指向空pTempBuffer = NULL;fclose(pfile);return FileSize;}int CopyFileBufferToImageBuffer(LPVOID pFileBuffer,LPVOID* pImageBuffer)//pImageBuffer是void类型指针，指向的是读取到内存中的文件内容首地址{//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//初始化tempBufferLPVOID pTempBuffer = NULL;//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息pDOSHeader = PIMAGE_DOS_HEADER(pFileBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//分配ImageBuffer内存pTempBuffer = malloc(pOptionalHeader-&gt;SizeOfImage);//初始化ImageBuffer内存memset(pTempBuffer, 0, pOptionalHeader-&gt;SizeOfImage);//拷贝数据memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//参数说明，目标数据、被使用数据，长度//循环拷贝节表信息PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++,pTempSectionHeader++){//因为memcpy只接受void类型的指针，所以要先强制转换memcpy((void*)((DWORD)pTempBuffer + pTempSectionHeader-&gt;VirtualAddress), (void*)((DWORD)pFileBuffer + pTempSectionHeader-&gt;PointerToRawData), pTempSectionHeader-&gt;SizeOfRawData);}//赋值给pImageBuffer*pImageBuffer = pTempBuffer;pTempBuffer = NULL;return pOptionalHeader-&gt;SizeOfImage;}int CopyImageBufferToNewBuffer(LPVOID pImageBuffer,LPVOID* pNewBuffer){//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//初始化TempBufferLPVOID pTempBuffer = NULL;//结构体强制转换pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//计算NewBuffer大小DWORD new_buffer_size = pOptionalHeader-&gt;SizeOfHeaders;//节表大小计算PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;//注意这里要使用临时变量，否则循环的时候，结构体指针后移，指向改变for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pTempSectionHeader++){new_buffer_size += pTempSectionHeader-&gt;SizeOfRawData;//printf("%X\n", pSectionHeader-&gt;SizeOfRawData);}printf("%X\n", new_buffer_size);//开辟空间并且设置为0pTempBuffer = malloc(new_buffer_size);memset(pTempBuffer, 0, new_buffer_size);//复制ImageBuffer信息memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//复制节表信息pTempSectionHeader = pSectionHeader;for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, ++pTempSectionHeader){//因为memcpy只接受void类型的指针，所以要先强制转换memcpy((PWORD)((DWORD)pTempBuffer + pTempSectionHeader-&gt;PointerToRawData), (PWORD)((DWORD)pImageBuffer + pTempSectionHeader-&gt;VirtualAddress), pTempSectionHeader-&gt;SizeOfRawData);}//赋值给pImageBuffer*pNewBuffer = pTempBuffer;pTempBuffer = NULL;return new_buffer_size;}void newbuffer_write2_exe(PVOID NewFileBuffer, DWORD FileSize, char* FilePath){FILE* fp1 = fopen(FilePath, "wb");if (fp1 != NULL){fwrite(NewFileBuffer, FileSize, 1, fp1);printf("成功存盘");}fclose(fp1);return ;}void ADD_Opcode(LPVOID pImageBuffer, LPVOID* pNewBuffer){//初始化PE结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS pNTHeader = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSectionHeader = NULL;//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);//判断能否插入if (shellcode_len &gt; pSectionHeader-&gt;SizeOfRawData - pSectionHeader-&gt;Misc.VirtualSize){printf("长度不足，无法插入\n");free(pImageBuffer);}//计算空白位置，转为char*指针PBYTE code_begin = (PBYTE)((DWORD)pImageBuffer + pSectionHeader-&gt;VirtualAddress+ pSectionHeader-&gt;Misc.VirtualSize);//插入shellcodememcpy(code_begin, shellcode, shellcode_len);//计算E8地址DWORD callADDr = (MessageBoxA_ADDR - (pOptionalHeader-&gt;ImageBase + pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize + 0xD));//将callADDR插入到E8之后,填充数据*(PDWORD)((DWORD)code_begin + 0x09) = callADDr;//计算jmp地址,跳转的值=真实地址-下一条指令地址DWORD jmpADDr = pOptionalHeader-&gt;ImageBase + pOptionalHeader-&gt;AddressOfEntryPoint - ((DWORD)code_begin + pOptionalHeader-&gt;ImageBase + shellcode_len-(DWORD)pImageBuffer);*(PDWORD)((code_begin + 14)) = jmpADDr;//修改OEPpOptionalHeader-&gt;AddressOfEntryPoint = ((DWORD)code_begin - (DWORD)pImageBuffer);//也可以使用VirtualAddress+VirtualSize//还原为NewBufferDWORD ret2=CopyImageBufferToNewBuffer(pImageBuffer, pNewBuffer);//存盘newbuffer_write2_exe(*pNewBuffer,ret2, final_path);return ;}void operate_pe(){LPVOID pFileBuffer = NULL;//LPVOID相当于void*LPVOID pNewBuffer = NULL;LPVOID pImageBuffer = NULL;//读取文件内容到FileBuffer中dDWORD file_size = LoadPE(&amp;pFileBuffer);//二级指针void**,将存储指针的地址传过去printf("文件长度为：  %08X\n", file_size);//将FileBuffer拉伸为ImageBufferDWORD Image_Size = CopyFileBufferToImageBuffer(pFileBuffer,&amp;pImageBuffer);printf("拉伸后的大小为：  %08X\n",Image_Size);//添加opcodeADD_Opcode(pImageBuffer, &amp;pNewBuffer);//开辟的内存需要free掉free(pFileBuffer);free(pNewBuffer);free(pImageBuffer);return;}int main(){operate_pe();return 0;}</code></pre><h1 id="PE文件新增节"><a href="#PE文件新增节" class="headerlink" title="PE文件新增节"></a>PE文件新增节</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;windows.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;/*思路：1、读取文件信息到buffer中判断节区信息够不够大小，两个节表的大小2、找到节区的最后位置，开辟指定大小的空间3、修改信息-NumberOfSection、SizeOfRawData、VirtualSize（注意要对齐）*/#define New_Buffer_Size 0x1000#define File_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe"#define Final_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\6++.exe"int Open_File(LPVOID *pFileBuffer){FILE* pfile = NULL;LPVOID TempBuffer = NULL;pfile = fopen(File_Path, "rb");fseek(pfile, 0, SEEK_END);DWORD file_size = ftell(pfile);//设置文件指针到文件头fseek(pfile, 0, SEEK_SET);TempBuffer = malloc(file_size);fread(TempBuffer , file_size, 1, pfile);*pFileBuffer = TempBuffer;TempBuffer = NULL;fclose(pfile);return file_size;}int Add_Section(LPVOID FileBuffer, LPVOID* pNewBuffer,DWORD file_size){//定义结构体指针PIMAGE_DOS_HEADER pDOSHeader = NULL;PIMAGE_NT_HEADERS32 pNTHeader = NULL;PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;PIMAGE_SECTION_HEADER pSection = NULL;PIMAGE_FILE_HEADER pFileHeader = NULL;PVOID pNewTempBuffer = NULL;DWORD New_File_Size = 0;//新增节New_File_Size = file_size + 0x1000;pNewTempBuffer = (PVOID)malloc(New_File_Size);// 判断开辟空间是否成功if (!pNewTempBuffer){printf("pNewTempBuffer开辟空间失败!\n");return 0;}// 初始化内存memset(pNewTempBuffer, 0, New_File_Size);// 将旧空间的内容copy到新的空间memcpy(pNewTempBuffer, FileBuffer, file_size);//读取信息pDOSHeader = (PIMAGE_DOS_HEADER)(pNewTempBuffer);pNTHeader = (PIMAGE_NT_HEADERS32)((DWORD)pNewTempBuffer + pDOSHeader-&gt;e_lfanew);pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));pSection = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));//找到节表的最后位置PIMAGE_SECTION_HEADER pfinal_Section = &amp;(pSection[pFileHeader-&gt;NumberOfSections - 1]);//判断能否插入节表,因为在文件和内存中PE头和DOS头大小不变，直接计算即可DWORD remain_size = (pOptionalHeader-&gt;SizeOfHeaders - pDOSHeader-&gt;e_lfanew - 4 - sizeof(IMAGE_FILE_HEADER) - sizeof(IMAGE_OPTIONAL_HEADER32) - sizeof(IMAGE_SECTION_HEADER) * pFileHeader-&gt;NumberOfSections);if (remain_size &lt; 2 * sizeof(IMAGE_SECTION_HEADER)){printf("位置不够捏，想想其他办法吧~\n");}//修改信息// 初始化新增节信息PVOID pSecName = &amp;pSection[pFileHeader-&gt;NumberOfSections].Name;PDWORD pSecMisc = &amp;pSection[pFileHeader-&gt;NumberOfSections].Misc.VirtualSize;PDWORD pSecVirtualAddress = &amp;pSection[pFileHeader-&gt;NumberOfSections].VirtualAddress;PDWORD pSecSizeofRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].SizeOfRawData;PDWORD pSecPointerToRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].PointerToRawData;PDWORD pSecCharacteristic = &amp;pSection[pFileHeader-&gt;NumberOfSections].Characteristics;//名字memcpy(pSecName, ".mycode", 8);//Misc*pSecMisc = 0x1000;//计算VirtualAddress=前一个节的VA+sizeofrawdata或者virtualSize内存对齐大小DWORD Sec_Size = (pfinal_Section-&gt;SizeOfRawData &gt; pfinal_Section-&gt;Misc.VirtualSize) ? pfinal_Section-&gt;SizeOfRawData : pfinal_Section-&gt;Misc.VirtualSize;//内存对齐Sec_Size= (Sec_Size % pOptionalHeader-&gt;SectionAlignment) ? ((Sec_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : Sec_Size;//修改VirtualAddress*pSecVirtualAddress = pfinal_Section-&gt;VirtualAddress + Sec_Size;//修改sizeofRawData*pSecSizeofRawData = 0x1000;//修改PointerDWORD size = pfinal_Section-&gt;SizeOfRawData;DWORD File_Size= (size % pOptionalHeader-&gt;FileAlignment) ? ((size / pOptionalHeader-&gt;FileAlignment) + 1) * pOptionalHeader-&gt;FileAlignment : size;*pSecPointerToRawData = pfinal_Section-&gt;PointerToRawData + File_Size;*pSecCharacteristic = 0xFFFFFFFF;//头部信息,先计算增加的长度在内存和文件拉伸的长度DWORD Sec_ADD = (New_Buffer_Size % pOptionalHeader-&gt;SectionAlignment) ? ((New_Buffer_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : New_Buffer_Size;DWORD File_ADD = pOptionalHeader-&gt;SizeOfImage += Sec_ADD;pFileHeader-&gt;NumberOfSections += 1;*pNewBuffer = pNewTempBuffer;pNewTempBuffer = NULL;return New_File_Size;}void Write_To_Newfile(DWORD New_File_Size, LPVOID pNewBuffer){FILE* fp;fp = fopen(Final_Path, "wb");fwrite(pNewBuffer, New_File_Size, 1, fp);fclose(fp);return ;}void PE_operate(){DWORD new_file_size = 0;PVOID pNewBuffer = NULL;PVOID FileBuffer = NULL;DWORD file_size = 0;DWORD New_File_Size = 0;//打开文件读取信息file_size = Open_File(&amp;FileBuffer);//新增节并且修改信息New_File_Size=Add_Section(FileBuffer,&amp;pNewBuffer,file_size);Write_To_Newfile(New_File_Size, pNewBuffer);}int main(){PE_operate();return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE文件结构</title>
      <link href="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="PE文件"><a href="#PE文件" class="headerlink" title="PE文件"></a>PE文件</h1><p>主要有exe、dll、sys文件，这些都是可执行文件</p><p>exe由多个exe文件组成，dll之类的</p><h1 id="PE文件头解析"><a href="#PE文件头解析" class="headerlink" title="PE文件头解析"></a>PE文件头解析</h1><p>在内存中和硬盘中数据几乎是一样的，但是存在差异，且程序开始的位置不同，所以可以知道存储信息的位置是可以改变的</p><p>根据不同的功能分了不同的节，也就是程序不同的块，这样做1、可以节省硬盘空间，在内存中占用空间大于硬盘占用空间（节之间的间隔较小）</p><p>2、节省内存，当程序需要多开的时候，只需要将可读可写的数据段重新复制一份即可，不需要对只读的数据进行复制</p><h2 id="硬盘（文件）对齐和内存对齐"><a href="#硬盘（文件）对齐和内存对齐" class="headerlink" title="硬盘（文件）对齐和内存对齐"></a>硬盘（文件）对齐和内存对齐</h2><p>目的都是为了提升读写的速度</p><p>老的编译器，硬盘对齐是200h个字节<strong>（当不够200h字节，会自动填充）</strong>，内存对齐是1000h个字节，所以PE结构执行（<strong>操作系统运行exe文件</strong>）时会发生拉伸的过程，即在内存中占用空间大于硬盘占用空间</p><p>新的编译器在硬盘和内存都采用1000h，这是因为编译器发展，这样内存和硬盘对齐一样，运行时可以减少运算，这样虽然牺牲了空间，但是缩短了时间</p><h2 id="PE磁盘文件与内存映像结构图"><a href="#PE磁盘文件与内存映像结构图" class="headerlink" title="PE磁盘文件与内存映像结构图"></a>PE磁盘文件与内存映像结构图</h2><p>块表（节表）概括节的基本信息（起始和终止位置，节的大小），DOS头和PE头对当前exe文件做的概要性描述（拉伸完后的大小，堆栈大小），节表存储信息</p><p> <img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/19100019-8692ac67434949cb9ec42764cab75468-1646313270630.jpg"> </p><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><p>DOS长度确定</p><p>解析exe文件时，先解析前两个字节，并通过DOS头找到exe文件真正开始的地方</p><p>第一个WORD MZSignature（e_magic）-MZ标记</p><p>最后一个LONG AddressOfNewExeHeader（e_lfanew）-指向了PE文件的真正开始地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646292642401.png"></p><p>这里的0108表示从文件开始的地方计算0108个字节就是PE结构开始的地方</p><h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><p>DOS头和NT头中间是一段空间，可以自由发挥，多与少不确定，我们可以在这一段写入shellcode（ <strong>利用软件漏洞而执行的代码</strong> ），在程序中调用。有地址我们就可以访问和执行</p><p>PE的标记-DWORD Signature-四个字节</p><h3 id="标准PE头-20字节"><a href="#标准PE头-20字节" class="headerlink" title="标准PE头-20字节"></a>标准PE头-20字节</h3><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646295409969.png"></p><p>关键信息</p><p>enum IMAGE_MACHINE Machine-程序运行的CPU型号：0x0 任何处理器 /0x14C 386及后续处理器</p><p>WORD NumberOfSections-文件中存在的节的数量，如果需要新增或者合并节，就要修改这个值</p><p>time_t TimeDateStamp-文件创建时间，编译器填写</p><p><strong>WORD SizeOfOptionalHeader</strong>-可选PE头的大小，32位PE文件默认E0h、64位PE文件默认为F0h  大小可以自定义.</p><p>struct FILE_CHARACTERISTICS Characteristics-每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 </p><p>这里的102拆成二进制</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296388161.png"></p><p>勾中即为1</p><h3 id="可选PE头"><a href="#可选PE头" class="headerlink" title="可选PE头"></a>可选PE头</h3><p>结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296662617.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646296680675.png"></p><p>关键信息</p><p>enum OPTIONAL_MAGIC Magic-说明文件类型：10B 32位下的PE文件、20B 64位下的PE文件</p><p>DWORD SectionAlignment-内存对齐</p><p>DWORD FileAlignment-文件对齐</p><p>DWORD SizeOfCode-所有代码节的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfInitializedData-已初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p>DWORD SizeOfUninitializedData-未初始化数据大小的和，必须是FileAlignment的整数倍，编译器填的，不会被使用</p><p><em><strong>DWORD AddressOfEntryPoint-程序入口</strong></em></p><p>DWORD BaseOfCode-代码开始的基址，编译器填的，不会被使用</p><p>DWORD BaseOfData-数据开始的基址，编译器填的，不会被使用</p><p>！！<em><strong>DWORD ImageBase-内存镜像基址</strong></em>（不从0开始是因为需要内存保护）</p><p><em><strong>把文件拖入OD时会断在ImageBase+AddressOfEntryPoint这个地址，也就是OEP</strong></em></p><blockquote><p>程序入口可以修改-加壳</p><p>加壳之后入口点EP（RVA）和OEP（RAW）都会改变，但是内存镜像基址不变</p></blockquote><blockquote><p>内核重载：（有一些软件会通过hook技术，检测是否调用函数）相当于PEloader（加载）-把硬盘文件拷贝到内存中进而执行exe文件，但是在拷贝过程中还会有一个文件的缓冲区，这个缓冲区也是在内存中的。装载到内存时是以ImageBase为起点的</p></blockquote><p>DWORD SizeOfImage-内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍，也就是PE文件在内存中被拉伸后的大小</p><p>DWORD SizeOfHeaders-所有头+节表按照文件对齐后的大小，否则加载会出错</p><p>DWORD CheckSum-校验和，一些系统文件有要求，用来判断文件是否被修改</p><p>DWORD SizeOfStackReserve-初始化时保留的堆栈大小</p><p>DWORD SizeOfStackCommit-初始化时实际提交的大小</p><p>DWORD SizeOfHeapReserve-初始化时保留的堆的大小</p><p>DWORD SizeOfHeapCommit-初始化时实际提交的大小</p><p>DWORD NumberOfRvaAndSizes-目录项数目</p><h1 id="节表-每个节有28字节的信息"><a href="#节表-每个节有28字节的信息" class="headerlink" title="节表-每个节有28字节的信息"></a>节表-每个节有28字节的信息</h1><p>节表定位-DOS+PE+OPTIONPE</p><p>描述每个节的信息</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306378425.png"></p><p>节的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306828500.png"></p><p>BYTE Name[8]是八个字节，不够补’\0’，在内存是0，所以不能使用char*，而要用char [9]，且可以随便改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646306924262.png"></p><p>第二个成员是union Misc，双字，是该节在没有对齐前的真实尺寸，该值可以不准确（可能被别的软件加工过），但是不会妨碍运行，<strong>里面的成员DWORD VirtualSize-存放PE文件放入内存时的数据宽度，他的值可能大于文件对齐后的数据宽度（SizeofRawData），这是因为未初始化的变量不会被存入文件中</strong></p><p>第三个成员-DWORD VirtualAddress-节区在内存中的相对偏移（拉伸-内存对齐后的），加上ImageBase才是在内存中的真正地址（跟文件中无关）</p><p>第四个成员-DWORD SizeOfRawData-节在文件中对齐后的尺寸</p><p>第五个成员-DWORD PointerToRawData-节区在文件中的偏移,所以.text是从400h开始的（跟内存中无关）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646309678678.png"></p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646308057578.png"></p><p>第二个和第四个是在调试时使用的，编译完这四个默认为0</p><p>struct SECTION_CHARACTERISTICS Characteristics-节的属性</p><p>最后一个成员struct SECTION_CHARACTERISTICS Characteristics-里面有32位，但不是每一位都用</p><pre class="language-c" data-language="c"><code class="language-c">--&gt; 标志(属性块) 常用特征值对照表：&lt;--[值:00000020h](*包含可执行代码)[值:00000040h](*该块包含已初始化的数据)[值:00000080h](*该块包含未初始化的数据)[值:00000200h][Section contains comments or some other type of information.][值:00000800h][Section contents will not become part of image.][值:00001000h][Section contents comdat.][值:00004000h][Reset speculative exceptions handling bits in the TLB entries for this section.][值:00008000h][Section content can be accessed relative to GP.][值:00500000h][Default alignment if no others are specified.][值:01000000h][Section contains extended relocations.][值:02000000h][Section can be discarded.][值:04000000h][Section is not cachable.][值:08000000h][Section is not pageable.][值:10000000h](*该块为共享块).[值:20000000h](*该块可执行)[值:40000000h](*该块可读)[值:80000000h](*该块可写)</code></pre><h1 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h1><p>拉伸完之后还需要进行一些准备步骤</p><p>先把文件对齐后的数据拷贝到内存中，根据SizeofHeades，直接copy，因为头和节表是不会变化的，但是节表后面不一定是节区，这是因为文件对齐和内存对齐不同</p><p>循环赋值节的内容，复制到内存的地方由节表信息里面的VirtualAddress决定，PointerToRawData决定了文件复制到内存的起始位置</p><p>复制数据的大小根据SizeofRawData（Misc也可以，但是如果MIsc存在大量未初始化数据，会变得很大，可能将下一节的信息也copy到内存中）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646548848907.png"></p><h2 id="根据内存数据存储的位置查找在文件中的位置"><a href="#根据内存数据存储的位置查找在文件中的位置" class="headerlink" title="根据内存数据存储的位置查找在文件中的位置"></a>根据内存数据存储的位置查找在文件中的位置</h2><p>假设内存开始位置是500000，数据在内存存储位置是501234</p><p>1、确定节</p><p>先确定偏移501234-500000</p><p>根据节的不同偏移（VirtualAddress）</p><p>1234&gt;VirtualAddress</p><p>1234&lt;VirtualAddress+Misc.VirtualSize</p><p>2、计算距离节初始位置的长度</p><p>1234-1000=234h</p><p>3、在文件中寻找</p><p>因为在文件中和在内存中距离节初始位置的长度相同，所以地址为400+234h</p><h1 id="代码节空白区添加代码"><a href="#代码节空白区添加代码" class="headerlink" title="代码节空白区添加代码"></a>代码节空白区添加代码</h1><p>MessageBoxA-四个参数，执行后会出现弹窗-一般exe都有这个函数-user32.dll里面</p><p>让程序执行我们的代码，需要先找到OEP，修改为call我们函数的地址，然后再jmp回到原程序的OEP</p><p>call=E8+四个字节，jmp=E9+四个字节</p><p>但是这四个字节不是直接的地址，需要进行计算</p><blockquote><p>真正要跳转的地址=E8这条指令的下一行地址（当前指令地址+5，因为call长度是5）+X（X就是E8后边跟着的四个字节）</p></blockquote><p>push=0x6A</p><p>所以我们要加的程序硬编码 = 6A 00  6A 00  6A 00  6A 00  E8 00 00 00 00 E9 00 00 00 00</p><p>我们加入的代码必须加在拉伸后的文件中，也就是内存中的，因为我们计算的地址是拉伸后的地址</p><h2 id="添加代码过程-文件注入"><a href="#添加代码过程-文件注入" class="headerlink" title="添加代码过程-文件注入"></a>添加代码过程-文件注入</h2><p>1、先看代码空白区能不能填充那十八个字节——（SizeofRawData-VirtualSize）</p><p>2、找到添加的地方，假设我们开始是从1000h开始的，而SizeofRawData是1a0000，所以两者相加就是当前节结束的地址，而在1b0000之前为0的部分是代码块的空白部分</p><p>3、开始填充我们的那十八个字节</p><p>4、算地址，要计算内存对齐的地址，而不是文件对齐的，因为我们需要的是运行时的地址（内存对齐和文件对齐不同）</p><p>先找到MessageBoxA在内存中的地址，在OD里面使用命令bp MessageBoxA，按状态栏的B可以找到内存的地址</p><p>5、填充，注意小端序，E8跟着计算后的地址，E9跟着计算后的OEP（ImageBase+EntryPoint）</p><p>6、将原本的EntryOfPoint改为我们填充数据在内存中的地址</p><h1 id="任意代码节空白区添加代码"><a href="#任意代码节空白区添加代码" class="headerlink" title="任意代码节空白区添加代码"></a>任意代码节空白区添加代码</h1><p>从内存转为硬盘文件计算大小-最后一个节的初始位置+最后一个节的大小</p><h1 id="新增节-添加代码"><a href="#新增节-添加代码" class="headerlink" title="新增节-添加代码"></a>新增节-添加代码</h1><p>新增之后，修改NumberOfSections，节表信息，节表后面必须跟着一定长度的00数据（空白区），所以要计算增加之后SizeofHeaders会不会大于PointerOfRawData，并且在新增节最后加上一个节表信息长度的00</p><p>计算内存偏移VirtualAddress（RVA）时，根据上一个节区的VirtualAddress+（SizofRawData/VirtualSize[谁大加谁]）按照内存对齐后的数</p><p>如果编译器在节表中加入一些数据，而我们不能修改，节表又不能断，只能将NT头前移（加入数据之前的），这样再去添加新的节表信息，就不会占用编译器加入的数据</p><p>当DOS到NT头大小不够开辟一个节表的信息，只能扩充最后一个节</p><h1 id="扩大节-合并节-数据目录"><a href="#扩大节-合并节-数据目录" class="headerlink" title="扩大节-合并节-数据目录"></a>扩大节-合并节-数据目录</h1><p>扩大节：在内存中进行扩大，然后再还原回文件中，还原的时候要修改参数</p><p>1、拉伸到内存</p><p>2、分配新空间N=SizeofImage+Ex</p><p>3、将最后一个节的SizeOfRawdata和VirtualSize改为N</p><p>4、修改SizeofImage</p><p>合并节：合并之后节表有空间进行添加节区</p><p>VirtualSize=SizeofImage-VIrtualAddress</p><blockquote><p>数据目录-里面存储各种表的信息</p></blockquote><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646564515662.png"></p><p>下面介绍几种比较重要的</p><h1 id="DLL-动态链接库和静态链接库"><a href="#DLL-动态链接库和静态链接库" class="headerlink" title="DLL-动态链接库和静态链接库"></a>DLL-动态链接库和静态链接库</h1><p>使用的时候都需要include</p><p>程序编译的过程为将.h和.cpp等文件进行预编译，然后进行编译，再进行汇编，最后链接上（.a/.lib/.so/.dll）成为可执行文件</p><p>静态库、动态库区别来自【链接阶段】如何处理库（处理方式不同来区分），链接成可执行程序。分别称为静态链接方式、动态链接方式</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>使用的时候需要include和#pragma comment(lib,”xxx.lib”)</p><p>因为头文件只包含函数声明，函数实现在lib文件中</p><p>即在链接阶段，将源文件用到的库函数与汇编生成的文件.o等合并（即函数被包含在exe文件中）生成可执行文件</p><p>好处：方便程序移植，因为可执行程序与库函数再无关系，放入任何环境当中都可以执行</p><p>缺点：可执行文件太大（因为包含了库函数），每次库文件升级都需要重新编译源文件，每个可执行程序都会合并库函数，存在很大的重复性，占用空间大</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>两个程序应用一个库，目标文件在内存中只有一份，供所有程序使用，但是可移植性太差，如果两台电脑运行环境不同，动态库存放位置不同，可能会导致程序运行失败</p><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>1、将dll，lib文件添加到调用文件中</p><p>2、将#pragma comment(lib,”xxx.lib”)添加到调用文件中</p><p>3、加入函数的声明</p><p>extern “C” _declspec(dllimport) _stdcall int Plus(int x,int y);</p><p>导出则为dllexport，dll导出和导入的方式必须一致，即导出的时候使用了_stdcall，导入的时候也应该是__stdcall</p><p>这样的话如果需要修改函数，只需要在dll文件修改即可，程序不用编译</p><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>1、定义函数指针</p><p>typedef int (__stdcall *lpPlus)(int,int);</p><p>2、声明函数指针变量</p><p>lpPlus myPlus</p><p>3、动态加载dll到内存中</p><p>HINSTANCE hModule=LoadLibrary(“DllDemo.dll”);</p><p>4、获取函数地址</p><p>myPlus=(lpPlus)GetProcAddress(hModule,”_Plus@8”);(__stdcall为了区分会自动加符号)，如果导入的时候没加stdcall就不需要加符号，即myPlus=(lpPlus)GetProcAddress(hModule,”Plus”);</p><p>5、调用函数</p><p>int a=myPlus(1,2);</p><h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p>Handle是代表系统内核的对象，如文件句柄、线程句柄、进程句柄</p><p>HMODULE代表应用程序载入的模块-在内存中拉伸的起始位置</p><p>HINSTANCE在win32是和前一个一样的 win16遗留</p><p>HWND是窗口句柄</p><blockquote><p>上面的都是无符号整数，四个字节</p></blockquote><p>这样做是为了方便区分，操作系统给的</p><h3 id="def文件导出"><a href="#def文件导出" class="headerlink" title="def文件导出"></a>def文件导出</h3><p>为了隐藏函数的名字</p><p>和前面的类似，先创建动态链接库，头文件只需要函数声明</p><p>创建def文件后，在def文件中写入</p><blockquote><p>EXPORTS</p><p>(函数名)                编号</p><p>Plus                    @12——导出序号是12</p><p>在编号后面+NONAME 可以隐藏函数名</p></blockquote><h2 id="dll导出函数的方式"><a href="#dll导出函数的方式" class="headerlink" title="dll导出函数的方式"></a>dll导出函数的方式</h2><p>extern表示是个全局函数，可以供各个其他的函数调用</p><p>声明导出：_declspec(dllexport)</p><p>def文件导出</p><p>dll函数调用</p><p>隐式链接</p><p>包含头文件，载入lib库</p><p>显式链接</p><p>LoadLibary，GetProAddress</p><h1 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h1><p>作用：记载我们写的dll或者exe导出的函数</p><h2 id="导出表重要成员"><a href="#导出表重要成员" class="headerlink" title="导出表重要成员"></a>导出表重要成员</h2><p>1、指向导出表文件名的字符串-DWORD Name</p><p>2、导出函数的起始序号-DWORD Base</p><p>3、导出函数地址表RVA-DWORD AddressOfFunctions</p><p>4、函数名称地址表RVA-DWORD AddressOfNames</p><p>5、函数序号地址表RVA-DWORD AddressOfNameOrdinals</p><h2 id="定位导出表"><a href="#定位导出表" class="headerlink" title="定位导出表"></a>定位导出表</h2><p>1、找出导出表RVA的偏移</p><p>首先我们要在数据目录的导出表信息的第一项，也就是导出表地址的RVA偏移是多少</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621065982.png"></p><p>可以看出c000h是RVA偏移，大小是164个字节</p><h3 id="判断属于哪一个节"><a href="#判断属于哪一个节" class="headerlink" title="判断属于哪一个节"></a>判断属于哪一个节</h3><p>根据节区的VIrtualAddress判断</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621026524.png"></p><p>所以可以知道在.edata节</p><h3 id="算出FOA位置"><a href="#算出FOA位置" class="headerlink" title="算出FOA位置"></a>算出FOA位置</h3><p>我们知道是在.rdata节的，可以算出FOA</p><p>FOA=RVA-节区的VA（VirtualAddress）+节.PointerOfRawData</p><p>计算发现为8200h</p><h3 id="通过FOA找到导出表位置"><a href="#通过FOA找到导出表位置" class="headerlink" title="通过FOA找到导出表位置"></a>通过FOA找到导出表位置</h3><p>找到后根据前面的导出表大小可以知道导出表的范围</p><p>跳转过去即可</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621157564.png"></p><h2 id="导出表的存储方式"><a href="#导出表的存储方式" class="headerlink" title="导出表的存储方式"></a>导出表的存储方式</h2><p>一个导出表大小为0x28个字节，也就是两行半</p><p>分段讲解</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621661598.png"></p><p>前面十二个字节没用，就不讲了</p><h3 id="Dword-Name"><a href="#Dword-Name" class="headerlink" title="Dword Name"></a>Dword Name</h3><p>绿框的4个字节存储的是dll名称的RVA，想查看的话，可以计算FOA，和前面一样的，得到8250地址存储的是我们的dll名称，以00结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646621843130.png"></p><h3 id="Dword-Base"><a href="#Dword-Base" class="headerlink" title="Dword Base"></a>Dword Base</h3><p>导出函数的起始序号</p><p> DLL导出的函数如果给序号了，那么就从这个序号开始</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622459296.png"></p><h3 id="Dword-NumberOfFunctions-所有的导出函数的个数"><a href="#Dword-NumberOfFunctions-所有的导出函数的个数" class="headerlink" title="Dword NumberOfFunctions-所有的导出函数的个数"></a>Dword NumberOfFunctions-所有的导出函数的个数</h3><p>前四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622410901.png"></p><h3 id="DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数"><a href="#DWORD-NumberOfNames-以名字（有名字的）导出的函数的个数" class="headerlink" title="DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数"></a>DWORD   NumberOfNames-以名字（有名字的）导出的函数的个数</h3><p>可以将两个不同的名字指向相同的地址</p><p>有一些是无名函数不会在里面</p><p>后四个</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622415877.png"></p><p>下面就是子表了，三个子表都是RVA，要转为FOA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622483098.png"></p><p>分别是函数地址表0x8228，函数名称表0x8238，函数序号表0x8248</p><blockquote><p>先去找函数名称表，根据名称的下标再去序号表找对应，然后再去函数地址表找</p></blockquote><h4 id="函数地址表-AddressOfFunctions"><a href="#函数地址表-AddressOfFunctions" class="headerlink" title="函数地址表-AddressOfFunctions"></a>函数地址表-AddressOfFunctions</h4><p>函数地址表指向一个偏移，这个偏移存放了所有导出函数的地址，每个地址占四个字节，存放的是RVA地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646622927186.png"></p><p>ImageBase+函数偏移就是函数在内存中的实际地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646623978690.png"></p><p>可以看到这就是函数</p><p> 还需要注意的就是，如果你按照序号导出1 3 4 5这4个函数，在导入表中我们的函数地址表中的地址会有5个，原因就是：中断的序号会给我们用0填充，２虽然没有，但是也会给我们导出. </p><h4 id="函数名称表-AddressOfNames"><a href="#函数名称表-AddressOfNames" class="headerlink" title="函数名称表-AddressOfNames"></a>函数名称表-AddressOfNames</h4><p>函数名称表也是存储名称的RVA，四个字节存储一个，RVA的个数由以函数名称导出函数个数来决定（DWORD  NumberOfNames）</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625166524.png"></p><p>转为FOA就是0x805e，0x8071,0x8082,0x8093</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625255683.png"></p><p>排序的时候是按照字母顺序排列的，而不是按照导出时函数的顺序进行排序的</p><p>例如:</p><p>　　EXPORT</p><p>　　　　SUB</p><p>　　　　ADD</p><p>　　　　MUL</p><p>导出三个函数，那么第一项就为 ADD，因为按照字母排序，A在前边，后面依次类推，所以我们上面看到的函数名称 ACquireSRW 这个函数名称，并不是第一个导出的函数.</p><h4 id="函数序号表-AddressOfNumberOrdinals－存储的是RVA"><a href="#函数序号表-AddressOfNumberOrdinals－存储的是RVA" class="headerlink" title="函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ"></a>函数序号表-AddressOfNumberOrdinals－存储的是ＲＶＡ</h4><p>给名称用的中转表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646625803927.png"></p><p>和函数名称表大小相同</p><h4 id="按名称导出"><a href="#按名称导出" class="headerlink" title="按名称导出"></a>按名称导出</h4><p>得到函数名称后去AddressOfNames中的函数名称对比，得到索引后根据索引取出AddressOfNameOrdinals存储的值，以此为索引去函数地址表找到函数的地址</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647329750554.png" alt="按名称导出过程"></p><p>函数数量计算方式=最大序号-最小序号+1，（连续的算得准）不连续的话在函数地址表会留有多余的地址，但是多余的地址没有被使用</p><h4 id="按序号导出"><a href="#按序号导出" class="headerlink" title="按序号导出"></a>按序号导出</h4><blockquote><p>当使用序号导出的时候不需要使用序号表，直接将序号-Base作为索引去函数地址表找即可</p></blockquote><h4 id="导出的过程"><a href="#导出的过程" class="headerlink" title="导出的过程"></a>导出的过程</h4><p>系统和我们前面说的不一样</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724098510.png" alt="1"></p><p>根据函数地址表找，如果索引在序号表中，说明是按名字导出的，再去名称表找对应，索引和序号表中的相同</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646724264502.png"></p><p>这里的100a索引是3，在序号表中没有，所以不是按照序号导出的，序号可算，为索引+Base=005</p><h1 id="重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable"><a href="#重定位表-struct-IMAGE-DATA-DIRECTORY-BaseRelocationTable" class="headerlink" title="重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable"></a>重定位表-struct IMAGE_DATA_DIRECTORY BaseRelocationTable</h1><h2 id="程序的加载过程"><a href="#程序的加载过程" class="headerlink" title="程序的加载过程"></a>程序的加载过程</h2><p>系统加载的dll一般在高空间运行，一般是71**************</p><p>先像贴图一样把dll贴在内存中，最后指向exe文件的入口点，exe开始运行</p><p>我们自己写的dll的imageBase都是1000000，所以当多个dll同时使用，会存在地址已经被占用的问题，所以dl只能往后放，但是：</p><p>编译器生成的地址=ImageBase+RVA，这个地址在程序编译完成后，已经写入文件了。但是如果当程序加载时没有按照原来的ImageBase载入，但是此时程序还是会按照前面生成的地址进行使用</p><p>所以一般exe不存在重定位表，而dll一般都有，用于记录需要修改的地方</p><h2 id="重定位表解析"><a href="#重定位表解析" class="headerlink" title="重定位表解析"></a>重定位表解析</h2><p>重定位表是分块，根据RVA计算得到FOA，跳转过去发现有几个重定位表</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727831045.png"></p><p>这两个数据分别存储RVA和大小</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646727910599.png"></p><p>下面的数据中，每两个字节代表这一段有多少个数据需要修复，一般是绝对地址需要修改</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646728080337.png"></p><p>只需要基础地址加上小表的值就可以定位到需要修改的地方，而不用四个字节来存储地址，节省了空间，而这个基础地址就是前面记录的RVA</p><p>而基础地址可以不同，所以才需要分块操作</p><p>可以发现每一块的间隔是1000h，也就是内存对齐的大小</p><p>一个页是1000h，所以只需要1000个十六进制的地址就可以记录完一页的每个位置，对应十进制的4096个</p><p>2^12=4096，所以只需要十二个二进制位就可以表示完所有可能，两个字节有十六位，所以最后找地址的时候，只用取低十二位，高四位有别的用处-如果高四位的值是3就说明这个地方需要修改</p><h3 id="判断块数"><a href="#判断块数" class="headerlink" title="判断块数"></a>判断块数</h3><p>下一块的开始地址都可以通过RVA+SizeOfBlock来得到</p><p>直到遇到全为零的块</p><p>计算需要修改的数据个数：(SizeOfBlock-8)/2，因为前面两个数据是8个字节，剩下的两个字节为1组</p><h1 id="移动导出表-重定位表"><a href="#移动导出表-重定位表" class="headerlink" title="移动导出表-重定位表"></a>移动导出表-重定位表</h1><p>表的数据也在节区中，加密代码时，表的信息也会被加密，这样程序无法初始化，所以要先增节，再移动表，学会移动各种表是对程序加密和破解的基础</p><h2 id="移动导出表"><a href="#移动导出表" class="headerlink" title="移动导出表"></a>移动导出表</h2><p>比较繁琐，因为要移动多张表</p><h3 id="在DLL文件中新增节"><a href="#在DLL文件中新增节" class="headerlink" title="在DLL文件中新增节"></a>在DLL文件中新增节</h3><p>先计算大小</p><p>并且返回新增节的FOA，因为后面的数据还要从新增节的开头开始</p><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>需要复制的数据类型和长度</p><h4 id="复制AddressOfFunctions"><a href="#复制AddressOfFunctions" class="headerlink" title="复制AddressOfFunctions"></a>复制AddressOfFunctions</h4><p>长度：4×NumberOfFunctions</p><h4 id="复制AddressOfNameOrdinals"><a href="#复制AddressOfNameOrdinals" class="headerlink" title="复制AddressOfNameOrdinals"></a>复制AddressOfNameOrdinals</h4><p>长度：2×NumberOfNames</p><h4 id="复制AddressOfNames"><a href="#复制AddressOfNames" class="headerlink" title="复制AddressOfNames"></a>复制AddressOfNames</h4><p>长度：4×NumberOfNames</p><h4 id="复制所有函数名"><a href="#复制所有函数名" class="headerlink" title="复制所有函数名"></a>复制所有函数名</h4><p>长度不确定，复制时直接修复AddressOfName（因为名字的地址也改变了），每复制完一个名字，都需要计算下一个复制的地方</p><h4 id="复制导出表的整体结构"><a href="#复制导出表的整体结构" class="headerlink" title="复制导出表的整体结构"></a>复制导出表的整体结构</h4><h3 id="修复地址"><a href="#修复地址" class="headerlink" title="修复地址"></a>修复地址</h3><p>AddressOfName</p><p>目录项指向新的导出表的位置</p><p>函数地址表、序号表、名称表都需要修复</p><h3 id="将目录项中的RVA修正"><a href="#将目录项中的RVA修正" class="headerlink" title="将目录项中的RVA修正"></a>将目录项中的RVA修正</h3><p>指向我们新的导出表的位置</p><h2 id="移动重定位表"><a href="#移动重定位表" class="headerlink" title="移动重定位表"></a>移动重定位表</h2><p>直接复制过去，修改RVA即可</p><p>加载程序：（当前面已经有DLL被加载）</p><p>1、将新的DLL复制到新的位置</p><p>2、修复重定位表，修改每一个重定位表的偏移</p><h1 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h1><p>作用：从其他第三方程序导入API，以供本程序调用</p><p>在exe运行的时候加载器会遍历导入表，将导入表中所有dll加载到进程中，被加载的DLL的DLLMain就会被调用</p><p>通过导入表可以知道程序使用了哪些函数</p><p> 导入表，是为了提供的要导入的dll的函数的地址，只不过由于dll地址不固定，所以每次都会重新修正 </p><h2 id="导入表解析"><a href="#导入表解析" class="headerlink" title="导入表解析"></a>导入表解析</h2><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><pre class="language-c" data-language="c"><code class="language-c">DWORD OriginalFirstThunk;</code></pre><p>指向导入名称表（INT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   FirstThunk;</code></pre><p>指向导入地址表（IAT）的RVA</p><pre class="language-c" data-language="c"><code class="language-c">DWORD   Name;</code></pre><p>指向导入映像文件的名字</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788456499.png"></p><p>计算后跳转过去，注意要算的是FOA，但是这里RVA和FOA一样 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788490238.png"></p><p>其中IAT与INT都指向 IMAGE_THUNK_DATA32（虽然二者的地址不同）</p><p>INT-以全0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646788999608.png">          函数名数组(对应IMAGE_THUNK_DATA32结构体数组,每一个结构体就是一个联合体-4字节) </p><pre class="language-c" data-language="c"><code class="language-c">typedef struct  _IMAGE_THUNK_DATA32{union{//联合体，实际是4字节DWORD ForwarderString;DWORD Function;//导入函数的地址,在加载到内存之后,这里才起作用DWORD Ordinal;//假如是序号导入的,会用到这里DWORD AddressOfData;//假如是函数名导入,会用到这里,它指向另外一个结构体PIMAGE_IMPORT_BY_NAME}u1;}IMAGE_THUNK_DATA32;//如果是函数名导入的,AddressOfData会指向下面这个结构体typedef struct _IMAGE_IMPORT_BY_NAME{WORD  Hint;//序号CHAR Name[1];//不定长,字符串}</code></pre><h2 id="导入表结构"><a href="#导入表结构" class="headerlink" title="导入表结构"></a>导入表结构</h2><p>在可选PE头最后的十六个数组的导入表结构，这里存放的是RVA</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646998855451.png"></p><p>跳转过去发现存储的是struct IMAGE_IMPORT_DESCRIPTOR ImportDescriptor[0]，这里存放的是真正的导入表结构</p><p>有多少个DLL，对应的结构体数组就有几个</p><p>关键的数据有下面三个，也要注意这里的TimeDateStamp-时间戳</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999149540.png"></p><h3 id="INT表"><a href="#INT表" class="headerlink" title="INT表"></a>INT表</h3><p><em><strong>ULONG OriginalFirstThunk-RVA</strong></em>，存放的是IMAGE_THUNK_DATA这个结构体数组，四字节数，以0结尾</p><p>跳转过去</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999423139.png"></p><p> 但是之前学导出表有了解到，导出函数可以以名字导出，亦可以序号导出。所以为了方便区分，就将这INT表的每个值做了细微调整。</p><blockquote><p> 如果这个4字节数的最高位（二进制）为1，那么抹去这个最高位之后，所表示的数就是要导入的函数的序号；如果最高位是0，那这个数就也是一个RVA，指向IMAGE_IMPORT_BY_NAME结构体（包含真正的导入函数的名字字符串，以0结尾）。INT表以4字节0结尾。 </p></blockquote><p>根据INT存储的RVA进行跳转</p><h4 id="struct-IMAGE-IMPORT-BY-NAME"><a href="#struct-IMAGE-IMPORT-BY-NAME" class="headerlink" title="struct _IMAGE_IMPORT_BY_NAME"></a>struct _IMAGE_IMPORT_BY_NAME</h4><p>1、WORD Hint，可能为0，编译器决定，如果不为0，则是函数在导出表中的索引</p><p>2、BYTE Name[1]，函数名称，以0结尾</p><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>DLL的名字，以0结尾</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1646999638790.png"></p><h3 id="ULONG-FirstThunk"><a href="#ULONG-FirstThunk" class="headerlink" title="ULONG FirstThunk"></a>ULONG FirstThunk</h3><p>根据RVA跳转，发现存储的值和INT的一样，这个存储的是IAT，当文件加载后，会发现IAT会改变</p><h4 id="IAT表-导入地址表"><a href="#IAT表-导入地址表" class="headerlink" title="IAT表-导入地址表"></a>IAT表-导入地址表</h4><p> 记录程序正在使用哪些库中的哪些函数 </p><p>分为两个过程，在文件中存储的是存放函数的地址，在内存中存放函数</p><p>在文件运行前类似于call [地址]</p><p>在文件运行时类似于call [上面地址存放的值]</p><h4 id="IAT表存在的原因"><a href="#IAT表存在的原因" class="headerlink" title="IAT表存在的原因"></a>IAT表存在的原因</h4><p> 一般程序在调用自身函数的时候，自身函数地址RAV是固定的；但是当程序在调用dll里的函数的时候，由于dll的地址会发生重定位，导致dll里的函数地址每次都会发生变化。 </p><p>为了准确调用dll函数的地址，构造了IAT表来存储程序运行时，即DLL文件重定位之后的dll函数的位置</p><h2 id="导入表加载过程"><a href="#导入表加载过程" class="headerlink" title="导入表加载过程"></a>导入表加载过程</h2><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAzMjg0Ni5wbmc-1647000237348.png" alt="PE文件加载前"></p><p>加载过程</p><p>先找ＤＬＬ，再确定使用的函数</p><h3 id="寻找DLL"><a href="#寻找DLL" class="headerlink" title="寻找DLL"></a>寻找DLL</h3><p>先根据导入表的NAME找到DLL名称和DLL的INT和IAT表，开始的时候INT和IAT数据相同，但是存储位置不同</p><h3 id="查INT表"><a href="#查INT表" class="headerlink" title="查ＩＮＴ表"></a>查ＩＮＴ表</h3><p>因为导出的时候可以按序号导出也可以按函数名称导出，所以为了区分，ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ最高位为１时，表示其存储的是序号，而剩下的３１位表示序号，否则ｉｍａｇｅ＿ｔｈｕｎｋ＿ｄａｔａ存储的是函数名称的ＲＶＡ</p><h3 id="修改IAT"><a href="#修改IAT" class="headerlink" title="修改ＩＡＴ"></a>修改ＩＡＴ</h3><p>使用ＧＥＴＰｒｏＡｄｄｒ（ｍｏｄｕｌｅ，）</p><p>将前面查找到的函数地址填充进ＩＡＴ表中</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/aHR0cHM6Ly9naXRlZS5jb20vY2h0MS9JbWFnZS9yYXcvbWFzdGVyL2ltZy8yMDIwMDcxNDAyNTEwMy5wbmc.png" alt="PE文件加载后"> </p><p>可以看到IAT表变成了函数的地址</p><p> IAT表会存储dll的函数的地址，方便调用该函数时，直接取IAT表这个地址内的值，作为函数地址，去CALL。</p><h1 id="绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR"><a href="#绑定导入表-struct-IMAGE-BOUND-IMPORT-DESCRIPTOR" class="headerlink" title="绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR"></a>绑定导入表- struct _IMAGE_BOUND_IMPORT_DESCRIPTOR</h1><p>可选NT头里的结构</p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647001593786.png"></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p> 有些windows程序，如notepad，为了提高加载速度，会直接把DLL中的函数地址写入到IAT表，省去了加载时的计算。 </p><h2 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h2><p> 第一，当DLL没有占住ImageBase时，IAT中的地址就是错的；第二，当链接的DLL被修改了，那IAT里写的地址也是错的。遇到这两种情形之一，加载时就必须修复IAT了。 </p><p>对于第二种情形，DLL是否被修改，是根据比较DLL的时间戳和绑定导入表中的记录的DLL时间戳来判断的，如果不一致，说明DLL被修改了。</p><p>加载程序时，操作系统根据导入表中的时间戳来判断程序是否使用了绑定导入。当时间戳为0，表示不使用绑定导入表；当时间戳为0xFFFFFFFF，说明该程序使用绑定导入。</p><h2 id="绑定导入表结构"><a href="#绑定导入表结构" class="headerlink" title="绑定导入表结构"></a>绑定导入表结构</h2><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    NumberOfModuleForwarderRefs;// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></pre><p> TimeDateStamp 是时间戳，用于和DLL中的时间戳比较，判断DLL是否已经发生变化； </p><p> OffsetModuleName 是当前模块名距离第一个 _IMAGE_BOUND_IMPORT_DESCRIPTOR 的偏移。</p><p>  NumberOfModuleForwarderRefs 是该模块依赖的模块数量； </p><h3 id="依赖模块结构"><a href="#依赖模块结构" class="headerlink" title="依赖模块结构"></a>依赖模块结构</h3><pre class="language-c" data-language="c"><code class="language-c">typedef struct _IMAGE_BOUND_FORWARDER_REF {    DWORD   TimeDateStamp;    WORD    OffsetModuleName;    WORD    Reserved;} IMAGE_BOUND_FORWARDER_REF,*PIMAGE_BOUND_FORWARDER_REF;</code></pre><p> 除了第三个属性保留，其他与 _IMAGE_BOUND_IMPORT_DESCRIPTOR 相同。 </p><p><img src="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/1647049008006.png" alt="绑定导入表"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame2022-WOW-patch数据段</title>
      <link href="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/"/>
      <url>/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531507324.png"></p><p>可以看到上面这一段是输入并且把加密后的输入赋值给Buf2，在这之后已经结束了判断，所以下面红色框的代码应该是解密代码，只需要把Buf在栈中进行修改为final字符串即可</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531624170.png"></p><p>这里点过去发现并没有数据，这可能是一些数据没有反编译出来，但是在图中蓝色部分可以看到地址是ebp-54</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531725452.png">计算一下，在堆栈窗口按g进行跳转</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531744867.png"></p><p>跳转之后</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531761124.png"></p><p>然后右键Edit，或者按快捷键F2，然后进行修改，注意大小端序的问题，这里使用lazyida选择DWORD导出来就很方便，再次右键，应用修改</p><p>然后运行即可，就可以在input看到flag了</p><p><img src="/2022/02/22/hgame2022-WOW-patch%E6%95%B0%E6%8D%AE%E6%AE%B5/1645531871154.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame-misc</title>
      <link href="/2022/02/19/hgame-misc/"/>
      <url>/2022/02/19/hgame-misc/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>总算是结束了，下面就记录一下misc遇到的一些题目</p><h1 id="这个压缩包有点麻烦"><a href="#这个压缩包有点麻烦" class="headerlink" title="这个压缩包有点麻烦"></a>这个压缩包有点麻烦</h1><h2 id="相关知识-压缩包"><a href="#相关知识-压缩包" class="headerlink" title="相关知识-压缩包"></a>相关知识-压缩包</h2><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p><img src="/2022/02/19/hgame-misc/1645212044252.png"></p><p>可以看到在zip给出了密码的提示，六位纯数字，Advanced Archive Password Recovery爆破</p><p><img src="/2022/02/19/hgame-misc/1645212152522.png"></p><p><img src="/2022/02/19/hgame-misc/1645212207157.png"></p><p>根据提示，给出的应该是字典，我们同样在爆破软件中选择字典</p><p><img src="/2022/02/19/hgame-misc/1645212320305.png"></p><p>继续下一步</p><p><img src="/2022/02/19/hgame-misc/1645212429206.png"></p><p>他让我们重新储存，把readme文件选择以存储的方式压缩发现</p><p><img src="/2022/02/19/hgame-misc/1645212573216.png"></p><p>这两个的CRC32的值是一样的，但是我们知道CRC32的值只有一个，所以使用明文攻击，这里4.5没跑出来，4.0跑出来了</p><p>在jpg文件尾部发现了zip，另存一下，是伪加密</p><p><img src="/2022/02/19/hgame-misc/1645213950846.png"></p><p>修复后得到flag</p><p><img src="/2022/02/19/hgame-misc/1645214098403.png"></p><h1 id="你上当了-我的很大"><a href="#你上当了-我的很大" class="headerlink" title="你上当了 我的很大"></a>你上当了 我的很大</h1><h2 id="相关知识-二维码"><a href="#相关知识-二维码" class="headerlink" title="相关知识-二维码"></a>相关知识-二维码</h2><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p>解压之后得到很多的视频，但都是重复的，有用的就几个，主要记录一下各种二维码的样子，以免之后认不出来</p><p><a href="https://barcode.tec-it.com/zh/CodablockF">https://barcode.tec-it.com/zh/CodablockF</a></p><p>这个网站可以生成不同的二维码，便于识别</p><p><a href="https://products.aspose.app/barcode/recognize#">https://products.aspose.app/barcode/recognize#</a></p><p>这个网站识别比较全</p><p><img src="/2022/02/19/hgame-misc/1645213399267.png"></p><p><img src="/2022/02/19/hgame-misc/1645213453036.png"></p><p><img src="/2022/02/19/hgame-misc/1645213467874.png"></p><h1 id="谁不喜欢猫猫呢"><a href="#谁不喜欢猫猫呢" class="headerlink" title="谁不喜欢猫猫呢"></a>谁不喜欢猫猫呢</h1><p><a href="https://blog.csdn.net/mochu7777777/article/details/122631962-%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%EF%BC%8C%E8%84%9A%E6%9C%AC%E4%B8%8D%E4%BC%9A%E5%86%99">https://blog.csdn.net/mochu7777777/article/details/122631962-可以看看，脚本不会写</a></p><h1 id="摆烂"><a href="#摆烂" class="headerlink" title="摆烂"></a>摆烂</h1><h2 id="相关知识-盲水印、APng、零宽隐写"><a href="#相关知识-盲水印、APng、零宽隐写" class="headerlink" title="相关知识-盲水印、APng、零宽隐写"></a>相关知识-盲水印、APng、零宽隐写</h2><h2 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h2><p>foremost分离压缩包得到png文件，也可以复制文件信息之后另存为，将png拖进010发现奇怪的地方</p><p><img src="/2022/02/19/hgame-misc/1645214249445.png"></p><p>正常的png文件是没有fdAT数据段的 APng-<a href="https://www.jianshu.com/p/5333bcc20ba7">https://www.jianshu.com/p/5333bcc20ba7</a></p><p>查阅资料发现是Apng，这里介绍一个分解Apng的网址</p><p><a href="https://ezgif.com/split">https://ezgif.com/split</a></p><p>得到两张一模一样的图片，这时候就想到了盲水印</p><p><img src="/2022/02/19/hgame-misc/1645214469303.png"></p><p>得到带有密码的图片</p><p><img src="/2022/02/19/hgame-misc/1645214585213.png"></p><p>得到密钥解压压缩包，拼接二维码，扫码得到</p><p><img src="/2022/02/19/hgame-misc/1645214612749.png"></p><p>发现很多问号，应该就是零宽了，这里我手机扫码后的信息再拿去解密-<a href="https://330k.github.io/misc_tools/unicode_steganography.html">https://330k.github.io/misc_tools/unicode_steganography.html</a></p><p><img src="/2022/02/19/hgame-misc/1645214720413.png"></p><h1 id="At0m的给你们的-迟到的-情人节礼物"><a href="#At0m的给你们的-迟到的-情人节礼物" class="headerlink" title="At0m的给你们的(迟到的)情人节礼物"></a>At0m的给你们的(迟到的)情人节礼物</h1><h2 id="相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具"><a href="#相关知识-avi隐写、NTFS数据流、-MSU-StegoVideo工具" class="headerlink" title="相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具"></a>相关知识-avi隐写、NTFS数据流、 MSU StegoVideo工具</h2><h2 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h2><p>一般数据流隐写都采取winrar，所以要关注rar文件</p><p>这里解压之后时候NTFS工具得到</p><p><img src="/2022/02/19/hgame-misc/1645214827597.png"></p><p>四个方向对应四进制，解码的到 6557225 </p><p>还有一个avi文件，一般是MSU StegoVideo工具</p><p>下载好之后选择好avi文件，并且指定写入的文本 ，输入密码即可</p><p>hgame{Q1ng_R3n_J1e_Da_Sh4_CTF}                        </p>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyc加花指令</title>
      <link href="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="VNCTF2022-BabyMaze"><a href="#VNCTF2022-BabyMaze" class="headerlink" title="VNCTF2022-BabyMaze"></a>VNCTF2022-BabyMaze</h1><p>pyc相关知识-<a href="https://zhuanlan.zhihu.com/p/145811103">https://zhuanlan.zhihu.com/p/145811103</a></p><p>使用uncompyle6发现无法反编译，应该是添加了花指令</p><p>先查看字节码</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import marshal, disf = open("D:\\new\\AD\\game\\vnctf2022\\re\\BabyMaze.pyc", "rb").read()code = marshal.loads(f[16:]) #这边从16位开始取因为是python3 python2从8位开始取dis.dis(code)</code></pre><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848858641.png"></p><p>发现这一段就是花指令</p><p>去python的包里面搜索opcode.h，找到对应的字节码</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644848986760.png"></p><p>转为十六进制后去010editor修改，去掉即可</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849226023.png"></p><p>但是发现还是不行，这是因为</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849421077.png"></p><p>pyc文件有co_code，所以修改长度之后要修改它</p><p>先打印出来长度，然后计算后修改</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849766935.png"></p><p>2030-6=7E8</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849849453.png"></p><p>重新uncompyle6</p><p><img src="/2022/02/14/pyc%E5%8A%A0%E8%8A%B1%E6%8C%87%E4%BB%A4/1644849958666.png"></p><p>反编译成功，接下来就是maze图，打印出来之后手打</p><h1 id="Pyc字节码阅读-unctf2021-pytrade"><a href="#Pyc字节码阅读-unctf2021-pytrade" class="headerlink" title="Pyc字节码阅读-unctf2021-pytrade"></a>Pyc字节码阅读-unctf2021-pytrade</h1><p>得到两个txt文件，一个是py的字节码，一个是输出</p><p>对字节码进行分析</p><p><a href="https://www.jianshu.com/p/557cfe36f0f0">https://www.jianshu.com/p/557cfe36f0f0</a></p><p><a href="https://bbs.pediy.com/thread-246683.htm">https://bbs.pediy.com/thread-246683.htm</a></p><p><a href="https://docs.python.org/zh-cn/3/library/dis.html">https://docs.python.org/zh-cn/3/library/dis.html</a>  这是python3的</p><pre class="language-python" data-language="python"><code class="language-python">0 LOAD_CONST               1 ('XXXXXX')       //This is flag,try to figure it out ! Don't forget to fill it in flag{} !             2 STORE_FAST               0 (flag)</code></pre><p>LOAD_CONST加载const变量，比如数值、字符串等，一般用于传给函数参数</p><p>STORE_FAST 一般用于保存值到局部变量</p><p>这句话意思是</p><pre class="language-none"><code class="language-none">flag='XXXXXXXX'</code></pre><p>第二段</p><pre class="language-python" data-language="python"><code class="language-python">4 LOAD_CONST               2 (0) const变量，一般用于传给函数的参数             6 BUILD_LIST               1  创建列表             8 LOAD_CONST               3 (18)   const变量  num=[0]*18            10 BINARY_MULTIPLY                12 STORE_FAST               1 (num) 保存值到局部变量中</code></pre><p>BINARY_MULTIPLY 是二元运算，即将栈顶的前两个元素取出进行计算，结果压回栈中 </p><p>BUILD_LIST 创建列表</p><pre class="language-none"><code class="language-none">num=[0]*18</code></pre><p>第三段</p><pre class="language-python" data-language="python"><code class="language-python">14 LOAD_CONST               2 (0)             16 STORE_FAST               2 (k)</code></pre><pre class="language-python" data-language="python"><code class="language-python">k=0</code></pre><p>第四段</p><pre class="language-python" data-language="python"><code class="language-python">18 LOAD_GLOBAL              0 (range) 加载全局变量             20 LOAD_GLOBAL              1 (len)              22 LOAD_FAST                0 (flag)              24 CALL_FUNCTION            1调用一个函数，在此之前要先赋值 len(flag)             26 CALL_FUNCTION            1  range(len(flag))             28 GET_ITER取迭代器        &gt;&gt;   30 FOR_ITER               112 (to 144)  一直到144都是for循环             32 STORE_FAST               3 (i) </code></pre><p> LOAD_GLOBAL 用来加载全局变量，包括指定函数名，类名，模块名等全局符号。当和函数搭配时，要注意有CALL_FUNCTION</p><p>LOAD_FAST一般加载局部变量的值，也就是读取值，用于计算或者函数调用传参等。这里调用完len之后，要使用其传值，这里传入flag</p><p>前半段意思是</p><pre class="language-python" data-language="python"><code class="language-python">range(len(flag))</code></pre><p>GET_ITER创建迭代器，一般是for循环</p><p>FOR_ITER(to 144)表示迭代器一直到144</p><p>STORE_FAST 创建局部变量，这里作为for循环的索引</p><pre class="language-python" data-language="python"><code class="language-python">for i in range(len(flag)):</code></pre><p>第五段</p><pre class="language-python" data-language="python"><code class="language-python">7          34 LOAD_GLOBAL              2 (ord)             36 LOAD_FAST                0 (flag)            38 LOAD_FAST                3 (i)            40 BINARY_SUBSCR索引运算            42 CALL_FUNCTION            1ord(flag[i])            44 LOAD_FAST                3 (i)            46 BINARY_ADD+i            48 LOAD_FAST                2 (k)            50 LOAD_CONST               4 (3)            52 BINARY_MODULO//取模运算 k%3            54 LOAD_CONST               5 (1)             56 BINARY_ADD(k%3)+1            58 BINARY_XOR(ord(flag[i])+i)^(k%3+1)            60 LOAD_FAST                1 (num)            62 LOAD_FAST                3 (i)            64 STORE_SUBSCR num[i]</code></pre><p>BINARY_SUBSCR下标 访问操作</p><p>BINARY_ADD也是二元运算，相加</p><p>BINARY_MODULO，二元运算取模</p><p>BINARY_XOR二元运算异或</p><p>STORE_SUBSCR下标访问操作</p><pre class="language-python" data-language="python"><code class="language-python">num[i]= (ord(flag[i]) + i) ^ (k % 3 + 1)</code></pre><p>第六段</p><pre class="language-python" data-language="python"><code class="language-python">8          66 LOAD_GLOBAL              2 (ord)             68 LOAD_FAST                0 (flag)             70 LOAD_GLOBAL              1 (len)             72 LOAD_FAST                0 (flag)             74 CALL_FUNCTION            1len(flag)             76 LOAD_FAST                3 (i)len(flag)-i             78 BINARY_SUBTRACT             80 LOAD_CONST               5 (1)             82 BINARY_SUBTRACT减法len(flag)-i-1             84 BINARY_SUBSCR索引运算flag[len(flag)-i-1]             86 CALL_FUNCTION            1ord(flag[len(flag)-i-1])             88 LOAD_GLOBAL              1 (len)             90 LOAD_FAST                0 (flag)             92 CALL_FUNCTION            1len(flag)             94 BINARY_ADDord(flag[len(flag)-i-1])+len(flag)-i-1             96 LOAD_FAST                3 (i)             98 BINARY_SUBTRACT            100 LOAD_CONST               5 (1)            102 BINARY_SUBTRACT            104 LOAD_FAST                2 (k)            106 LOAD_CONST               4 (3)            108 BINARY_MODULOk%3            110 LOAD_CONST               5 (1)            112 BINARY_ADDk%3+1            114 BINARY_XORord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)            116 LOAD_FAST                1 (num)            118 LOAD_GLOBAL              1 (len)            120 LOAD_FAST                0 (flag)len(flag)            122 CALL_FUNCTION            1            124 LOAD_FAST                3 (i)            126 BINARY_SUBTRACTlen(flag)-i            128 LOAD_CONST               5 (1)            130 BINARY_SUBTRACTlen(flag)-i-1            132 STORE_SUBSCRnum[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>BINARY_SUBTRACT二元运算减法</p><pre class="language-python" data-language="python"><code class="language-python">num[len(flag)-i-1]=ord(flag[len(flag)-i-1])+(len(flag)-i-1)^(k%3+1)</code></pre><p>第七段</p><pre class="language-python" data-language="python"><code class="language-python">9         134 LOAD_FAST                2 (k)            136 LOAD_CONST               5 (1)            138 INPLACE_ADDk++            140 STORE_FAST               2 (k)            142 JUMP_ABSOLUTE           30//循环结束</code></pre><p>JUMP_ABSOLUTE绝对跳转，结束循环</p><p>INPLACE_ADD  计算结果可以被操作数引用的到，每一个 二元运算，都对应一个inplace 运算 </p><pre class="language-python" data-language="python"><code class="language-python">k+=1</code></pre><p>第八段</p><pre class="language-python" data-language="python"><code class="language-python">10     &gt;&gt;  144 LOAD_GLOBAL              3 (print)            146 LOAD_FAST                1 (num)            148 CALL_FUNCTION            1 print(num)            150 POP_TOP            152 LOAD_CONST               0 (None)            154 RETURN_VALUE</code></pre><pre class="language-none"><code class="language-none">print(num)</code></pre><h1 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h1><p>python3.9，无法uncompyle6，使用pycdc翻译成字节码</p><pre class="language-python" data-language="python"><code class="language-python">main.pyc (Python 3.9)[Code]    File Name: main.py    Object Name: &lt;module&gt;    Arg Count: 0    Pos Only Arg Count: 0    KW Only Arg Count: 0    Locals: 0    Stack Size: 4    Flags: 0x00000040 (CO_NOFREE)    [Names]        'base64'        'encode'        'enCodeAgain'        'correct'        'flag'        'print'        'input'    [Var Names]    [Free Vars]    [Cell Vars]    [Constants]        0        None        [Code]            File Name: main.py            Object Name: encode            Arg Count: 1            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 4            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'chr'                'base64'                'b64encode'                'encode'            [Var Names]                'message'                's'                'i'                'x'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                32                16                'utf-8' [Disassembly]                0       LOAD_CONST              1: ''                2       STORE_FAST              1: s       s=''                4       LOAD_FAST               0: message                6       GET_ITER                                8       FOR_ITER                32 (to 42) for i in message:                10      STORE_FAST              2: i                   12      LOAD_FAST               2: i                  14      LOAD_CONST              2: 32                16      BINARY_XOR               i^32                18      STORE_FAST              3: xx=i^32                20      LOAD_FAST               3: x                22      LOAD_CONST              3: 16                24      BINARY_ADD              x+16                26      STORE_FAST              3: xx=x+16                28      LOAD_FAST               1: s                30      LOAD_GLOBAL             0: chr                32      LOAD_FAST               3: x                    34      CALL_FUNCTION           1  chr(x)                36      INPLACE_ADD             s+chr(x)                38      STORE_FAST              1: ss=s+chr(x)                40      JUMP_ABSOLUTE           8    循环结束                42      LOAD_GLOBAL             1: base64                44      LOAD_METHOD             2: b64encodebase64.b64                46      LOAD_FAST               1: s                48      LOAD_METHOD             3: encode   LOAD_METHOD是加载类，CALL调用                50      LOAD_CONST              4: 'utf-8'                 52      CALL_METHOD             1                  54      CALL_METHOD             1 base64.b64(s.encode('utf-8'))                56      RETURN_VALUE            return  base64.b64(s.encode('utf-8'))        'encode'        [Code]            File Name: main.py            Object Name: enCodeAgain            Arg Count: 2            Pos Only Arg Count: 0            KW Only Arg Count: 0            Locals: 5            Stack Size: 5            Flags: 0x00000043 (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)            [Names]                'str'                'range'                'len'            [Var Names]                'string'                'space'                's'                'i'                'j'            [Free Vars]            [Cell Vars]            [Constants]                None                ''                'utf-8'                0            [Disassembly]                0       LOAD_CONST              1: ''                  2       STORE_FAST              2: ss=''                4       LOAD_GLOBAL             0: str                6       LOAD_FAST               0: string                8       LOAD_CONST              2: 'utf-8'                 10      CALL_FUNCTION           2//参数个数 str(string,'utf-8')                12      STORE_FAST              0: string string=str(string,'utf-8')                14      LOAD_GLOBAL             1: range                 16      LOAD_CONST              3: 0                18      LOAD_FAST               1: space                20      CALL_FUNCTION           2 range(0,space)                22      GET_ITER                //创建迭代器                24      FOR_ITER                50 (to 76)                 26      STORE_FAST              3: ifor i range(0,space):                28      LOAD_GLOBAL             1: range                 30      LOAD_FAST               3: i                32      LOAD_GLOBAL             2: len                34      LOAD_FAST               0: string                36      CALL_FUNCTION           1len(string)                38      LOAD_FAST               1: space                40      CALL_FUNCTION           3                 42      GET_ITER                                44      FOR_ITER                28 (to 74)                46      STORE_FAST              4: j  for j in range(i,len(string),space)                48      LOAD_FAST               4: j                 50      LOAD_GLOBAL             2: len                52      LOAD_FAST               0: string                54      CALL_FUNCTION           1  len(string)                56      COMPARE_OP              0 (&lt;)if(j&lt;len(string))                58      POP_JUMP_IF_FALSE       44跳转                60      LOAD_FAST               2: s                62      LOAD_FAST               0: string                64      LOAD_FAST               4: j                66      BINARY_SUBSCR           string[j]                68      INPLACE_ADD                             70      STORE_FAST              2: s      s+=string[j]                72      JUMP_ABSOLUTE           44第二个循环                74      JUMP_ABSOLUTE           24第一个循环                76      LOAD_FAST               2: s                78      RETURN_VALUE             return s        'enCodeAgain'        'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        ''        'Input flag:'        'utf-8'        2        'correct'        'wrong'    [Disassembly]        0       LOAD_CONST              0: 0        2       LOAD_CONST              1: None        4       IMPORT_NAME             0: base64        6       STORE_NAME              0: base64import base64        8       LOAD_CONST              2: &lt;CODE&gt; encode        10      LOAD_CONST              3: 'encode' //函数        12      MAKE_FUNCTION           0        14      STORE_NAME              1: encode        16      LOAD_CONST              4: &lt;CODE&gt; enCodeAgain        18      LOAD_CONST              5: 'enCodeAgain'        20      MAKE_FUNCTION           0//第二个函数        22      STORE_NAME              2: enCodeAgain        24      LOAD_CONST              6: 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='        26      STORE_NAME              3: correctcorrect=VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ=        28      LOAD_CONST              7: ''        30      STORE_NAME              4: flagflag=''        32      LOAD_NAME               5: print        34      LOAD_CONST              8: 'Input flag:'        36      CALL_FUNCTION           1print('Int flag:')        38      POP_TOP                         40      LOAD_NAME               6: input        42      CALL_FUNCTION           0input()        44      STORE_NAME              4: flagflag=input()        46      LOAD_NAME               4: flag        48      LOAD_METHOD             1: encode        50      LOAD_CONST              9: 'utf-8'        52      CALL_METHOD             1        54      STORE_NAME              4: flagflag=flag.encode('utf-8')        56      LOAD_NAME               5: print        58      LOAD_NAME               2: enCodeAgain        60      LOAD_NAME               1: encode        62      LOAD_NAME               4: flag        64      CALL_FUNCTION           1        66      LOAD_CONST              10: 2 其中一个参数        68      CALL_FUNCTION           2//两个参数        70      CALL_FUNCTION           1print(enCodeAgain(encodee(flag),2))        72      POP_TOP                 函数栈顶元素出栈        74      LOAD_NAME               2: enCodeAgain        76      LOAD_NAME               1: encode        78      LOAD_NAME               4: flag        80      CALL_FUNCTION           1        82      LOAD_CONST              10: 2        84      CALL_FUNCTION           2(enCodeAgain(encodee(flag),2))        86      LOAD_NAME               3: correct        88      COMPARE_OP              2 (==)//比较        90      POP_JUMP_IF_FALSE       102跳转        92      LOAD_NAME               5: print        94      LOAD_CONST              11: 'correct'        96      CALL_FUNCTION           1print('correct')        98      POP_TOP                         100     JUMP_FORWARD            8 (to 110)结束        102     LOAD_NAME               5: print        104     LOAD_CONST              12: 'wrong'        106     CALL_FUNCTION           1print('wrong)        108     POP_TOP                         110     LOAD_CONST              1: None        112     RETURN_VALUE            </code></pre><pre class="language-python" data-language="python"><code class="language-python">import base64def encode(message):    s = ''    for i in message:        x = i ^ 32        x += 16        s += chr(x)        return (base64.b64encode(s.encode('utf-8')))def enCodeAgain(string, space):    s = ''    string = str(string, 'utf-8')    for i in range(0, space):        for j in range(i, len(string), space):            if j &lt; len(string):                s += string[j]    return scorrect = 'VxVtd5dKIPjMw9wVb=lR2WVTcPWC2goWoeQ='flag = ''print('Input flag:')flag = input()flag = flag.encode('utf-8')print(enCodeAgain(encode(flag), 2))if enCodeAgain(encode(flag), 2) == correct:    print(correct)else:    print('wrong')</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame2022-week3-re</title>
      <link href="/2022/02/13/hgame2022-week3-re/"/>
      <url>/2022/02/13/hgame2022-week3-re/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>算是总结和反思吧</p><h1 id="hardened"><a href="#hardened" class="headerlink" title="hardened"></a>hardened</h1><h2 id="考点：加壳、AES-CBC、Base64魔改"><a href="#考点：加壳、AES-CBC、Base64魔改" class="headerlink" title="考点：加壳、AES-CBC、Base64魔改"></a>考点：加壳、AES-CBC、Base64魔改</h2><h2 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h2><p>首先可以先试试用jeb打开</p><p><img src="/2022/02/13/hgame2022-week3-re/1644828115040.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644828621422.png"></p><p>没有找到mainactivitity，且有application，应该是加了壳，去lib找一下so文件，进行识别</p><pre class="language-none"><code class="language-none">markNameMap.put("libchaosvmp.so", "娜迦");markNameMap.put("libddog.so", "娜迦");markNameMap.put("libfdog.so", "娜迦");markNameMap.put("libedog.so", "娜迦企业版");markNameMap.put("libexec.so", "爱加密");markNameMap.put("libexecmain.so", "爱加密");markNameMap.put("ijiami.dat", "爱加密");markNameMap.put("ijiami.ajm", "爱加密企业版");markNameMap.put("libsecexe.so", "梆梆免费版");markNameMap.put("libsecmain.so", "梆梆免费版");markNameMap.put("libSecShell.so", "梆梆免费版");markNameMap.put("libDexHelper.so", "梆梆企业版");markNameMap.put("libDexHelper-x86.so", "梆梆企业版");markNameMap.put("libprotectClass.so", "360");markNameMap.put("libjiagu.so", "360");markNameMap.put("libjiagu_art.so", "360");markNameMap.put("libjiagu_x86.so", "360");markNameMap.put("libegis.so", "通付盾");markNameMap.put("libNSaferOnly.so", "通付盾");markNameMap.put("libnqshield.so", "网秦");markNameMap.put("libbaiduprotect.so", "百度");markNameMap.put("aliprotect.dat", "阿里聚安全");markNameMap.put("libsgmain.so", "阿里聚安全");markNameMap.put("libsgsecuritybody.so", "阿里聚安全");markNameMap.put("libmobisec.so", "阿里聚安全");markNameMap.put("libtup.so", "腾讯");markNameMap.put("libexec.so", "腾讯");markNameMap.put("libshell.so", "腾讯");markNameMap.put("mix.dex", "腾讯");markNameMap.put("lib/armeabi/mix.dex", "腾讯");markNameMap.put("lib/armeabi/mixz.dex", "腾讯");markNameMap.put("libtosprotection.armeabi.so", "腾讯御安全");markNameMap.put("libtosprotection.armeabi-v7a.so", "腾讯御安全");markNameMap.put("libtosprotection.x86.so", "腾讯御安全");markNameMap.put("libnesec.so", "网易易盾");markNameMap.put("libAPKProtect.so", "APKProtect");markNameMap.put("libkwscmm.so", "几维安全");markNameMap.put("libkwscr.so", "几维安全");markNameMap.put("libkwslinker.so", "几维安全");markNameMap.put("libx3g.so", "顶像科技");markNameMap.put("libapssec.so", "盛大");markNameMap.put("librsprotect.so", "瑞星");</code></pre><p>这个程序是被梆梆加固加固过的</p><p>使用工具脱壳-</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829142036.png"></p><p>安装到手机或者模拟器上面</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829295135.png"></p><p>找到目录再移动到共享文件夹就可以了</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829809855.png"></p><p>选中后打开共享文件夹，打开安卓文件夹</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829839920.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644829849310.png"></p><p>移动到此</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829879528.png"></p><p>再打开电脑文件夹就可以找到了</p><p><img src="/2022/02/13/hgame2022-week3-re/1644829901534.png"></p><p>把dex依次拖入jeb，发现540702有关键信息</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830177982.png"></p><p>第二段是关键比较</p><p>查看前一个方框中引用的类</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830302545.png"></p><p>是用来调用so的，改为zip文件把enc.so文件拖进ida进行分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830479144.png"></p><p>找到关键的函数，可以看出是aes-cbc模式，查看AES函数调用的关键参数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830690500.png"></p><p>找到key和iv，对一些关键数据查看交叉引用</p><p>发现其他加密函数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830877369.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644830924673.png"></p><p>base64，再看看有没有魔改，对表查看交叉引用</p><p><img src="/2022/02/13/hgame2022-week3-re/1644830970190.png"></p><p>发现对key和iv，以及base64表都进行了异或操作，写脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char key[32] = {0x7A, 0x65, 0x63, 0x64, 0x6F, 0x71, 0x6F, 0x7E, 0x7F, 0x62, 0x7D, 0x71, 0x7C, 0x6F, 0x7B, 0x75,0x69, 0x6F, 0x76, 0x7F, 0x62, 0x6F, 0x69, 0x7F, 0x65, 0x6F, 0x64, 0x7F, 0x6F, 0x74, 0x75, 0x73};char iv[16] = {0x06, 0x10, 0x0A, 0x20, 0x19, 0x16, 0x11, 0x1B,0x20, 0x12, 0x1A, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E};char base64_table[63] = {0x79, 0x78, 0x7B, 0x7A, 0x7D, 0x7C, 0x7F, 0x7E, 0x71, 0x70, 0x08, 0x0B, 0x0A, 0x0D, 0x0C, 0x0F,0x0E, 0x01, 0x00, 0x03, 0x02, 0x05, 0x04, 0x07, 0x06, 0x19, 0x18, 0x1B, 0x1A, 0x1D, 0x1C, 0x1F,0x1E, 0x11, 0x10, 0x13, 0x28, 0x2B, 0x2A, 0x2D, 0x2C, 0x2F, 0x2E, 0x21, 0x20, 0x23, 0x22, 0x25,0x24, 0x27, 0x26, 0x39, 0x38, 0x3B, 0x3A, 0x3D, 0x3C, 0x3F, 0x3E, 0x31, 0x30, 0x33, 0x62};for (int i = 0; i &lt; 32; ++i){key[i] ^= 0x30;printf("%c", key[i]);}printf("\n");for (int i = 0; i &lt; 16; ++i){iv[i] ^= 0x7f;printf("%c", iv[i]);}printf("\n");for (int i = 0; i &lt; 63; ++i){base64_table[i] ^= 0x49;printf("%c", base64_table[i]);}return 0;}</code></pre><p><img src="/2022/02/13/hgame2022-week3-re/1644831095464.png"></p><p>找在线网站解密-<a href="https://www.iculture.cc/demo/cyberchef/">https://www.iculture.cc/demo/cyberchef/</a></p><p><img src="/2022/02/13/hgame2022-week3-re/1644831134385.png"></p><h1 id="Answer’s-Windows"><a href="#Answer’s-Windows" class="headerlink" title="Answer’s Windows"></a>Answer’s Windows</h1><h2 id="考点：QT逆向、Base64魔改"><a href="#考点：QT逆向、Base64魔改" class="headerlink" title="考点：QT逆向、Base64魔改"></a>考点：QT逆向、Base64魔改</h2><h2 id="做题过程-1"><a href="#做题过程-1" class="headerlink" title="做题过程"></a>做题过程</h2><p><img src="/2022/02/13/hgame2022-week3-re/1644826230792.png"></p><p>根据字符串的搜索功能，快速定位到关键函数，可以看到进行了字符串比较，所以往上找到对字符串进行操作的函数</p><p><img src="/2022/02/13/hgame2022-week3-re/1644826372187.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644826396198.png"></p><p>从这些关键特征可以猜测是base64，但是根据最后的字符串，可知道应该是对base64表进行了修改</p><p>查看交叉引用</p><p><img src="/2022/02/13/hgame2022-week3-re/1644826515161.png"></p><p><img src="/2022/02/13/hgame2022-week3-re/1644826528911.png"></p><p>这时候可以绕过反调试进行动调，得到base64表</p><p><img src="/2022/02/13/hgame2022-week3-re/1644827711098.png"></p><p>然后写脚本即可</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = {  0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A,  0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34,  0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E,  0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,  0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52,  0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C,  0x5D, 0x5E, 0x5F, 0x60, 0x61};void base64_encode(char raw[], char encode[]){int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){encode[i_] = base64_table[raw[i] &gt;&gt; 2];encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1]) &gt;&gt; 4)];encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] ) &gt;&gt; 6)];encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];}if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}return;}int Findindex(char c){for (int i = 0; i &lt; strlen(base64_table); ++i){if (c == base64_table[i])return i;}}void base64_decode(char* encode, char* decode){int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;int i = 0, i_ = 0;for (; i &lt; encode_len; i_ += 4, i += 3){decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);decode[i + 2] = ((Findindex(encode[i_ + 2]) &amp; 0x3) &lt;&lt; 6) | ((Findindex(encode[i_ + 3])));}decode[decode_len] = 0;return;}int main(){char raw[] = ";'&gt;B&lt;76\\=82@-8.@=T\"@-7ZU:8*F=X2J&lt;G&gt;@=W^@-8.@9D2T:49U@1aa";char encode[100] = { 0 };char decode[100] = { 0 };/*base64_encode(raw, encode);printf("%s", encode);*/base64_decode(raw, decode);printf("%s", decode);}</code></pre><h1 id="creakme3"><a href="#creakme3" class="headerlink" title="creakme3"></a>creakme3</h1><h2 id="考点：猴子排序"><a href="#考点：猴子排序" class="headerlink" title="考点：猴子排序"></a>考点：猴子排序</h2><h2 id="做题过程-2"><a href="#做题过程-2" class="headerlink" title="做题过程"></a>做题过程</h2><p>开始用7.0无法反编译，使用7.5就行</p><p><img src="/2022/02/13/hgame2022-week3-re/1644827237787.png"></p><p>因为要满足for的第二个条件，所以就是进行排序，rand这一步是为了限制数组内的值小于88，而第二个条件是以偶数下标作为索引，前一个要大于后一个，所以使用结构体数组</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;struct data{int asc;int num;};struct data a[89]={{48,20093},{48,26557},{48,31304},{48,33442},{48,37694},{49,39960},{50,23295},{50,27863},{50,42698},{50,48505},{50,52925},{51,12874},{51,12946},{51,14597},{51,17041},{51,23262},{51,28319},{51,42282},{51,48693},{51,52067},{53,32571},{56,14612},{56,45741},{57,14554},{57,20048},{57,27138},{57,45327},{66,30949},{95,32502},{95,35235},{95,36541},{95,38371},{97,29658},{100,21388},{100,25403},{100,40604},{100,46987},{100,51302},{101,12974},{101,30329},{102,10983},{102,19818},{102,22280},{102,26128},{102,41560},{102,47116},{102,51333},{103,28938},{103,31988},{104,16246},{104,28715},{104,41966},{104,44368},{104,47815},{105,16420},{105,35362},{105,49237},{106,11090},{106,50823},{107,24320},{107,50199},{108,24962},{109,30171},{110,15457},{110,18838},{110,24001},{111,11638},{111,32023},{111,43291},{112,39661},{114,17872},{114,33895},{114,43869},{115,20611},{115,25122},{115,36243},{115,37434},{115,38686},{115,46266},{115,51077},{116,13656},{116,34493},{116,38712},{117,14096},{117,38777},{119,12095},{119,17629},{123,30945},{125,40770}};int main(){for (int i = 0; i &lt; 89; ++i){for (int j = i + 1; j &lt; 89; ++j){if (a[i].num &gt;= a[j].num){struct data tmp = a[i];a[i] = a[j];a[j] = tmp;}}}for (int i = 0; i &lt; 89; ++i){printf("%c", a[i].asc);}return 0;}</code></pre><h1 id="fishman"><a href="#fishman" class="headerlink" title="fishman"></a>fishman</h1><h2 id="考点：pyd逆向、Blowfish分组加密算法"><a href="#考点：pyd逆向、Blowfish分组加密算法" class="headerlink" title="考点：pyd逆向、Blowfish分组加密算法"></a>考点：pyd逆向、Blowfish分组加密算法</h2><h2 id="做题过程-3"><a href="#做题过程-3" class="headerlink" title="做题过程"></a>做题过程</h2><p>附件给了一个pyd文件，pyd文件是python的动态库，拖进ida分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644835618562.png"></p><p>使用Findcrypt插件查看发现是Blowfish加密算法</p><p>Blowfish-<a href="https://www.cnblogs.com/iBinary/p/14883752.html">https://www.cnblogs.com/iBinary/p/14883752.html</a></p><p><img src="/2022/02/13/hgame2022-week3-re/1644835958154.png"></p><p>加密后的数据</p><p>可以动调得到S盒和P盒的数据再写脚本，也可以不用，在string发现一个类似key的字符串</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836282247.png"></p><h3 id="pyd动调"><a href="#pyd动调" class="headerlink" title="pyd动调"></a>pyd动调</h3><p><img src="/2022/02/13/hgame2022-week3-re/1644836332456.png"></p><p>这是里面的一些函数，init初始化，check检查字符串</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836466799.png"></p><p>cp后面是python的版本，这里是3.9，把pyd文件修改名称为fishman.pyd，放入D:\python3.9\Lib\site-packages\</p><p>脚本</p><pre class="language-python" data-language="python"><code class="language-python">import fishmanimport osprint(os.getpid())flag=input("input your flag here:")fishman.init()print(fishman.check(flag))</code></pre><p><img src="/2022/02/13/hgame2022-week3-re/1644836396140.png"></p><p>下好断点开启调试</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836650927.png"></p><p>这是线程，去ida，attach to process</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836705113.png"></p><p>注意要先在ida下好断点</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836779973.png"></p><p>停在了dll文件，要F9继续运行</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836830306.png"></p><p>这里处于Running状态，回去python程序，F8单步步过</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836868323.png"></p><p>回到ida分析</p><p><img src="/2022/02/13/hgame2022-week3-re/1644836914886.png"></p><p>停在了这里，这时候已经完成对S盒和P盒的初始化，找到后提取出来即可</p><p>贴一下大佬的脚本</p><p>blowfish.cpp</p><pre class="language-c" data-language="c"><code class="language-c">#include"blowfish_head.h"#include&lt;stdio.h&gt;//变换后的P盒unsigned long pbx[18] ={0x6af74079, 0xc87db4da, 0x064b77a4, 0x33a56687, 0x73924432, 0x3a78e859, 0xa0f9451e, 0x6e99ea5f, 0xcb62f79c,0xec009d50, 0x46b85709, 0x3b2bfdf6, 0xd0a0f937, 0x67c4c3e1, 0x80d02257, 0x4162d4de, 0x814dce61, 0x227bde9b};//变换后的S盒unsigned long sbx[4][256] ={{ 0x857e5597, 0x326dad20, 0x2d507f8e, 0x2b80ba2c, 0xd711e661, 0x4b7e9667, 0x7a4b2509, 0x5117c0a3, 0x537791d2,0xbda0ec99, 0x9f5d600, 0x97d7453e, 0x6c3dede1, 0xefbec2ec, 0x31f20650, 0x86ea7ee1, 0x4a380c4e, 0x688500c0,0xc939e94b, 0xee64fe1f, 0xdae4a7bd, 0xafdfe274, 0xef95a497, 0xca5e8fc8, 0xa16220a, 0x9c85d82f, 0x3f411e1f,0x199cd133, 0x52ecbaa8, 0x68886557, 0xf8d4ca71, 0x729c0def, 0x5d6d4eb4, 0x550b9697, 0x77a9b569, 0xae8aacd5,0xa48c80d0, 0xb171f834, 0xd6828c5f, 0xf5219b37, 0x260e8a36, 0x9a8fbeba, 0xdf6ca01, 0x5f5ee56f, 0xc2e21a2f,0x87d75493, 0x87ef74ef, 0xfe01a2da, 0x8326e260, 0x7b3f0f, 0xc21ab19, 0x589f28be, 0x9ff0636, 0x2ac6affc, 0xb8e547d,0x91fa13e2, 0xde9a211f, 0x70b95314, 0x5879cad1, 0x8d38aa78, 0xffae559e, 0x132d25af, 0x4244c5f1, 0x7831cb8d,0x5625d8a2, 0xa99878b6, 0x44dfa664, 0x5b4e43c7, 0xfde79c18, 0xa8f89efb, 0x96a65669, 0xfa7ec977, 0x6438138b,0x63098e28, 0x7048ba4b, 0xc6f0e94, 0xabc7ae87, 0xdce4560, 0x2ee85291, 0xa7e24dd8, 0xdf0b5970, 0x3d8fcbe5,0x55b43ae4, 0x9eceee50, 0x6542e890, 0x4f70b16b, 0x778b58dc, 0xf3f830e4, 0x1b9d5867, 0x7076b41c, 0x6b8386de,0x8b148ce, 0x31c2fb7d, 0x42fe87c5, 0x108eb334, 0x7c40206, 0x2f783c90, 0xe593491f, 0x2b4ace07, 0xeba73a3c,0x44fa6586, 0x56ed2871, 0xd9b3ed4f, 0xb04d3c81, 0x93c1656c, 0xc8044fcb, 0x127ff622, 0x159d9dcf, 0x2fc79936,0x8549ee27, 0x262156cb, 0x721d3364, 0xf5a6f15e, 0x7fe8b137, 0x6cb075da, 0xfaa54cf4, 0x634519ec, 0xde79d57d,0x8b728797, 0x4b994f3e, 0x242eb5e6, 0x274f5cec, 0xc0f072e0, 0xb6928b6f, 0x8922972b, 0x2207de1e, 0xc0236ffa,0xc9dca5e5, 0x8d1286f, 0x90729fa3, 0x6a6ed134, 0x4369fae7, 0xf9ae5610, 0x13398b9e, 0xfdd59299, 0x21a3a98b,0xae6a4a80, 0x6b6e89a6, 0xce85be83, 0xda4c3800, 0x867af755, 0x26b3fb41, 0x96141cce, 0xf176999a, 0x1d844757,0xe27ce11f, 0x18638c21, 0x960ccbf2, 0xe4ccbbae, 0xaa0fab55, 0xf093bd6f, 0x4cb18fad, 0xf27853df, 0x5d5d925b,0xc389a234, 0xa9e9b90b, 0x6f06d9e4, 0xf0389646, 0xc75f5884, 0x9961dd6b, 0x44b1dc6a, 0x7ef092, 0xa4ca52a6,0x5342115d, 0x31d445bb, 0x6cb0b744, 0xd1abcf6, 0x95c6f259, 0xdf719b5d, 0xea51c785, 0xc7303253, 0x1e6a034e,0xf60989f1, 0x93f55b8d, 0xde786239, 0x9d01dfc5, 0xa4cd54ba, 0xfa60804a, 0x3da55ae7, 0x64d673a, 0x5ee1a39c,0x6daa769a, 0xec57802a, 0x7acdc0b0, 0xcdfedc6d, 0x72cb1321, 0x42d07041, 0xa45aa294, 0xdbf5b287, 0xca681d73,0x8d302710, 0x2b1ad68d, 0xc1c6521d, 0x4f40a81c, 0xf4762cb1, 0x8962117f, 0xe33e8bc2, 0xffa7db53, 0xd617f8af,0xd8b1563b, 0x1ed7d3b4, 0x9f998ca6, 0x1c32a736, 0x3513f35f, 0x7a4da8a8, 0x93f43a38, 0x6bf2eac7, 0xfe3041fd,0x8853f184, 0x81c00f3e, 0xc601a409, 0x1ceba826, 0x94bc26cd, 0xd07aaf4e, 0x46884d2, 0x5d4ec036, 0xe5587bf2,0xa3482f3f, 0xdbecc4b2, 0xe5a8e81e, 0x1287e1a3, 0x6e4ef861, 0xb4560ada, 0x5f18f3d5, 0xd9299202, 0xbab5cc00,0x18464f47, 0x58877430, 0xb4335a0a, 0x7a6e33e, 0xe62e23b4, 0x648e0251, 0xdd94b375, 0x719a409f, 0x5d45064d,0x243af927, 0xfbd3ab12, 0xdc74bb88, 0x21a563a8, 0x37b0a314, 0x5da98b1f, 0xfc4d4869, 0xbf0c7320, 0xebf308d3,0x714a3f9a, 0x6606297c, 0x28ff2689, 0xa6779947, 0xfb556d94, 0xb6413de2, 0x21519c0f, 0xb1052485, 0x69c2624b,0xde9cc548, 0xce36df75, 0x5dbfa8a7 },{ 0xaee3df14, 0x399d3136, 0x1c0b3ea1, 0xf8416210, 0x719b0d88, 0x908ce2e5, 0x623e46a2, 0xef7772ec, 0xdbc4da3a,0xe88f6e2e, 0x7fb80562, 0x1a33bfa7, 0xb972b27c, 0xfccb67ab, 0xb53bc933, 0xad99167e, 0x1831a7f0, 0x295e3c91,0x6afb6529, 0xb1d2c1eb, 0x38702ff1, 0xfb03fc16, 0xf85c29e8, 0x154bbcbf, 0xfc10c6d8, 0x1a07656, 0x9ec55090,0x52201a4a, 0x9b0ee83f, 0xe08b560a, 0xaff5a8bc, 0x35c5d6d7, 0x8d1f52f, 0x7b2becf0, 0xaf01ac97, 0x3b8700c9,0xfe56cea4, 0x1c4b14f6, 0xef86351c, 0x27a382c9, 0x28f51829, 0xcdeeee51, 0x3d73d792, 0x152c4a00, 0x7122ccea,0xbe459436, 0x624f6a81, 0xba728d6f, 0xdf7f103d, 0x7faf6a84, 0xd91174e1, 0xef9ca2f5, 0xa0675400, 0x9e0129,0x276f61d4, 0xf6e0bbb, 0x2f5e103d, 0x3d24363f, 0x36f1d769, 0xddabaa4d, 0xbd209d7b, 0x38898cda, 0x59aa0a47,0x3dc28a3b, 0x9374f915, 0x7164635e, 0xa09379f0, 0x462da24e, 0x7a6cd48d, 0xde20ce, 0xeac2f361, 0x9796cbc3,0x2cc87742, 0x2220d2f5, 0xab17e0c2, 0x16cb3b75, 0x5dc0d229, 0x7d14b8c8, 0x86ad060c, 0xfc1ac21c, 0xa25f8e37,0x23e553f1, 0xcfca2eb5, 0xda61f278, 0x7a6d0c2c, 0x10f72c33, 0xb9e7da31, 0xf0271ef1, 0xf6d8d0da, 0xccb9fb54,0x9c16adcc, 0x9c793e5d, 0x308dbae0, 0x8152f53d, 0xb8b02ea8, 0xbb7a73ef, 0x5b52b6e7, 0xda7691a1, 0x6f15166f,0x1bcf2abf, 0xed9eb801, 0xcc07f0d1, 0x30fd146a, 0xed552ed1, 0xfe280048, 0xca519936, 0xc6bb62d3, 0x78eb0ca9,0xde25bf1e, 0x377099d1, 0x9e3d9a2a, 0x58d4fdc5, 0x9ef6d4ba, 0x4c4b801c, 0x8d5c098c, 0x84cad315, 0x43b323ca,0xaff0262, 0x2b3be91f, 0xfd49761b, 0x93671206, 0x2460dd5e, 0x1328fc3, 0xa87f6e1a, 0xceebf4dc, 0x21f7d1d6,0x8dafb785, 0x1f058aa4, 0xf636282e, 0xf5d5c6a2, 0xdcb85ea1, 0xea4ce0f2, 0xb37fcdaa, 0xadb4cd12, 0xa51b34b3,0xb2aa712e, 0xa15f5bd, 0x617f127c, 0x7a5dbd16, 0x8aee5420, 0x4d0af701, 0xb2e113d9, 0xb4d09dcb, 0xd258e319,0x704ec155, 0x533c80be, 0x400c952d, 0xc0dd74a1, 0xa9e5599f, 0xada9e64, 0xa775ef10, 0x35abb495, 0x238b1eb3,0x5c8ea9e9, 0xd63ac5e, 0xecb22c6f, 0x836879b, 0xdb4958b0, 0x26606a34, 0x33fa456d, 0x91dc9940, 0xccbd103, 0x644cf9a7,0x80165230, 0xb0e45576, 0x4d28c64d, 0x8d9841cc, 0x3d42c9d1, 0x6fce26aa, 0xe5bd6421, 0xd0e1eb58, 0xfd61f403,0xdeff165, 0xd5a1bfb1, 0xb3323bbe, 0xdb641c02, 0xbfca7536, 0xb8f5820f, 0xda30db7b, 0xd76a9581, 0x61b8a87f,0x5d8410c2, 0x4b2df093, 0xc96447e9, 0xc4ba2487, 0xb24afc5a, 0x797db008, 0xc362253a, 0xc6bbe115, 0x1cc0ed71,0xabe73320, 0xc4364688, 0x5adef1c2, 0x59af22fb, 0xa9aca101, 0x4b5bac9b, 0xb121e519, 0xd8fcf69e, 0x2f0f0f89,0xef615692, 0xd9fac700, 0x6729f5e, 0x15b5965f, 0x83a0e48a, 0xd80cd549, 0xc85443c6, 0xdb051d9e, 0x8646780f,0x7e1bcd54, 0x7746aafa, 0xbc85c57a, 0x42430bc6, 0x36ab5fb6, 0x92e892ed, 0x87b8897f, 0xefcf526c, 0x6b10f264,0xe72e284, 0x6fe2966, 0x42f18a1f, 0xdff79c2a, 0x77fbe8e7, 0x942c9858, 0x637710f, 0xad12b3b8, 0xcf786ed1, 0xd7cda884,0x2cb1dcf1, 0x94f76ac0, 0xf7c4ebbe, 0x6d5591de, 0x6524ea76, 0x200d037e, 0xeb51ac71, 0x8b37601, 0xc9ac832,0x7721b2a4, 0xca23beee, 0x328c7019, 0xd27fd8c8, 0xc5be7325, 0xe9244524, 0x5b1ea918, 0x74c75201, 0x37621445,0xae75bef7, 0x174937dc, 0xf71c7cef, 0xf41d6ed3, 0x94c2d289, 0x7d68c2f0, 0xbddfcee6, 0x51d86ee8, 0x97379f95,0x4275b8c2, 0xf9b3122c },{ 0x6dbfa6dd, 0x6808c4be, 0x65fb06bd, 0xfde21a89, 0xf4c126b7, 0x438a1cc0, 0x850a843, 0x377114b2, 0x259c0fd,0x5881f166, 0x6e9fa190, 0x899a312e, 0x8001b123, 0x56d91bd5, 0x31b9a6db, 0x5a4f1940, 0x98140dee, 0x73ad8506,0x6649c267, 0x6fd7daa8, 0x682bb9e5, 0x7f9061dc, 0x27732a88, 0xa2755af7, 0x54b1b2ec, 0xc171fe6d, 0x33a31667,0x9afc41e2, 0x396678d5, 0x83cb861, 0xfc473f10, 0x575a023e, 0xfe11cafc, 0xe8ea4057, 0x1289aaa7, 0xa38ef05a,0x502c3f4a, 0xcb0928e9, 0x8d521829, 0x24c29091, 0xc07fbd37, 0x30cad78f, 0xcd8dba45, 0xc8ccbce8, 0xfdaee556,0x2a1fc86f, 0x8206edd4, 0x14c2ec89, 0xf0050d48, 0x31f5c320, 0xa5626fd9, 0x19ca606d, 0x65f46320, 0x43e58985,0xe3f777da, 0x4b9fa89e, 0xf3532d19, 0x1e63ee86, 0xa4c0f1b1, 0x56e691ed, 0xc79b5aa3, 0x1d005b01, 0x7ff86805,0xed4f0ce3, 0x167128ab, 0x96702d6b, 0x6f2cb666, 0x40d6b43d, 0x7f2e27f9, 0x25813783, 0xf06f47fe, 0xa1eb246e,0xe11c9c3f, 0x165237ab, 0xa9719981, 0xe0c072ef, 0xbc1430c8, 0x319018e0, 0x65323013, 0xa6337184, 0xe1c06cf0,0x2c99ecdc, 0xd682f79f, 0x2ebde8d2, 0xbdeca5a8, 0xb85ab458, 0xabc0be15, 0x5ed69b9d, 0x28bf53d3, 0x791d867b,0x86e6a98a, 0xba722e1c, 0x2311281a, 0xc8cce88d, 0x6c2d3743, 0xf868a752, 0xe0b86a8a, 0x70058bb9, 0xba926231,0x86a5a32c, 0x3e907ed6, 0x6f03f61e, 0xa87fbe48, 0xa09e8eaa, 0xdd78f5b, 0x622c29eb, 0x26cce112, 0x57215e0f,0xf9d9b37d, 0xc195133e, 0x703bd721, 0x27f1319b, 0xdccf0b77, 0xb73b7af4, 0xc9f75f9e, 0xf5c62fcb, 0x7293703,0xeed8b98f, 0x4a9bf102, 0x7349d5c7, 0xda6f8b23, 0x34529af2, 0x968579a9, 0x986d4e5f, 0x8d1903a2, 0x8960df2e,0x4dccb15c, 0x6a87f919, 0x8bc8e948, 0x82c8274c, 0x52f8bb80, 0xb3b5512c, 0x6b51a116, 0x16abf8e9, 0x99e48bf6,0xea03be4e, 0xa0766e91, 0x75e2c7e, 0x237be6a5, 0x8c1bd482, 0x473541f5, 0xc4af608b, 0xed686762, 0x1bf0cfc1,0x4844f0ca, 0x6a9a1980, 0x9d01dbf5, 0x10660435, 0x72fb5e04, 0xbf3de5a3, 0x21fbb319, 0xd303ed2f, 0xa30d610a,0x76ff38bb, 0x87136fca, 0xa4d11a77, 0xe6c197fd, 0x4e6bc1d1, 0xf2a87aa9, 0xcc795622, 0xb82be2b4, 0x77487ed2,0x2e7719ad, 0x142854f3, 0xe501258d, 0xb8556c95, 0x4e1a1309, 0x3d74b894, 0xfc1b626d, 0xcff955ec, 0x33bdc46f,0xed6091ef, 0x645f4f02, 0x7707e28a, 0x556f385a, 0xf8758408, 0xb06b762e, 0xa698d074, 0x46147980, 0x22668afc,0xdc1f5fa9, 0x245dc1d5, 0x32c87ded, 0xcfa4f49d, 0x734187b5, 0x700bc670, 0x97beeab3, 0x70f6ad54, 0xf0d6535d,0x76e34811, 0xb734677, 0x7ddbb9d3, 0x2bd695ab, 0xdb2daa29, 0x35c9f605, 0xfc4be706, 0x6e44a54b, 0xa96c5fbe,0x51e51ba6, 0xc4ebe8c7, 0xe103a24a, 0x842b0bac, 0xdfac2d6d, 0x1aed355d, 0xbdeafbde, 0x32338f9d, 0xaa634582,0xe152c83a, 0x84be8504, 0x46291ed, 0x7b863e96, 0xdb6776f8, 0x20f815f2, 0xa82af75d, 0xab76c0f5, 0xd550efa2,0xfd0330f1, 0x22e1fab0, 0x5f4407a3, 0x9b8e9e11, 0xeb1cadde, 0x3d104b1f, 0xc3054713, 0x982eb7fb, 0x543314da,0x13ae6d5d, 0x56594d93, 0x7af9ddb3, 0x5dbd0b3c, 0xeca553d0, 0x5f892e42, 0xdc466104, 0xf3b8fe09, 0xea63cc0e,0xe8187fa1, 0xf587d222, 0x762e3246, 0xe3134afd, 0xc8a909a3, 0x2a1b8843, 0xbcf88b37, 0x106d829d, 0xbc6cb72b,0xba700358, 0x4419c67b, 0x298e5b99, 0x53633710, 0xb4676dfb, 0x5003bfdd, 0x4b1f3fd6, 0xbff5676e, 0xfe221749,0x22769dec, 0xfa874d3f, 0xe3ab93a1, 0x7e7eac49 },{ 0xda47873d, 0xb4067196, 0x35629fff, 0x5f9ba741, 0xfc3b885c, 0x7db96275, 0x4be65d7c, 0xaac5aaff, 0xc48e069f,0xa2b51d88, 0x68efc326, 0x5dc94059, 0xf8fa7b3d, 0xc3e21cc2, 0xa619a16f, 0x46dec824, 0x399fea6, 0x8fc7db62,0x184569be, 0xc5f04731, 0x90c0dea5, 0xc180bf5f, 0xfccbd6c9, 0x49d7a598, 0x96425151, 0xe53c49fb, 0x15713840,0xcea6a8a0, 0x5c360e6b, 0x8278ef53, 0xa45ce852, 0xaf1fa60d, 0xd1d357d4, 0xcac8c677, 0x1258a65b, 0x561cc841,0xe73da602, 0x907e2447, 0xe62e297f, 0x107a743, 0xb0d19719, 0x84bb247a, 0xf8077268, 0xd5f63d60, 0xd9a141de,0x3486e6a4, 0xbe1052bf, 0x5be4fa46, 0xe792c9c8, 0xb9fbf3b0, 0xcfd36c94, 0x726aa896, 0x683cd337, 0x392a533a,0x223657a2, 0xf83da285, 0x16c1a03f, 0x68bdbcf5, 0xada3c5ab, 0x124148a8, 0xe7d2a95c, 0xd11922ac, 0x4c6899fd,0x7d8edf38, 0x118e9247, 0x15c6f2f0, 0x9056dd9f, 0x33520052, 0x7204913c, 0x3171d62d, 0x25d9ff0b, 0x8b629a57,0xc3ea9218, 0x699e2abf, 0xa9ff8e0f, 0x14dd1c3e, 0xee95bbe7, 0xa2e277c9, 0xd3966991, 0xce4fb1c6, 0x62f9c9,0x24bee229, 0xc677cc3e, 0x2163ca36, 0xbf6dd3f1, 0x7ae4222f, 0x4322f038, 0x692542df, 0x6692aca0, 0xf6d4946f,0x89154cfd, 0x9f6a7dbc, 0x104ea9f0, 0x89e3289, 0x87c95990, 0xf945a420, 0xb6a20072, 0x5b630e87, 0x848636c0,0xa48bb210, 0x4d5494bb, 0x7b7fb94f, 0xc48841b7, 0x422a2e4, 0x6d915a09, 0xcdabb5a5, 0xa36a9dd3, 0x2b321655,0xe7bd69cf, 0x8c5a8dd8, 0x74615473, 0x8c143ade, 0x6cb1ce59, 0x4396f842, 0xfccbf901, 0xf39018b0, 0x576ba9f5,0x97aeb15d, 0x6f7df74, 0x30f10bb9, 0x214789d7, 0xdf5edc71, 0xcdd4d413, 0x4e26b481, 0xa96771c4, 0xfbbf9600,0x61b03c10, 0xb41ec41b, 0x50e85e2c, 0x9ae79ae9, 0x1bffa793, 0x18402dde, 0x3a896084, 0x604aca05, 0xf0370269,0x83f6b326, 0xfb64099a, 0xabf943bf, 0xe9aa8b99, 0x54ec3adb, 0xa56b3a46, 0x71c05f89, 0x4a7f1444, 0xdf991094,0x8f5efd28, 0x9ad00ad5, 0x3cbee3c, 0xf5898fc4, 0x692ba57, 0x1928304a, 0x2978de0f, 0x64f85786, 0x62b4f525,0xda78ad05, 0xb3da431b, 0xdde89dde, 0xcc7da3d9, 0xbde46885, 0xd26c42cf, 0xa7850e7c, 0xff3b73d, 0xd60665a5,0x825b2d8c, 0xbce1ba7, 0x12be55de, 0x7cf29faa, 0x71a29eca, 0xbd067b1a, 0x2e33857, 0xf0c7e782, 0x9ac9f181,0x61d9b196, 0x288412eb, 0x756010ba, 0x20f99e06, 0x67e6cb96, 0xd1efb6, 0x1a4dfffb, 0x9d097c31, 0x6890b138,0xa162f385, 0x5038a02a, 0xdcca2edc, 0xd68af382, 0xed5c9bb, 0xe88cf6c4, 0x4c031e98, 0xca08127b, 0xc67a831f,0x306fb3f6, 0x9d7315c5, 0x2c72ae76, 0xdd3b3ecc, 0x2ab71490, 0x6e79ef13, 0xe6aa6316, 0x3729bfbc, 0xa13c9bea,0xa4fa53c, 0xdbafeec6, 0x57a11cc2, 0x8f1be1ba, 0x542a4d3b, 0x8f9c90c4, 0xa2b3ad9f, 0x8951b50, 0xda0641dd,0xd7cdf19b, 0xebe79e9b, 0x7d6ae548, 0x2ae7eb6f, 0x3ebefb7f, 0xb9cf555d, 0x22b46357, 0x963e79b5, 0x81729e6f,0xa0657b30, 0x297d0ea1, 0x2d722676, 0xd7c263c7, 0x8fd31545, 0x74b4d545, 0xc9ddb768, 0xd7af1a95, 0x3b41452d,0xeaa84874, 0x3094af86, 0xc71461f6, 0x8cd49c9b, 0x9d6f96b1, 0x9b45bb4c, 0x58742714, 0x29b19a6a, 0xa85bddc6,0xb1e0cf54, 0xb55e81d4, 0xcb219b85, 0xcea74b66, 0xd28a041e, 0xe28c4803, 0x490de006, 0x19bb91b1, 0x14d67500,0x80243406, 0x1ed8b3e, 0xef5636b3, 0x956f13bd, 0x9ae34304, 0xaea37a2c, 0xc90fe0b9, 0x2301fb8f, 0x55716d77,0xc50297f7, 0x3cabc6a4, 0xa0764bb0, 0xcf38a2a2 } };/*P盒和S盒根据密钥进行变换因为我们直接替换成变换后的P盒和S盒，所以不需要调用*/void getkey(char *keytext){int i = -1, j = 0;unsigned long key[18];while (keytext[++i]);while (i&lt;72) keytext[i++] = 0;memcpy(key, keytext, 72);for (i = 0; i&lt;18; i++) pbx[i] ^= key[i];key[0] = key[1] = 0;for (i = 0; i&lt;18; i += 2){blowfish_encrypt(key, key);memcpy(&amp;pbx[i], key, 8);}for (i = 0; i&lt;4; i++){for (j = 0; j&lt;256; j += 2){blowfish_encrypt(key, key);memcpy(&amp;sbx[i][j], key, 8);}}}void blowfish_encrypt(void *protext, void *ciptext){int i = 0;unsigned long x[2], temp;memcpy(x, protext, 8);for (i = 0; i&lt;16; i++){x[0] ^= pbx[i];x[1] ^= f(x[0]);temp = x[1];x[1] = x[0];x[0] = temp;}temp = x[1];x[1] = x[0];x[0] = temp;x[0] ^= pbx[17];x[1] ^= pbx[16];memcpy(ciptext, x, 8);printf("0x%x,0x%x\n", x[0], x[1]);}void blowfish_decrypt(void *protext, void *ciptext){int i = 0;unsigned long x[2], temp;memcpy(x, ciptext, 8);for (i = 17; i &gt;= 2; i--){x[0] ^= pbx[i];x[1] ^= f(x[0]);temp = x[1];x[1] = x[0];x[0] = temp;}temp = x[1];x[1] = x[0];x[0] = temp;x[0] ^= pbx[0];x[1] ^= pbx[1];memcpy(protext, x, 8);printf("0x%x,0x%x\n", x[0], x[1]);}unsigned long f(unsigned long x){unsigned long a, b, c, d;a = (x &amp; 0xff000000) &gt;&gt; 24;b = (x &amp; 0x00ff0000) &gt;&gt; 16;c = (x &amp; 0x0000ff00) &gt;&gt; 8;d = (x &amp; 0x000000ff) &gt;&gt; 0;return(((sbx[0][a] + sbx[1][b]) ^ sbx[2][c]) + sbx[3][d]);}int main(){char data[] = "abcdefgh";char cipher[]={ 0xBF, 0x4E, 0x6F, 0x54, 0x7B, 0x93, 0xED, 0xB4 };//0x6d616768,0x30447b65//0x7E, 0xA0, 0xD2, 0x82, 0xDD, 0xEF, 0xD3, 0x13-&gt;0x7530795f,0x3465725f//0x0F, 0xAE, 0x09, 0x22, 0x61, 0xDF, 0x4E, 0x59-&gt;0x5f563131,0x336b3131//0x2C, 0x78, 0x33, 0xB9, 0x32, 0xE5, 0x07, 0x1C-&gt;0x7456395f,0x7d6e6f68//blowfish_encrypt(data, cipher);blowfish_decrypt(data, cipher);}</code></pre><p>将多组数据分别代入进行运算，再转为字符串即可，注意小端序</p><p>blowfish_head.h</p><pre class="language-c" data-language="c"><code class="language-c">#ifndef BLOWFISHH#define BLOWFISHH#include&lt;stdlib.h&gt;#include&lt;string.h&gt;void blowfish_encrypt(void*, void*);void blowfish_decrypt(void*, void*);void getkey(char*);unsigned long f(unsigned long);#endif#pragma once</code></pre><h3 id="另一个脚本"><a href="#另一个脚本" class="headerlink" title="另一个脚本"></a>另一个脚本</h3><pre class="language-c" data-language="c"><code class="language-c">#include "BlowFish.h"#include &lt;string.h&gt;#include &lt;stdio.h&gt;// using namespace std;int BlowFishInit(BLOWFISH_CTX* blowCtx, unsigned char* key, unsigned intkeylen){//设置传入的CTX中的SBOX值for (int Row = 0; Row &lt; 4; Row++){for (int Col = 0; Col &lt; 256; Col++){blowCtx-&gt;sbox[Row][Col] = ORIG_S[Row][Col];}}/*设置pbox1.循环18轮2.每轮都设置ctx.pbox值与data ^3.data = *(DWORD*)key[0] key[1].....*/int KeyIndex = 0;for (int index = 0; index &lt; N + 2; index++){unsigned int data = 0;//填充data 将key的字符设置到data当中for (int k = 0; k &lt; 4; k++){//通过移位设置每个字符data = (data &lt;&lt; 8) | key[KeyIndex];KeyIndex++;//如果超出了key长度 那么key要从开始if (KeyIndex &gt;= keylen)KeyIndex = 0;}//否则不满足blowCtx-&gt;pbox[index] = ORIG_P[index] ^ data;}//对一个64位0 进行加密。加密结果的输出设置到pbox[i]与pbox[i+1]中unsigned int Data1 = 0;unsigned int Data2 = 0;for (int i = 0; i &lt; N + 2; i += 2){BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);blowCtx-&gt;pbox[i] = Data1;blowCtx-&gt;pbox[i + 1] = Data2;}//初始化Sboxfor (int i = 0; i &lt; 4; i++){for (int j = 0; j &lt; 256; j += 2){BlowFish_Encry(blowCtx, &amp;Data1, &amp;Data2);blowCtx-&gt;sbox[i][j] = Data1;blowCtx-&gt;sbox[i][j + 1] = Data2;}}return 1;}//unsigned int F(PBLOWFISH_CTX blowCtx, unsigned int Data)//{//// unsigned int a, b, c, d;// /*// 利用位运算 取出下标值// *///// a = (Data &gt;&gt; 24) &amp; 0xFF;// b = (Data &gt;&gt; 16) &amp; 0xFF;// c = (Data &gt;&gt; 8) &amp; 0xFf;// d = Data &amp; 0xFF;////// int TempValue = blowCtx-&gt;sbox[0][a] + blowCtx-&gt;sbox[1][b];// TempValue = TempValue ^ blowCtx-&gt;sbox[2][c];// TempValue = TempValue + blowCtx-&gt;sbox[3][d];// //公式 ((a+b)^c)+d// return TempValue;//}static unsigned long F(BLOWFISH_CTX* ctx, unsigned long x) {unsigned short a, b, c, d;unsigned long y;/* d = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;c = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;b = (unsigned short)(x &amp; 0xFF);x &gt;&gt;= 8;a = (unsigned short)(x &amp; 0xFF);//都可以使用*/a = (x &gt;&gt; 24) &amp; 0xFF;b = (x &gt;&gt; 16) &amp; 0xFF;c = (x &gt;&gt; 8) &amp; 0xFf;d = x &amp; 0xFF;y = ctx-&gt;sbox[0][a] + ctx-&gt;sbox[1][b];y = y ^ ctx-&gt;sbox[2][c];y = y + ctx-&gt;sbox[3][d];return y;}void BlowFish_Encry(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right){unsigned long Xl;unsigned long Xr;unsigned long temp;short i;//加密部分首先将其分为left跟right两组。 每一组分别32位Xl = *left;Xr = *right;for (i = 0; i &lt; N; ++i) {Xl = Xl ^ blowCtx-&gt;pbox[i];Xr = F(blowCtx, Xl) ^ Xr;temp = Xl;Xl = Xr; //交换左右的值。 l = R r= l 继续下一轮循环。总共16轮Xr = temp;}temp = Xl;Xl = Xr; //16轮完毕之后交换变量Xr = temp;Xr = Xr ^ blowCtx-&gt;pbox[N]; //最后进行一次疑或Xl = Xl ^ blowCtx-&gt;pbox[N + 1];*left = Xl;*right = Xr;}void BlowFish_Decrypt(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right){unsigned int Xl = *left;unsigned int Xr = *right;//倒着循环for (int i = N + 1; i &gt; 1; --i){Xl = Xl ^ blowCtx-&gt;pbox[i];Xr = Xr ^ F(blowCtx, Xl);//继续左右交换unsigned int temp = Xl;Xl = Xr;Xr = temp;}//最后一轮继续交换unsigned int temp = Xl;Xl = Xr;Xr = temp;//返还原Xr = Xr ^ blowCtx-&gt;pbox[1];Xl = Xl ^ blowCtx-&gt;pbox[0];//设置变量返回*left = Xl;*right = Xr;}// int main()// {// unsigned int L = 1, R = 2;// BLOWFISH_CTX ctx;// BlowFishInit(&amp;ctx,(unsigned char*)"IBinary",strlen("IBinary"));// BlowFish_Encry(&amp;ctx, &amp;L, &amp;R);// BlowFish_Decrypt(&amp;ctx, &amp;L, &amp;R);// }void main(void) {// unsigned int L = 1, R = 2;unsigned int L1 = 0x546F4EBF, R1 = 0x0B4ED937B;BLOWFISH_CTX ctx;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L1, &amp;R1);printf("%x %x\n", L1, R1);unsigned int L2 = 0x82D2A07E, R2 = 0x13D3EFDD;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L2, &amp;R2);printf("%x %x\n", L2, R2);unsigned int L3 = 0x2209AE0F, R3 = 0x594EDF61;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L3, &amp;R3);printf("%x %x\n", L3, R3);unsigned int L4 = 0x0B933782C, R4 = 0x1C07E532;BlowFishInit(&amp;ctx, (unsigned char*)"LET_U_D", 7);BlowFish_Decrypt(&amp;ctx, &amp;L4, &amp;R4);printf("%x %x\n", L4, R4);}</code></pre><p>BlowFish.h</p><pre class="language-c" data-language="c"><code class="language-c">#pragma once#pragma once/*使用BlowFish进行加解密*///定义全局旧的pbox sbox 都是根据小数来的。#define N 16static const unsigned long ORIG_P[16 + 2] = {0x243F6A88L, 0x85A308D3L, 0x13198A2EL, 0x03707344L,0xA4093822L, 0x299F31D0L, 0x082EFA98L, 0xEC4E6C89L,0x452821E6L, 0x38D01377L, 0xBE5466CFL, 0x34E90C6CL,0xC0AC29B7L, 0xC97C50DDL, 0x3F84D5B5L, 0xB5470917L,0x9216D5D9L, 0x8979FB1BL};static const unsigned long ORIG_S[4][256] = {{ 0xD1310BA6L, 0x98DFB5ACL, 0x2FFD72DBL, 0xD01ADFB7L,0xB8E1AFEDL, 0x6A267E96L, 0xBA7C9045L, 0xF12C7F99L,0x24A19947L, 0xB3916CF7L, 0x0801F2E2L, 0x858EFC16L,0x636920D8L, 0x71574E69L, 0xA458FEA3L, 0xF4933D7EL,0x0D95748FL, 0x728EB658L, 0x718BCD58L, 0x82154AEEL,0x7B54A41DL, 0xC25A59B5L, 0x9C30D539L, 0x2AF26013L,0xC5D1B023L, 0x286085F0L, 0xCA417918L, 0xB8DB38EFL,0x8E79DCB0L, 0x603A180EL, 0x6C9E0E8BL, 0xB01E8A3EL,0xD71577C1L, 0xBD314B27L, 0x78AF2FDAL, 0x55605C60L,0xE65525F3L, 0xAA55AB94L, 0x57489862L, 0x63E81440L,0x55CA396AL, 0x2AAB10B6L, 0xB4CC5C34L, 0x1141E8CEL,0xA15486AFL, 0x7C72E993L, 0xB3EE1411L, 0x636FBC2AL,0x2BA9C55DL, 0x741831F6L, 0xCE5C3E16L, 0x9B87931EL,0xAFD6BA33L, 0x6C24CF5CL, 0x7A325381L, 0x28958677L,0x3B8F4898L, 0x6B4BB9AFL, 0xC4BFE81BL, 0x66282193L,0x61D809CCL, 0xFB21A991L, 0x487CAC60L, 0x5DEC8032L,0xEF845D5DL, 0xE98575B1L, 0xDC262302L, 0xEB651B88L,0x23893E81L, 0xD396ACC5L, 0x0F6D6FF3L, 0x83F44239L,0x2E0B4482L, 0xA4842004L, 0x69C8F04AL, 0x9E1F9B5EL,0x21C66842L, 0xF6E96C9AL, 0x670C9C61L, 0xABD388F0L,0x6A51A0D2L, 0xD8542F68L, 0x960FA728L, 0xAB5133A3L,0x6EEF0B6CL, 0x137A3BE4L, 0xBA3BF050L, 0x7EFB2A98L,0xA1F1651DL, 0x39AF0176L, 0x66CA593EL, 0x82430E88L,0x8CEE8619L, 0x456F9FB4L, 0x7D84A5C3L, 0x3B8B5EBEL,0xE06F75D8L, 0x85C12073L, 0x401A449FL, 0x56C16AA6L,0x4ED3AA62L, 0x363F7706L, 0x1BFEDF72L, 0x429B023DL,0x37D0D724L, 0xD00A1248L, 0xDB0FEAD3L, 0x49F1C09BL,0x075372C9L, 0x80991B7BL, 0x25D479D8L, 0xF6E8DEF7L,0xE3FE501AL, 0xB6794C3BL, 0x976CE0BDL, 0x04C006BAL,0xC1A94FB6L, 0x409F60C4L, 0x5E5C9EC2L, 0x196A2463L,0x68FB6FAFL, 0x3E6C53B5L, 0x1339B2EBL, 0x3B52EC6FL,0x6DFC511FL, 0x9B30952CL, 0xCC814544L, 0xAF5EBD09L,0xBEE3D004L, 0xDE334AFDL, 0x660F2807L, 0x192E4BB3L,0xC0CBA857L, 0x45C8740FL, 0xD20B5F39L, 0xB9D3FBDBL,0x5579C0BDL, 0x1A60320AL, 0xD6A100C6L, 0x402C7279L,0x679F25FEL, 0xFB1FA3CCL, 0x8EA5E9F8L, 0xDB3222F8L,0x3C7516DFL, 0xFD616B15L, 0x2F501EC8L, 0xAD0552ABL,0x323DB5FAL, 0xFD238760L, 0x53317B48L, 0x3E00DF82L,0x9E5C57BBL, 0xCA6F8CA0L, 0x1A87562EL, 0xDF1769DBL,0xD542A8F6L, 0x287EFFC3L, 0xAC6732C6L, 0x8C4F5573L,0x695B27B0L, 0xBBCA58C8L, 0xE1FFA35DL, 0xB8F011A0L,0x10FA3D98L, 0xFD2183B8L, 0x4AFCB56CL, 0x2DD1D35BL,0x9A53E479L, 0xB6F84565L, 0xD28E49BCL, 0x4BFB9790L,0xE1DDF2DAL, 0xA4CB7E33L, 0x62FB1341L, 0xCEE4C6E8L,0xEF20CADAL, 0x36774C01L, 0xD07E9EFEL, 0x2BF11FB4L,0x95DBDA4DL, 0xAE909198L, 0xEAAD8E71L, 0x6B93D5A0L,0xD08ED1D0L, 0xAFC725E0L, 0x8E3C5B2FL, 0x8E7594B7L,0x8FF6E2FBL, 0xF2122B64L, 0x8888B812L, 0x900DF01CL,0x4FAD5EA0L, 0x688FC31CL, 0xD1CFF191L, 0xB3A8C1ADL,0x2F2F2218L, 0xBE0E1777L, 0xEA752DFEL, 0x8B021FA1L,0xE5A0CC0FL, 0xB56F74E8L, 0x18ACF3D6L, 0xCE89E299L,0xB4A84FE0L, 0xFD13E0B7L, 0x7CC43B81L, 0xD2ADA8D9L,0x165FA266L, 0x80957705L, 0x93CC7314L, 0x211A1477L,0xE6AD2065L, 0x77B5FA86L, 0xC75442F5L, 0xFB9D35CFL,0xEBCDAF0CL, 0x7B3E89A0L, 0xD6411BD3L, 0xAE1E7E49L,0x00250E2DL, 0x2071B35EL, 0x226800BBL, 0x57B8E0AFL,0x2464369BL, 0xF009B91EL, 0x5563911DL, 0x59DFA6AAL,0x78C14389L, 0xD95A537FL, 0x207D5BA2L, 0x02E5B9C5L,0x83260376L, 0x6295CFA9L, 0x11C81968L, 0x4E734A41L,0xB3472DCAL, 0x7B14A94AL, 0x1B510052L, 0x9A532915L,0xD60F573FL, 0xBC9BC6E4L, 0x2B60A476L, 0x81E67400L,0x08BA6FB5L, 0x571BE91FL, 0xF296EC6BL, 0x2A0DD915L,0xB6636521L, 0xE7B9F9B6L, 0xFF34052EL, 0xC5855664L,0x53B02D5DL, 0xA99F8FA1L, 0x08BA4799L, 0x6E85076AL },{ 0x4B7A70E9L, 0xB5B32944L, 0xDB75092EL, 0xC4192623L,0xAD6EA6B0L, 0x49A7DF7DL, 0x9CEE60B8L, 0x8FEDB266L,0xECAA8C71L, 0x699A17FFL, 0x5664526CL, 0xC2B19EE1L,0x193602A5L, 0x75094C29L, 0xA0591340L, 0xE4183A3EL,0x3F54989AL, 0x5B429D65L, 0x6B8FE4D6L, 0x99F73FD6L,0xA1D29C07L, 0xEFE830F5L, 0x4D2D38E6L, 0xF0255DC1L,0x4CDD2086L, 0x8470EB26L, 0x6382E9C6L, 0x021ECC5EL,0x09686B3FL, 0x3EBAEFC9L, 0x3C971814L, 0x6B6A70A1L,0x687F3584L, 0x52A0E286L, 0xB79C5305L, 0xAA500737L,0x3E07841CL, 0x7FDEAE5CL, 0x8E7D44ECL, 0x5716F2B8L,0xB03ADA37L, 0xF0500C0DL, 0xF01C1F04L, 0x0200B3FFL,0xAE0CF51AL, 0x3CB574B2L, 0x25837A58L, 0xDC0921BDL,0xD19113F9L, 0x7CA92FF6L, 0x94324773L, 0x22F54701L,0x3AE5E581L, 0x37C2DADCL, 0xC8B57634L, 0x9AF3DDA7L,0xA9446146L, 0x0FD0030EL, 0xECC8C73EL, 0xA4751E41L,0xE238CD99L, 0x3BEA0E2FL, 0x3280BBA1L, 0x183EB331L,0x4E548B38L, 0x4F6DB908L, 0x6F420D03L, 0xF60A04BFL,0x2CB81290L, 0x24977C79L, 0x5679B072L, 0xBCAF89AFL,0xDE9A771FL, 0xD9930810L, 0xB38BAE12L, 0xDCCF3F2EL,0x5512721FL, 0x2E6B7124L, 0x501ADDE6L, 0x9F84CD87L,0x7A584718L, 0x7408DA17L, 0xBC9F9ABCL, 0xE94B7D8CL,0xEC7AEC3AL, 0xDB851DFAL, 0x63094366L, 0xC464C3D2L,0xEF1C1847L, 0x3215D908L, 0xDD433B37L, 0x24C2BA16L,0x12A14D43L, 0x2A65C451L, 0x50940002L, 0x133AE4DDL,0x71DFF89EL, 0x10314E55L, 0x81AC77D6L, 0x5F11199BL,0x043556F1L, 0xD7A3C76BL, 0x3C11183BL, 0x5924A509L,0xF28FE6EDL, 0x97F1FBFAL, 0x9EBABF2CL, 0x1E153C6EL,0x86E34570L, 0xEAE96FB1L, 0x860E5E0AL, 0x5A3E2AB3L,0x771FE71CL, 0x4E3D06FAL, 0x2965DCB9L, 0x99E71D0FL,0x803E89D6L, 0x5266C825L, 0x2E4CC978L, 0x9C10B36AL,0xC6150EBAL, 0x94E2EA78L, 0xA5FC3C53L, 0x1E0A2DF4L,0xF2F74EA7L, 0x361D2B3DL, 0x1939260FL, 0x19C27960L,0x5223A708L, 0xF71312B6L, 0xEBADFE6EL, 0xEAC31F66L,0xE3BC4595L, 0xA67BC883L, 0xB17F37D1L, 0x018CFF28L,0xC332DDEFL, 0xBE6C5AA5L, 0x65582185L, 0x68AB9802L,0xEECEA50FL, 0xDB2F953BL, 0x2AEF7DADL, 0x5B6E2F84L,0x1521B628L, 0x29076170L, 0xECDD4775L, 0x619F1510L,0x13CCA830L, 0xEB61BD96L, 0x0334FE1EL, 0xAA0363CFL,0xB5735C90L, 0x4C70A239L, 0xD59E9E0BL, 0xCBAADE14L,0xEECC86BCL, 0x60622CA7L, 0x9CAB5CABL, 0xB2F3846EL,0x648B1EAFL, 0x19BDF0CAL, 0xA02369B9L, 0x655ABB50L,0x40685A32L, 0x3C2AB4B3L, 0x319EE9D5L, 0xC021B8F7L,0x9B540B19L, 0x875FA099L, 0x95F7997EL, 0x623D7DA8L,0xF837889AL, 0x97E32D77L, 0x11ED935FL, 0x16681281L,0x0E358829L, 0xC7E61FD6L, 0x96DEDFA1L, 0x7858BA99L,0x57F584A5L, 0x1B227263L, 0x9B83C3FFL, 0x1AC24696L,0xCDB30AEBL, 0x532E3054L, 0x8FD948E4L, 0x6DBC3128L,0x58EBF2EFL, 0x34C6FFEAL, 0xFE28ED61L, 0xEE7C3C73L,0x5D4A14D9L, 0xE864B7E3L, 0x42105D14L, 0x203E13E0L,0x45EEE2B6L, 0xA3AAABEAL, 0xDB6C4F15L, 0xFACB4FD0L,0xC742F442L, 0xEF6ABBB5L, 0x654F3B1DL, 0x41CD2105L,0xD81E799EL, 0x86854DC7L, 0xE44B476AL, 0x3D816250L,0xCF62A1F2L, 0x5B8D2646L, 0xFC8883A0L, 0xC1C7B6A3L,0x7F1524C3L, 0x69CB7492L, 0x47848A0BL, 0x5692B285L,0x095BBF00L, 0xAD19489DL, 0x1462B174L, 0x23820E00L,0x58428D2AL, 0x0C55F5EAL, 0x1DADF43EL, 0x233F7061L,0x3372F092L, 0x8D937E41L, 0xD65FECF1L, 0x6C223BDBL,0x7CDE3759L, 0xCBEE7460L, 0x4085F2A7L, 0xCE77326EL,0xA6078084L, 0x19F8509EL, 0xE8EFD855L, 0x61D99735L,0xA969A7AAL, 0xC50C06C2L, 0x5A04ABFCL, 0x800BCADCL,0x9E447A2EL, 0xC3453484L, 0xFDD56705L, 0x0E1E9EC9L,0xDB73DBD3L, 0x105588CDL, 0x675FDA79L, 0xE3674340L,0xC5C43465L, 0x713E38D8L, 0x3D28F89EL, 0xF16DFF20L,0x153E21E7L, 0x8FB03D4AL, 0xE6E39F2BL, 0xDB83ADF7L },{ 0xE93D5A68L, 0x948140F7L, 0xF64C261CL, 0x94692934L,0x411520F7L, 0x7602D4F7L, 0xBCF46B2EL, 0xD4A20068L,0xD4082471L, 0x3320F46AL, 0x43B7D4B7L, 0x500061AFL,0x1E39F62EL, 0x97244546L, 0x14214F74L, 0xBF8B8840L,0x4D95FC1DL, 0x96B591AFL, 0x70F4DDD3L, 0x66A02F45L,0xBFBC09ECL, 0x03BD9785L, 0x7FAC6DD0L, 0x31CB8504L,0x96EB27B3L, 0x55FD3941L, 0xDA2547E6L, 0xABCA0A9AL,0x28507825L, 0x530429F4L, 0x0A2C86DAL, 0xE9B66DFBL,0x68DC1462L, 0xD7486900L, 0x680EC0A4L, 0x27A18DEEL,0x4F3FFEA2L, 0xE887AD8CL, 0xB58CE006L, 0x7AF4D6B6L,0xAACE1E7CL, 0xD3375FECL, 0xCE78A399L, 0x406B2A42L,0x20FE9E35L, 0xD9F385B9L, 0xEE39D7ABL, 0x3B124E8BL,0x1DC9FAF7L, 0x4B6D1856L, 0x26A36631L, 0xEAE397B2L,0x3A6EFA74L, 0xDD5B4332L, 0x6841E7F7L, 0xCA7820FBL,0xFB0AF54EL, 0xD8FEB397L, 0x454056ACL, 0xBA489527L,0x55533A3AL, 0x20838D87L, 0xFE6BA9B7L, 0xD096954BL,0x55A867BCL, 0xA1159A58L, 0xCCA92963L, 0x99E1DB33L,0xA62A4A56L, 0x3F3125F9L, 0x5EF47E1CL, 0x9029317CL,0xFDF8E802L, 0x04272F70L, 0x80BB155CL, 0x05282CE3L,0x95C11548L, 0xE4C66D22L, 0x48C1133FL, 0xC70F86DCL,0x07F9C9EEL, 0x41041F0FL, 0x404779A4L, 0x5D886E17L,0x325F51EBL, 0xD59BC0D1L, 0xF2BCC18FL, 0x41113564L,0x257B7834L, 0x602A9C60L, 0xDFF8E8A3L, 0x1F636C1BL,0x0E12B4C2L, 0x02E1329EL, 0xAF664FD1L, 0xCAD18115L,0x6B2395E0L, 0x333E92E1L, 0x3B240B62L, 0xEEBEB922L,0x85B2A20EL, 0xE6BA0D99L, 0xDE720C8CL, 0x2DA2F728L,0xD0127845L, 0x95B794FDL, 0x647D0862L, 0xE7CCF5F0L,0x5449A36FL, 0x877D48FAL, 0xC39DFD27L, 0xF33E8D1EL,0x0A476341L, 0x992EFF74L, 0x3A6F6EABL, 0xF4F8FD37L,0xA812DC60L, 0xA1EBDDF8L, 0x991BE14CL, 0xDB6E6B0DL,0xC67B5510L, 0x6D672C37L, 0x2765D43BL, 0xDCD0E804L,0xF1290DC7L, 0xCC00FFA3L, 0xB5390F92L, 0x690FED0BL,0x667B9FFBL, 0xCEDB7D9CL, 0xA091CF0BL, 0xD9155EA3L,0xBB132F88L, 0x515BAD24L, 0x7B9479BFL, 0x763BD6EBL,0x37392EB3L, 0xCC115979L, 0x8026E297L, 0xF42E312DL,0x6842ADA7L, 0xC66A2B3BL, 0x12754CCCL, 0x782EF11CL,0x6A124237L, 0xB79251E7L, 0x06A1BBE6L, 0x4BFB6350L,0x1A6B1018L, 0x11CAEDFAL, 0x3D25BDD8L, 0xE2E1C3C9L,0x44421659L, 0x0A121386L, 0xD90CEC6EL, 0xD5ABEA2AL,0x64AF674EL, 0xDA86A85FL, 0xBEBFE988L, 0x64E4C3FEL,0x9DBC8057L, 0xF0F7C086L, 0x60787BF8L, 0x6003604DL,0xD1FD8346L, 0xF6381FB0L, 0x7745AE04L, 0xD736FCCCL,0x83426B33L, 0xF01EAB71L, 0xB0804187L, 0x3C005E5FL,0x77A057BEL, 0xBDE8AE24L, 0x55464299L, 0xBF582E61L,0x4E58F48FL, 0xF2DDFDA2L, 0xF474EF38L, 0x8789BDC2L,0x5366F9C3L, 0xC8B38E74L, 0xB475F255L, 0x46FCD9B9L,0x7AEB2661L, 0x8B1DDF84L, 0x846A0E79L, 0x915F95E2L,0x466E598EL, 0x20B45770L, 0x8CD55591L, 0xC902DE4CL,0xB90BACE1L, 0xBB8205D0L, 0x11A86248L, 0x7574A99EL,0xB77F19B6L, 0xE0A9DC09L, 0x662D09A1L, 0xC4324633L,0xE85A1F02L, 0x09F0BE8CL, 0x4A99A025L, 0x1D6EFE10L,0x1AB93D1DL, 0x0BA5A4DFL, 0xA186F20FL, 0x2868F169L,0xDCB7DA83L, 0x573906FEL, 0xA1E2CE9BL, 0x4FCD7F52L,0x50115E01L, 0xA70683FAL, 0xA002B5C4L, 0x0DE6D027L,0x9AF88C27L, 0x773F8641L, 0xC3604C06L, 0x61A806B5L,0xF0177A28L, 0xC0F586E0L, 0x006058AAL, 0x30DC7D62L,0x11E69ED7L, 0x2338EA63L, 0x53C2DD94L, 0xC2C21634L,0xBBCBEE56L, 0x90BCB6DEL, 0xEBFC7DA1L, 0xCE591D76L,0x6F05E409L, 0x4B7C0188L, 0x39720A3DL, 0x7C927C24L,0x86E3725FL, 0x724D9DB9L, 0x1AC15BB4L, 0xD39EB8FCL,0xED545578L, 0x08FCA5B5L, 0xD83D7CD3L, 0x4DAD0FC4L,0x1E50EF5EL, 0xB161E6F8L, 0xA28514D9L, 0x6C51133CL,0x6FD5C7E7L, 0x56E14EC4L, 0x362ABFCEL, 0xDDC6C837L,0xD79A3234L, 0x92638212L, 0x670EFA8EL, 0x406000E0L },{ 0x3A39CE37L, 0xD3FAF5CFL, 0xABC27737L, 0x5AC52D1BL,0x5CB0679EL, 0x4FA33742L, 0xD3822740L, 0x99BC9BBEL,0xD5118E9DL, 0xBF0F7315L, 0xD62D1C7EL, 0xC700C47BL,0xB78C1B6BL, 0x21A19045L, 0xB26EB1BEL, 0x6A366EB4L,0x5748AB2FL, 0xBC946E79L, 0xC6A376D2L, 0x6549C2C8L,0x530FF8EEL, 0x468DDE7DL, 0xD5730A1DL, 0x4CD04DC6L,0x2939BBDBL, 0xA9BA4650L, 0xAC9526E8L, 0xBE5EE304L,0xA1FAD5F0L, 0x6A2D519AL, 0x63EF8CE2L, 0x9A86EE22L,0xC089C2B8L, 0x43242EF6L, 0xA51E03AAL, 0x9CF2D0A4L,0x83C061BAL, 0x9BE96A4DL, 0x8FE51550L, 0xBA645BD6L,0x2826A2F9L, 0xA73A3AE1L, 0x4BA99586L, 0xEF5562E9L,0xC72FEFD3L, 0xF752F7DAL, 0x3F046F69L, 0x77FA0A59L,0x80E4A915L, 0x87B08601L, 0x9B09E6ADL, 0x3B3EE593L,0xE990FD5AL, 0x9E34D797L, 0x2CF0B7D9L, 0x022B8B51L,0x96D5AC3AL, 0x017DA67DL, 0xD1CF3ED6L, 0x7C7D2D28L,0x1F9F25CFL, 0xADF2B89BL, 0x5AD6B472L, 0x5A88F54CL,0xE029AC71L, 0xE019A5E6L, 0x47B0ACFDL, 0xED93FA9BL,0xE8D3C48DL, 0x283B57CCL, 0xF8D56629L, 0x79132E28L,0x785F0191L, 0xED756055L, 0xF7960E44L, 0xE3D35E8CL,0x15056DD4L, 0x88F46DBAL, 0x03A16125L, 0x0564F0BDL,0xC3EB9E15L, 0x3C9057A2L, 0x97271AECL, 0xA93A072AL,0x1B3F6D9BL, 0x1E6321F5L, 0xF59C66FBL, 0x26DCF319L,0x7533D928L, 0xB155FDF5L, 0x03563482L, 0x8ABA3CBBL,0x28517711L, 0xC20AD9F8L, 0xABCC5167L, 0xCCAD925FL,0x4DE81751L, 0x3830DC8EL, 0x379D5862L, 0x9320F991L,0xEA7A90C2L, 0xFB3E7BCEL, 0x5121CE64L, 0x774FBE32L,0xA8B6E37EL, 0xC3293D46L, 0x48DE5369L, 0x6413E680L,0xA2AE0810L, 0xDD6DB224L, 0x69852DFDL, 0x09072166L,0xB39A460AL, 0x6445C0DDL, 0x586CDECFL, 0x1C20C8AEL,0x5BBEF7DDL, 0x1B588D40L, 0xCCD2017FL, 0x6BB4E3BBL,0xDDA26A7EL, 0x3A59FF45L, 0x3E350A44L, 0xBCB4CDD5L,0x72EACEA8L, 0xFA6484BBL, 0x8D6612AEL, 0xBF3C6F47L,0xD29BE463L, 0x542F5D9EL, 0xAEC2771BL, 0xF64E6370L,0x740E0D8DL, 0xE75B1357L, 0xF8721671L, 0xAF537D5DL,0x4040CB08L, 0x4EB4E2CCL, 0x34D2466AL, 0x0115AF84L,0xE1B00428L, 0x95983A1DL, 0x06B89FB4L, 0xCE6EA048L,0x6F3F3B82L, 0x3520AB82L, 0x011A1D4BL, 0x277227F8L,0x611560B1L, 0xE7933FDCL, 0xBB3A792BL, 0x344525BDL,0xA08839E1L, 0x51CE794BL, 0x2F32C9B7L, 0xA01FBAC9L,0xE01CC87EL, 0xBCC7D1F6L, 0xCF0111C3L, 0xA1E8AAC7L,0x1A908749L, 0xD44FBD9AL, 0xD0DADECBL, 0xD50ADA38L,0x0339C32AL, 0xC6913667L, 0x8DF9317CL, 0xE0B12B4FL,0xF79E59B7L, 0x43F5BB3AL, 0xF2D519FFL, 0x27D9459CL,0xBF97222CL, 0x15E6FC2AL, 0x0F91FC71L, 0x9B941525L,0xFAE59361L, 0xCEB69CEBL, 0xC2A86459L, 0x12BAA8D1L,0xB6C1075EL, 0xE3056A0CL, 0x10D25065L, 0xCB03A442L,0xE0EC6E0EL, 0x1698DB3BL, 0x4C98A0BEL, 0x3278E964L,0x9F1F9532L, 0xE0D392DFL, 0xD3A0342BL, 0x8971F21EL,0x1B0A7441L, 0x4BA3348CL, 0xC5BE7120L, 0xC37632D8L,0xDF359F8DL, 0x9B992F2EL, 0xE60B6F47L, 0x0FE3F11DL,0xE54CDA54L, 0x1EDAD891L, 0xCE6279CFL, 0xCD3E7E6FL,0x1618B166L, 0xFD2C1D05L, 0x848FD2C5L, 0xF6FB2299L,0xF523F357L, 0xA6327623L, 0x93A83531L, 0x56CCCD02L,0xACF08162L, 0x5A75EBB5L, 0x6E163697L, 0x88D273CCL,0xDE966292L, 0x81B949D0L, 0x4C50901BL, 0x71C65614L,0xE6C6C7BDL, 0x327A140AL, 0x45E1D006L, 0xC3F27B9AL,0xC9AA53FDL, 0x62A80F00L, 0xBB25BFE2L, 0x35BDD2F6L,0x71126905L, 0xB2040222L, 0xB6CBCF7CL, 0xCD769C2BL,0x53113EC0L, 0x1640E3D3L, 0x38ABBD60L, 0x2547ADF0L,0xBA38209CL, 0xF746CE76L, 0x77AFA1C5L, 0x20756060L,0x85CBFE4EL, 0x8AE88DD8L, 0x7AAAF9B0L, 0x4CF9AA7EL,0x1948C25CL, 0x02FB8A8CL, 0x01C36AE4L, 0xD6EBE1F9L,0x90D4F869L, 0xA65CDEA0L, 0x3F09252DL, 0xC208E69FL,0xB74E6132L, 0xCE77E25BL, 0x578FDFE3L, 0x3AC372E6L }};#define N 16//定义初始化需要用到的加密结构typedef struct _BLOWFISH_CTX{//定义初始化的pbox 以及 sbox 在程序中进行初始化unsigned int pbox[N + 2]; //总共18unsigned int sbox[4][256];}BLOWFISH_CTX, * PBLOWFISH_CTX;/*初始化函数 此函数功能如下1.接受key 与 keylen参数（当然keylen）可以自己计算2.初始化sbox 将全局的sbox的内容复制到CTX中的sbox中3.初始化pbox pbox的初始化方法如下1.迭代18论。然后每一轮都设置CTX的pbox2.CTX.pbox需要使用全局pbox ^ data3.data是一个四字节整数。其中存储的就是key的四个字节。key = "12345678abc"每一轮中 data = "1234"data = "5678"data = "abc1" //注意这里当超出keylen的时候。 data获取的key要从0开始。。。。*/int BlowFishInit(BLOWFISH_CTX* blowCtx, unsigned char* key, unsigned int keylen);/*F函数F函数是将一个32位数分别进行拆分。 拆分为四组。 每一组都作为sbox的索引值然后进行下列运算(（s1[a] + s2[b]) ^ s3[c]) + s4[d]在编程中sbox是数组是从零开始。 所以s1 对应s[0] s2对应s[1]在编程中总结下公式：temap = s[0][a] + s[1][b]teamp = temp ^ s[2][c]'temp = temp + s[3][d]简单的记住就是 ((a+b) ^ c)+d;当然每个都对应下标为 0 1 2 3 s[0][a] s[1][b] s[2][c] s[3][d]最后返回结果值 return temp*/static unsigned long F(BLOWFISH_CTX* ctx, unsigned long x);//signed int F(PBLOWFISH_CTX blowCtx,unsigned int Data);/*加密函数：首次用在初始化中是对一个64位0进行加密。一次加密八个字节核心思想为 加密左边与右边数据左边数据直接 ^ PBOX右边数据 = 右边数据 ^ f(左边数据）然后进行交换。以上是16轮的交换剩下一轮则是左边 = 左边^PBOX[N+1]右边 = 右边^pbox[N]最后设置相关数值*/void BlowFish_Encry(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right);/*跟加密一样。只不过结果相反步骤如下：首先遍历从最后一轮开始逐次递减最后一轮数据 右边= 右边^PBOX[1] 左边数据 = 左边数据 ^pbox[0]*/void BlowFish_Decrypt(PBLOWFISH_CTX blowCtx, unsigned int* left, unsigned int*right);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Competition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AES</title>
      <link href="/2022/02/08/AES/"/>
      <url>/2022/02/08/AES/</url>
      
        <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>AES属于分组加密算法，即加解密都是使用同一密钥，但是是分为几组进行加密</p><p>明文长度固定为128位的倍数</p><p>密钥长度可以是128、192、256位</p><h1 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h1><p><img src="/2022/02/08/AES/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png"></p><h2 id="初始变换"><a href="#初始变换" class="headerlink" title="初始变换"></a>初始变换</h2><p>这里以16字节为例子</p><p>明文放入矩阵中</p><p><img src="/2022/02/08/AES/1644303811694.png"></p><p>子密钥放入矩阵，这里有省略号是因为后面会根据子密钥进行密钥扩展，初始变换取得是密钥扩展后的第0轮密钥</p><p><img src="/2022/02/08/AES/1644303864629.png"></p><p>明文矩阵和子密钥矩阵进行异或</p><p>对应位置进行逐字节异或</p><p><img src="/2022/02/08/AES/1644304005507.png"></p><h2 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h2><p>AES算法会生成一个Sbox盒用于字节代换</p><p>代换方法：假如某个字节是D4，那么找到D4的位置，xy坐标结合就是代换后的结果，这里为19</p><p><img src="/2022/02/08/AES/1644304381876.png"></p><h2 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h2><p><img src="/2022/02/08/AES/1644304702612.png"></p><h2 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h2><p>将输入的4×4矩阵<strong>左乘</strong>一个给定的4×4矩阵</p><p>这里的+和×和矩阵里面的运算不同，待会介绍</p><p>给定的正矩阵</p><p><img src="/2022/02/08/AES/1644304934448.png"></p><p>过程</p><p><img src="/2022/02/08/AES/1644305201031.png"></p><h3 id="列混合计算"><a href="#列混合计算" class="headerlink" title="列混合计算"></a>列混合计算</h3><p>基于有限域的二维运算</p><h4 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h4><p><img src="/2022/02/08/AES/1644308359054.png"></p><p>要得到第一个数的结果，要先将第一个矩阵的第一行与第二个矩阵的第一列进行乘法，最后相加</p><p>而在列混合中，加法被替换成了异或</p><p>乘法也被修改了</p><p><img src="/2022/02/08/AES/1644308799475.png"></p><p>这里以第一个数为例</p><p>02×d4+03×bf+01×5d+01×30，这里的+是异或</p><p>02×d4过程</p><p>00000010×11010100，因为d4首位是1，所以结果为10101000^00011011,得到10110011</p><p>同理的到第一个数为04</p><h2 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h2><p>每一列进行进行异或操作</p><p><img src="/2022/02/08/AES/1644306385450.png"></p><h2 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h2><p>通过子密钥生成十轮需要的密钥</p><h3 id="i不是4的倍数"><a href="#i不是4的倍数" class="headerlink" title="i不是4的倍数"></a>i不是4的倍数</h3><p>第i列计算公式：</p><p>W[i]=W[i-4]^W[i-1]</p><p><img src="/2022/02/08/AES/1644307284515.png"></p><h3 id="i是4的倍数"><a href="#i是4的倍数" class="headerlink" title="i是4的倍数"></a>i是4的倍数</h3><p>W[i]=W[i-4]^T(W[i-1])</p><p>T函数包括三部分：字循环、字节代换、轮常量异或</p><h4 id="字循环"><a href="#字循环" class="headerlink" title="字循环"></a>字循环</h4><p>将一列中的四个字节循环左移一个字节，即输入[b0,b1,b2,b3]变换成[b1,b2,b3,b0],然后放在一列中</p><p><img src="/2022/02/08/AES/1644307546072.png"></p><h4 id="字节代换-1"><a href="#字节代换-1" class="headerlink" title="字节代换"></a>字节代换</h4><p>对字循环的结果使用S盒进行字节代换</p><p><img src="/2022/02/08/AES/1644307740839.png"></p><h4 id="轮常量异或"><a href="#轮常量异或" class="headerlink" title="轮常量异或"></a>轮常量异或</h4><p>将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。</p><p>轮常量是给定的，因为要生成十个轮密钥，所以有十个轮常量</p><p><img src="/2022/02/08/AES/1644307898552.png"></p><p>过程</p><p><img src="/2022/02/08/AES/1644308032666.png"></p><p>最后，将得到的结果和W[i-4]异或即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tea、XTea、XXTea原理和实现</title>
      <link href="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h1><p>1、特征量（一般是0x9e3779b9，它是黄金分割数和232的乘积），可以替换成其他的值，但是可能会出现问题</p><p>2、主要加密部分进行异或和移位操作（一般都存在&lt;&lt;4、&gt;&gt;5）</p><p>3、key为128bit</p><h1 id="Tea"><a href="#Tea" class="headerlink" title="Tea"></a>Tea</h1><h2 id="加密流程"><a href="#加密流程" class="headerlink" title="加密流程"></a>加密流程</h2><p>数组的奇数下标元素从右侧传入后进行了移位异或和相加操作，最后偶数下标加上上面操作完的值，所以可以把等式右边看成一个常数，这样写逆向脚本好理解</p><p>结束第一步之后，奇数下标元素的偶数下标元素进行置换，再对奇数下标进行相同的加密</p><p>第三步就是sum+=Delta</p><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/OIP-C.jfif"> </p><h2 id="加密代码"><a href="#加密代码" class="headerlink" title="加密代码"></a>加密代码</h2><pre class="language-c" data-language="c"><code class="language-c">int main(){unsigned int Data[8] = { 0 };unsigned int key[4] = { 0 };unsigned int tmp[2] = { 0 };unsigned int sum = 0;unsigned int delta = 0x9e3779b9;for (int i = 0; i &lt; 8; i += 2){tmp[0] = Data[i];tmp[1] = Data[i + 1];        sum=0;for (int i = 0; i &lt; 32; ++i){sum += delta;tmp[0] += ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);tmp[1] += ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);}Data[i] = tmp[i];Data[i + 1] = tmp[i + 1];}return 0;}</code></pre><h3 id="解密代码"><a href="#解密代码" class="headerlink" title="解密代码"></a>解密代码</h3><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;#include &lt;stdio.h&gt;int main(){unsigned int Data[8] = { 0 };unsigned int key[4] = { 0 };unsigned int tmp[2] = { 0 };unsigned int sum = 0;unsigned int delta = 0x9e3779b9;for (int i = 0; i &lt; 8; i += 2){tmp[0] = Data[i];tmp[1] = Data[i + 1];sum = delta*32;for (int i = 0; i &lt; 32; ++i){tmp[1] -= ((tmp[0] &lt;&lt; 4) + key[2]) ^ (tmp[0] + sum) ^ ((tmp[0] &gt;&gt; 5) + key[3]);tmp[0] -= ((tmp[1] &lt;&lt; 4) + key[0]) ^ (tmp[1] + sum) ^ ((tmp[1] &gt;&gt; 5) + key[1]);sum -= delta;}Data[i] = tmp[i];Data[i + 1] = tmp[i + 1];}return 0;}</code></pre><p>解密的时候主要是要找到Key和密文，并且可能会有大小端序的问题</p><h1 id="XTea"><a href="#XTea" class="headerlink" title="XTea"></a>XTea</h1><p>Xtea是Tea的升级版，添加了一些移位和异或操作</p><h2 id="加密流程-1"><a href="#加密流程-1" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/20190112131633-3a396138-1629-1.png"> </p><p>因为加密过程实际上没发生太多变化，就不贴加密和解密的代码了</p><h1 id="XXTea"><a href="#XXTea" class="headerlink" title="XXTea"></a>XXTea</h1><h2 id="加密流程-2"><a href="#加密流程-2" class="headerlink" title="加密流程"></a>加密流程</h2><p> <img src="/2022/02/07/Tea%E3%80%81XTea%E3%80%81XXTea%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/921830_48K7JHRW383FZWR.jpg"> </p><h2 id="加解密代码"><a href="#加解密代码" class="headerlink" title="加解密代码"></a>加解密代码</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9            //固定的一个常量#define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))   //固定的运算void btea(uint32_t *v, int n, uint32_t const key[4])   //v是要加密的两个元素的数组{                                                      //n为数组的长度    uint32_t y, z, sum;                                //无符号整型         unsigned p, rounds, e;                                if (n &gt; 1)            /* Coding Part */       {        rounds = 6 + 52/n;               //固定的得出轮数        sum = 0;                                z = v[n-1];                             do        {            sum += DELTA;                //每次进行叠加            e = (sum &gt;&gt; 2) &amp; 3;          //固定运算            for (p=0; p&lt;n-1; p++)                   {                y = v[p+1];                v[p] += MX;                      z = v[p];                             }            y = v[0];            z = v[n-1] += MX;        }        while (--rounds);    }    else if (n &lt; -1)      /* Decoding Part */    {        n = -n;        rounds = 6 + 52/n;        sum = rounds*DELTA;        y = v[0];        do        {            e = (sum &gt;&gt; 2) &amp; 3;            for (p=n-1; p&gt;0; p--)            {                z = v[p-1];                y = v[p] -= MX;            }            z = v[n-1];            y = v[0] -= MX;            sum -= DELTA;        }        while (--rounds);    }} int main(){    uint32_t v[2]= {1,2};    uint32_t const k[4]= {2,2,3,4};    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密    // v为要加密的数据是两个32位无符号整数  // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位    printf("加密前原始数据：%u %u\n",v[0],v[1]);    btea(v, n, k);    printf("加密后的数据：%u %u\n",v[0],v[1]);    btea(v, -n, k);    printf("解密后的数据：%u %u\n",v[0],v[1]);    return 0;}</code></pre><p>还没实现过，看着流程图不知道怎么入手</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RC4原理和实现</title>
      <link href="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>RC4属于对称密码算法中的流密码加密算法</p><p>密钥长度可变，面向字节操作</p><p>以一个足够大的S表为基础，对表进行非线性变换，产生密钥流</p><p>两次交换过程是为了增加随机性</p><h1 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h1><h2 id="初始化S表"><a href="#初始化S表" class="headerlink" title="初始化S表"></a>初始化S表</h2><p>1、对S表进行先行填充，一般为256字节，且为unsigned类型</p><p>2、用种子密钥填充另一个256字节的K表</p><p>如果种子密钥长度不为256，将循环使用种子密钥对K表进行填充</p><p>3、用 K表对S表进行初始置换</p><h3 id="样例展示"><a href="#样例展示" class="headerlink" title="样例展示"></a>样例展示</h3><p>这里我们假设S表和K表都是7个字节的，密钥为345，填充结果如下</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168199163.png"></p><p>使用K表对S表进行置换</p><pre class="language-c" data-language="c"><code class="language-c">int j = 0;for (int i = 0; i &lt; 7; ++i){j = (j + S[i] + K[i]) % 7;Swap(S[i], S[j]);}</code></pre><p>得到被置换后的S表</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644168394862.png"></p><h2 id="生成密钥流"><a href="#生成密钥流" class="headerlink" title="生成密钥流"></a>生成密钥流</h2><p>作用：为每个待价密的字节生成一个伪随机数，用来异或</p><p>注：S表完成初始化之后，种子密钥将不会再被使用</p><p>使用置换后的S表生成密钥流</p><pre class="language-c" data-language="c"><code class="language-c">int i, j = 0;for (int k = 0; k &lt; strlen(raw); ++k){i = (i + 1) % 7;j = (j + S[i]) % 7;Swap(S[i], S[j]);int t = (S[i] + S[j]) % 7;K[k] = S[t];}</code></pre><h1 id="加密过程-1"><a href="#加密过程-1" class="headerlink" title="加密过程"></a>加密过程</h1><p>密钥流和明文进行异或得到密文</p><h1 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h1><p>加密部分的j是用来打乱的，实现伪随机</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;void Rc4_init(unsigned char* S, unsigned char*K,unsigned char* key, unsigned long len){unsigned char  tmp = 0;for (int i = 0; i &lt; 256; ++i){S[i] = i;K[i] = key[i % len];}int j = 0;for (int i = 0; i &lt; 256; ++i){j = (j + S[i] + K[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;}return;}void Rc4_encrypt(unsigned char* S, unsigned  char* flag,int len){int i = 0, j = 0,t = 0 ;unsigned char key_liu[len] = { 0 };unsigned char tmp = 0;for (unsigned long k = 0; k &lt; len; ++k){i = (i + 1) % 256;j = (j + S[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;t = (S[i] + S[j]) % 256;key_liu[k] = S[t];}for (int i = 0; i &lt; len; ++i){flag[i] ^= key_liu[i];}}int main(){unsigned char S[256] = { 0 };unsigned char K[256] = { 0 };char flag[512] = { 0xB6, 0x94, 0xFA, 0x8F, 0x3D, 0x5F, 0xB2, 0xE0,0xEA, 0x0F, 0xD2, 0x66, 0x98, 0x6C, 0x9D, 0xE7,0x1B, 0x08, 0x40, 0x71, 0xC5, 0xBE, 0x6F, 0x6D,0x7C, 0x7B, 0x09, 0x8D, 0xA8, 0xBD, 0xF3, 0xF6};char key[] = "w0wy0ugot1t";unsigned long Len = strlen(flag);Rc4_init(S, K,(unsigned char*)key, strlen(key));Rc4_encrypt(S, (unsigned char*)flag, Len);printf("%s", flag);return 0;}</code></pre><p>可以不保存密钥流，直接进行异或，逆向的时候我们可以动调得到密钥流，再与密文进行异或就可以得到明文了</p><pre class="language-c" data-language="c"><code class="language-c">void Rc4_encrypt(unsigned char* S, unsigned  char* flag,char*flag1){int len = strlen(flag1);int i = 0, j = 0,t = 0 ;unsigned char tmp = 0;for (unsigned long k = 0; k &lt; len; ++k){i = (i + 1) % 256;j = (j + S[i]) % 256;tmp = S[i];S[i] = S[j];S[j] = tmp;t = (S[i] + S[j]) % 256;flag[k] ^= S[t];}}</code></pre><p>分别看一下加密过程的逆向代码</p><p>直接异或，动调根据存储的寄存器进行提取</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, char *a3){  unsigned int v3; // eax  unsigned __int8 v4; // ST2B_1  __int64 result; // rax  unsigned int v6; // [rsp+30h] [rbp-10h]  unsigned int i; // [rsp+34h] [rbp-Ch]  int v8; // [rsp+38h] [rbp-8h]  signed int v9; // [rsp+3Ch] [rbp-4h]  unsigned __int8 *v10; // [rsp+50h] [rbp+10h]  unsigned __int8 *v11; // [rsp+58h] [rbp+18h]  v10 = a1;  v11 = a2;  v6 = strlen(a3);  v9 = 0;  v8 = 0;  for ( i = 0; ; ++i )  {    result = v6;    if ( v6 &lt;= i )      break;    v9 = (unsigned __int8)(((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24) + v9 + 1) - ((unsigned int)((v9 + 1) &gt;&gt; 31) &gt;&gt; 24);    v3 = (unsigned int)((v8 + v10[v9]) &gt;&gt; 31) &gt;&gt; 24;    v8 = (unsigned __int8)(v3 + v8 + v10[v9]) - v3;    v4 = v10[v9];    v10[v9] = v10[v8];    v10[v8] = v4;    v11[i] ^= v10[(unsigned __int8)(v10[v9] + v10[v8])];  }  return result;}</code></pre><p>先保存再异或</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall Rc4_encrypt(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3){  void *v3; // rsp  char *v4; // rax  signed __int64 i; // rdx  unsigned int v6; // eax  __int64 result; // rax  __int64 v8; // [rsp+0h] [rbp-30h]  __int64 *v9; // [rsp+8h] [rbp-28h]  __int64 v10; // [rsp+10h] [rbp-20h]  int v11; // [rsp+1Ch] [rbp-14h]  unsigned int k; // [rsp+20h] [rbp-10h]  unsigned int j; // [rsp+24h] [rbp-Ch]  unsigned int v14; // [rsp+28h] [rbp-8h]  unsigned int v15; // [rsp+2Ch] [rbp-4h]  unsigned __int8 *v16; // [rsp+58h] [rbp+28h]  v16 = a2;  v15 = 0;  v14 = 0;  v11 = 0;  v10 = a3 - 1i64;  v3 = alloca(16 * ((unsigned __int64)(a3 + 15i64) &gt;&gt; 4));  v9 = &amp;v8;  LOBYTE(v8) = 0;  v4 = (char *)&amp;v8 + 1;  for ( i = a3 - 2i64; i != -1; --i )    *v4++ = 0;  HIBYTE(v8) = 0;  for ( j = 0; a3 &gt; j; ++j )  {    v15 = (unsigned __int8)(((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24) + v15 + 1)        - ((unsigned int)((signed int)(v15 + 1) &gt;&gt; 31) &gt;&gt; 24);    v6 = (unsigned int)((signed int)(v14 + a1[v15]) &gt;&gt; 31) &gt;&gt; 24;    v14 = (unsigned __int8)(v6 + v14 + a1[v15]) - v6;    HIBYTE(v8) = a1[v15];    a1[v15] = a1[v14];    a1[v14] = HIBYTE(v8);    v11 = (unsigned __int8)(a1[v15] + a1[v14]);    *((_BYTE *)v9 + j) = a1[v11];  }  for ( k = 0; ; ++k )  {    result = k;    if ( (signed int)k &gt;= a3 )      break;    v16[k] ^= *((_BYTE *)v9 + (signed int)k);  }  return result;}</code></pre><p>可以看到密钥流存储在v9，动调之后可以直接提取</p><p>Vs2022生成的exe文件反编译</p><pre class="language-c" data-language="c"><code class="language-c">__int64 __fastcall sub_140015E30(__int64 a1, __int64 a2, char *a3){  __int64 result; // rax  __int64 v4; // kr00_8  unsigned __int8 v5; // dl  char v6; // STA4_1  int v7; // edx  unsigned int v8; // [rsp+24h] [rbp+4h]  int v9; // [rsp+44h] [rbp+24h]  int v10; // [rsp+64h] [rbp+44h]  unsigned int i; // [rsp+C4h] [rbp+A4h]  __int64 v12; // [rsp+1C0h] [rbp+1A0h]  __int64 v13; // [rsp+1C8h] [rbp+1A8h]  const char *Str; // [rsp+1D0h] [rbp+1B0h]  Str = a3;  v13 = a2;  v12 = a1;  sub_140011361(&amp;unk_14002200E);  v8 = j_strlen(Str);  v9 = 0;  v10 = 0;  for ( i = 0; ; ++i )  {    result = v8;    if ( i &gt;= v8 )      break;    v4 = v9 + 1;    v9 = (BYTE4(v4) + v9 + 1) - BYTE4(v4);    v5 = (*(v12 + v9) + v10) &gt;&gt; 31;    v10 = (v5 + *(v12 + v9) + v10) - v5;    v6 = *(v12 + v9);    *(v12 + v9) = *(v12 + v10);    *(v12 + v10) = v6;    v7 = (*(v12 + v10) + *(v12 + v9)) &gt;&gt; 31;    *(v13 + i) ^= *(v12 + (v7 + *(v12 + v10) + *(v12 + v9)) - v7);  }  return result;}</code></pre><p>看着跟别的不一样</p><h1 id="题目——BUU-GUET-CTF2019-encrypt"><a href="#题目——BUU-GUET-CTF2019-encrypt" class="headerlink" title="题目——BUU-[GUET-CTF2019]encrypt"></a>题目——BUU-[GUET-CTF2019]encrypt</h1><p>拖进ida，对一些变量和函数名进行识别和改名</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644325364867.png"></p><p>点进加密函数进行查看</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339350075.png"></p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339358773.png"></p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339366532.png"></p><p>整体就是先RC4，然后将加密后的三个字符变为四个字符</p><p>逆向过来先将四个字符转为三个字符，然后直接将转换后的结果和密钥流进行异或得到明文</p><p>密钥流可以通过动调得到</p><p><img src="/2022/02/06/RC4%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/1644339479964.png"></p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){char raw[52]={0x5a,    0x60, 0x54, 0x7A, 0x7A, 0x54, 0x72, 0x44, 0x7C, 0x66, 0x51, 0x50, 0x5B, 0x5F, 0x56, 0x56, 0x4C,    0x7C, 0x79, 0x6E, 0x65, 0x55, 0x52, 0x79, 0x55, 0x6D, 0x46, 0x6B, 0x6C, 0x56, 0x4A, 0x67, 0x4C,    0x61, 0x73, 0x4A, 0x72, 0x6F, 0x5A, 0x70, 0x48, 0x52, 0x78, 0x49, 0x55, 0x6C, 0x48, 0x5C, 0x76,    0x5A, 0x45, 0x3D};char decode[39]={0};for(int i=0;i&lt;52;++i){raw[i]-=61;}for(int i=0,i_=0;i&lt;52;i+=4,i_+=3){decode[i_]=((raw[i])&lt;&lt;2)|((raw[i+1])&gt;&gt;4);decode[i_+1]=((raw[i+1]&amp;0xf)&lt;&lt;4)|((raw[i+2]&amp;0x3c)&gt;&gt;2);decode[i_+2]=((raw[i+2]&amp;0xF)&lt;&lt;6)|(raw[i+3]);}char v[90]={0x10,0x59,0x9C,0x92,0x06,0x22,0xCF,0xA5,0x72,0x1E,0x45,0x6A,0x06,0xCB,0x08,0xC3,0xE4,0x49,0x5A,0x63,0x0C,0xDF,0xF6,0x5F,0x08,0x28,0xBD,0xE2,0x10,0x15,0x1F,0x6E,0xAA,0x5A,0xCA,0xEC,0x80,0xAF,0x9B,0x16,0xBB,0x3D,0x13,0x2F,0x6A,0xA4,0xC7,0x2E,0xBC,0x4B,0x60,0x9A,0xAF,0xE9,0xCE,0xDA,0x67,0x39,0xBA,0x3B,0x85,0xEB,0xD2,0x6B,0xAB,0x06,0x6B,0x10,0x57,0x2C,0x88,0x70,0xF7,0x4F,0xAA,0x7F,0x12,0x47,0xD6,0xDE,0x74,0xB2,0x1D,0xA4,0xD7,0x76,0x9A,0xE0};for(int i=0;i&lt;39;++i){decode[i]^=v[i];}printf("%s",decode);return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>base64实现及细节剖析</title>
      <link href="/2022/02/06/base64%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/"/>
      <url>/2022/02/06/base64%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%BB%86%E8%8A%82%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";void base64_encode(char raw[], char encode[]){int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;int i = 0, i_ = 0;for (; i &lt; code_len; i += 3, i_ += 4){encode[i_] = base64_table[raw[i] &gt;&gt; 2];encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1] &amp; 0xf0) &gt;&gt; 4)];encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] &amp; 0xc0) &gt;&gt; 6)];encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];}if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}return;}int Findindex(char c){for (int i = 0; i &lt; strlen(base64_table); ++i){if (c == base64_table[i])return i;}}void base64_decode(char* encode, char* decode){int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;int i = 0, i_ = 0;for (; i &lt; encode_len; i_ += 4, i += 3){decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);decode[i + 2] = ((Findindex(encode[i_ + 2]) &amp; 0x3) &lt;&lt; 6) | ((Findindex(encode[i_ + 3])));}decode[decode_len] = 0;return;}int main(){char raw[] = "hgame{123456}";char encode[100] = { 0 };char decode[100] = { 0 };base64_encode(raw, encode);printf("%s", encode);base64_decode(encode, decode);printf("\n%s", decode);}</code></pre><h1 id="细节剖析"><a href="#细节剖析" class="headerlink" title="细节剖析"></a>细节剖析</h1><h2 id="编码部分"><a href="#编码部分" class="headerlink" title="编码部分"></a>编码部分</h2><h3 id="记录长度"><a href="#记录长度" class="headerlink" title="记录长度"></a>记录长度</h3><p>首先要先计算长度，base64就是将三个字节扩展为四个字节，所以要分成有余数和整除两种情况</p><pre class="language-c" data-language="c"><code class="language-c">int code_len = strlen(raw);int final_len = 0;if (code_len % 3){final_len = (code_len / 3 + 1) * 4;}elsefinal_len = (code_len / 3) * 4;</code></pre><h3 id="编码部分-1"><a href="#编码部分-1" class="headerlink" title="编码部分"></a>编码部分</h3><p>首先先介绍一下两个工具，&amp;和|，和一些数据做&amp;运算可以取到我们想要的位，而|运算可以将两部分结合在一起</p><p>编码后的索引最多为六位，原先的数据可以是八位的</p><h4 id="encode-i"><a href="#encode-i" class="headerlink" title="encode[i]"></a>encode[i]</h4><p>这个其实是最好实现的，因为只需要取到前六位，所以直接&gt;&gt;2就可以实现</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_] = base64_table[raw[i] &gt;&gt; 2];</code></pre><h4 id="encode-i-1"><a href="#encode-i-1" class="headerlink" title="encode[i+1]"></a>encode[i+1]</h4><p>先明确我们的需求，从第一个数据获取最后的两位与第二个数据获取的前四位结合。需要用到&amp;，这里的结合就需要用到|。</p><p>首先要保证我们取到的是两位的，需要&amp;0x03</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>因为只有最后两位是1，根据按位&amp;，当有一个是0时运算后结果必定为0，所以就可以取到最后两位</p><p>下一步是移到正确的位置，需要用到位移运算符</p><p>这里第一个数的最后两位编码后是放在前面两位的位置，所以需要&lt;&lt;4</p><p>接下来取剩余的四位</p><p>剩余的四位来自第二个数的前四位</p><p>可以先&amp;0xf0使得后四位都为0，当然也可以不用，直接&gt;&gt;4</p><p>最后使用|结合起来</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td>与</td><td>运</td><td>算</td><td></td></tr><tr><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 1] = base64_table[((raw[i] &amp; 0x03) &lt;&lt; 4) | ((raw[i + 1]) &gt;&gt; 4)];</code></pre><h4 id="encode-i-2"><a href="#encode-i-2" class="headerlink" title="encode[i+2]"></a>encode[i+2]</h4><p>要用到第二个数据的后四位和第三个数据的前两位</p><p>同理，要保留第二个数据的后四位并且去除前四位，就需要&amp;0xf，移到正确的位置&lt;&lt;2，剩余两位留给第三个数据的前两位</p><p>要取到第三个数据的前两位</p><p>可以直接&gt;&gt;6保证前两位移动到最后的两位，也可以先用&amp;0xc0清除后四位，因为是00110000，最后结合起来就可以了</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 2] = base64_table[((raw[i + 1] &amp; 0x0f) &lt;&lt; 2) | ((raw[i + 2] ) &gt;&gt; 6)];</code></pre><h4 id="encode-i-3"><a href="#encode-i-3" class="headerlink" title="encode[i+3]"></a>encode[i+3]</h4><p>只需要取到第三个数据的后六位就可以了</p><p>直接&amp;0x3f，因为0x3f的二进制是00111111</p><pre class="language-c" data-language="c"><code class="language-c">encode[i_ + 3] = base64_table[raw[i + 2] &amp; 0x3f];</code></pre><h4 id="填加"><a href="#填加" class="headerlink" title="填加="></a>填加=</h4><p>如果编码前的数据长度%3不等于0，需要使用=填充</p><p>如果多出一位的话，根据经过上述过程会变成两位，所以最后两位需要用到=来填充</p><p>多出两位，经过上述过程变成三位，所以只需填充最后一位为=</p><pre class="language-c" data-language="c"><code class="language-c">if (code_len % 3 == 1){encode[i_ - 1] = '=';encode[i_ - 2] = '=';}else if (code_len % 3 == 2){encode[i_ - 1] = '=';}</code></pre><h3 id="解码部分"><a href="#解码部分" class="headerlink" title="解码部分"></a>解码部分</h3><p>六位还原为八位</p><h4 id="去除"><a href="#去除" class="headerlink" title="去除="></a>去除=</h4><p>先计算解码后的长度，每四个对应三个，最后减去=的长度</p><pre class="language-c" data-language="c"><code class="language-c">int decode_len=0;int encode_len = strlen(encode);if (strstr(encode, "=="))decode_len = (encode_len / 4) * 3 - 2;else if (strstr(encode, "="))decode_len = (encode_len / 4) * 3 - 1;elsedecode_len = (encode_len / 4) * 3;</code></pre><h4 id="decode-i"><a href="#decode-i" class="headerlink" title="decode[i]"></a>decode[i]</h4><p>其实和上面过程正好相反，取第一个编码数据的后六位（因为前两位是填充的0）和第二个编码数据的前两位，在此之前需要先去除前两位填充的0，所以要&amp;0x30，根据上面的过程，我们需要的是00110000，正好是0x30</p><p>再用|结合</p><pre class="language-c" data-language="c"><code class="language-c">decode[i] = (Findindex(encode[i_]) &lt;&lt; 2) | (Findindex(encode[i_ + 1]) &amp; 0x30) &gt;&gt; 4;</code></pre><h4 id="decode-i-1"><a href="#decode-i-1" class="headerlink" title="decode[i+1]"></a>decode[i+1]</h4><p>需要第二个编码数据的后四位和第三个编码数据的前四位，也是需要先去除填充的0</p><p>所以第二个数据&amp;0xf保证取到后四位，&lt;&lt;4移到前四位</p><p>第三个数据&amp;0x3c（00111100）进行去除填充的前两位0以及取到需要的那四位，再&gt;&gt;2，最后使用|结合</p><pre class="language-c" data-language="c"><code class="language-c">decode[i + 1] = ((Findindex(encode[i_ + 1]) &amp; 0xf) &lt;&lt; 4) | ((Findindex(encode[i_ + 2]) &amp; 0x3c) &gt;&gt; 2);</code></pre><h4 id="decode-i-2"><a href="#decode-i-2" class="headerlink" title="decode[i+2]"></a>decode[i+2]</h4><p>第三个编码数据的后两位和第四个编码数据的那六位</p><p>和上述过程类似，就不赘述了</p><h4 id="字符数组结束"><a href="#字符数组结束" class="headerlink" title="字符数组结束"></a>字符数组结束</h4><p>最后记得填加字符数组结束符</p><pre class="language-c" data-language="c"><code class="language-c">decode[decode_len] = 0;</code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>base64还可以魔改，进行变表操作或者在编码过程中参杂异或（Dasctf2022）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件手脱upx变形壳</title>
      <link href="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/"/>
      <url>/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="题目-hgame2022-week2-upx-magic1"><a href="#题目-hgame2022-week2-upx-magic1" class="headerlink" title="题目-hgame2022-week2-upx magic1"></a>题目-hgame2022-week2-upx magic1</h1><p>发现命令行脱壳没用，只能手脱，elf文件没办法使用esp定律，ida手脱</p><p>进入ida</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643878891388.png"></p><p>在第一个call下断点，进行动态调试</p><p>F7单步进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879064585.png"></p><p>到了第二个call再次F7进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879092434.png"></p><p>一路f8</p><p>retn后到</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879119459.png"></p><p>F7进入</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879160619.png"></p><p>有三个向上的跳转</p><p>在第三个跳转之后F4</p><p>一直F8到达程序真正的入口点</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879196863.png"></p><p>此时需要dumpfile</p><p>ALT+F7运行脚本，脚本需要修改后缀为idc</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;idc.idc&gt;#define PT_LOAD              1#define PT_DYNAMIC           2static main(void){         auto ImageBase,StartImg,EndImg;         auto e_phoff;         auto e_phnum,p_offset;         auto i,dumpfile;         ImageBase=0x400000;         StartImg=0x400000;         EndImg=0x0;         if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )  {    if(dumpfile=fopen("D:\\dumpfile2","wb"))//这路可以更改路径    {      e_phoff=ImageBase+Qword(ImageBase+0x20);      Message("e_phoff = 0x%x\n", e_phoff);      e_phnum=Word(ImageBase+0x38);      Message("e_phnum = 0x%x\n", e_phnum);      for(i=0;i&lt;e_phnum;i++)      {         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)                         {                                  p_offset=Qword(e_phoff+0x8);                                 StartImg=Qword(e_phoff+0x10);                                 EndImg=StartImg+Qword(e_phoff+0x28);                                 Message("start = 0x%x, end = 0x%x, offset = 0x%x\n", StartImg, EndImg, p_offset);                                 dump(dumpfile,StartImg,EndImg,p_offset);                                 Message("dump segment %d ok.\n",i);                         }             e_phoff=e_phoff+0x38;      }      fseek(dumpfile,0x3c,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fseek(dumpfile,0x28,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fclose(dumpfile);        }else Message("dump err."); }}static dump(dumpfile,startimg,endimg,offset) {        auto i;        auto size;        size=endimg-startimg;        fseek(dumpfile,offset,0);        for ( i=0; i &lt; size; i=i+1 )         {        fputc(Byte(startimg+i),dumpfile);        }}</code></pre><p>得到dumpfile2，拖进ida得到正常的代码</p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1643879324566.png"></p><h3 id="爆破脚本"><a href="#爆破脚本" class="headerlink" title="爆破脚本"></a>爆破脚本</h3><p>这里要按位与上0xffff，因为这里最后只赋值了最后十六位，所以需要使用&amp;0xffff来限制位数，保证取到最后的十六位</p><p>有时候还存在左移溢出的问题：</p><p><a href="https://blog.csdn.net/u013658041/article/details/78116449">https://blog.csdn.net/u013658041/article/details/78116449</a></p><p><img src="/2022/02/03/ELF%E6%96%87%E4%BB%B6%E6%89%8B%E8%84%B1upx%E5%8F%98%E5%BD%A2%E5%A3%B3/1644069404698.png"></p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt; #include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(){int s[]={0x8d68,0x9d49,0x2a12,0xab1a,0xcbdc,0xb92b,0x2e32,0x9f59,0xddcd,0x9d49,0xa90a,0xe70,0xf5cf,0x5ed5,0x3c03,0x7c87,0x2672,0xab1a,0xa50,0x5af5,0xff9f,0x9f59,0xbd0b,0x58e5,0x3823,0xbf1b,0x78a7,0xab1a,0x48c4,0xa90a,0x2c22,0x9f59,0x5cc5,0x5ed5,0x78a7,0x2672,0x5695};for(int i=0;i&lt;40;++i){for(int j=32;j&lt;=127;++j){int temp=(j&lt;&lt;8)&amp;0xffff;for(int  k=0;k&lt;8;++k){if((temp&amp;0x8000)!=0){temp=((2*temp)^0x1021)&amp;0xffff;}elsetemp=(2*temp)&amp;0xffff;}if(temp==s[i]){printf("%c",j);}}}return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hook</title>
      <link href="/2022/02/03/Hook/"/>
      <url>/2022/02/03/Hook/</url>
      
        <content type="html"><![CDATA[<h1 id="题目-BUUCTF-easystrcmp"><a href="#题目-BUUCTF-easystrcmp" class="headerlink" title="题目-BUUCTF-easystrcmp"></a>题目-BUUCTF-easystrcmp</h1><p>进入主函数</p><p><img src="/2022/02/03/Hook/1643884712406.png"></p><p>看似是一个简单的比较，但是输入之后发现并不对</p><p>应该是做了什么处理，动态调试</p><p>点进strcmp函数</p><p><img src="/2022/02/03/Hook/1643884961802.png"></p><p>发现跳转到了加密函数</p><p>原理分析</p><p>因为存在init段，去查看函数</p><p><img src="/2022/02/03/Hook/1643885017644.png"></p><p>这样可以查看函数列表进行跳转</p><p><img src="/2022/02/03/Hook/1643885047181.png"></p><p>进入off函数</p><p><img src="/2022/02/03/Hook/1643885073169.png"></p><p>第一个函数点进去没发现什么，第二个函数点进去</p><p><img src="/2022/02/03/Hook/1643885101701.png"></p><p>可以看到先把strcmp函数的地址赋值给qword_201090</p><p>然后把sub_6EA函数赋值给off-102028,点进去</p><p><img src="/2022/02/03/Hook/1643885199097.png"></p><p>发现正好是strcmp的地址，所以真正运行起来，函数会跳转到sub_6EA函数中，而不是strcmp函数，这样就实现了一个简单的hook</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include &lt;string.h&gt;int main(){char flag[]="********CENSORED********";char s[]={0x42, 0x09,   0x4A, 0x49, 0x35, 0x43, 0x0A, 0x41, 0xF0, 0x19, 0xE6, 0x0B,   0xF5, 0xF2, 0x0E, 0x0B, 0x2B, 0x28, 0x35, 0x4A, 0x06, 0x3A,   0x0A, 0x4F};  for(int i=0;i&lt;strlen(flag);++i)  {  flag[i]+=s[i];  }  printf("%s",flag);return 0; } </code></pre><p><a href="https://www.cnblogs.com/iBinary/p/7599789.html%E5%85%B7%E4%BD%93%E8%AE%B2%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFHook">https://www.cnblogs.com/iBinary/p/7599789.html具体讲解什么是Hook</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Init初始化</title>
      <link href="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h1><p><a href="https://carrychen.website/2021/05/14/elf-format/">https://carrychen.website/2021/05/14/elf-format/</a></p><p> .init节定义了一个_init函数，用于可执行目标文件开始时的初始化工作。当进入主程序之前，系统先执行.init节的指令代码初始化 </p><h1 id="例题-hgame2022-week2-fakeshell"><a href="#例题-hgame2022-week2-fakeshell" class="headerlink" title="例题-hgame2022-week2-fakeshell"></a>例题-hgame2022-week2-fakeshell</h1><p>先去看看init段进行了什么处理</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870839069.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870867197.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870876729.png"></p><p>在第二个函数发现了处理</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870922345.png"></p><p>查看aHappyh4me交叉引用</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870957940.png"></p><p>可以看到后面还有操作</p><p>定位到加密函数</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643870991851.png"></p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643871002931.png"></p><p>可以知道是rc4加密，密钥在init段被修改了</p><p>写脚本，也可以使用工具CaptfEncoder-win-1.1.0</p><p>得到flag</p><p><img src="/2022/02/03/Init%E5%88%9D%E5%A7%8B%E5%8C%96/1643871135186.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEH原理和例题</title>
      <link href="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/"/>
      <url>/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="WINDOWS下的异常处理"><a href="#WINDOWS下的异常处理" class="headerlink" title="WINDOWS下的异常处理"></a>WINDOWS下的异常处理</h1><h2 id="异常列表"><a href="#异常列表" class="headerlink" title="异常列表"></a>异常列表</h2><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220203125855.jpg"></p><h1 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h1><p><a href="https://www.cnblogs.com/Sna1lGo/p/14732048.html#:~:text=Windows%E4%B8%AD,%E5%88%99%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E3%80%82%E4%BB%8B%E7%BB%8D">https://www.cnblogs.com/Sna1lGo/p/14732048.html#:~:text=Windows%E4%B8%AD,%E5%88%99%E7%9B%B4%E6%8E%A5%E7%A8%8B%E5%BA%8F%E5%B4%A9%E6%BA%83%E3%80%82介绍</a></p><h2 id="题目——hagme2022——week2——creakme2"><a href="#题目——hagme2022——week2——creakme2" class="headerlink" title="题目——hagme2022——week2——creakme2"></a>题目——hagme2022——week2——creakme2</h2><p>在静态分析中，只找到了tea加密算法，直接写脚本解不出来，去查看汇编代码（因为有时候ida没办法识别出一些汇编）</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643864939414.png"></p><p>第一个框对应上上面那句代码，这里按/就会显示出来对应反编译过来的伪代码</p><p>下面两个框的都是没被识别的语句</p><p>在图中位置下断点进行动态调试，会报错</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643865333034.png"></p><p>因为除数不能为0，去看看汇编</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643865908164.png"></p><p>按；写下注释</p><p>开始动态调试</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866006832.png"></p><p>选择yes，发现进入到这段未被反编译的语句</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866024820.png"></p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866787250.png"></p><p>第二次执行到这一段代码，可以看到ecx寄存器的值不是0，不会触发异常</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866890816.png"></p><p>发现没有执行异或，而是继续往下执行，这就是下一步进行的反汇编语句</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643866944920.png"></p><p>因此可以知道，当变量num的最高位为0的时候，会触发异常，这时候系统会交给SEH进行处理，即__try代码</p><p>__except会执行异常后代码</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643867671850.png"></p><p>按空格查看执行顺序</p><p><img src="/2022/02/03/SEH%E5%8E%9F%E7%90%86%E5%92%8C%E4%BE%8B%E9%A2%98/1643867149242.png"></p><p>会发现这样一段独立出来的汇编代码</p><p>所以就可以写脚本，因为是unsigned int，右移31位就能知道最高位了</p><p>脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){    unsigned int tmp1, tmp2;    unsigned int num;    unsigned int init_num=0;    int Buf2[8] = { 0 };    unsigned int key[10] = { 1,2,3,4,5,6,7,8.9,0 };    Buf2[0] = 0x457E62CF;    Buf2[1] = 0x9537896C;    Buf2[2] = 0x1F7E7F72;    Buf2[3] = 0xF7A073D8;    Buf2[4] = 0x8E996868;    Buf2[5] = 0x40AFAF99;    Buf2[6] = 0xF990E34;    Buf2[7] = 0x196F4086;    for (int i = 0; i &lt; 32; i++)    {        init_num += 2654435761;        if ((init_num &gt;&gt;31) == 0)        {            init_num ^= 0x1234567;        }    }//0C78E4D05    for (int j = 0; j &lt; 8; j += 2)    {        tmp1 = Buf2[j], tmp2 = Buf2[j + 1];        num = init_num;        for (int i = 0; i &lt; 32; i++)        {            tmp2 -= (num + key[(num &gt;&gt; 11) &amp; 3]) ^ (tmp1 + ((16 * tmp1) ^ (tmp1 &gt;&gt; 5)));            if ((num&gt;&gt;31) == 0)            {                num ^= 0x01234567;            }            num -= 2654435761;            tmp1 -= (num + key[num &amp; 3]) ^ (tmp2 + ((16 * tmp2) ^ (tmp2 &gt;&gt; 5)));        }        Buf2[j] = tmp1;        Buf2[j + 1] = tmp2;    }    for (int i = 0; i &lt; 8; i++)    {        printf("%x\n", Buf2[i]);    }    printf("%s", Buf2);}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言汇编2</title>
      <link href="/2022/02/02/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%962/"/>
      <url>/2022/02/02/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%962/</url>
      
        <content type="html"><![CDATA[<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VM逆向</title>
      <link href="/2022/01/23/VM%E9%80%86%E5%90%91/"/>
      <url>/2022/01/23/VM%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Dasctf——EasyVm"><a href="#Dasctf——EasyVm" class="headerlink" title="Dasctf——EasyVm"></a>Dasctf——EasyVm</h1><p>一开始有个花指令，是比较常见的永真跳转，先对call指令按u取消定义，将e8改为90，再重新弄成函数就可以了</p><p>先找到加密的函数</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951424173.png"></p><p>点进去看看</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951469199.png"></p><p>这里是base64变种，在最后加了一个异或操作，先把脚本写出来</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);/*while (code[len] != '!' &amp;&amp; code[len] != 0){len++;}*/for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i]^0xa, b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1]^0xb, b64_table) &amp; 0x30) &gt;&gt; 4;str[i_ + 1] = (findIndex(memstr[i + 1]^0xb, b64_table) &amp; 0xf) &lt;&lt; 4 | (findIndex(memstr[i + 2]^0xc, b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2]^0xc, b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3]^0xd, b64_table));}int str_len = (len / 4) * 3 + len % 4;if (len % 4){str_len -= 1;}str[str_len] = 0;return str;}int main(){char code[100] = "";char decode[] = { 0 };base64_decode(code, decode, base64_table);printf("%s", decode);return 0;}</code></pre><p>接下来就是vm的部分</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642951694407.png"></p><p>先看func函数的类型，是指针数组</p><p>这里需要结合动调看每条指令对应的操作</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642953729321.png"></p><p>在这里下断点之后F7进入函数</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642953871966.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955403773.png"></p><p>这就是func数组存放的东西，因为是指针，所以要先按d转为dd才会显示</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955602049.png"></p><p>先把指令提取出来</p><pre class="language-c" data-language="c"><code class="language-c">unsigned char ida_chars[] ={  0xCA, 0x00, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 0x00,  0xCC, 0xCF, 0xC9, 0xEE, 0x00, 0x00, 0x00, 0xCF, 0xD1, 0xD3,  0x01, 0xFE, 0xC2, 0xD2, 0x39, 0x00, 0x00, 0x00, 0xD4, 0xEC,  0xFF, 0x00};</code></pre><p>F8单步调试</p><p>0xCA</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955631076.png"></p><p>0xCB</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955978948.png"></p><p>0xCC</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642955994447.png"></p><p>0xCF</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956392630.png"></p><p>每执行完再进入func[2]都能知道当前位置，便于查看指令</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956568041.png"></p><p>0xc9</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642956806744.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957130761.png"></p><p>0xd1</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957467393.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642957487310.png"></p><p>这里本来赋值为0，1，2，为了保持字符相等的情况，把 this[5]全部赋值为1</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642987459030.png"></p><p>0xd3</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988305784.png"></p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988338522.png"></p><p>0xc2</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988366450.png"></p><p>0xd2</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988655617.png"></p><p>长度判断</p><p>0xd4</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642988824766.png"></p><p>0xcc</p><p>接下来又回到0xcc，所以就能猜测是循环做了异或操作，然后判断</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1642989162099.png"></p><table><thead><tr><th>func[1]</th><th>指令集</th></tr></thead><tbody><tr><td>func[2]</td><td>加密后的flag的字符</td></tr><tr><td>func[3]</td><td>0</td></tr><tr><td>func[4]</td><td>索引</td></tr><tr><td>func[5]</td><td>判断字符相等</td></tr><tr><td>func[6]</td><td>对比的flag</td></tr><tr><td>func[7]</td><td>0</td></tr><tr><td>func[8]</td><td>加密后的字符串</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td>0xca</td><td>先将this[1]指令后的数据存放到this[3]，然后往后跳转5，正好对应了下一条指令,一开始this[1]后一个数据为0，要先转为 dword</td></tr><tr><td></td><td></td></tr><tr><td>0xcb</td><td>先将this[1]指令后的数据存放到this[4]，然后往后跳转5，这也是下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xcc</td><td>把this[2]先赋值为this[8]+this[4]，这里this[4]是个整数，所以猜测this[4]是索引，然后继续执行下一指令</td></tr><tr><td></td><td></td></tr><tr><td>0xcf</td><td>将this[3]和this[2]的值异或后存放在this[3],进入下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xc9</td><td>先把this[1]下一个数据赋值给this[2],进入下一条指令，也就是0xee</td></tr><tr><td></td><td></td></tr><tr><td>0xcf</td><td>将this[3]和this[2]的值异或后存放在this[3],进入下一条指令</td></tr><tr><td></td><td></td></tr><tr><td>0xd1</td><td>根据this[4]的索引来进行字符比较，这里是调试过程，所以为了进行下一步，需要修改汇编指令</td></tr><tr><td></td><td></td></tr><tr><td>0xd3</td><td>v1是指针，解引用是v1下一个位置，也就是0x1，整个就是0xee，这时候然后指向下三个位置，也就是c2指令</td></tr><tr><td></td><td></td></tr><tr><td>0xc2</td><td>索引this[4]+1</td></tr><tr><td></td><td></td></tr><tr><td>0xd2</td><td>this[4]是索引，所以是判断是否结束，这里没结束，所以this[5]赋值为0</td></tr><tr><td></td><td></td></tr><tr><td>0xd4</td><td>ec+2==ee</td></tr></tbody></table><p>整个过程就是这样</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220124125427.jpg"></p><p>因为偶数次的异或等于不变，所以只需对奇数次的进行异或即可</p><p>最终脚本</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;char base64_table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";int findIndex(char c, char b64_table[]){for (int i = 0; i &lt; 64; ++i){if (c == b64_table[i])return i;}}char* base64_decode(char code[], char str[], char b64_table[]){char memstr[200] = { 0 };memcpy(memstr, code, strlen(code));int len = strlen(code);/*while (code[len] != '!' &amp;&amp; code[len] != 0){len++;}*/for (int i = 0, i_ = 0; i &lt; len; i += 4, i_ += 3){str[i_] = (findIndex(memstr[i], b64_table) &lt;&lt; 2) | (findIndex(memstr[i + 1], b64_table) &amp; 0x30) &gt;&gt; 4;str[i_ + 1] = (findIndex(memstr[i + 1], b64_table) &amp; 0xf) &lt;&lt; 4 | (findIndex(memstr[i + 2], b64_table) &amp; 0x3c) &gt;&gt; 2;str[i_ + 2] = (findIndex(memstr[i + 2], b64_table) &amp; 0x03) &lt;&lt; 6 | (findIndex(memstr[i + 3], b64_table));}int str_len = (len / 4) * 3 + len % 4;if (len % 4){str_len -= 1;}str[str_len] = 0;return str;}int main(){char s[] ={  190,  54, 172,  39, 153,  79, 222,  68, 238,  95,  218,  11, 181,  23, 184, 104, 194,  78, 156,  74,  225,  67, 240,  34, 138,  59, 136,  91, 229,  84,  255, 104, 213, 103, 212,   6, 173,  11, 216,  80,  249,  88, 224, 111, 197,  74, 253,  47, 132,  54,  133,  82, 251, 115, 215,  13,0};char s2[] = { 0 };for (int i = 0; i &lt; 56; i+=2){s[i] ^= 0xee;}for (int i = 0; i &lt; 56; ++i){s2[i] = s[i];for (int k = i; k &gt; 0; k--){s2[i] ^= (s2[k - 1]);//该字符前面的全部都要异或上}}//printf("%s", s2);for (int i = 0; i &lt; 56; i = i + 4){s2[i] ^= 0xA;s2[i + 1] ^= 0xB;s2[i + 2] ^= 0xC;s2[i + 3] ^= 0xD;}char decode[] = { 0 };base64_decode(s2, decode, base64_table);printf("%s", decode);return 0;}</code></pre><h1 id="hgame2022-week4-easyvm"><a href="#hgame2022-week4-easyvm" class="headerlink" title="hgame2022-week4-easyvm"></a>hgame2022-week4-easyvm</h1><p>第一次尝试写解释器，跟着别人的大致思路的</p><p>首先VM就是模仿汇编，用指令代替汇编，用数据段来模拟寄存器和数据段，所以我们关键是要找到数据段和操作数、opcode，以及一些数据存放内容的含义</p><p>先来给寄存器重新命名</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447619996.png"></p><p>根据main函数中switch可以找到类寄存器的位置，重命名</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447726404.png"></p><p>从switch的v3可以知道，前面给v3赋值的就是操作数</p><p>r0[0]开始是0，所以操作指令第一个存储的位置是r0[109]，因为是int型，计算的时候×4，就可以找到地址</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447904556.png"></p><p>按g跳转，使用lazyida dump下来</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645447995063.png"></p><p>接下来动调分析每条指令对应的汇编代码</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448145669.png"></p><p>先++，再赋值给它，就相当于push指令的入栈操作，然后还有一个r4后移一位</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448615771.png"></p><p>先–，再赋值给r5，相当于pop操作</p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448764344.png"></p><p>又回到0x12，还是push，但是因为r4++，所以已经后移，我们根据计算也可以找到存储数据的地址并提取出数据</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645448880740.png"></p><p>回到汇编，这里的指令push了-5进入到堆栈，也就是寄存器下面的位置</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449458278.png"></p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449560687.png"></p><p>获取输入，并存储到a1中，这里的a1对应r3</p><table><thead><tr><th>getchar</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645449886162.png"></p><p>熟悉的操作，把输入压入堆栈，记得栈顶往低处移动</p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645450099792.png"></p><p>这里的a1是r2</p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645450235632.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>根据前面的pop r5可以知道此时r5是0A，而我们的输入被存入了r3，也就是对我们的输入字符进行判断，那么r8应该就对应ZF标志位</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645513351201.png"></p><p>验证了上面的想法，这里的a1是r6，也就是-5，指令跳转回去，相当于进行循环，输入完成后会有一个换行符，getchar会吸收，这里也就是结束我们的循环</p><table><thead><tr><th>jnz</th><th>r0-5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>直接在下一条指令下断点，F9运行</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645513742181.png"></p><p>这里的a1是r2，用于记录输入长度，因为最后有一个回车符，所以要–</p><table><thead><tr><th>r2–</th><th></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>根据前面就可以先对数组进行注释</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514228495.png"></p><p>r4没写上去，是内存中存储的一段数据</p><p>继续往下走</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514299405.png"></p><p>将内存段的下一个数据入栈，也就是0x20</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514469709.png"></p><table><thead><tr><th>pop</th><th>r5,这里懒得改了，可以点过去查看</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>接下来是0x12和0x9</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r6</td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514666638.png"></p><p>把r2的值赋给r3</p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514774277.png"></p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645514918356.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>但是这次比较的是字符串的长度，也就是字符串长度是32</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515061894.png"></p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里r6存放的是2f，正好对应结束，所以这段就相当于exit</p><p>下面是0x12和0x09</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r6</td></tr></tbody></table><p>0x12和0x0A</p><p>这是0x0a的代码</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515342308.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>pop</td><td>r2</td></tr></tbody></table><p>0x13</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515472275.png"></p><p>r2此时为0，+9正好是堆栈的位置，也是存放我们输入数据的位置</p><table><thead><tr><th>mov</th><th>r3,stack[count]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>从下面开始就是加密的部分了</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515606892.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0B</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515758080.png"></p><table><thead><tr><th>pop</th><th>r7</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x15</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515807493.png"></p><table><thead><tr><th>add</th><th>r3,r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x03</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515866224.png"></p><table><thead><tr><th>xor</th><th>r3,r7</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645515954359.png"></p><p>把处理完的数据重新放入栈中</p><table><thead><tr><th>mov</th><th>stack[count],r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516003430.png"></p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516131712.png"></p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xF</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516166189.png"></p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516207834.png"></p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>此时的r6是-10，也就是跳转回到前十条指令，这就是循环加密，现在就差最终的密文了，前面加密的部分直接运行过去</p><p>再次来到0x12</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645516848887.png"></p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xA</p><table><thead><tr><th>pop</th><th>r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517151788.png"></p><p>接下来是三个0x12</p><table><thead><tr><th>push</th><th>data[r4++]</th></tr></thead><tbody><tr><td>push</td><td>data[r4++]</td></tr><tr><td>push</td><td>data[r4++]</td></tr></tbody></table><p>到了0x08，此时我们的比较数据已经被压入栈中</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517394177.png"></p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x13，将处理完的值重新从堆栈中取出</p><table><thead><tr><th>mov</th><th>r3,satck[count]</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xF</p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x07</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517670674.png"></p><table><thead><tr><th>pop</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x04</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645517727020.png"></p><table><thead><tr><th>mov</th><th>stack[count],r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x09</p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0D</p><p>r6是0x15，加上之后正好exit，和前面类似，压入栈是因为待会需要多次使用</p><table><thead><tr><th>jnz</th><th>r0+r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这里没有问题就会往下</p><p>0x09</p><table><thead><tr><th>pop</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>此时把-17给到r6</p><p>0x08</p><table><thead><tr><th>pop</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x05</p><table><thead><tr><th>push</th><th>r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x06</p><table><thead><tr><th>push</th><th>r6</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x04</p><table><thead><tr><th>push</th><th>r3</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x01</p><table><thead><tr><th>add</th><th>r2,1</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x00</p><table><thead><tr><th>mov</th><th>r3,r2</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0x0F//长度判断</p><table><thead><tr><th>cmp</th><th>r3,r5</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>0xd，重新进入循环</p><p><img src="/2022/01/23/VM%E9%80%86%E5%90%91/1645518636756.png"></p><h2 id="最终的一些数据和分组和脚本"><a href="#最终的一些数据和分组和脚本" class="headerlink" title="最终的一些数据和分组和脚本"></a>最终的一些数据和分组和脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){int opcode[65] = {    0x00000012, 0x00000008, 0x00000012, 0x00000009, 0x00000010, 0x00000004, 0x00000001, 0x0000000F, 0x0000000D, //接受我们的输入 0x00000002, 0x00000012, 0x00000008, 0x00000012, 0x00000009, 0x00000000, 0x00000004, 0x0000000F, 0x0000000D,//对flag进行存储操作，比较长度，因为getchar最后是32，所以flag长度为32 0x00000012, 0x00000009, 0x00000012, 0x0000000A, 0x00000013, 0x00000012, 0x0000000B, 0x00000015, 0x00000003, 0x00000014, 0x00000001, 0x00000000, 0x0000000F, 0x0000000D, //flag加密，flag[i]*2^3c存储的值     0x00000012, 0x0000000A, 0x00000012, 0x00000012, 0x00000012, 0x00000008, 0x00000013, 0x0000000F, 0x00000007, 0x00000004, 0x00000009, 0x0000000D, 0x00000009, 0x00000008, 0x00000005, 0x00000006, 0x00000004, 0x00000001, 0x00000000, 0x0000000F, 0x0000000D, //字符串比较 0x00000012, 0x00000009, 0x00000012,     0x00000008, 0x00000012, 0x0000000A, 0x00000012, 0x00000007, 0x0000000F, 0x0000000C, 0x00000011, //打印     0x0000000E};unsigned char xor_table[32]={0x5e,0x46,0x61,0x43,0x0e,0x53,0x49,0x1f,0x51,0x5e,0x36,0x37,0x29,0x41,0x63,0x3b,0x64,0x3b,0x15,0x18,0x5b,0x3e,0x22,0x50,0x46,0x5e,0x35,0x4e,0x43,0x23,0x60,0x3b};unsigned char enc[32]={0x8E, 0x88, 0xA3, 0x99, 0xC4, 0xA5, 0xC3, 0xDD,0x19, 0xEC, 0x6C, 0x9B, 0xF3, 0x1B, 0x8B, 0x5B,0x3E, 0x9B, 0xF1, 0x86, 0xF3, 0xF4, 0xA4, 0xF8,0xF8, 0x98, 0xAB, 0x86, 0x89, 0x61, 0x22, 0xC1};unsigned int data[83] = {//用于跳转和判断长度的数     0x0000000A, -5, 0x00000020, 0x0000002F, -10, 0x00000000,     //异或数据 0x0000005E, 0x00000046, 0x00000061, 0x00000043, 0x0000000E, 0x00000053, 0x00000049, 0x0000001F, 0x00000051, 0x0000005E, 0x00000036, 0x00000037, 0x00000029, 0x00000041, 0x00000063, 0x0000003B, 0x00000064, 0x0000003B, 0x00000015, 0x00000018, 0x0000005B, 0x0000003E, 0x00000022, 0x00000050, 0x00000046, 0x0000005E, 0x00000035, 0x0000004E, 0x00000043, 0x00000023, 0x00000060, 0x0000003B, //用于跳转，以及赋值初始索引 0x00000000, -17, 0x00000015, //密文 0x0000008E, 0x00000088, 0x000000A3, 0x00000099, 0x000000C4, 0x000000A5, 0x000000C3, 0x000000DD, 0x00000019, 0x000000EC, 0x0000006C, 0x0000009B, 0x000000F3, 0x0000001B, 0x0000008B, 0x0000005B, 0x0000003E, 0x0000009B, 0x000000F1, 0x00000086, 0x000000F3, 0x000000F4, 0x000000A4, 0x000000F8,0x000000F8, 0x00000098, 0x000000AB, 0x00000086, 0x00000089, 0x00000061, 0x00000022, 0x000000C1, 0x00000002, 0x00000000, -6, 0x00000073, 0x00000075, 0x00000063, 0x00000063,     0x00000065, 0x00000073, 0x00000073};char flag[32]={0};for(int i=0;i&lt;32;++i){enc[i]=(enc[i]^xor_table[i])/2;}printf("%s",enc);return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓知识</title>
      <link href="/2022/01/22/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/01/22/%E5%AE%89%E5%8D%93%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="APK基本结构"><a href="#APK基本结构" class="headerlink" title="APK基本结构"></a>APK基本结构</h1><p><a href="https://www.cnblogs.com/zhaijiahui/p/6916556.html">https://www.cnblogs.com/zhaijiahui/p/6916556.html</a></p><p>因为java语言没办法直接控制硬件，所以要使用C/C++来写代码，保存在so文件中 </p><p>反编译之后是smali代码，动态调试</p><p>assets：存放未编译的资源</p><p>lib：存放so文件，即本地代码</p><p>libs：第三方包</p><p>META-INF：存放签名</p><p>res：编译后的资源</p><p>AndroidManifest.xml：用于存放清单</p><p>.dex文件：反编译后为smali代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言汇编</title>
      <link href="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/"/>
      <url>/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="VC6基础操作"><a href="#VC6基础操作" class="headerlink" title="VC6基础操作"></a>VC6基础操作</h1><p>F7：编译、F5：调试、F9：设置断点、F10：单步步过、F11：单步进入、shift+F5：结束调试</p><p>调试过程打开寄存器窗口和反汇编窗口</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643095481259.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643095520646.png"></p><h1 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h1><p>编译器不会管的函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643097998389.png"></p><p>__declspec(naked) Func()</p><p>调用空的裸函数会出现错误，因为有call，却没有ret</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643123413854.png"></p><p>进入后直接跳到int3，运行程序会报错</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643123914848.png"></p><p>解决这种只需要加入汇编语句ret，在C语言程序加入汇编语句，需要用到__asm{}。也就是说可以自己在里面写汇编代码来实现需求。</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126281063.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126324265.png"></p><p>执行完这段代码，ret回来了</p><h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><table><thead><tr><th>__cdecl（c、c++默认）</th><th>从右至左入栈</th><th>调用者清理栈</th></tr></thead><tbody><tr><td>__stdcall</td><td>从右至左入栈</td><td>自身清理堆栈（内平栈）子函数平衡堆栈</td></tr><tr><td>__fastcall</td><td>ECX/EDX传送前两个，剩下的从右至左，寄存器传递速度更快。当只有两个参数传递进去，不需要平衡堆栈</td><td>自身清理堆栈</td></tr></tbody></table><p>所以不能通过ret来分析函数参数的个数</p><p>__cdecl</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643125931583.png"></p><p>外平栈</p><p>内部只有ret</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126021930.png"></p><p>__stdcall</p><p>右边的参数先入栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126780828.png"></p><p>可以看到这里call之后没有add来回复堆栈平衡，进入调用函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643126852766.png"></p><p>可以看到ret变成了ret 8，这就是内平栈</p><p>__fastcall</p><p>两个参数存放在寄存器</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127369433.png"></p><p>没有修改堆栈，所以不需要add回复堆栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127503312.png"></p><p>有push和mov，外面没有add，进去看</p><p>也是内平栈</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127554833.png"></p><h1 id="参数个数"><a href="#参数个数" class="headerlink" title="参数个数"></a>参数个数</h1><p>公式一：寄存器+ret 4=参数个数</p><p>公式二：寄存器+[esp+8]+[ebp+0x]=参数个数</p><h1 id="寻找程序入口"><a href="#寻找程序入口" class="headerlink" title="寻找程序入口"></a>寻找程序入口</h1><p>callstack，调用窗口</p><p>main是我们写的程序的入口，但是不是真正程序的入口</p><p>因为在main函数之前需要调用如下函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127627555.png"></p><p>在callstack发现这个函数</p><p>Getversion()</p><p>_headp_int()</p><p>GetCommandLineA()</p><p>_crtGetEnvironmentStringA()</p><p>_setargv()</p><p>_setenvp()</p><p>_cinit()  </p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127791606.png"></p><p>main函数具有三个参数，所以要寻找具有三个参数的函数，找三个push，并且调用完会add 0xc</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127884930.png"></p><p>这里很符合</p><p>下断点进入，这里才是main函数</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643127941350.png"></p><h1 id="数据类型与数据存储"><a href="#数据类型与数据存储" class="headerlink" title="数据类型与数据存储"></a>数据类型与数据存储</h1><p>1、存储数据的宽度 </p><p>2、存储数据的格式</p><p>3、作用范围</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>char、int、long、short：字节数1、4、4、2，对应上byte、dword、dword、word，long long在VC6对应__int 64</p><p>只会根据数据宽度进行操作，超出数据宽度的不会做修改</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643188104181.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643128939675.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643128998071.png"></p><p>g存储的只有0x56</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643129038958.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643129130357.png"></p><p>数据窗口是小端序</p><h4 id="有符号与无符号"><a href="#有符号与无符号" class="headerlink" title="有符号与无符号"></a>有符号与无符号</h4><p>C语言默认是有符号数</p><p>在内存中存储时无区别，但是在类型转换、比较大小和数学运算时需要注意</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>float、double在存储方式遵从IEEE的规范</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643166176045.png"></p><h1 id="局部变量和全局变量的区分"><a href="#局部变量和全局变量的区分" class="headerlink" title="局部变量和全局变量的区分"></a>局部变量和全局变量的区分</h1><p>局部变量是以ebp-开头的</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643180778946.png"></p><p>全局变量在编译完之后地址就不会改变</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643180903634.png"></p><p>直接放进地址，所以就是全局变量</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643181101615.png"></p><p>在vs2022会因为编译器版本问题，出现不同的汇编指令，但都是大同小异</p><h1 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h1><p>cmp+jcc指令</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643181892321.png"></p><p>cmp相当于减法，前面一个减后面一个，因为x&gt;y时继续执行，所以跳转指令的条件是小于等于</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182181368.png"></p><p>改成&gt;=之后，汇编指令变成了jl，汇编指令是和C语言反着来的</p><p>&lt;</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182345813.png"></p><p>==</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643182397987.png"></p><h1 id="多分支语句"><a href="#多分支语句" class="headerlink" title="多分支语句"></a>多分支语句</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643183573683.png"></p><p>x&lt;=y的情况直接跳转到else中</p><p>x&gt;y则往后执行，执行完之后jmp跳转到else语句的后面</p><p>因为mov两边不能都是地址，所以需要用到寄存器</p><h2 id="if、else-if、else"><a href="#if、else-if、else" class="headerlink" title="if、else if、else"></a>if、else if、else</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643184460823.png"></p><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643187985614.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643187574671.png"></p><p>内部得到eax的值，eax一般用来存储返回值</p><p>参数传递4个字节</p><p>压栈的时候都是eax</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643188571362.png"></p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="switch语句反汇编"><a href="#switch语句反汇编" class="headerlink" title="switch语句反汇编"></a>switch语句反汇编</h2><p>当分支较少时采取if……else if ……else的方式</p><h3 id="case连续"><a href="#case连续" class="headerlink" title="case连续"></a>case连续</h3><p>创建大表</p><p> <img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726580401.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726615144.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643726837151.png"></p><p>sub</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727141397.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727234505.png"></p><p>这里修改参数为103，case条件也修改，发现sub的值发生了变化，所以可以知道sub的值对应最小的case条件的值，这样对应上了大表的位置，所以sub是为了跳转到生成的大表</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727350589.png"></p><p>正好是case 103的地址</p><h3 id="case连续但中断"><a href="#case连续但中断" class="headerlink" title="case连续但中断"></a>case连续但中断</h3><p>101、102、103的情况使用default的地址填充</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727925669.png"></p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728035747.png"></p><p>只要有断开的，就会浪费一片内存地址，所以当间隔太远就不会使用这种方式</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728378338.png"></p><p>但是当间隔比较大的时候，出现了新情况</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728454178.png"></p><p>因为已经清空了edx，所以可使用该寄存器，这句话相当于把0x004010dd+eax的值对应地址的内容放入到dl中，dl是八位，对应1个字节，这个就是小表</p><p>当连续但相差较远时会采用小表</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643728595269.png"></p><h3 id="case不连续"><a href="#case不连续" class="headerlink" title="case不连续"></a>case不连续</h3><p>当差值太大，不会生成大表，会直接采取if……else结构</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643727643051.png"></p><p>先判断大于je，再判断等于cmp+jmp</p><h2 id="while循环反汇编"><a href="#while循环反汇编" class="headerlink" title="while循环反汇编"></a>while循环反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643730937945.png"></p><p>je是当ZF标志位为0是跳转，test是按位与操作，用于判断寄存器的值是否为0</p><h2 id="do……while反汇编"><a href="#do……while反汇编" class="headerlink" title="do……while反汇编"></a>do……while反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643731312416.png"></p><h2 id="for循环反汇编"><a href="#for循环反汇编" class="headerlink" title="for循环反汇编"></a>for循环反汇编</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643730507558.png"></p><h1 id="数组在内存的存储和寻址"><a href="#数组在内存的存储和寻址" class="headerlink" title="数组在内存的存储和寻址"></a>数组在内存的存储和寻址</h1><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368384236.png"></p><p>这里数组的存储是从高位往低位存储，也就是从右到左开始存储到缓冲区中，替换缓冲区的数值</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368588775.png"></p><p>可以看到数组的存储</p><p>再看看数组引用</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643368768572.png"></p><p>[ebp-4]是第一个形参的地址</p><p>[ebp-1ch]对应上数组首元素的地址，eax是存储着第一个形参，****<em>4是因为是int型数组，如果是short，则</em>2</p><p>，数组比较常见的形式就是[ebp+寄存器*数组类型对应的字节大小-数字]</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643369846681.png"></p><p>因为数组下标存在变量，而mov两边不能同时是地址，所以需要先用寄存器存储下标，而直接引用就不需要，即arr[1]</p><h2 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h2><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371348362.png"></p><p>因为每个寄存器最多存储四个字节，所以需要用到多个寄存器来存储</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371421546.png"></p><p>在数据窗口中是这样存放的</p><p>寄存器可以重复使用，比如长度不够的情况</p><p><img src="/2022/01/20/C%E8%AF%AD%E8%A8%80%E6%B1%87%E7%BC%96/1643371753305.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编</title>
      <link href="/2022/01/19/%E6%B1%87%E7%BC%96/"/>
      <url>/2022/01/19/%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<h1 id="堆栈图"><a href="#堆栈图" class="headerlink" title="堆栈图"></a>堆栈图</h1><p>调用函数实现两数相加</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592553591.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592569833.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592579671.png"></p><p>因为pop之后，有一部分的值还是之前保留下来的，所以要进行填充</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592639529.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642592648442.png"></p><h1 id="LEA和MOV的区别"><a href="#LEA和MOV的区别" class="headerlink" title="LEA和MOV的区别"></a>LEA和MOV的区别</h1><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数，例如：</p><p>lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的内存地址里的数据赋给eax。</p><p>而mov指令则恰恰相反，例如：</p><p>mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p><h1 id="函数在汇编的结构"><a href="#函数在汇编的结构" class="headerlink" title="函数在汇编的结构"></a>函数在汇编的结构</h1><p>函数调用前，堆栈结构如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642649724413.png"></p><p>EBP栈底高位，ESP栈顶低位</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642649843226.png"></p><p>下面的三个PUSH是把函数的参数压入栈中，这里是立即数，也可以是寄存器里面的值，注意PUSH指令执行完ESP-4，即栈顶往低位移动</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650060363.png"></p><p>堆栈图如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650200472.png"></p><p>下一步是CALL指令，F7单步步入，CALL指令会修改EIP的值，将CALL指令下一条指令的地址压入栈顶 ，并且修改EIP的值，相当于一条PUSH和JMP指令，JMP只会修改EIP的值，EIP存放下一条会执行指令的地址</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642650793595.png"></p><p>堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651074289.png"></p><p>这里JMP直接F8跳转过去，进入函数，入口是PUSH EBP</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651212988.png"></p><p>可以看到ESP没有变化</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651299175.png"></p><p>在函数调用中，这三步是提升栈顶，开辟空间</p><p>运行完堆栈应该如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651845629.png"></p><p>运行看看</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651761171.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642651894330.png"></p><p>接下来这三步是保存现场，因为在函数调用中，这些寄存器可能被用到，所以要先把里面原本的值压入栈中，此时堆栈图为</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652121644.png"></p><p>EBP是FED0</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652204239.png"></p><p>已经被压入栈中 </p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652304817.png"></p><p>接下来这步是填充缓冲区</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642652335865.png"></p><p>可以看到堆栈图中开辟的空间里面的值并不是为0，这是因为在调用完函数之后，这些空间的值没有被清除，所以需要填充</p><p>堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656762839.png"></p><p>这里有一点需要说明，local.18是什么意思呢</p><p>看下图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656813955.png"></p><p>我们去OD修改设置</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656868498.png"></p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656879655.png"></p><p>取消掉就可以了，刚才的指令发生了变化</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642656905307.png"></p><p>接下来解释这几句指令</p><p>lea是取地址，意思是将ebp-0x48的地址存入EDI中</p><p>ECX一般用来存放循环次数，这里是0x12，即18次，这个对应开辟空间的大小</p><p>mov eax，0xCCCCCCCC是填充缓冲区</p><p>最后一句rep表示重复次数，次数由ECX决定，stos dword这条指令表示将EAX内的值放入EDI指定的内存单元中，注意执行一次后EDI会移动4，加减由DF标志位决定</p><p>DF决定movs执行完后esi和edi的移动方向，当为0时，加，否则为减。</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657323715.png"></p><p>看接下来的几行指令</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657469555.png"></p><p>1、将0x2赋给ebp地址的前一个内存单元，<strong>这里的0x2就是局部变量</strong></p><p>2、将EBP+0xc的值赋给eax，eax的值压入栈中，下面也是，画堆栈图</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642657989835.png"></p><p>这里压入栈的数值，将作为内部嵌套函数的参数</p><p>执行完之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658026768.png"></p><p>接下来又是调用函数，将CALL指令下一条指令的地址压入栈顶，EIP修改</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658203867.png"></p><p>F7步入</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658261575.png"></p><p>F8之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642658343466.png"></p><p>红框部分和前面一样，都是调用函数前提升栈顶、开辟空间、保存现场、填充缓冲区，主要看操作部分</p><p>先把堆栈图画好</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659116555.png"></p><p>接下来看操作</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659284922.png"></p><p>这些都没有改变堆栈的值，第一条将0xA赋给EBP-0x4的内存单元，对应堆栈写出操作方式 EAX的值为1+2，最后+0xA，所以最后EAX的值为0xD</p><p>运行</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659505718.png"></p><p>此时函数的操作部分已经结束，接下来就是退出函数了</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642659609650.png"></p><p>对比一下，跟函数开始正好是反过来的</p><p>POP是先出栈再移动 ，这几个POP就相当于恢复现场，要恢复到未调用函数前，这也是为什么要先把这些值压入栈中的原因。</p><p>mov就是降低栈底，恢复到原来的位置</p><p>retn指令相当于POP EIP，先将栈顶的值赋给EIP，然后栈顶指针移动</p><p>堆栈图如下</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660789466.png"></p><p>执行后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660837614.png"></p><p>可以看到执行完之后，缓冲区的内容不会清理，这也是为什么需要填充缓冲区</p><p>回到后我们发现一个问题，就是函数调用前后堆栈不平衡，堆栈平衡是指调用函数前后堆栈应该相等，这里是因为将函数的参数压入了栈，所以需要接下来的ADD平衡堆栈</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642660910037.png"></p><p>执行完之后</p><p><img src="/2022/01/19/%E6%B1%87%E7%BC%96/1642661042648.png"></p><p>和调用前一致，所以没问题了</p><p>剩下的就是重复之前的操作了，先执行函数操作指令，然后POP还原现场，retn后ADD恢复堆栈平衡</p><p>函数的参数存放在ebp+0x8开始因为call指令会将下一条指令地址压入栈中，而局部变量从ebp-0x4开始</p>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z3</title>
      <link href="/2022/01/17/Z3/"/>
      <url>/2022/01/17/Z3/</url>
      
        <content type="html"><![CDATA[<p>先来看官方文档</p><p><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">https://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></p><p>这个博客也不错</p><p><a href="https://blog.csdn.net/qq_38154820/article/details/108656598">https://blog.csdn.net/qq_38154820/article/details/108656598</a></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>  基本语句</p><p>Op    Mnmonics    Description<br>            0    true    恒真<br>            1    flase    恒假<br>            2    =    相等<br>            3    distinct    不同<br>            4    ite    if-then-else<br>            5    and    n元 合取（其中条件必须全部满足）<br>            6    or    n元 析取（其中条件满足之一即可）<br>            7    iff    implication<br>            8    xor    异或<br>            9    not    否定<br>            10    implies    Bi-implications</p><p>1、创建容器</p><p>s=Solver()</p><p>2、创建变量，变量有Int(整型)、BitVector(字节)、数组</p><p>3、添加约束条件</p><p>s.add(约束条件)，需要注意Int不能进行移位运算，python除是//</p><p>4、判断是否存在</p><pre class="language-python" data-language="python"><code class="language-python">if s.check() == sat:      m = s.model()      print(m)else:      print("no answer")</code></pre><h1 id="变量为整型"><a href="#变量为整型" class="headerlink" title="变量为整型"></a>变量为整型</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]Universe_final_answer">https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]Universe_final_answer</a></p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p><img src="/2022/01/17/Z3/1642416626641.png"></p><p>这里就直接放脚本了</p><pre class="language-python" data-language="python"><code class="language-python">from z3 import*s=Solver()v1=Int('v1')v2=Int('v2')v3=Int('v3')v4=Int('v4')v5=Int('v5')v6=Int('v6')v7=Int('v7')v8=Int('v8')v9=Int('v9')v11=Int('v11')s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 *64) - 120 * v9 == -10283)s.add(71 * v6 + (v7 *128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855)s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944)s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222)s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258)s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559)s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308)s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697)if s.check()==sat:    result=s.model()print(result)</code></pre><h1 id="变量为数组"><a href="#变量为数组" class="headerlink" title="变量为数组"></a>变量为数组</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#[GWCTF%202019]xxor">https://buuoj.cn/challenges#[GWCTF%202019]xxor</a></p><h2 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h2><p><img src="/2022/01/17/Z3/1642417350041.png"></p><pre class="language-python" data-language="python"><code class="language-python">from z3 import*#添加六个Int数据到s变量中s = [Int('s%d' % i) for i in range(6)]a=Solver()#多个约束条件可以使用逗号间隔a.add(s[2]-s[3]==2225223423,s[3]+s[4]==4201428739,s[2]-s[4]==1121399208,s[0]==0xdf48ef7e,s[5]==0x84f30420,s[1]==0x20caacf4)if a.check() == sat:    print(a.model())</code></pre><p>这样得到的结果不会是数组的形式，如下得到的是数组形式</p><p><img src="/2022/01/17/Z3/1642418166049.png"></p><h1 id="数独问题"><a href="#数独问题" class="headerlink" title="数独问题"></a>数独问题</h1><p>数独问题就是9×9的方块填数（只能是1-9），分成3×3的小方块，行列数字不同，每个小方块数字不能重复</p><p>先贴一下</p><pre class="language-python" data-language="python"><code class="language-python">from z3 import *# 9x9整数变量矩阵X = [ [ Int("x_%s_%s" % (i+1, j+1)) for j in range(9) ]      for i in range(9) ]  # 每个单元格包含{1，…，9}中的值cells_c  = [ And(1 &lt;= X[i][j], X[i][j] &lt;= 9)             for i in range(9) for j in range(9) ]  # 每行最多包含一个数字一次rows_c   = [ Distinct(X[i]) for i in range(9) ]  # 每列最多包含一个数字cols_c   = [ Distinct([ X[i][j] for i in range(9) ])             for j in range(9) ]  # 每个3x3正方形最多包含一个数字sq_c     = [ Distinct([ X[3*i0 + i][3*j0 + j]                        for i in range(3) for j in range(3) ])             for i0 in range(3) for j0 in range(3) ]  sudoku_c = cells_c + rows_c + cols_c + sq_c  # 数独实例，我们用'0'表示空单元格instance = ((0,0,0,0,9,4,0,3,0),            (0,0,0,5,1,0,0,0,7),            (0,8,9,0,0,0,0,4,0),            (0,0,0,0,0,0,2,0,8),            (0,6,0,2,0,1,0,5,0),            (1,0,2,0,0,0,0,0,0),            (0,7,0,0,0,0,5,2,0),            (9,0,0,0,6,5,0,0,0),            (0,4,0,9,7,0,0,0,0))  instance_c = [ If(instance[i][j] == 0,                  True,                  X[i][j] == instance[i][j])               for i in range(9) for j in range(9) ]  s = Solver()s.add(sudoku_c + instance_c)if s.check() == sat:    m = s.model()    r = [ [ m.evaluate(X[i][j]) for j in range(9) ]          for i in range(9) ]    print_matrix(r)else:    print("failed to solve")</code></pre><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>这是改了的数独，比较简单，拿来练练手</p><p><a href="https://buuoj.cn/challenges#[GUET-CTF2019]number_game">https://buuoj.cn/challenges#[GUET-CTF2019]number_game</a></p><h2 id="Z3在题目的运用"><a href="#Z3在题目的运用" class="headerlink" title="Z3在题目的运用"></a>Z3在题目的运用</h2><pre class="language-python" data-language="python"><code class="language-python">from z3 import *# 5*5整数变量矩阵X = [[Int("x_%s_%s" % (i + 1, j + 1)) for j in range(5)]     for i in range(5)]# 每个单元格包含{0，…，4}中的值cells_c = [And(0 &lt;= X[i][j], X[i][j] &lt;= 4)           for i in range(5) for j in range(5)]# 每行最多包含一个数字一次rows_c = [Distinct(X[i]) for i in range(5)]# 每列最多包含一个数字cols_c = [Distinct([X[i][j] for i in range(5)])          for j in range(5)]# 每个5x5正方形最多包含一个数字,i0和j0表示分为几组sq_c = [Distinct([X[5 * i0 + i][5 * j0 + j]                  for i in range(5) for j in range(5)])        for i0 in range(0) for j0 in range(0)]sudoku_c = cells_c + rows_c + cols_c + sq_c# 数独实例，我们用'5'表示空单元格instance = ((1,4,5,2,3),(3,0,5,1,5),(0,5,2,3,5),(5,3,5,5,5),(4,2,5,5,1))instance_c = [If(instance[i][j] == 5,                 True,                 X[i][j] == instance[i][j])              for i in range(5) for j in range(5)]s = Solver()s.add(sudoku_c + instance_c)if s.check() == sat:    m = s.model()    r = [[m.evaluate(X[i][j]) for j in range(5)]         for i in range(5)]    print_matrix(r)else:    print("failed to solve")</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令</title>
      <link href="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.anquanke.com/post/id/208682">https://www.anquanke.com/post/id/208682</a></p><h1 id="花指令原理"><a href="#花指令原理" class="headerlink" title="花指令原理"></a>花指令原理</h1><p>ida采用的是线性扫描反汇编算法，也就是一步一步往下识别，一旦在中间插入奇怪的立即数，ida可能就会识别出错，进而不能正确反编译</p><h1 id="花指令实现"><a href="#花指令实现" class="headerlink" title="花指令实现"></a>花指令实现</h1><p>首先，我们插入花指令不能阻碍我们程序的正常运行，这是最基本的</p><p>下面使用一段常规代码进行花指令的添加</p><pre class="language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;windows.h&gt;int main(int argc, char* argv[]){char s[] = "1234234";int i = 0, k = 1;for (; i &lt; 10; ++i){k += i;}printf("%d", k);return 0;}</code></pre><p>没插花指令前的反编译</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/MF%5DH0@C0%5BLZFAI%7BX83MEI.png"></p><h2 id="永真跳转"><a href="#永真跳转" class="headerlink" title="永真跳转"></a>永真跳转</h2><pre class="language-c" data-language="c"><code class="language-c">__asm {    push eax;xor eax, eax;test eax, eax;jz LABEL1;jnz  LABLE2;LABLE2:__emit 0xe8;LABEL1:    pop eax;}</code></pre><p>先来看看效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646113378508.png"></p><p>可以看到ida不能正确反编译</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>xor eax,eax能够保证eax的值为0，异或自己，相同为0</p><p>根据目标操作数修改符号标志位、奇偶标志位、零标志位，经过这一步后，ZF为1</p><p>test eax,eax是按位与操作，并且会根据值修改ZF标志位，并且只有当位都清 0 时，零标志位才置 1 </p><p>ZF为1时，jz进行跳转，到LABEL1，因为里面没有其他值，所以代码正常执行，但是在 反编译的时候，因为是线性扫描，所以遇到了LABEL2里面的0xe8（call的机器码），就会将其后面的机器码当作要调用的地址，这样一来，jz就直接跳转到被错误识别的汇编代码中，所以会出现错误</p><h3 id="去除"><a href="#去除" class="headerlink" title="去除"></a>去除</h3><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114167483.png"></p><p>可以看到这里面的jz和jnz后面的地址存在+1，这就基本可以看出是花指令了，找到对应的地址，按u取消定义</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114596608.png"></p><p>可以看到这里也是两个函数，对下面的按C弄成代码</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114739199.png"></p><p>然后为了反编译，要把0xe8使用90填充，也就是nop，填充后按C即可</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114800614.png"></p><p>按P弄成函数后反编译，和上面的基本一致</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646114856426.png"></p><h2 id="插入立即数"><a href="#插入立即数" class="headerlink" title="插入立即数"></a>插入立即数</h2><pre class="language-c" data-language="c"><code class="language-c">__asm {xor eax, eax;jz LABEL1;__emit 0x11;__emit 0x22;__emit 0x33;LABEL1:}</code></pre><p>效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646115623618.png"></p><p>识别出错，原理和上面一样，感觉这种稍微恶心一点，因为有一段可能是正常的，需要一个一个试</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646115805153.png"></p><p>直接nop掉即可</p><h2 id="破坏堆栈"><a href="#破坏堆栈" class="headerlink" title="破坏堆栈"></a>破坏堆栈</h2><p>我们可以插入对esp和eip的操作进而破坏堆栈</p><pre class="language-c" data-language="c"><code class="language-c">__asm {xor eax, eax;jz LABEL1;add esp, 8;LABEL1:}</code></pre><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646116696374.png"></p><p>ida能够正常反编译，但是在函数末端会发现堆栈错误提示</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646116781788.png"></p><h2 id="call-amp-ret构造花指令"><a href="#call-amp-ret构造花指令" class="headerlink" title="call&amp;ret构造花指令"></a>call&amp;ret构造花指令</h2><p>call本质是先将其 下一条指令压入栈中，再jmp函数地址</p><p>ret则是pop eip</p><p>所以我们可以修改返回地址，然后在中前插入垃圾数</p><pre class="language-c" data-language="c"><code class="language-c">__asm {call LABEL1;__emit 0x83;LABEL1:add dword ptr ss : [esp] , 8;ret;    __emit 0xf3;}</code></pre><p>效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646118501242.png"></p><p>这里我们插入的不是机器码，所以没有识别成奇怪的代码，但是还是让ida出现了错误</p><h3 id="去除-1"><a href="#去除-1" class="headerlink" title="去除"></a>去除</h3><p>全部nop掉即可</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646122556219.png"></p><p>这里之所以程序能够进行正常的运行，是因为call会把其下一条指令的地址压入栈中，也就是41459F，（不知道为什么这里会多出一个db 36h -.-)，接下来执行将当前esp地址的值+8，也就是栈顶存储的值+8，也就是返回地址加8，正好对应4145A7，下面的代码c之后是正常的代码，所以不会出错</p><p>在此基础上，我们可以构造各种花指令</p><p>下面连接有一些花指令</p><p><a href="https://www.bilibili.com/read/cv13177757">https://www.bilibili.com/read/cv13177757</a></p><h2 id="call嵌套"><a href="#call嵌套" class="headerlink" title="call嵌套"></a>call嵌套</h2><pre class="language-c" data-language="c"><code class="language-c">__asm {call LABEL1;_emit 0xE8;LABEL2:jmp LABEL3;_emit 0;_emit 0;_emit 0xE8;_emit 0xf6;_emit 0xff;_emit 0xff;_emit 0xff;LABEL1:call LABEL2;LABEL3:add esp, 8;}</code></pre><p>效果</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646123989260.png"></p><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>这里之所以程序能够正常运行，是因为只有两个call对堆栈有影响，所以只需要在最后esp+8就可以回到原来的堆栈</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124342486.png"></p><p>这里先callA9，然后0xE8和后面的结合成了call指令，这里可以看到call到了全是int 3的地方</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124399722.png"></p><p>然后这个9f一直在call自己，所以可以判断是花指令</p><p>把这两个函数nop掉之后</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124643631.png"></p><p>所以这个调用也没用了</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124712766.png"></p><p>同理这个也可以nop掉，那么堆栈会不平衡，add esp,8也要nop</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646124803779.png"></p><p>得到正常代码</p><h2 id="jmp变形-SUSCTF2022-tttree"><a href="#jmp变形-SUSCTF2022-tttree" class="headerlink" title="jmp变形-SUSCTF2022-tttree"></a>jmp变形-SUSCTF2022-tttree</h2><p>感觉很巧妙，拿出来看看</p><p>动调可以看得更清楚</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646126953595.png"></p><p>前面的push没什么好说的，关键在call之后的</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127104589.png"></p><p>当前的栈顶，call会将其之后的地址压入栈顶</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127228921.png"></p><p>可以看到是B7D82FF9B0</p><p>下面两步就是将当前栈顶的元素先+0x191b给到rax</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127367726.png"></p><p>下一步是把rax里的值给到rsp+16</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127416441.png" alt="1646127416441"></p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127424928.png"></p><p>经过两步pop，可以发现来到了存储原本返回值+0x191b的栈的位置</p><p><img src="/2022/01/17/%E8%8A%B1%E6%8C%87%E4%BB%A4/1646127512911.png"></p><p>retn先将栈顶元素pop到eip，再jmp，而eip正好记录我们下一步执行的指令</p><p>这样就是一个简单的jmp</p><p>解决方法就是先计算跳转的地址，然后改成jmp即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMC</title>
      <link href="/2022/01/17/SMC/"/>
      <url>/2022/01/17/SMC/</url>
      
        <content type="html"><![CDATA[<p>参考文章：<a href="https://www.anquanke.com/post/id/238645">https://www.anquanke.com/post/id/238645</a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>SMC，是self-modifying-code的缩写 ，即自我修改的代码，通过程序运行后执行相关代码功能，对加密的代码数据进行解密，让其恢复正常功能</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>1、要有两个函数，一个用于加密，一个用于解密，两个是对应的</p><p>2、找到要SMC的代码地址，然后提前在程序开始的地方设置对该地址数据的解密函数</p><p>3、取出要进行SMC的代码的字节码，对其使用准备好的加密函数进行加密</p><p>4、用这串加密的数据替换原代码的字节码</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84]jocker">https://buuoj.cn/challenges#[%E7%BD%91%E9%BC%8E%E6%9D%AF%202020%20%E9%9D%92%E9%BE%99%E7%BB%84]jocker</a></p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>打开ida反编译看到</p><p><img src="/2022/01/17/SMC/1642563702820.png"></p><p>点进这个函数ida直接报错</p><p><img src="/2022/01/17/SMC/1642563778289.png"></p><p>查看汇编代码</p><p><img src="/2022/01/17/SMC/1642563800178.png"></p><p>点击函数跟进</p><p><img src="/2022/01/17/SMC/1642563901545.png"></p><p>发现一长串没被识别的数据段，这种情况可能是花指令导致，也可能是SMC，结合之前有一个循环异或，可以猜测是SMC，接下来有两种方法解密 </p><h2 id="使用IDC对加密数据进行解密"><a href="#使用IDC对加密数据进行解密" class="headerlink" title="使用IDC对加密数据进行解密"></a>使用IDC对加密数据进行解密</h2><p>首先要找到被加密数据段的初始地址以及加密数据段的长度，这里长度在for循环里面，初始位置</p><p><img src="/2022/01/17/SMC/1642566995107.png"></p><p>点击函数跳转</p><p><img src="/2022/01/17/SMC/1642567097998.png"></p><p>黄色段就是初始地址，可以看到这里函数入口并不是pop开始，所以也可以猜到被加密了</p><p>idc脚本如下(shift+f2)打开</p><pre class="language-c" data-language="c"><code class="language-c">#include &lt;idc.idc&gt;static main(){    auto addr = 0x401500;    auto i = 0;    for(i=0;i&lt;187;i++)    {        PatchByte(addr+i,Byte(addr+i)^0x41);    }}</code></pre><p>得到了解密的数据段</p><p><img src="/2022/01/17/SMC/1642567365432.png"></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>因为程序自带解密函数，只需要在解密函数后面下断点，运行到断点处，被加密的数据段就能成功解密</p><p><img src="/2022/01/17/SMC/1642565058450.png"></p><p>这是未解密的，运行后</p><p><img src="/2022/01/17/SMC/1642565236932.png"></p><p>这时候只需要先对函数按U，取消定义，然后选中按C——force转为汇编代码</p><p><img src="/2022/01/17/SMC/1642565348450.png"></p><p>然后按p定义成函数，再按F5就可以正常反编译了</p><p><img src="/2022/01/17/SMC/1642565393714.png"></p><h1 id="SMC-反调试技术"><a href="#SMC-反调试技术" class="headerlink" title="SMC+反调试技术"></a>SMC+反调试技术</h1><p>因为smc可以采取动态调试来还原加密代码，所以可以采用反调试技术来阻止动态调试，所以这时候就需要绕过</p><h2 id="狗狗的秘密"><a href="#狗狗的秘密" class="headerlink" title="狗狗的秘密"></a>狗狗的秘密</h2><p><img src="/2022/01/17/SMC/1643034259013.png"></p><p>在数据段发现这里类型SMC，猜测是SMC自修改，所以需要定位到解密函数</p><p>在exports发现了一个函数</p><p>TLS回调函数会在oep也就是程序入口前执行</p><p><img src="/2022/01/17/SMC/1643034347085.png"></p><p>这个函数会在main函数之前执行，所以先进去看看</p><p><img src="/2022/01/17/SMC/1643034411621.png"></p><p>把鼠标放在上面发现他是个指针，被赋值为smc的函数段，v8同理，所以接下来这一段应该就是smc解密代码</p><p><img src="/2022/01/17/SMC/1643034535760.png"></p><p>很明显是tea，不会写idctea脚本，所以打算采取动调，但是前面有几个反调试，需要绕过，保证能走到解密代码这一步 </p><p><img src="/2022/01/17/SMC/1643034646186.png"></p><p>对于if语句，只需要用jnz或jz替换即可</p><p>所以相对来说还行，主要是要先定位到这里</p><p><img src="/2022/01/17/SMC/1643034751964.png"></p><p>也可以去这些函数列表看一看</p><p>动调完成还是发现出错，所以里面的值可能被引用修改，对着变量按x查看交叉引用</p><p><img src="/2022/01/17/SMC/1643034871276.png"></p><p>发现在此之前被修改过，但是动调的时候显示是0，很奇怪，不知道什么时候赋值的，所以第一次进入 tea函数需要先对dword_915168的值在hex窗口进行修改</p><p><img src="/2022/01/17/SMC/1643035000708.png"></p><p>要注意在这个窗口中数据以小端序存储</p><p>修改好之后，下好断点后f9让程序跑起来就可以了</p><p><img src="/2022/01/17/SMC/1643035086013.png"></p><p>之后就是前面说的，先取消定义，然后转为代码，再定义函数</p><p>寻找怎么修改hex值的时候发现了 可以添加查看窗口，就很方便，在VM逆向里面可能会看起来更方便</p><p><img src="/2022/01/17/SMC/1643035222239.png"></p><p><img src="/2022/01/17/SMC/1643035235237.png"></p><h1 id="SMC实现"><a href="#SMC实现" class="headerlink" title="SMC实现"></a>SMC实现</h1><p>下面所说的段就是节</p><p>先贴源码</p><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;Windows.h&gt;#include&lt;malloc.h&gt;#pragma code_seg(".scode")void _declspec(naked) Func()//我这里声明一个裸函数，自己开辟堆栈和释放堆栈，避开检测堆栈的函数，防止函数地址重定位的影响{//通过特征块定位到函数开头    __asm {        nop        nop        nop        nop    }    __asm    {        push        ebp        mov         ebp, esp        sub         esp, 0C0h    }    printf("helloworld");    __asm {        add         esp, 0C0h        pop         ebp        ret    }}#pragma code_seg()#pragma comment(linker, "/SECTION:.scode,ERW")void decode(){   //通过获取线程句柄可以得到我们的基地址    LPVOID pModule = GetModuleHandle(NULL);//传入参数为NULL时，表示获取当前程序的基址，也就是MZ    //初始化结构体指针    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)(pModule);    PIMAGE_NT_HEADERS32 pNTheader = (PIMAGE_NT_HEADERS32)((DWORD)pModule + pDosHeader-&gt;e_lfanew);    PIMAGE_FILE_HEADER pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTheader + 4);    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + sizeof(IMAGE_OPTIONAL_HEADER32));        //遍历节表得到我们的解密节表    for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pSectionHeader++)    {        if (!strcmp((const char*)pSectionHeader-&gt;Name, ".scode"))        {            PBYTE pSection = (PBYTE)((DWORD)pModule + pSectionHeader-&gt;VirtualAddress);            for (DWORD k = 0; k &lt; pSectionHeader-&gt;SizeOfRawData; ++k)            {                if (*(PDWORD)pSection == 0xC4C4C4C4)                {                    char comp[] = {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc};                    printf("找到函数段");                    for (;; ++k)                    {                        if (strncmp((const char*)(pSection), comp, 6))                        {                            *(pSection) ^= 0x54;                            printf("%02X", *(pSection));                            pSection++;                        }                        else                        {                            printf("不在函数段内,退出加密");                            return;                        }                   }               }                pSection += 4;            }            printf("解密成功\n");        }    }}int main(){    decode();    Func();return 0;}</code></pre><p>这里只做了一个简单的异或加密</p><p>解释一下一些实现的步骤，如果要实现比较难的加密算法，需要先将原本数据DUMP下来，加密后再重新放入exe文件中，exe文件存放解密代码</p><h2 id="插入段"><a href="#插入段" class="headerlink" title="插入段"></a>插入段</h2><p>1、生成段</p><p>生成名称为.socde的段，如果不填写则默认添加到.text段后面</p><pre class="language-c" data-language="c"><code class="language-c">#pragma code_seg(".scode")</code></pre><p>2、段结尾</p><pre class="language-c" data-language="c"><code class="language-c">#pragma code_seg()</code></pre><p>通过上面两行代码可以生成一个段</p><p>3、设置段的属性</p><pre class="language-c" data-language="c"><code class="language-c">#pragma comment(linker, "/SECTION:.scode,ERW")</code></pre><p>三个字母分别对应可执行、可读和可写</p><h2 id="在段中插入函数"><a href="#在段中插入函数" class="headerlink" title="在段中插入函数"></a>在段中插入函数</h2><p>前面第一和第二行代码之间插入代码-函数，当然是可以直接插入函数的，这里是自己用汇编代码构造的函数</p><p>解释一下为什么前面先插了几个nop，首先我们要知道不同编译器使用生成段的代码得到结果是不同的</p><p><img src="/2022/01/17/SMC/1647950648709.png" alt="VC6生成段"></p><p><img src="/2022/01/17/SMC/1647950674759.png" alt="VS2022生成段"></p><p>可以看到VS2022中我们写的函数在生成段的中间，那么就需要定位，而VC6又不一样了，具体情况具体分析吧</p><p>所以在VS2022中，我们要先定位到插入的函数，而不能直接将整个段加密，这也是为什么插入nop的原因，nop可以用作特征码来识别，当然也可以替换或不用</p><h2 id="定位到段的位置"><a href="#定位到段的位置" class="headerlink" title="定位到段的位置"></a>定位到段的位置</h2><p>先来介绍一个函数，GetModuleHandle可以得到进程的句柄，当传入的参数为NULL时，可以得到当前运行程序的基址，也就是ImageBase，这一块还需要多了解，就先简单介绍</p><p>得到基址之后我们就可以根据windows.h提供的结构体指针，得到PE头、DOS头、节表的信息</p><pre class="language-c" data-language="c"><code class="language-c">//通过获取线程句柄可以得到我们的基地址    LPVOID pModule = GetModuleHandle(NULL);//传入参数为NULL时，表示获取当前程序的基址，也就是MZ    //初始化结构体指针    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)(pModule);    PIMAGE_NT_HEADERS32 pNTheader = (PIMAGE_NT_HEADERS32)((DWORD)pModule + pDosHeader-&gt;e_lfanew);    PIMAGE_FILE_HEADER pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTheader + 4);    PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader + sizeof(IMAGE_OPTIONAL_HEADER32));</code></pre><p>接着就是遍历，比较段的名字，这样就可以定位到我们插入的段</p><h2 id="定位段位置"><a href="#定位段位置" class="headerlink" title="定位段位置"></a>定位段位置</h2><p>我们先前得到的句柄+该节的VirtualAddress就是节开始的地方</p><p>因为我们加密时是单字节加密，所以转为(PBYTE)型</p><h2 id="根据特征代码定位"><a href="#根据特征代码定位" class="headerlink" title="根据特征代码定位"></a>根据特征代码定位</h2><p>因为SMC会在程序运行中进行解密，所以我们要定位到函数位置</p><p>nop的机器码是0x90，异或加密后是0xC4，注意这里的小段序问题</p><h2 id="判断结束位置"><a href="#判断结束位置" class="headerlink" title="判断结束位置"></a>判断结束位置</h2><p>在这个例子中，结束代码之后都是0xCC，这样就可以使用字符串比较，然后判断是否到达末尾</p><pre class="language-c" data-language="c"><code class="language-c">if (strncmp((const char*)(pSection), comp, 6))                        {                            *(pSection) ^= 0x54;                            printf("%02X", *(pSection));                            pSection++;                        }                        else                        {                            printf("不在函数段内,退出加密");                            return;                        }</code></pre><h2 id="修改exe文件"><a href="#修改exe文件" class="headerlink" title="修改exe文件"></a>修改exe文件</h2><p>这里我把加密后的数据打印了出来，方便贴到exe中</p><p><img src="/2022/01/17/SMC/1647951555438.png" alt="修改后的字节"></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>运行exe发现</p><p><img src="/2022/01/17/SMC/1647951602713.png"></p><p>最后打印的就是段中的代码结果</p><p>ida中，可以看到已经无法正常反编译</p><p><img src="/2022/01/17/SMC/1647951757121.png" alt="ida中函数情况"></p><h1 id="另外实现"><a href="#另外实现" class="headerlink" title="另外实现"></a>另外实现</h1><p>更多的可以看去文章头部的链接看看</p><p>我们可以手动定位到加密的位置，这样就比较麻烦，因为还要计算大小，不过代码倒是比较简单</p><pre class="language-c" data-language="c"><code class="language-c">for (DWORD i = 0; i &lt; 30; ++i)   {       *(unsigned char*)(0x00411780 + i) ^= 0x54;       printf("%02X", *(unsigned char*)(0x00411780 + i));   }   printf("解密成功\n");</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip</title>
      <link href="/2022/01/15/zip/"/>
      <url>/2022/01/15/zip/</url>
      
        <content type="html"><![CDATA[<h1 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h1><h2 id="伪加密原理及操作"><a href="#伪加密原理及操作" class="headerlink" title="伪加密原理及操作"></a>伪加密原理及操作</h2><h3 id="zip文件组成"><a href="#zip文件组成" class="headerlink" title="zip文件组成"></a>zip文件组成</h3><p>可以去里面看看，挺全的</p><p><a href="https://blog.csdn.net/qq_26187985/article/details/83654197">https://blog.csdn.net/qq_26187985/article/details/83654197</a></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>这里找了一道大佬出的题，适合练练手</p><p>《美丽的烟火》</p><p>链接：<a href="http://ctf.bugku.com/challenges/detail/id/350.html">http://ctf.bugku.com/challenges/detail/id/350.html</a></p><p>直接打开压缩包，可以得到被加密的文件</p><p><img src="/2022/01/15/zip/1642245880907.png"></p><p>痛苦，一般这种没有提示的(下面会有介绍)，一般就是伪加密了。</p><p>拖进winhex，搜索504b0102（不知道为什么的速速去看前面那篇文章），这个按钮</p><p><img src="/2022/01/15/zip/1642246321198.png"></p><p>把09改成00，要仔细，这里有两个，我开始只看到一个</p><p><img src="/2022/01/15/zip/1642246469204.png"></p><p><img src="/2022/01/15/zip/1642246506196.png"></p><p>重新打开压缩包</p><p><img src="/2022/01/15/zip/1642246638206.png"></p><p>心情愉悦~</p><p>接下来就是进行解密了</p><p>这里不细讲了，不然就跑偏了，png文件是stegpy隐写，密码是shumu，stegpy安装应该会有问题，具体安装请看图片隐写</p><p><img src="/2022/01/15/zip/1642246877362.png"></p><p>password解密是base64，base58，栅栏，</p><p>这里推荐一篇博客</p><p>得到的字符串是aes的key，然后直接aes在线解密</p><p><img src="/2022/01/15/zip/1642247152438.png"></p><p>flag：flag{yX73nAutbBozYhge6d2flG}</p><p>网站也放这了：<a href="https://the-x.cn/cryptography/Aes.aspx">https://the-x.cn/cryptography/Aes.aspx</a></p><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><p>winrar可以修复伪加密，不过是部分的</p><p><img src="/2022/01/15/zip/1642251859085.png"></p><p>点开上面的工具-&gt; 修复压缩文件</p><h1 id="套娃压缩包"><a href="#套娃压缩包" class="headerlink" title="套娃压缩包"></a>套娃压缩包</h1><p>顾名思义，就是压缩包套娃</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://buuoj.cn/challenges#[MRCTF2020]%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF">https://buuoj.cn/challenges#[MRCTF2020]%E5%8D%83%E5%B1%82%E5%A5%97%E8%B7%AF</a></p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><pre class="language-python" data-language="python"><code class="language-python">from PIL import Imagex = y = 200img = Image.new("RGB",(x,y))file = open('./qr.txt','r')for width in range(0,x):    for height in range(0,y):        line = file.readline()        rgb = line.replace('(','').replace(')','').split(',')        img.putpixel((width,height),(int(rgb[0]),int(rgb[1]),int(rgb[2])))img.save('flag.jpg')</code></pre><h1 id="CRC32爆破"><a href="#CRC32爆破" class="headerlink" title="CRC32爆破"></a>CRC32爆破</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>CRC校验实用程序库 在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC的全称是循环冗余校验。(这里还不是很懂，后续再看)</p><p>总之每个文件都有唯一的CRC32值，即便数据中一个bit发生变化，也会导致CRC32值不同。若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但通常只适用于较小文本文件。</p><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>打开里面有很多压缩包，里面存储的都是小数据文件</p><p><img src="/2022/01/15/zip/1642249237942.png"></p><p><img src="/2022/01/15/zip/1642249207274.png"></p><p>直接上脚本(不是很会)</p><pre class="language-python" data-language="python"><code class="language-python">#python3import zipfileimport stringimport binasciidef CrackCrc(crc):for i in dic:for j in dic:for k in dic:for h in dic:s = i + j + k + hif crc == (binascii.crc32(s.encode())):f.write(s)returndef CrackZip():for i in range(0,68):file = 'D:\\new\\新建文件夹\\out'+str(i)+'.zip'crc = zipfile.ZipFile(file,'r').getinfo('data.txt').CRCCrackCrc(crc)print('\r'+"loading：{:%}".format(float((i+1)/68)),end='')dic = string.ascii_letters + string.digits + '+/='f = open('printaaa.txt','w')print("\nCRC32begin")CrackZip()print("CRC32finished")f.close()</code></pre><p>得到base64编码的东西</p><pre class="language-none"><code class="language-none">z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==</code></pre><p>网站在线解码，这个网站挺好的，可以直接转换文件</p><p><a href="https://the-x.cn/base64/">https://the-x.cn/base64/</a></p><p>解码后在尾部看到这句话</p><p><img src="/2022/01/15/zip/1642250774952.png"></p><p>他让我们修复文件，所以我们首先要先了解文件头和尾</p><p><a href="https://blog.csdn.net/Ahuuua/article/details/109165473?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-2.queryctrv2">https://blog.csdn.net/Ahuuua/article/details/109165473?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2.queryctrv2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2.queryctrv2</a></p><p>修补好rar文件头在注释里得到flag</p><p>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h1 id="压缩文件带注释"><a href="#压缩文件带注释" class="headerlink" title="压缩文件带注释"></a>压缩文件带注释</h1><p>有一些题目会在注释里面添加信息，直观的就不说了，现在说两种空白符，Whitespace <a href="https://vii5ard.github.io/whitespace/">https://vii5ard.github.io/whitespace/</a> 和snow隐写，snow需要密码，有可执行文件</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.yunyansec.com/#/experiment/expdetail/3">https://www.yunyansec.com/#/experiment/expdetail/3</a></p><p>无字天书</p><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p>得到流量包，导出HTTP对象</p><p>得到几个文件，依次查看，注意要仔细看，流量包文件有时候会很多</p><p><img src="/2022/01/15/zip/1642254197336.png"></p><p>发现了504b0304，可以写脚本，也可以直接网站解码得到压缩包</p><p><a href="https://the-x.cn/zh-cn/encodings/Hex.aspx">https://the-x.cn/zh-cn/encodings/Hex.aspx</a></p><p><img src="/2022/01/15/zip/1642254255927.png"></p><p>也可以使用脚本</p><pre class="language-python" data-language="python"><code class="language-python">s='填写16进制数据'import binasciiout=open('2.jpg','wb')out.write(binascii.unhexlify(s))out.close()#Author: MoChu7import structa = open("str.txt","r")#十六进制数据文件lines = a.read()res = [lines[i:i+2] for i in range(0,len(lines),2)]with open("res.jpg","wb") as f:for i in res:s = struct.pack('B',int(i,16))f.write(s)</code></pre><p>打开之后得到两个文件，打开里面什么都看不到，全选就会有显示，key.ws应该是snow的密码，拿去whitespace解密</p><p><img src="/2022/01/15/zip/1642254325041.png"></p><p>然后snow解密 命令：SNOW.EXE -p 密码 -C 文件</p><p><img src="/2022/01/15/zip/1642254470293.png"></p><p>cazy{C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng}</p><h1 id="爆破压缩包"><a href="#爆破压缩包" class="headerlink" title="爆破压缩包"></a>爆破压缩包</h1><p>使用工具爆破，如Advanced Archive Password Recovery</p><h2 id="已知明文攻击"><a href="#已知明文攻击" class="headerlink" title="已知明文攻击"></a>已知明文攻击</h2><h2 id="掩码攻击"><a href="#掩码攻击" class="headerlink" title="掩码攻击"></a>掩码攻击</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文档隐写</title>
      <link href="/2022/01/15/%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E6%96%87%E6%A1%A3%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>可以看看这篇<a href="https://xz.aliyun.com/t/1883/">https://xz.aliyun.com/t/1883/</a></p><h1 id="WORD"><a href="#WORD" class="headerlink" title="WORD"></a>WORD</h1><h2 id="xml隐藏信息"><a href="#xml隐藏信息" class="headerlink" title="xml隐藏信息"></a>xml隐藏信息</h2><h2 id="隐藏文字"><a href="#隐藏文字" class="headerlink" title="隐藏文字"></a>隐藏文字</h2><h2 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h2><h1 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h1><h2 id="图片遮挡"><a href="#图片遮挡" class="headerlink" title="图片遮挡"></a>图片遮挡</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频隐写</title>
      <link href="/2022/01/15/%E8%A7%86%E9%A2%91%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E8%A7%86%E9%A2%91%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Kinovea"><a href="#Kinovea" class="headerlink" title="Kinovea"></a>Kinovea</h1><p>可以一帧一帧地看视频，视频隐写目前只接触到在视频一些 帧里面藏信息</p><p><a href="https://mochu.blog.csdn.net/article/details/109461931">https://mochu.blog.csdn.net/article/details/109461931</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流量分析</title>
      <link href="/2022/01/15/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2022/01/15/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>只试过直接导出HTTP流对象</p><p><img src="/2022/01/15/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/1642297780618.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存取证</title>
      <link href="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/"/>
      <url>/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>volatility是内存取证的工具，这里我使用的是打包好了的可执行文件</p><p>volatility下载地址：<a href="https://www.volatilityfoundation.org/releases">https://www.volatilityfoundation.org/releases</a></p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642229196730.png"></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目链接：</p><p><a href="https://www.yunyansec.com/#/experiment/expdetail/3">https://www.yunyansec.com/#/experiment/expdetail/3</a></p><p>朴实无华的取证</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><p>先使用命令volatility -f 朴实无华的取证.raw iamgeinfo查看系统信息</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642230119786.png"></p><p>上面的系统都有可能，主要是第一个</p><h2 id="查看运行程序列表"><a href="#查看运行程序列表" class="headerlink" title="查看运行程序列表"></a>查看运行程序列表</h2><p>命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86 pslist</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642230482092.png"></p><p>这里有三处需要注意，mspaint是画图工具，360zip是解压工具，notepad是笔记本，接下来重点放在这几处</p><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><p>命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86  filescan，这里可以使用grep来指定搜索的字符串 格式如下：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86  filescan | grep flag</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642230787104.png"></p><p>可以看到过滤出了flag的相关数据</p><h2 id="提取文件"><a href="#提取文件" class="headerlink" title="提取文件"></a>提取文件</h2><p>接下来需要把文件dump下来，命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86 dumpfiles -Q 偏移量 -D ./(-D指定文件夹，这里aaa表示存储到aaa文件夹中)</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642231017652.png"></p><p>可以在aaa文件夹中找到dump下来的文件</p><p>得到<img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642231186454.png"></p><p>还有一个加了密的zip文件，这时候注意我们的notepad还没有被使用，可以去看看信息</p><h2 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h2><p>命令：volatility -f 朴实无华的取证.raw –profile=WinXPSP2x86 notepad</p><p><img src="/2022/01/15/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81/1642231403984.png"></p><p>这样就得到了encrypt的密码</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(){char str[]="FDCB[8LDQ?ZLOO?FHUWDLQ)B?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]";for(int i = 0; i &lt; strlen(str); i++){str[i] += 32;if(str[i] &gt;='a'+3 &amp;&amp; str[i]&lt;='w'+3)str[i]-=3;else if(str[i]=='a')str[i]='x';else if(str[i]=='b')str[i]='y';else if(str[i]=='c')str[i]='z';else if(str[i]=='|')str[i]='_';}printf("%s",str);return 0;}</code></pre><p>得到flag：cazy{Xian_will_certainIy_succeed_in_fighting_the_epidemic}</p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频隐写</title>
      <link href="/2022/01/15/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>在这篇文章：<a href="https://blog.csdn.net/vanarrow/article/details/105667244">https://blog.csdn.net/vanarrow/article/details/105667244</a></p><h1 id="摩斯电码"><a href="#摩斯电码" class="headerlink" title="摩斯电码"></a>摩斯电码</h1><h1 id="MP3steg"><a href="#MP3steg" class="headerlink" title="MP3steg"></a>MP3steg</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片隐写</title>
      <link href="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/"/>
      <url>/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="PNG和JPG文件结构"><a href="#PNG和JPG文件结构" class="headerlink" title="PNG和JPG文件结构"></a>PNG和JPG文件结构</h1><p>PNG：<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/8986391.html">https://www.cnblogs.com/ECJTUACM-873284962/p/8986391.html</a>   （有题目需要修改PNG宽高），结尾是IEND</p><p><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_format">https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_format</a></p><p>JPG：<a href="https://www.cnblogs.com/bandy/p/4956086.html">https://www.cnblogs.com/bandy/p/4956086.html</a></p><p>jpg的一些隐写：<a href="https://zhuanlan.zhihu.com/p/24054040">https://zhuanlan.zhihu.com/p/24054040</a></p><p>无论是png还是jpg，只会识别到文件尾，所以可以在文件尾加入信息</p><h1 id="F5隐写"><a href="#F5隐写" class="headerlink" title="F5隐写"></a>F5隐写</h1><h1 id="Stegpy隐写"><a href="#Stegpy隐写" class="headerlink" title="Stegpy隐写"></a>Stegpy隐写</h1><p>之前有过题了，就不说了，讲讲下载</p><p>看这篇就够了</p><p><a href="https://blog.csdn.net/Amherstieae/article/details/109010064">https://blog.csdn.net/Amherstieae/article/details/109010064</a></p><h1 id="Steghide"><a href="#Steghide" class="headerlink" title="Steghide"></a>Steghide</h1><p><a href="https://www.jianshu.com/p/c3679f805a0c">https://www.jianshu.com/p/c3679f805a0c</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF">https://buuoj.cn/challenges#%E4%B9%9D%E8%BF%9E%E7%8E%AF</a></p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>binwalk分解文件</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642302431480.png"></p><p>伪加密</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642302894034.png"></p><p>得到图片和加密压缩包</p><p>对图片使用steghide</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642302996915.png"></p><p>steghide info 文件查看隐藏信息，输入y后提取，也可以直接：steghide extract 文件 </p><p>找到ko.txt,得到压缩包密码</p><p>flag{1RTo8w@&amp;4nK@z*XL}</p><h1 id="Binwalk、Winrar——图片隐藏文件"><a href="#Binwalk、Winrar——图片隐藏文件" class="headerlink" title="Binwalk、Winrar——图片隐藏文件"></a>Binwalk、Winrar——图片隐藏文件</h1><p>binwalk使用：<a href="https://blog.csdn.net/wxh0000mm/article/details/85683661">https://blog.csdn.net/wxh0000mm/article/details/85683661</a></p><p>可以直接binwalk提取文件，命令：binwalk -e 文件，这个比较常见，就不说了</p><p>winrar也可以直接打开被隐藏的文件</p><h1 id="修改图片宽高"><a href="#修改图片宽高" class="headerlink" title="修改图片宽高"></a>修改图片宽高</h1><pre class="language-python" data-language="python"><code class="language-python">import binasciiimport structimport sysfile = input("图片地址：")fr = open(file,'rb').read()data = bytearray(fr[0x0c:0x1d])crc32key = eval('0x'+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1])#原来的代码: crc32key = eval(str(fr[29:33]).replace('\\x','').replace("b'",'0x').replace("'",''))n = 4095for w in range(n):    width = bytearray(struct.pack('&gt;i', w))    for h in range(n):        height = bytearray(struct.pack('&gt;i', h))        for x in range(4):            data[x+4] = width[x]            data[x+8] = height[x]        crc32result = binascii.crc32(data) &amp; 0xffffffff        if crc32result == crc32key:            print(width,height)            newpic = bytearray(fr)            for x in range(4):                newpic[x+16] = width[x]                newpic[x+20] = height[x]            fw = open(file+'.png','wb')            fw.write(newpic)            fw.close            sys.exit()</code></pre><h1 id="二进制转二维码"><a href="#二进制转二维码" class="headerlink" title="二进制转二维码"></a>二进制转二维码</h1><pre class="language-python" data-language="python"><code class="language-python">from PIL import Imagefrom zlib import *MAX = 25pic = Image.new("RGB",(MAX,MAX))str ='''0000000001110010000000000000000000001111010000000000000000011100010000000000000000010111100000000000000000001010101000000000000000000011000101000000000000000010101010100000000000000000100000110000000011000111011101101000110000001000010110010010010100010011110100001110111001100111101001010110010010011000001001100001001101000111100011111101110010100010110111110011011111101111000110110010010101101100100011110011111111111011100000000101100011000101000000000010010100101010001000000001010101010001100100000000001001111111100100000000000011001011110111000000000100110010010000100000000110000110110110010000000011010000101110101'''i=0for y in range(0,MAX):    for x in range(0,MAX):        if(str[i] == '1'):            pic.putpixel([x,y],(0,0,0))        else:pic.putpixel([x,y],(255,255,255))        i = i+1pic.show()pic.save("flag.png")</code></pre><h1 id="坐标画图"><a href="#坐标画图" class="headerlink" title="坐标画图"></a>坐标画图</h1><h2 id="gnuplot"><a href="#gnuplot" class="headerlink" title="gnuplot"></a>gnuplot</h2><p>linux，直接sudo apt install gnuplot，使用 直接gnuplot进入后，plot 文件名，就可以了</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#%E6%A2%85%E8%8A%B1%E9%A6%99%E4%B9%8B%E8%8B%A6%E5%AF%92%E6%9D%A5">https://buuoj.cn/challenges#%E6%A2%85%E8%8A%B1%E9%A6%99%E4%B9%8B%E8%8B%A6%E5%AF%92%E6%9D%A5</a></p><h2 id="解题过程-1"><a href="#解题过程-1" class="headerlink" title="解题过程"></a>解题过程</h2><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642300357300.png"></p><p>在文件尾之后发现大量十六进制数据，这里我使用010editor复制，这样比较快，复制后转为字符</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642300558126.png"></p><p>这样的格式不能被识别，所以需要替换，我使用的是VS</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642301030524.png"></p><p>替换这里不用填写，直接替换全部，然后保存到txt中，再使用工具</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642301392143.png"></p><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p>在stegsolve可以实现，逐帧查看，注意不要漏了</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642304858835.png"></p><h1 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h1><h1 id="文件头尾倒置"><a href="#文件头尾倒置" class="headerlink" title="文件头尾倒置"></a>文件头尾倒置</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.yunyansec.com/#/experiment/expdetail/3">https://www.yunyansec.com/#/experiment/expdetail/3</a></p><p>pipicc</p><h2 id="解题过程-2"><a href="#解题过程-2" class="headerlink" title="解题过程"></a>解题过程</h2><p>得到一张图片</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642303873774.png"></p><p>有噪点，应该是修改了像素点，是需要修复的</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306122403.png"></p><p>缺少png文件头，修补文件头</p><p>接下来找到IEND块,将多余部分删去，改为png</p><p>得到</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306518311.png"></p><p>拖进stegsolve</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306719043.png"></p><p>在蓝色低位发现了d9ff，这正好是jpg的文件尾反过来，save bin 下来，搜索d8ff，对应倒置的文件头</p><p>010editor有工具</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306907507.png"></p><p>需要安装</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306934016.png"></p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642306975753.png"></p><p>逆序后保存改为jpg后缀，得到图片</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642307072291.png"></p><p>也可以使用脚本</p><pre class="language-python" data-language="python"><code class="language-python">input = open('D:\\new\\5', 'rb')input_all = input.read()ss = input_all[::-1]output = open('m0re.jpg', 'wb')output.write(ss)input.close()output.close()</code></pre><h1 id="Base64隐写"><a href="#Base64隐写" class="headerlink" title="Base64隐写"></a>Base64隐写</h1><pre class="language-python" data-language="python"><code class="language-python">import base64path = input("请输入加密文件路径\n")file = open(path)a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"aaa = ''while True:    text = file.readline()  # 只读取一行内容    # 判断是否读取到内容    text = text.replace("\n", "")    if not text:        break    if text.count('=') == 1:        aaa = aaa + \            str('{:02b}'.format((a.find(text[len(text)-2])) % 4))    if text.count('=') == 2:        aaa = aaa + \            str('{:04b}'.format((a.find(text[len(text)-3])) % 16))file.close()t = ""ttt = len(aaa)ttt = ttt//8*8for i in range(0,ttt,8):    t = t + chr(int( aaa[i:i+8],2))print(t)</code></pre><h1 id="StegSolve"><a href="#StegSolve" class="headerlink" title="StegSolve"></a>StegSolve</h1><h2 id="两张图片拼接"><a href="#两张图片拼接" class="headerlink" title="两张图片拼接"></a>两张图片拼接</h2><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312404099.png"></p><p>提取http对象</p><p>把scanlines拖进stegsolve，在多个通道发现了一条横线</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312485498.png"></p><p>而logo正好缺了一段</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312592372.png"></p><p>使用stegsolve的图像结合</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312633974.png"></p><p>得到flag</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642312671617.png"></p><h1 id="添加文件头"><a href="#添加文件头" class="headerlink" title="添加文件头"></a>添加文件头</h1><h1 id="文件属性藏信息"><a href="#文件属性藏信息" class="headerlink" title="文件属性藏信息"></a>文件属性藏信息</h1><p>图片属性可以隐藏信息</p><h1 id="outguess隐写"><a href="#outguess隐写" class="headerlink" title="outguess隐写"></a>outguess隐写</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p><a href="https://buuoj.cn/challenges#[WUSTCTF2020]alison_likes_jojo">https://buuoj.cn/challenges#[WUSTCTF2020]alison_likes_jojo</a></p><h2 id="解题过程-3"><a href="#解题过程-3" class="headerlink" title="解题过程"></a>解题过程</h2><p>binwalk分解boki.png得到压缩包，是真加密</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642311449760.png"></p><p>尝试爆破</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642311499706.png"></p><p>得到一段字符串</p><p>base64三次得到killerqueen</p><p>另一张图片是outguess隐写</p><p><img src="/2022/01/15/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99/1642311787198.png"></p><p>打开flag1.txt文件</p><p>wctf2020{pretty_girl_alison_likes_jojo}</p><h1 id="盲水印"><a href="#盲水印" class="headerlink" title="盲水印"></a>盲水印</h1><h2 id="BlindWaterMark"><a href="#BlindWaterMark" class="headerlink" title="BlindWaterMark"></a>BlindWaterMark</h2><h1 id="点阵提取"><a href="#点阵提取" class="headerlink" title="点阵提取"></a>点阵提取</h1><pre class="language-python" data-language="python"><code class="language-python"># from PIL import Image## img = Image.open('D:\\new\\cat.png')# width, height = img.size# pixs_list = []# for w in range(5, width, 11):# for h in range(5, height, 11):# pix = img.getpixel((w, h))# pixs_list.append(pix)# #分解下pixs_list的长度，就可以得到生成图片的宽高# new_width, new_height = 215, 215# new_img = Image.new('RGB', (new_width, new_height))# idx = 0# for n_w in range(new_width):# for n_h in range(new_height):# new_img.putpixel((n_w, n_h), pixs_list[idx])# idx += 1# new_img.save('ok.png')# new_img.show()# from PIL import Image## img = Image.open('ok.png')# width, height = img.size# pixs_list = []# for w in range(2, width, 5):# for h in range(2, height, 5):# pix = img.getpixel((w, h))# pixs_list.append(pix)# #分解pixs_list的长度，# new_width, new_height = 43, 43# new_img = Image.new('RGB', (new_width, new_height))# idx = 0# for n_w in range(new_width):# for n_h in range(new_height):# new_img.putpixel((n_w, n_h), pixs_list[idx])# idx += 1# new_img.save('ok1.png')# new_img.show()from PIL import Imageimg = Image.open('ok1.png')if img.mode == "P":    img = img.convert("RGB")assert img.size[0] == img.size[1]dim = width, height = img.sizest = 1a = 9b = 39for _ in range(st):    with Image.new(img.mode, dim) as canvas:        for nx in range(img.size[0]):            for ny in range(img.size[0]):                y = (ny - nx * a) % width                x = (nx - y * b) % height                canvas.putpixel((y, x), img.getpixel((ny, nx)))canvas.show()canvas.save('ok2.png')</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A&amp;D1</title>
      <link href="/2021/12/27/A-D1/"/>
      <url>/2021/12/27/A-D1/</url>
      
        <content type="html"><![CDATA[<h1 id="IsDebugger-Present"><a href="#IsDebugger-Present" class="headerlink" title="IsDebugger Present"></a>IsDebugger Present</h1><p><strong>原理</strong></p><hr><p>​          反调试，该API查询PEB结构中的IsDebugger标志位， 未调试返回0，调试状态返回1。</p><p><strong>绕过</strong></p><hr><ol><li><p>nop指令</p> <pre class="language-none"><code class="language-none">mov rax ; IsDebuggerPresentcall rax ; IsDebuggerPresent</code></pre></li><li><p>jnz和jz</p><hr><p> jnz在结果不为0时跳转，jz在结果为0时跳转</p> <pre class="language-none"><code class="language-none">sub_4019F4(){    return ISDebuggerPresent;}if(!sub_4019F4){     puts();}</code></pre><p> 这个时候如果处于调试状态，返回1，不会执行put，这时候只需要去汇编指令处把jnz改为jz，重新汇编后会变成</p> <pre class="language-none"><code class="language-none">sub_4019F4(){    return ISDebuggerPresent;}if(sub_4019F4){     puts();}</code></pre><p> 3.Attach to process</p> <pre class="language-none"><code class="language-none">sub_4019F4();printf("%d",n);scanf("%d",&amp;m);</code></pre><p> 可以先让程序运行，这时候已经步过了反调试函数，然后Attach to process就可以调试了</p><p> 4.修改EIP：jump、call、ret指令</p></li></ol><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ol><li><p>函数介绍</p> <pre class="language-none"><code class="language-none">1 CreateThread 创建线程2 CloseHandle 关闭线程3 WaitForSingleObject() 实现线程转换</code></pre></li></ol><p>​      2.题目——Youngter drive</p><pre class="language-none"><code class="language-none">int __cdecl main_0(int argc, const char **argv, const char **envp){  HANDLE v4; // [esp+D0h] [ebp-14h]  HANDLE hObject; // [esp+DCh] [ebp-8h]  ((void (*)(void))sub_4110FF)();  ::hObject = CreateMutexW(0, 0, 0);  j_strcpy(Destination, &amp;Source);  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);  v4 = CreateThread(0, 0, sub_41119F, 0, 0, 0);  CloseHandle(hObject);  CloseHandle(v4);  while ( dword_418008 != -1 )    ;  sub_411190();  CloseHandle(::hObject);  return 0;}</code></pre><pre class="language-none"><code class="language-none">void __stdcall StartAddress_0(int a1){  while ( 1 )  {    WaitForSingleObject(hObject, 0xFFFFFFFF);    if ( dword_418008 &gt; -1 )    {      sub_41112C(&amp;Source, dword_418008);      --dword_418008;      Sleep(0x64u);    }    ReleaseMutex(hObject);  }}</code></pre><pre class="language-none"><code class="language-none">void __stdcall sub_411B10(int a1){  while ( 1 )  {    WaitForSingleObject(hObject, 0xFFFFFFFF);    if ( dword_418008 &gt; -1 )    {      Sleep(0x64u);      --dword_418008;    }    ReleaseMutex(hObject);  }}</code></pre><p>实际上就是每隔两位对数组元素做一次处理</p><h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><ol><li><p>基础</p> <pre class="language-none"><code class="language-none">1 声明整数x = Int('x')2 声明实数x = Real('x')3 声明布尔类型x = Bool('x')1 创建solver求解器   例：s = Solver()2 添加约束条件   例：s.add(x+y==10)3 检查solver中的约束是否满足   例：s.check()4 利用model()输出运算结果   例：s.model()</code></pre><p> 2.题目——Universe_final_answer</p> <pre class="language-none"><code class="language-none">__int64 __fastcall main(int a1, char **a2, char **a3){  char v4[32]; // [rsp+0h] [rbp-A8h] BYREF  char input[104]; // [rsp+20h] [rbp-88h] BYREF  unsigned __int64 v6; // [rsp+88h] [rbp-20h]  v6 = __readfsqword(0x28u);  __printf_chk(1LL, "Please give me the key string:", a3);  scanf("%s", input);  if ( sub_860(input) )  {    sub_C50(input, v4);    __printf_chk(1LL, "Judgement pass! flag is actf{%s_%s}\n", input);  }  else  {    puts("False key!");  }  return 0LL;}</code></pre> <pre class="language-none"><code class="language-none">bool __fastcall sub_860(char *input){  int v1; // ecx  int v2; // esi  int v3; // edx  int v4; // er9  int v5; // er11  int v6; // ebp  int v7; // ebx  int v8; // er8  int v9; // er10  bool result; // al  int v11; // [rsp+0h] [rbp-38h]  v1 = input[1];  v2 = *input;  v3 = input[2];  v4 = input[3];  v5 = input[4];  v6 = input[6];  v7 = input[5];  v8 = input[7];  v9 = input[8];  result = 0;  if ( -85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613 )  {    v11 = input[9];    if ( 30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400      &amp;&amp; -103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 &lt;&lt; 6) - 120 * v9 == -10283      &amp;&amp; 71 * v6 + (v7 &lt;&lt; 7) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855      &amp;&amp; 5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944      &amp;&amp; -54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222      &amp;&amp; -83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258      &amp;&amp; 81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559      &amp;&amp; 101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308 )    {      result = 99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697;    }  }  return result;}</code></pre><p> 脚本</p> <pre class="language-none"><code class="language-none">from z3 import*s=Solver()v1=Int('v1')v2=Int('v2')v3=Int('v3')v4=Int('v4')v5=Int('v5')v6=Int('v6')v7=Int('v7')v8=Int('v8')v9=Int('v9')v11=Int('v11')s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613)s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 *64) - 120 * v9 == -10283)s.add(71 * v6 + (v7 *128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855)s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944)s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222)s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258)s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559)s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308)s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697)if s.check()==sat:    result=s.model()print(result)</code></pre><p> 这里的移位操作不能被识别，需要手动转换。</p><p> 其实这道题带了个简单的混淆</p> <pre class="language-none"><code class="language-none">unsigned __int64 __fastcall sub_C50(const char *a1, _BYTE *a2){  size_t v4; // rax  unsigned int v5; // edx  int v6; // edi  int v7; // ecx  __int64 v8; // r8  __int128 *v9; // rsi  unsigned int v10; // ecx  int v11; // eax  int v12; // edi  int v13; // edx  int v14; // eax  _BYTE *v15; // rsi  _BYTE *v16; // rcx  _BYTE *v17; // r8  int *i; // rax  unsigned __int64 result; // rax  __int128 v20[2]; // [rsp+0h] [rbp-48h] BYREF  __int64 v21; // [rsp+20h] [rbp-28h]  unsigned __int64 v22; // [rsp+28h] [rbp-20h]  v22 = __readfsqword(0x28u);  v20[0] = 0LL;  v21 = 0LL;  v20[1] = 0LL;  v4 = strlen(a1);  v5 = 0;  v6 = 9;  while ( v5 &lt; v4 )  {    v7 = a1[v5++];    v6 ^= v7;  }  if ( v6 )  {    v8 = 0LL;    v9 = v20;    while ( 1 )    {      v9 = (__int128 *)((char *)v9 + 4);      v10 = v8 + 1;      v11 = v6 / 10;      v12 = v6 % 10;      *((_DWORD *)v9 - 1) = v12;      LOBYTE(v13) = v12;      v6 = v11;      if ( !v11 )        break;      v8 = v10;    }    v14 = v8 - 1;    v15 = a2;    v16 = &amp;a2[v10];    v17 = &amp;a2[v8];    for ( i = (int *)v20 + v14; ; --i )    {      *v15 = v13 + 48;      if ( v17 == v15 )        break;      v13 = *i;      ++v15;    }  }  else  {    v16 = a2;  }  result = __readfsqword(0x28u) ^ v22;  *v16 = 0;  return result;}</code></pre><p> 这里面的函数没有对输入进行处理，所以不用管</p></li></ol><h1 id="修改二进制文件汇编指令"><a href="#修改二进制文件汇编指令" class="headerlink" title="修改二进制文件汇编指令"></a>修改二进制文件汇编指令</h1><p>1.题目——Overlong</p><p>运行程序，得到</p><pre class="language-none"><code class="language-none">I never broke the encoding：</code></pre><pre class="language-none"><code class="language-none">int __stdcall start(int a1, int a2, int a3, int a4){  CHAR Text[128]; // [esp+0h] [ebp-84h] BYREF  int v6; // [esp+80h] [ebp-4h]  v6 = sub_401160(Text, &amp;unk_402008, 28);  Text[v6] = 0;  MessageBoxA(0, Text, Caption, 0);  return 0;}</code></pre><p>这里只取出了TEXT的前28位，而程序运行后的输出长度正好是28，加上题目overlong提示和：结尾，猜测部分长度没显示</p><p>所以需要修改二进制文件汇编指令</p><pre class="language-none"><code class="language-none">.text:004011C0                 push    ebp.text:004011C1                 mov     ebp, esp.text:004011C3                 sub     esp, 84h.text:004011C9                 push    1Ch.text:004011CB                 push    offset unk_402008.text:004011D0                 lea     eax, [ebp+Text]</code></pre><p>1c对应28，所以需要将1c改大</p><p>1、ida修改–&gt; 点击菜单项“Edit”–“Patch program”–“Assemble” –&gt; 点击菜单项“Edit”–“Patch program”–“Apply patches to input file”，在弹出的对话框中点击OK按钮，则成功完成指令修改。</p><p>点击确认按钮时，可能会弹出无法写入对话框，只需去除该文件的只读属性，再次执行第三步即可。</p><p>2、OD修改–&gt;根据汇编指令定位–&gt;右键–&gt;二进制–&gt;编辑 ,其他的可以直接修改指令，但是这里修改之后后面的汇编代码全变了，虽然不知道为啥。</p><p>3、winhex修改–&gt;定位——先去ida的patch byte找到push 1c对应6A 1C 68 08 20 40 00 8D 85 7C FF FF FF 50 E8 84–&gt;去winhex修改1c，然后重新保存运行</p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><p>1、题目——Signin</p><pre class="language-none"><code class="language-none">__int64 __fastcall main(int a1, char **a2, char **a3){  char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF  char v5[16]; // [rsp+10h] [rbp-490h] BYREF  char v6[16]; // [rsp+20h] [rbp-480h] BYREF  char v7[16]; // [rsp+30h] [rbp-470h] BYREF  char v8[112]; // [rsp+40h] [rbp-460h] BYREF  char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF  unsigned __int64 v10; // [rsp+498h] [rbp-8h]  v10 = __readfsqword(0x28u);  puts("[sign in]");  printf("[input your flag]: ");  __isoc99_scanf("%99s", v8);  sub_96A(v8, v9);//加密函数直接linux远调就可以知道是转十六进制数；  __gmpz_init_set_str(v7, "ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35", 16LL);//十六进制  __gmpz_init_set_str(v6, v9, 16LL);  __gmpz_init_set_str(v4, "103461035900816914121390101299049044413950405173712170434161686539878160984549", 10LL);//十进制  __gmpz_init_set_str(v5, "65537", 10LL);  __gmpz_powm(v6, v6, v5, v4);  if ( (unsigned int)__gmpz_cmp(v6, v7) )    puts("GG!");  else    puts("TTTTTTTTTTql!");  return 0LL;}</code></pre><p>看到65537，加上查了__gmpz_powm()函数，也相当于__mpz_powm()函数，可以判断这是rsa加密</p><pre class="language-none"><code class="language-none">void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod) [Function]Set rop to base^exp mod mod.</code></pre><p> 其实就是计算 base 的 exp 次方，并对 mod 取模，最后将结果写入 rop 中 </p><p>剩下的就是解出p、q，然后写脚本了</p><pre class="language-none"><code class="language-none">C=M^E mod NC是密文，M是明文，E是公钥（E和 φ(N)互为质数），N是公共模数（质数 P 、Q相乘得到N），MOD就是模运算M=C^D mod N求D：E * D % φ(N) = 1    φ(N) = (P-1)(Q-1)   </code></pre><p>2、rsa</p><p>题目给出了公钥和flag.enc文件</p><pre class="language-none"><code class="language-none">(N,e)是公钥， (N, d)是私钥</code></pre><p>公钥和密钥生成</p><pre class="language-none"><code class="language-none">4.1 求N我们准备两个很小对质数，p ＝ 17q ＝ 19N ＝ p ＊ q ＝ 3234.2 求LL ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144144为16和18对最小公倍数4.3 求E求E必须要满足2个条件：1 &lt; E &lt; L ，gcd（E，L）=1即1 &lt; E &lt; 144，gcd（E，144） ＝ 1 #gcd，最大公因数E和144互为质数，5显然满足上述2个条件故E ＝ 5        此时公钥=(E，N）＝ （5，323）4.4 求D求D也必须满足2个条件：1 &lt; D &lt; L，E＊D mod L ＝ 1即1 &lt; D &lt; 144，5 ＊ D mod 144 ＝ 1显然当D＝ 29 时满足上述两个条件1 &lt; 29 &lt; 1445＊29 mod 144 ＝ 145 mod 144 ＝ 1此时私钥＝（D，N）＝（29，323）</code></pre><p>私钥和公钥都可以拿去解析</p><p>这里解析得到</p><pre class="language-none"><code class="language-none">e = 65537n=86934482296048119190666062003494800588905656017203025617216654058378322103517(n拿去分解)p = 285960468890451637935629440372639283459q = 304008741604601924494328155975272418463</code></pre><p>从文件读取公钥或者私钥</p><pre class="language-none"><code class="language-none">with open('private.pem', mode='rb') as privatefile:keydata = privatefile.read()#rb 是以二进制形式打开文件privkey = rsa.PrivateKey.load_pkcs1(keydata)</code></pre><pre class="language-none"><code class="language-none">import gmpy2 import rsa  e = 65537n = 86934482296048119190666062003494800588905656017203025617216654058378322103517p = 285960468890451637935629440372639283459q = 304008741604601924494328155975272418463phin = (q-1)*(p-1)d = gmpy2.invert(e, phin)key = rsa.PrivateKey(n, e, int(d), p, q)#生成私钥with open("D:\\new\\题目\\output\\flag.enc", "rb+") as f:    f = f.read()    print(rsa.decrypt(f, key))</code></pre><h1 id="Maze"><a href="#Maze" class="headerlink" title="Maze"></a>Maze</h1><p>Maze题一般都需要找到入口、出口还有移动方向</p><p>题目——unctf20201—easymaze</p><pre class="language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 *v3; // rax  char *v4; // rdi  unsigned __int64 v5; // rbx  const char *v6; // rdx  int v7; // eax  int v8; // er9  int v9; // er8  int v10; // edx  char v11; // cl  int v12; // ecx  int v13; // ecx  __int64 *v14; // rax  sub_1400011A0(argc, argv, envp);  dword_140006790[0] = 1;#把鼠标放上去显示int型  dword_140006794 = 1;  dword_1400067B4 = 1;  dword_1400067CC = 1;  dword_1400067EC = 1;  dword_1400067F0 = 1;  dword_1400067D4 = 1;  dword_1400067D8 = 1;  dword_1400067F8 = 1;  dword_140006810 = 1;  dword_14000682C = 1;  dword_140006844 = 1;  dword_140006840 = 1;  dword_140006864 = 1;  dword_140006868 = 1;  dword_140006884 = 1;  dword_1400068A0 = 1;  dword_1400068BC = 1;  dword_1400068DC = 1;  dword_14000689C = 1;  v3 = sub_140001800(std::cout, (__int64)"Plz inpu7 the P4th :");  std::ostream::operator&lt;&lt;(v3, sub_1400019D0);  v4 = input;  v5 = -1i64;  sub_140001AA0(std::cin, -1i64, input);  do    ++v5;  while ( input[v5] );  if ( v5 &gt; 0x11 )  {    v6 = "to0 lon9!t0o long!";    goto LABEL_26;  }  if ( v5 &lt; 0x11 )  {    v6 = (const char *)&amp;unk_140003770;    goto LABEL_26;  }  v7 = dword_140006710;  v8 = 0;  v9 = dword_140006714;  v10 = dword_140006710;  do  {    v11 = *v4;    if ( *v4 == 'A' )      goto LABEL_21;    if ( v11 == 'W' )    {      ++v10;      v12 = v7 % 2;      ++v7;      goto LABEL_20;    }    if ( v11 == 'E' )    {      ++v10;      v13 = v7 % 2;      ++v7;LABEL_16:      dword_140006710 = v7;      if ( v13 )        goto LABEL_23;      goto LABEL_17;    }    if ( v11 != 'D' )    {      if ( v11 != 'X' )      {        if ( v11 != 'Z' )        {          v6 = "What the fuck did you give me?";          goto LABEL_26;        }        --v10;        v12 = v7 % 2;        --v7;LABEL_20:        dword_140006710 = v7;        if ( !v12 )          goto LABEL_23;LABEL_21:        --v9;        goto LABEL_22;      }      --v10;      v13 = v7 % 2;      --v7;      goto LABEL_16;    }LABEL_17:    ++v9;LABEL_22:    dword_140006714 = v9;LABEL_23:    ++v8;    ++v4;  }  while ( v8 &lt; v5 );  v6 = "Congratulations on this forced to get the right flag, you entered is the correct answer!";    if ( dword_140006790[7 * v7 + v9] != 1 )        v6 = "Try it again little unlucky!";LABEL_26:  v14 = sub_140001800(std::cout, (__int64)v6);  std::ostream::operator&lt;&lt;(v14, sub_1400019D0);  return 0;}</code></pre><p>动调就可以把AWEDXZ的移动弄出来</p><p>在ida里面dd表示四个字节，db表示一个字节</p><pre class="language-none"><code class="language-none">data:00007FF673BF6794 dword_7FF673BF6794 dd 0                 ; DATA XREF: main+27↑w.data:00007FF673BF6798 dd 0.data:00007FF673BF679C db    0.data:00007FF673BF679D db    0.data:00007FF673BF679E db    0.data:00007FF673BF679F db    0.data:00007FF673BF67A0 db    0.data:00007FF673BF67A1 db    0.data:00007FF673BF67A2 db    0.data:00007FF673BF67A3 db    0.data:00007FF673BF67A4 db    0.data:00007FF673BF67A5 db    0.data:00007FF673BF67A6 db    0.data:00007FF673BF67A7 db    0</code></pre><p>要对着db按D转换数据类型，全部转为int型</p><h1 id="base64变表"><a href="#base64变表" class="headerlink" title="base64变表"></a>base64变表</h1><p>1、base64变表实际上就是将base64编码表进行了修改</p><p>2、题目——nctf2021 shadowbringer</p><pre class="language-none"><code class="language-none">int __cdecl main(int argc, const char **argv, const char **envp){  char v4[16]; // [rsp+20h] [rbp-60h] BYREF  char v5[15]; // [rsp+30h] [rbp-50h] BYREF  char v6; // [rsp+3Fh] [rbp-41h] BYREF  char v7[16]; // [rsp+40h] [rbp-40h] BYREF  char v8[16]; // [rsp+50h] [rbp-30h] BYREF  char v9[16]; // [rsp+60h] [rbp-20h] BYREF  char v10[32]; // [rsp+70h] [rbp-10h] BYREF  _main();  youknowwhat();  std::string::string((std::string *)v5);  std::allocator&lt;char&gt;::allocator(&amp;v6);  std::string::string(v4, "U&gt;F2UsQXN`5sXMELT=:7M_2&lt;X]^1ThaWF0=KM?9IUhAsTM5:T==_Ns&amp;&lt;Vhb!", &amp;v6);  std::allocator&lt;char&gt;::~allocator(&amp;v6);  std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(printf_0, "Welcome.Please input your flag:\n");  std::operator&gt;&gt;&lt;char&gt;(scanf, (std::string *)v5);  std::string::string((std::string *)v8, (const std::string *)v5);    Emet(v7, v8);    std::string::operator=(v5, v7);  std::string::~string((std::string *)v7);  std::string::~string((std::string *)v8);  std::string::string((std::string *)v10, (const std::string *)v5);    Selch(v9, v10);    std::string::operator=(v5, v9);                 std::string::~string((std::string *)v9);  std::string::~string((std::string *)v10);  if ( (unsigned __int8)std::operator==&lt;char&gt;(v5, v4) )    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(printf_0, "Right.");  else    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(printf_0, "Wrong.");  std::string::~string((std::string *)v4);  std::string::~string((std::string *)v5);  return 0;}</code></pre><pre class="language-none"><code class="language-none">std::string *__fastcall Emet(std::string *a1, std::string *a2){  int i; // ebx  char *v3; // rax  unsigned __int64 v4; // rax  int j; // ebx  unsigned int v6; // eax  char *v7; // rax  unsigned __int64 v9; // [rsp+20h] [rbp-90h] BYREF  char v10; // [rsp+2Eh] [rbp-82h] BYREF  char v11; // [rsp+2Fh] [rbp-81h] BYREF  char v12[16]; // [rsp+30h] [rbp-80h] BYREF  char v13[16]; // [rsp+40h] [rbp-70h] BYREF  char v14[16]; // [rsp+50h] [rbp-60h] BYREF  char v15[16]; // [rsp+60h] [rbp-50h] BYREF  char v16[16]; // [rsp+70h] [rbp-40h] BYREF  char v17[16]; // [rsp+80h] [rbp-30h] BYREF  char v18[16]; // [rsp+90h] [rbp-20h] BYREF  char v19[16]; // [rsp+A0h] [rbp-10h] BYREF  std::allocator&lt;char&gt;::allocator(&amp;v10);  std::string::string(&amp;v9, &amp;unk_48A000, &amp;v10);  std::allocator&lt;char&gt;::~allocator(&amp;v10);  std::allocator&lt;char&gt;::allocator(&amp;v11);  std::string::string(a1, &amp;unk_48A000, &amp;v11);  std::allocator&lt;char&gt;::~allocator(&amp;v11);  for ( i = 0; i &lt; (unsigned __int64)std::string::size(a2); ++i )  {    v3 = (char *)std::string::operator[](a2, i);    std::bitset&lt;8ull&gt;::bitset(v14, (unsigned int)*v3);    std::bitset&lt;8ull&gt;::to_string(v13, v14);    std::operator+&lt;char&gt;(v12, &amp;v9, v13);    std::string::operator=(&amp;v9, v12);    std::string::~string((std::string *)v12);    std::string::~string((std::string *)v13);  }  while ( 1 )  {    v4 = std::string::size((std::string *)&amp;v9);    if ( v4 == 6 * (v4 / 6) )      break;    std::operator+&lt;char&gt;(v15, &amp;v9, 48i64);    std::string::operator=(&amp;v9, v15);    std::string::~string((std::string *)v15);  }  for ( j = 0; j &lt; (unsigned __int64)std::string::size((std::string *)&amp;v9); j += 6 )  {    std::string::substr((std::string *)v18, (unsigned __int64)&amp;v9, j);    std::bitset&lt;6ull&gt;::bitset&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v17, v18, 0i64);    v6 = std::bitset&lt;6ull&gt;::to_ulong(v17);    v7 = (char *)std::string::operator[](&amp;hisoralce, v6);    std::operator+&lt;char&gt;(v16, a1, (unsigned int)*v7);    std::string::operator=(a1, v16);    std::string::~string((std::string *)v16);    std::string::~string((std::string *)v18);  }  while ( (std::string::size(a1) &amp; 3) != 0 )  {    std::operator+&lt;char&gt;(v19, a1, 33i64);    std::string::operator=(a1, v19);    std::string::~string((std::string *)v19);  }  std::string::~string((std::string *)&amp;v9);  return a1;}</code></pre><p>这里的j+=6，像是base64，而&amp;hisorale是指针</p><pre class="language-none"><code class="language-none">bss:00000000004AA030 hisoralce db  28h ; (                   ; DATA XREF: youknowwhat(void)+2A↑o.bss:00000000004AA030                                         ; youknowwhat(void)+40↑o ....bss:00000000004AA031 db  3Dh ; =.bss:00000000004AA032 db 0BBh.bss:00000000004AA033 db    0.bss:00000000004AA034 db    0.bss:00000000004AA035 db    0.bss:00000000004AA036 db    0.bss:00000000004AA037 db    0</code></pre><p>需要对着db按d转换类型，才能看到该地址存储的内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
