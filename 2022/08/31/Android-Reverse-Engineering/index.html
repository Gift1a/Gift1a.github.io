<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Android_Reverse_Engineering">
<meta property="og:type" content="article">
<meta property="og:title" content="Android_Reverse_Engineering">
<meta property="og:url" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Android_Reverse_Engineering">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/0.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/2.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/4,856ab7b141.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1662380130833.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1662450909912.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1662453034704.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/16784215bcc99e97_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663044873233.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663045185308.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663046205303.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663057562069.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663046313607.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663046332189.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663046374008.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663046435707.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663046503302.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663048128871.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663048645736.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663049075238.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663048903877.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663048982355.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663049205313.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663049224754.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663056706023.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663056767581.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663057436575.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663057837115.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663058048017.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663059844715.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663060304853.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663065694339.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663066658590.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663485969473.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663557014085.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663557327759.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663557437706.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663557730285.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663557907125.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663558161849.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663558271389.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663558826171.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663559042157.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663559758515.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663562350795.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663563150239.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663563355880.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663078077134.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663419013223.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663289657209.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663419595624.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663291619627.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663482436003.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663482673581.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663482730147.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663482743705.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663483447057.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663417512103.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1663657312049.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664076582081.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664111445479.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664171372070.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664171003366.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664171707347.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664171751666.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664171777960.png">
<meta property="og:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/1664171791787.png">
<meta property="article:published_time" content="2022-08-31T12:09:58.000Z">
<meta property="article:modified_time" content="2022-10-07T05:25:24.218Z">
<meta property="article:author" content="Gift1a">
<meta property="article:tag" content="Reverse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/0.png">


<link rel="canonical" href="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/","path":"2022/08/31/Android-Reverse-Engineering/","title":"Android_Reverse_Engineering"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android_Reverse_Engineering | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Learning-Link"><span class="nav-number">1.</span> <span class="nav-text">Learning Link</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android-Application-Framework"><span class="nav-number">2.</span> <span class="nav-text">Android Application Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%8D%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">安卓操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8"><span class="nav-number">2.1.2.</span> <span class="nav-text">内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%8D%93%E6%9E%B6%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">安卓架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kernel"><span class="nav-number">2.2.1.</span> <span class="nav-text">Kernel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hardware-Abstraction-Layer"><span class="nav-number">2.2.2.</span> <span class="nav-text">Hardware Abstraction Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Libraries"><span class="nav-number">2.2.3.</span> <span class="nav-text">Libraries</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Android-Runtime"><span class="nav-number">2.2.4.</span> <span class="nav-text">Android Runtime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-Framework"><span class="nav-number">2.2.5.</span> <span class="nav-text">Application Framework</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#System-Applications"><span class="nav-number">2.2.6.</span> <span class="nav-text">System Applications</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91"><span class="nav-number">2.3.</span> <span class="nav-text">编译与反编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#APK%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">APK构建流程和执行过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smali%E4%BB%A3%E7%A0%81"><span class="nav-number">2.3.2.</span> <span class="nav-text">Smali代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#APK%E7%9A%84%E5%A4%A7%E8%87%B4%E5%86%85%E5%AE%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">APK的大致内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#APK%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B4%BB%E5%8A%A8%E5%92%8C%E5%85%A5%E5%8F%A3"><span class="nav-number">2.4.</span> <span class="nav-text">APK程序的活动和入口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E5%8A%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">活动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3"><span class="nav-number">2.4.2.</span> <span class="nav-text">入口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Oncreate%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">Oncreate函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Smali"><span class="nav-number">3.</span> <span class="nav-text">Smali</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5"><span class="nav-number">3.1.</span> <span class="nav-text">学习链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#smali%E5%AD%A6%E4%B9%A0"><span class="nav-number">3.2.</span> <span class="nav-text">smali学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#smali%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">smali代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#smali%E5%92%8Cjava%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">smali和java的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smali%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">smali源码结构分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">3.2.1.2.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.2.2.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.1.2.3.</span> <span class="nav-text">main方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#smali%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.1.2.4.</span> <span class="nav-text">smali代码中的for循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Toast%E5%9C%A8smali%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.1.2.5.</span> <span class="nav-text">Toast在smali中的代码</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">关于方法返回的关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84smali%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">静态代码块的smali代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smali%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">smali各种方法的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smali%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.2.1.6.</span> <span class="nav-text">smali中对象的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.1.7.</span> <span class="nav-text">数据的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%96%E5%80%BC%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="nav-number">3.2.1.8.</span> <span class="nav-text">字段的取值与赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%ACif"><span class="nav-number">3.2.1.9.</span> <span class="nav-text">条件跳转if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">3.2.1.10.</span> <span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#smali%E8%AF%AD%E6%B3%95%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.2.1.11.</span> <span class="nav-text">smali语法关键字</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#smali%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5"><span class="nav-number">3.3.</span> <span class="nav-text">smali代码注入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IDA-Dump-Android%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">IDA Dump Android应用内存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Root"><span class="nav-number">5.</span> <span class="nav-text">Root</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Objection"><span class="nav-number">5.1.</span> <span class="nav-text">Objection</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MT%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">MT管理器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AS%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95APK"><span class="nav-number">7.</span> <span class="nav-text">AS动态调试APK</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">8.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">8.1.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">8.1.1.</span> <span class="nav-text">反射的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="nav-number">8.1.2.</span> <span class="nav-text">类加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">8.1.3.</span> <span class="nav-text">获取Class对象的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">8.1.4.</span> <span class="nav-text">Class类对象的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Field"><span class="nav-number">8.1.5.</span> <span class="nav-text">获取Field</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Constructor"><span class="nav-number">8.1.6.</span> <span class="nav-text">获取Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Method"><span class="nav-number">8.1.7.</span> <span class="nav-text">获取Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">8.1.8.</span> <span class="nav-text">整个过程的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81-v2"><span class="nav-number">8.3.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.4.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">8.4.1.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3-v2"><span class="nav-number">8.4.2.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">抽象方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.2.3.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.2.4.</span> <span class="nav-text">私有方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">8.4.2.5.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.4.2.6.</span> <span class="nav-text">一个类实现多个接口</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF"><span class="nav-number">9.</span> <span class="nav-text">移动端攻防技术</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Xposed%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">10.</span> <span class="nav-text">Xposed框架介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AS%E7%BC%96%E5%86%99Xposed%E6%A1%86%E6%9E%B6"><span class="nav-number">10.1.</span> <span class="nav-text">AS编写Xposed框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%93%E5%8C%85%E8%AF%A6%E8%A7%A3"><span class="nav-number">11.</span> <span class="nav-text">抓包详解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%8D%93%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF"><span class="nav-number">12.</span> <span class="nav-text">安卓攻防技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#App%E5%8A%A0%E5%9B%BA"><span class="nav-number">12.1.</span> <span class="nav-text">App加固</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DEX%E6%95%B4%E4%BD%93%E5%8A%A0%E5%9B%BA"><span class="nav-number">12.1.1.</span> <span class="nav-text">DEX整体加固</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Frida%E8%84%B1%E5%A3%B3"><span class="nav-number">12.1.1.1.</span> <span class="nav-text">Frida脱壳</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E6%8A%BD%E5%8F%96%E4%BF%9D%E6%8A%A4"><span class="nav-number">12.1.2.</span> <span class="nav-text">代码抽取保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FART%E8%84%B1%E5%A3%B3"><span class="nav-number">12.1.2.1.</span> <span class="nav-text">FART脱壳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DexHunter%E8%84%B1%E5%A3%B3"><span class="nav-number">12.1.2.2.</span> <span class="nav-text">DexHunter脱壳</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VMP%E4%B8%8EDex2C"><span class="nav-number">12.1.3.</span> <span class="nav-text">VMP与Dex2C</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Ollvm"><span class="nav-number">12.2.</span> <span class="nav-text">Ollvm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OLLVM%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BC%96%E8%AF%91so%E6%96%87%E4%BB%B6"><span class="nav-number">12.2.1.</span> <span class="nav-text">OLLVM环境配置与编译so文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E6%9B%BF%E6%8D%A2%E6%B7%B7%E6%B7%86"><span class="nav-number">12.2.2.</span> <span class="nav-text">指令替换混淆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96"><span class="nav-number">12.2.3.</span> <span class="nav-text">控制流平坦化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E9%80%A0%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">12.2.4.</span> <span class="nav-text">伪造控制流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="nav-number">13.</span> <span class="nav-text">Android反调试</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gift1a"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Gift1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gift1a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://1.12.239.117:8090/" title="http:&#x2F;&#x2F;1.12.239.117:8090&#x2F;" rel="noopener" target="_blank">Fallw1nd</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://equinox-shame.github.io/" title="https:&#x2F;&#x2F;equinox-shame.github.io&#x2F;" rel="noopener" target="_blank">梓曰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://a2ur2.github.io/" title="https:&#x2F;&#x2F;a2ur2.github.io&#x2F;" rel="noopener" target="_blank">A2ure</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/spmonkey/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;spmonkey&#x2F;" rel="noopener" target="_blank">星空</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/08/31/Android-Reverse-Engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android_Reverse_Engineering | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android_Reverse_Engineering
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-31 20:09:58" itemprop="dateCreated datePublished" datetime="2022-08-31T20:09:58+08:00">2022-08-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-07 13:25:24" itemprop="dateModified" datetime="2022-10-07T13:25:24+08:00">2022-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Reverse/" itemprop="url" rel="index"><span itemprop="name">Reverse</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2022/08/31/Android-Reverse-Engineering/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/08/31/Android-Reverse-Engineering/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Android_Reverse_Engineering</p>
<span id="more"></span>
<h1 id="Learning-Link"><a class="header-anchor" href="#Learning-Link">¶</a>Learning Link</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/DaqianC/article/details/101135872">Ubuntu安装并管理多个版本的Python</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6949078900064387103">Android逆向</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/APKLab/APKLab">APKLAB</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/dn0m1n8tor/AndroidPentest101">Android Pentest</a>是关于安卓渗透测试的，但是有一部分还是可以借鉴的</p>
<p><a target="_blank" rel="noopener" href="https://tryhackme.com/room/androidhacking101">Android Hacking101</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/tlamb96/kgb_messenger">Android Pratice</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cyberheartmi9/Frida-Guide/blob/main/Frida%20Guide/Frida%20Guide.md">Frida Guide</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ragingrock.com/AndroidAppRE/app_fundamentals.html">Android App reverse101</a></p>
<h1 id="Android-Application-Framework"><a class="header-anchor" href="#Android-Application-Framework">¶</a>Android Application Framework</h1>
<p>安卓是基于Linux内核和其他开源项目的修改版本的移动操作系统</p>
<h2 id="安卓操作系统"><a class="header-anchor" href="#安卓操作系统">¶</a>安卓操作系统</h2>
<h3 id="硬件"><a class="header-anchor" href="#硬件">¶</a>硬件</h3>
<p>Android的主要硬件平台是ARM，在以后的版本中也支持X86架构和X86-64架构</p>
<h3 id="内核"><a class="header-anchor" href="#内核">¶</a>内核</h3>
<p>截至2020年，Android使用Linux内核的4.4，4.9或4.14版本。Android Kernel 基于 Linux Kernel 的长期支持 （LTS）分支</p>
<h3 id="文件系统"><a class="header-anchor" href="#文件系统">¶</a>文件系统</h3>
<p>之前的Android使用YAFFS2文件系统，在Android2.3之后使用EXT4文件系统，虽然很多的OEM（原始设备制造厂商）已经尝试了F2FS，但以下的目录在任何Android都存在</p>
<ul>
<li>
<p>Boot：包含内核，虚拟硬盘等</p>
</li>
<li>
<p>System：包含操作系统文件，其中包括Android UI和预安装的应用程序</p>
</li>
<li>
<p>Recovery：引导到操作系统的替代选项，允许恢复和备份分区</p>
</li>
<li>
<p>Data：保存用户数据，其子文件夹包括</p>
<ul>
<li>Android：默认用于应用程序缓存和保存的数据</li>
<li>Alarms：警报的自定义音频文件</li>
<li>Cardboard：包含VR文件的数据</li>
<li>DCIM：相机拍摄的照片的视频</li>
<li>Downloads：存放在互联网上下载的文件</li>
<li>Notifications：某些应用通知的自定义提示音</li>
<li>Musics,Movies：存储第三方的音乐和视频</li>
<li>Pictures：存储第三方的图片</li>
<li>Podcasts：使用播客应用时存储播客文件</li>
<li>Videos：存储从第三方下载的视频</li>
</ul>
</li>
<li>
<p>Cache：存储常用数据和应用组件</p>
</li>
<li>
<p>Misc：包含其他重要的系统设置信息</p>
</li>
</ul>
<h2 id="安卓架构"><a class="header-anchor" href="#安卓架构">¶</a>安卓架构</h2>
<p><img src="/2022/08/31/Android-Reverse-Engineering/0.png" alt="img"></p>
<h3 id="Kernel"><a class="header-anchor" href="#Kernel">¶</a>Kernel</h3>
<p>它为用户提供了与硬件通信的接口。它包含程序用来指示硬件组件执行特定功能的基本驱动程序。这些驱动程序是音频，显示器，蓝牙等</p>
<h3 id="Hardware-Abstraction-Layer"><a class="header-anchor" href="#Hardware-Abstraction-Layer">¶</a>Hardware Abstraction Layer</h3>
<p><strong>硬件抽象层</strong> （<strong>HAL</strong>） 是代码的逻辑划分，用作计算机物理硬件与其软件之间的抽象层。它提供了一个设备驱动程序接口，允许程序与硬件进行通信</p>
<h3 id="Libraries"><a class="header-anchor" href="#Libraries">¶</a><strong>Libraries</strong></h3>
<p>位于内核的顶部，库为开发人员提供开发应用程序，资源文件甚至清单的支持。有一些原生库，如SSL，SQLite，Libc等，是原生代码有效执行任务所必需的。</p>
<h3 id="Android-Runtime"><a class="header-anchor" href="#Android-Runtime">¶</a><strong>Android Runtime</strong></h3>
<p>ART是Android操作系统使用的应用程序运行时环境，Runtime Environment是程序可以向计算机处理器发送指令并访问计算机主存(RAM)的状态。JAVA编写的Android应用程序，在编译期间首先转换为字节码，打包为APK和运行运行时</p>
<blockquote>
<p><strong>Android使用虚拟机来执行应用程序，以便将程序的执行和操作系统隔离开来，并免受恶意代码的侵害</strong></p>
</blockquote>
<p>在Android4.4之前，程序的运行是由DVM(<em>Dalvik Virtual Machine</em>)执行的，后来被Android Runtime替代</p>
<h3 id="Application-Framework"><a class="header-anchor" href="#Application-Framework">¶</a>Application Framework</h3>
<blockquote>
<p><strong>安卓由四大组件：Activity、Service、Broadcast Receiver、Content Provider</strong></p>
</blockquote>
<p>Android操作系统的整个功能集可以通过Java编写的API提供给开发人员，这些API是Android应用所需要的最重要的组件</p>
<ul>
<li>View System：主要用于构建应用程序的UI。包括列表、文本框和按键</li>
<li>Resource Manager：提供对布局文件、图形等非代码资源的访问</li>
<li>Notification Manager：允许应用在状态栏显示自定义警报</li>
<li>Activity Manager：管理应用的生命周期</li>
<li>Content Providers：使应用程序能够访问其他应用程序</li>
</ul>
<h3 id="System-Applications"><a class="header-anchor" href="#System-Applications">¶</a>System Applications</h3>
<p>预装的核心应用程序集，用于基本功能，如短信，日历，互联网浏览，联系人等</p>
<h2 id="编译与反编译"><a class="header-anchor" href="#编译与反编译">¶</a>编译与反编译</h2>
<p>ART的主要编译过程如下</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/2.png" alt="img"></p>
<p>APK文件只是一个包含XML文件，dex代码，资源文件和其他文件的ZIP压缩包，需要反编译的时候需要先解包然后再反编译，使用<strong>APKLab</strong>即可</p>
<h3 id="APK构建流程和执行过程"><a class="header-anchor" href="#APK构建流程和执行过程">¶</a>APK构建流程和执行过程</h3>
<p><img src="/2022/08/31/Android-Reverse-Engineering/4,856ab7b141.png" alt=""></p>
<ol>
<li>.java文件中的java源代码通过<strong>javac</strong>转换为字节码(.class文件)</li>
<li>所有的.class文件都通过dx编辑器转换为.dex文件(Dalvik可执行文件)。DEX字节码独立于设备架构，需要转换为本机机器代码才能在设备上运行</li>
<li>AAPT将资源(res文件夹)编译为二进制文件(resources.arsc)，并且将已经编译的资源、非编译的资源、.dex文件打包到apk文件中</li>
<li>对应用程序进行签名，然后才能发布</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013773608/article/details/100033868">Dalvik JIT和ART的区别</a></p>
<p>如果Android使用的是Dalvik JIT编译器，那么每次运行程序时，他都会<strong>动态地将Dalvik字节码(也就是.dex文件)地一部分转换为字节码然后执行</strong>，随着程序的执行，将编译和缓存更多的字节码</p>
<p>如果是Android使用的是ART，那么在应用程序的安装阶段，他就会<strong>静态地将DEX字节码转换为机器代码</strong>，并且存储在设备的内存中，这是一次性事件</p>
<h3 id="Smali代码"><a class="header-anchor" href="#Smali代码">¶</a>Smali代码</h3>
<p>Smali是<strong>Dalvik VM内部执行的核心代码，是Dalvik自己的语法规范</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9931a1e77066">smali语言学习</a></p>
<p>Smali代码就是dex文件反编译之后的代码，所以说Smali语言是Android虚拟机的反汇编语言</p>
<blockquote>
<p>我们可以通过修改Smali代码来修改APK运行逻辑，再重新编译打包成新的APK</p>
</blockquote>
<h3 id="APK的大致内容"><a class="header-anchor" href="#APK的大致内容">¶</a>APK的大致内容</h3>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1662380130833.png" alt="1662380130833"></p>
<ul>
<li>
<p>AndroidMainfest.xml：二进制XML格式的清单文件，存储应用程序的软件包名称，版本组件和其他元数据</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1662450909912.png" alt="包含的内容"></p>
</li>
<li>
<p>META_INF：清单，用于存储有关应用程序的元数据，它还包含APK的证书和前面</p>
</li>
<li>
<p>classes.dex：以dex格式编译的应用程序代码，Dalvik VM（<strong>相当关于Java中的JVM</strong>）可以识别和执行</p>
</li>
<li>
<p>res/：包含未编译成resources.arsc中的资源的文件夹</p>
</li>
<li>
<p>lib/：包含本地已编译代码文件-即本机代码库</p>
</li>
<li>
<p>assets/：应用程序的资产</p>
</li>
<li>
<p>resources.arsc：提前编译好的资源文件</p>
</li>
</ul>
<h2 id="APK程序的活动和入口"><a class="header-anchor" href="#APK程序的活动和入口">¶</a>APK程序的活动和入口</h2>
<h3 id="活动"><a class="header-anchor" href="#活动">¶</a>活动</h3>
<p><strong>活动是用来承载用户界面的容器，是Android的四大组件之一</strong>，我们再APP里面看到的页面就需要一个Activity，而页面之间的跳转就是Activity之间的跳转。比如，登陆页面是一个LoginActivity，注册页面是一个 RegisterActivity，当我们需要从登陆页面跳转到注册页面时，也就是 LoginActivity 通过 Intent 跳转到 RegisterActivity</p>
<h3 id="入口"><a class="header-anchor" href="#入口">¶</a>入口</h3>
<p>我们新建一个Android项目时会默认生成一个Activity，叫做 <strong>MainActivity</strong>，MainActivity就是这个项目的唯一页面，也就是APP的启动页面。<strong>每一个Activity都需要在AndroidManifest.xml文件中配置。每创建一个Activity都需要在这个文件中国注册</strong></p>
<p>在AndroidManifest.xml文件中<strong>android.intent.action.MAIN</strong>会将Mainactivity注册为最先启动多个Activity，同时我们也可以在其中配置Activity的其他属性</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1662453034704.png" alt=""></p>
<h4 id="Oncreate函数"><a class="header-anchor" href="#Oncreate函数">¶</a>Oncreate函数</h4>
<p>Oncreate函数<strong>通常配置需要的信息</strong>，<strong>一个Activity启动回调的第一个函数就是Oncreate，Oncreate函数做一些Activity启动的一些必要的初始化的工作</strong>。有点像Java中的构造函数</p>
<h1 id="Smali"><a class="header-anchor" href="#Smali">¶</a>Smali</h1>
<h2 id="学习链接"><a class="header-anchor" href="#学习链接">¶</a>学习链接</h2>
<p><a target="_blank" rel="noopener" href="https://source.android.google.cn/docs/core/dalvik/dalvik-bytecode">字节码格式</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903732774174734">smali详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43278826/article/details/108377201?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-108377201-blog-80825044.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-108377201-blog-80825044.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=3">AS调试时Smali下不了断点</a></p>
<p>下不了断点可能是版本不对，下载最新版即可</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangjianming2018/article/details/124512370">AS中调试smali</a></p>
<p>直接使用APKLab解包(如果没有debuggable属性则<strong>需要先在application标签中加入android:debuggable=“true”，然后重新打包</strong>)，然后以调试方式启动最后附加上去即可(这里我直接开启调试是失败的)</p>
<blockquote>
<p><strong>adb shell am satrt -D -n 包名/.主活动</strong></p>
</blockquote>
<h2 id="smali学习"><a class="header-anchor" href="#smali学习">¶</a>smali学习</h2>
<p>Java编译器将.java源文件编译为.class字节码文件，然后JVM将字节码解释为机器代码在目标机器上执行。<strong>DVM指的是DalVIk VM，在Android中，java类被打包为DEX字节码文件(.dex)，DEX字节码经过Dalvik或者ART转为机器码进行执行，而smali就是dex文件反编译之后的汇编代码</strong></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/16784215bcc99e97_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt=""></p>
<blockquote>
<p><strong>JVM是基于栈帧的，也就是Stack-based，而DVM基于寄存器，也就是Register-based</strong></p>
</blockquote>
<h3 id="smali代码"><a class="header-anchor" href="#smali代码">¶</a>smali代码</h3>
<h4 id="smali和java的对比"><a class="header-anchor" href="#smali和java的对比">¶</a>smali和java的对比</h4>
<p><strong>注释</strong></p>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在java中使用<span class="regexp">//</span></span><br><span class="line">而smali中使用<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>类声明</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在java中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">class_name</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在smali中</span></span><br><span class="line">.class 权限修饰符 类的全包名路径，使用L开头，以;结尾</span><br><span class="line">    </span><br><span class="line">.<span class="keyword">super</span> Ljava/lang/Object;#声明父类，默认为Object</span><br><span class="line">.implement L/java/lang/CharSequence;#如果实现了接口需要添加接口代码</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663044873233.png" alt=""></p>
<p><strong>方法声明</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在java中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method</span><span class="params">()</span></span>{};</span><br><span class="line"></span><br><span class="line"><span class="comment">//smali中</span></span><br><span class="line">.method 属性 方法名(参数的签名)返回值签名</span><br><span class="line"></span><br><span class="line">.end method;#成对出现</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663045185308.png" alt=""></p>
<p>这里表示Onclick的属性是public、参数为View(<strong>因为View是对象，需要使用全包名路径</strong>)，返回值为void(V)</p>
<blockquote>
<p><strong>全包名路径时java中的.被修改为/,并且使用L开头,以;结尾</strong></p>
</blockquote>
<p><strong>字段声明</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中</span></span><br><span class="line"><span class="keyword">public</span> String a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//smali中,</span></span><br><span class="line">.filed <span class="keyword">public</span> a:com/lang/String;#声明了一个字段</span><br><span class="line">.filed 权限修饰符+静态修饰符+变量名:变量全类名路径</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量声明</span></span><br><span class="line">.filed <span class="keyword">public</span> a:com/lang/String;=<span class="string">"hello"</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>字段取值赋值</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smali中</span></span><br><span class="line">iget iput sget sput#i表示instance，s表示<span class="keyword">static</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法调用</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//smali中，以invoke开头</span></span><br><span class="line">在方法中必须声明方法中寄存器的数量</span><br></pre></td></tr></tbody></table></figure>
<p><strong>方法取值</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取返回值首先需要调用方法invoke，然后接收返回值move</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>smali和java基础数据类型对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">smali</th>
<th style="text-align:center">java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">byte</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">short</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">J</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">V</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">[</td>
<td style="text-align:center">数组</td>
</tr>
<tr>
<td style="text-align:center">L+全类名路径，用/分割</td>
<td style="text-align:center">object</td>
</tr>
</tbody>
</table>
<h4 id="smali源码结构分析"><a class="header-anchor" href="#smali源码结构分析">¶</a>smali源码结构分析</h4>
<p>先自己编写一个简单的APK</p>
<p>源代码如下</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663046205303.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663057562069.png" alt=""></p>
<h5 id="声明"><a class="header-anchor" href="#声明">¶</a>声明</h5>
<p>类方法的声明</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663046313607.png" alt=""></p>
<p>.super表示继承的类，.source是java源文件</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663046332189.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663046374008.png" alt=""></p>
<p>实现的类</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663046435707.png" alt=""></p>
<h5 id="构造方法"><a class="header-anchor" href="#构造方法">¶</a>构造方法</h5>
<p>java中自动生成无参构造器</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663046503302.png" alt=""></p>
<p>.method和.end method一起使用，<strong>construct <init>是构造器特有的关键字</init></strong>，()V表示构造方法为无参构造且返回值为void</p>
<p>.line 14表示在源码中的行数为14行，<strong>可以删除</strong></p>
<p><strong>invoke-direct是方法的调用，凡是私有方法或者构造方法统统使用invoke-direct，这里的invoke-direct其实就是调用父类的初始化方法</strong></p>
<p>invoke-direct表示将p0参数传入后面的<strong>方法</strong>中，<strong>p0这里就是this指针，其实存在于构造器的参数列表中</strong>，将this传入后面的方法进行Object的初始化操作</p>
<blockquote>
<p><strong>invoke-direct {参数},方法所对应的全包名路径类; -&gt; 方法名称(方法参数签名)方法返回值签名</strong></p>
</blockquote>
<p><strong>return-void表示返回值为void</strong></p>
<blockquote>
<p>当返回值为String时，返回<strong>Object</strong></p>
<p>const-string v0,“hello” <strong>声明一个常量字符串</strong></p>
</blockquote>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663048128871.png" alt=""></p>
<blockquote>
<p><strong>在方法声明之后的.locals可以理解为调用该方法需要使用到的变量</strong></p>
</blockquote>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663048645736.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663049075238.png" alt=""></p>
<h5 id="main方法"><a class="header-anchor" href="#main方法">¶</a>main方法</h5>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663048903877.png" alt=""></p>
<p><strong>main函数的参数是[Ljava/lang/String;表明其参数为String数组</strong></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663048982355.png" alt=""></p>
<p><strong>.param表明参数对应的名称为args</strong></p>
<p><strong>.line两个之间的smali代码表示java源代码中的一行代码</strong></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663049205313.png" alt=""></p>
<p>对应java中</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663049224754.png" alt=""></p>
<h5 id="smali代码中的for循环"><a class="header-anchor" href="#smali代码中的for循环">¶</a><strong>smali代码中的for循环</strong></h5>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663056706023.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663056767581.png" alt=""></p>
<blockquote>
<p><strong>首先使用const初始化两个常量，然后进行比较if-ge代表如果p1&gt;=v0，则跳转到con_0分支，否则add-int/lit8 p1,p1,0x1表示将p1+0x1的值然后赋值给p1</strong>，即p1=p1+1，<strong>然后使用goto语句回到判断处</strong></p>
</blockquote>
<h5 id="Toast在smali中的代码"><a class="header-anchor" href="#Toast在smali中的代码">¶</a><strong>Toast在smali中的代码</strong></h5>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663057436575.png" alt=""></p>
<blockquote>
<p><strong>调用实例方法/一般方法一般使用invoke-virtual，invoke-static调用静态方法</strong></p>
</blockquote>
<p>先获取参数，然后存储到{}中，接着使用-&gt;(这里-&gt;相当于Toast.makeText(p1,v1,v0))将参数传入到makeText方法中，makeText(参数签名)返回值签名</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663057837115.png" alt=""></p>
<p>接收方法的返回值传递到p1然后show</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663058048017.png" alt=""></p>
<h4 id="关于方法返回的关键字"><a class="header-anchor" href="#关于方法返回的关键字">¶</a>关于方法返回的关键字</h4>
<table>
<thead>
<tr>
<th style="text-align:center">smali</th>
<th style="text-align:center">数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">byte</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">short</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">int</td>
</tr>
<tr>
<td style="text-align:center">return-wide</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">float</td>
</tr>
<tr>
<td style="text-align:center">return-wide</td>
<td style="text-align:center">double</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">return</td>
<td style="text-align:center">boolean</td>
</tr>
<tr>
<td style="text-align:center">return-void</td>
<td style="text-align:center">void</td>
</tr>
<tr>
<td style="text-align:center">return-object</td>
<td style="text-align:center">数组</td>
</tr>
<tr>
<td style="text-align:center">return-object</td>
<td style="text-align:center">String</td>
</tr>
</tbody>
</table>
<h4 id="静态代码块的smali代码"><a class="header-anchor" href="#静态代码块的smali代码">¶</a>静态代码块的smali代码</h4>
<p><clinit>初始化</clinit></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663059844715.png" alt=""></p>
<h4 id="smali各种方法的调用"><a class="header-anchor" href="#smali各种方法的调用">¶</a>smali各种方法的调用</h4>
<p>关键字</p>
<figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">invoke-virtual</span><span class="comment">#非私有(private)实例方法的调用</span></span><br><span class="line"><span class="built_in">invoke-direct</span><span class="comment">#用于构造方法以及私有方法</span></span><br><span class="line"><span class="built_in">invoke-static</span><span class="comment">#调用静态方法，static方法不需要传入this实例</span></span><br><span class="line"><span class="built_in">invoke-super</span><span class="comment">#调用父类方法</span></span><br><span class="line"><span class="built_in">invoke-interface</span><span class="comment">#调用接口方法，interface为接口</span></span><br></pre></td></tr></tbody></table></figure>
<p>编写一个类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String a)</span></span>{</span><br><span class="line">        getname();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663060304853.png" alt=""></p>
<h4 id="smali中对象的创建"><a class="header-anchor" href="#smali中对象的创建">¶</a>smali中对象的创建</h4>
<figure class="highlight vala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#声明实例</span></span><br><span class="line"><span class="keyword">new</span>-instance+变量名,对象包名路径</span><br><span class="line"></span><br><span class="line"><span class="meta">#调用构造方法(即构造器)(如果该构造方法还定义了成员变量，那么在函数调用前需要提前声明，然后在invoke时当作参数一并传入)</span></span><br><span class="line">invoke-direct{变量名},对象全包名路径;-&gt;&lt;init&gt;(参数)返回类型</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{}</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Test();</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="keyword">new</span>-instance v0,LTest;</span><br><span class="line">invoke-direct{v0},LTest;-&gt;&lt;init&gt;()v#构造器默认无参返回<span class="keyword">void</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="数据的定义"><a class="header-anchor" href="#数据的定义">¶</a>数据的定义</h4>
<p>主要有字符串数据、字节码数据、数据类型数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串.smali中不能直接返回，需要先存储在容器中</span></span><br><span class="line"><span class="keyword">const</span>-string v0,<span class="string">"hello"</span></span><br><span class="line"><span class="keyword">return</span>-object v0</span><br><span class="line"></span><br><span class="line"><span class="comment">//字节码对象</span></span><br><span class="line"><span class="keyword">const</span>-<span class="class"><span class="keyword">class</span> <span class="title">V0</span>,<span class="title">GoActivity</span></span>;</span><br><span class="line">startActivity在smali中分为两个步骤</span><br><span class="line">首先声明要启动的<span class="class"><span class="keyword">class</span>，以及当前<span class="title">Activity</span>的<span class="title">this</span>对象</span></span><br><span class="line"><span class="class">	<span class="title">const</span>-<span class="title">class</span> <span class="title">v0</span>,<span class="title">SecondActivity</span></span></span><br><span class="line"><span class="class">然后创建<span class="title">Intent</span>对象,<span class="title">v1</span>用于接收<span class="title">init</span>的返回对象</span></span><br><span class="line"><span class="class">    <span class="title">new</span>-<span class="title">instance</span> <span class="title">v1</span>,<span class="title">Landroid</span>/<span class="title">content</span>/<span class="title">Intent</span></span>;</span><br><span class="line">	invoke-direct{v1,p0,v0},Landroid/content/Intentl-&gt;&lt;init&gt;(Landroid/content/Intent;Ljava/lang/<span class="class"><span class="keyword">class</span></span>;)V</span><br><span class="line">最后调用StartActivity方法</span><br><span class="line">	invoke-virtual{p0,v1},LTestActivity-&gt;StartActivity(Landroid/content/Intent;)V</span><br><span class="line">        </span><br><span class="line"><span class="comment">//数值型数据的定义        </span></span><br><span class="line"><span class="keyword">const</span><span class="comment">//占用一个容器</span></span><br><span class="line"><span class="keyword">const</span>-wide<span class="comment">//占用两个容器,long</span></span><br><span class="line">        <span class="keyword">const</span> v0,<span class="number">30</span></span><br><span class="line">        <span class="keyword">const</span>-wide v0,<span class="number">30</span>#占用v0和v1容器，会默认占用目标寄存器和目标寄存器的下一个容器，<span class="number">64</span>位</span><br><span class="line">        <span class="keyword">const</span>/<span class="number">4</span>#最大只允许四个二进制位，也就是<span class="number">1111</span>(有符号)(<span class="keyword">char</span>)</span><br><span class="line">        <span class="keyword">const</span>/<span class="number">16</span>#word</span><br><span class="line">        <span class="keyword">const</span>#占用一个寄存器，<span class="number">32</span>位,<span class="keyword">int</span></span><br><span class="line">        <span class="keyword">const</span>/high16#最大只允许存放高十六位二进制位数值</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span>-wide/<span class="number">16</span></span><br><span class="line">        <span class="keyword">const</span>-wide/<span class="number">32</span></span><br><span class="line">        <span class="keyword">const</span>-wide</span><br><span class="line">        <span class="keyword">const</span>-wide/highssss32</span><br></pre></td></tr></tbody></table></figure>
<h4 id="字段的取值与赋值"><a class="header-anchor" href="#字段的取值与赋值">¶</a>字段的取值与赋值</h4>
<figure class="highlight livescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.filed</span><br><span class="line">	<span class="keyword">static</span>对应sget<span class="string">\sput</span></span><br><span class="line">	instance对应iput<span class="string">\sput</span></span><br></pre></td></tr></tbody></table></figure>
<p>同样的不同的数据类型也对应不同的类型</p>
<figure class="highlight smali"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.class</span><span class="keyword"> public</span> <span class="class">LTest;</span><span class="comment">#声明类</span></span><br><span class="line"><span class="keyword">.field</span><span class="keyword"> private</span><span class="keyword"> static</span> a:<span class="class">Ljava/lang/String;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">.method</span></span><br><span class="line"><span class="built_in">	const-string </span>v0,<span class="string">"hello"</span></span><br><span class="line"><span class="built_in">	sput-object </span>v0,<span class="class">LTest;</span>-&gt;a:<span class="class">Ljava/lang/String;</span><span class="comment">#进行赋值</span><span class="keyword"></span></span><br><span class="line"><span class="keyword">.end method</span> </span><br></pre></td></tr></tbody></table></figure>
<h4 id="条件跳转if"><a class="header-anchor" href="#条件跳转if">¶</a>条件跳转if</h4>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663065694339.png" alt=""></p>
<h4 id="寄存器"><a class="header-anchor" href="#寄存器">¶</a>寄存器</h4>
<p>内部寄存器声明，<strong>在Dalvik中，每个寄存器都是32位的，2个寄存器用于存储long和double</strong></p>
<figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.registers</span> 数量<span class="comment">#声明于方法内部</span></span><br><span class="line"><span class="string">.locals</span> 数量<span class="comment">#都是表明寄存器数量</span></span><br><span class="line">上面两者的区别在于</span><br><span class="line"><span class="string">.locals</span>指明了这个非参寄存器的数量，而寄存器的总数包括保存方法参数的寄存器<span class="params">(存储局部变量寄存器的数量)</span>，如v0、v1等，没有p0</span><br><span class="line"><span class="string">.registers</span>指定了在这个方法中有多少个可用的寄存器<span class="params">(局部+参数)</span>，如p0、v0、v1</span><br></pre></td></tr></tbody></table></figure>
<p>寄存器的两种命名方法-<strong>p命名法和v命名法</strong>，<strong>主要是使用p命名法</strong></p>
<figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是v命名法，优先对局部变量进行声明</span></span><br><span class="line">比如v0和<span class="built_in">v1</span>已经被使用，那么方法中第一个参数存入<span class="built_in">v2</span>寄存器，依次往后</span><br><span class="line"><span class="comment">//p命名法，方法的参数使用p寄存器表示</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663066658590.png" alt=""></p>
<h4 id="smali语法关键字"><a class="header-anchor" href="#smali语法关键字">¶</a>smali语法关键字</h4>
<figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.line N<span class="comment">#表示与java源文件代码的映射关系，可删除</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">:cond_0</span><span class="comment">#条件分支，配合if使用</span></span><br><span class="line"></span><br><span class="line">.prologue<span class="comment">#表示程序的开始，可删除</span></span><br><span class="line"></span><br><span class="line">.goto_0<span class="comment">#goto跳转分支</span></span><br><span class="line"></span><br><span class="line">.local<span class="comment">#显示局部变量(寄存器中的值)别名信息，类比.line</span></span><br><span class="line"></span><br><span class="line">.locals N<span class="comment">#寄存器数量声明</span></span><br><span class="line"></span><br><span class="line">.Param p1,<span class="string">"a"</span><span class="symbol">:Ljava/lang/String</span>;<span class="comment">#也是起别名</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="smali代码注入"><a class="header-anchor" href="#smali代码注入">¶</a>smali代码注入</h2>
<h1 id="IDA-Dump-Android应用内存"><a class="header-anchor" href="#IDA-Dump-Android应用内存">¶</a>IDA Dump Android应用内存</h1>
<ol>
<li>首先先将应用程序附加到ida上</li>
<li>然后配置调试器在不同事件触发的地方设置断点</li>
<li>加载完目标so文件之后</li>
<li>首先获取应用程序的PID，<strong>adb shell ps</strong>，然后在adb shell内<strong>cat /proc/PID/map获取so文件起始地址</strong>，<strong>可以使用|grep "so"过滤</strong></li>
<li>然后编写IDAPython dump即可</li>
</ol>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663485969473.png" alt=""></p>
<blockquote>
<p><strong>在IDA中的Modules中能看到Odex文件，接下来可以从内存中Dump下来Dex文件，这是对抗动态加载壳的常用思路</strong></p>
</blockquote>
<h1 id="Root"><a class="header-anchor" href="#Root">¶</a>Root</h1>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/506203078">Magisk Hide替代品</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/StepTp/article/details/120678944">Pixel 3xl Root</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e86296765a0c">Xposed和Magisk</a></p>
<h2 id="Objection"><a class="header-anchor" href="#Objection">¶</a>Objection</h2>
<blockquote>
<p><strong>Objection可以快速完成诸如内存搜索、类和 模块搜索、方法Hook以及打印参数、返回值、调用栈等常用功能</strong></p>
<p><strong>Objection依托Frida完成了对应用的注入以及对函 数的Hook模板，使用时只需要将具体的类填充进去即可完成相应的 Hook测试</strong></p>
</blockquote>
<p>安装好之后，通过命令<strong>objection -g 包名 explore</strong>注入进程后即可进入REPL界面</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663557014085.png" alt=""></p>
<p>在REPL界面中，按空格键就会提示可用的命令，出现提示之后通过上下选择键及回车键便可输入命令</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663557327759.png" alt=""></p>
<ol>
<li>
<p>help命令：在当前命令前加help之后再回车即可查看当前命令的解释信息<img src="/2022/08/31/Android-Reverse-Engineering/1663557437706.png" alt=""></p>
</li>
<li>
<p>jobs命令：用于查看和管理当前所执行的Hook的任务，可以同时运行多项Hook任务</p>
</li>
<li>
<p>frida命令：查看Frida相关信息</p>
</li>
<li>
<p>内存漫游相关命令，<strong>Objection可以快速便捷地打印出内存中各种类地相关信息</strong></p>
<ul>
<li><strong>android hooking list classes</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663557730285.png" alt=""></li>
<li><strong>android hooking search classes 关键字</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663557907125.png" alt=""></li>
<li>**android hooking search methods <key>**来从内存中获取所有包含关键字key的方法</key></li>
<li>搜索到我们感兴趣的类后可以使用<strong>android hooking list class_methods</strong>来查看类的所有方法<img src="/2022/08/31/Android-Reverse-Engineering/1663558161849.png" alt=""></li>
<li><strong>android hooking list activities</strong>列出进程中所有的活动<img src="/2022/08/31/Android-Reverse-Engineering/1663558271389.png" alt=""></li>
<li><strong>android hooking list services</strong>列出进程所有的service，对于其余两个组件，只需要修改为<strong>receivers和providers</strong>即可</li>
</ul>
</li>
<li>
<p><strong>Hook命令</strong>：**通过android hooking watch class_method <methodname>**对指定类进行Hook<img src="/2022/08/31/Android-Reverse-Engineering/1663558826171.png" alt=""></methodname></p>
<p>还可以使用**–dump-args–dump-backtrace–dump-return**来打印函数的参数、调用栈以及返回值，<strong>默认会Hook对应方法的所有重载方法</strong></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663559042157.png" alt=""></p>
</li>
<li>
<p>Hook结束之后可以使用<strong>jobs kill pid</strong>来删除作业，<strong>jobs list</strong>列出所有作业</p>
</li>
<li>
<p><strong>主动调用</strong>：基于最简单的Java.choose的实现，**android heap search instances <classname>**来搜索实例，<strong>HashCode作为实例句柄来调用和执行函数</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663559758515.png" alt=""></classname></p>
<p>然后使用<strong>android heap execute HashCode Method</strong>，注意这里只能是无参的实例方法</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663562350795.png" alt=""></p>
</li>
<li>
<p><strong>主动调用有参实例方法</strong>：输入<strong>android heap evaluate HashCode Method</strong>之后需要自己编写脚本，其中<strong>clazz是该类的实例</strong><img src="/2022/08/31/Android-Reverse-Engineering/1663563150239.png" alt=""></p>
</li>
<li>
<p><strong>启动活动命令</strong>:<strong>android intent launch_activity 活动</strong></p>
</li>
</ol>
<p>当我们无法使用USB进行连接时，还可以使用Objection进行网络模式连接</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663563355880.png" alt=""></p>
<h1 id="MT管理器"><a class="header-anchor" href="#MT管理器">¶</a>MT管理器</h1>
<p><a target="_blank" rel="noopener" href="https://www.mianshigee.com/tutorial/mt-manual/basic.md">MT管理器的使用</a></p>
<h1 id="AS动态调试APK"><a class="header-anchor" href="#AS动态调试APK">¶</a>AS动态调试APK</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kenbo_257/article/details/122726128#:~:text=android%20studio%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95apk%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B%201%20%E9%A6%96%E5%85%88%E8%A6%81%E6%87%82%E7%9A%84smali%E5%BE%97%E8%AF%AD%E6%B3%95%EF%BC%8C%E7%9F%A5%E9%81%93%E5%9C%A8%E5%93%AA%E9%87%8C%E4%B8%8B%E6%96%AD%E7%82%B9%EF%BC%8C%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%EF%BC%8C%E8%B0%83%E8%AF%95%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%AE%9A%E4%BD%8D%E5%BE%88%E9%87%8D%E8%A6%81%EF%BC%8C%E4%B8%8D%E7%94%A8%E5%A4%AA%E7%B2%BE%E9%80%9A%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%80%E8%B5%B7%E7%A0%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A6%81%E7%9F%A5%E9%81%93%202%20%E4%BD%A0%E6%89%80%E8%B0%83%E8%AF%95%E7%9A%84apk%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%8C%81%E5%8F%8D%E7%BC%96%E8%AF%91%E5%90%8E%E4%BA%8C%E6%AC%A1%E7%AD%BE%E5%90%8D%EF%BC%8C%E6%9C%89%E4%B8%80%E4%BA%9Bapk%E5%8C%85%E6%98%AF%E5%81%9A%E4%BA%86%E7%AD%BE%E5%90%8D%E6%95%88%E9%AA%8C%E7%9A%84%EF%BC%8C%E9%9C%80%E8%A6%81%E7%A0%B4%E8%A7%A3%E4%B9%8B%E5%90%8E%E6%89%8D%E8%83%BD%E6%89%93%E5%8C%85%EF%BC%8C%E6%9C%89%E4%BA%9B%E6%98%AF%E5%8A%A0%E4%BA%86%E5%A3%B3%E7%9A%84%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E5%8E%BB%E5%A4%84%E7%90%86%E4%BD%A0%E6%89%80%E8%B0%83%E8%AF%95%E7%9A%84apk%E5%8C%85%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%8D%E4%BB%94%E7%BB%86%E8%AF%B4%E6%98%8E%E6%80%8E%E4%B9%88%E7%A0%B4%E8%A7%A3%E7%AD%BE%E5%90%8D%E6%95%88%E9%AA%8C%E5%92%8C%E8%84%B1%E5%A3%B3%E6%93%8D%E4%BD%9C%E3%80%82,3%20%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%88%96%E8%80%85%E6%89%8B%E6%9C%BA%EF%BC%88%E6%97%A0%E9%9C%80ROOT%EF%BC%89%EF%BC%8Cadb%E8%83%BD%E5%A4%9F%E6%AD%A3%E5%B8%B8%E9%93%BE%E6%8E%A5%E6%89%8B%E6%9C%BA%204%20%E9%9C%80%E8%A6%81android%20studio%20%EF%BC%88%E5%BB%BA%E8%AE%AE%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%89">AS动态调试APK</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/joby1981/article/details/16809869">通过资源id找到所在位置</a></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663078077134.png" alt=""></p>
<h1 id="Java"><a class="header-anchor" href="#Java">¶</a>Java</h1>
<h2 id="反射"><a class="header-anchor" href="#反射">¶</a>反射</h2>
<p>反射是框架的设计灵魂，<strong>反射就是将类的各个组成部分封装为其他对象</strong></p>
<p>首先我们先来看java代码文件在计算机中的经历的阶段</p>
<blockquote>
<p>Java源文件首先通过javac编译为class文件，class文件中存储<strong>成员变量、构造方法、普通方法</strong>。<strong>然后将硬盘中的class类通过类加载器(ClassLoader)加载到内存中，而Java中有class类对象来存储字节码文件中的信息</strong>，字节码文件中主要的内容有<strong>成员变量、构造方法、成员方法</strong>，因为上述内容可能存在多个，所以使用数组进行存储。最后在<strong>运行时阶段构造成员</strong>。这样就将类中的各个部分封装为其他对象</p>
</blockquote>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663419013223.png" alt=""></p>
<p><strong>反射的好处：可以在程序运行时阶段操作这些对象，同时可以解耦，提高程序的可扩展性</strong>，就像下面的输入提示，当我们输入"a."，程序会提示输入，<strong>这就是将String类的方法进行了封装Method[]，然后遍历数组将所有的方法进行展示</strong></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663289657209.png" alt=""></p>
<h3 id="反射的好处"><a class="header-anchor" href="#反射的好处">¶</a>反射的好处</h3>
<p>我们可以通过在配置文件中写入要加载的类和需要调用的方法（使用集合存储），然后在程序中加载类和调用方法。<strong>在框架中需要经常地通过配置外部文件，在不修改源码的情况下来控制程序</strong></p>
<h3 id="类加载"><a class="header-anchor" href="#类加载">¶</a>类加载</h3>
<p><strong>分为静态加载和动态加载</strong></p>
<ol>
<li>静态加载：在编译时加载相关的类，如果没有则报错，<strong>即使我们在程序中可能不会用到这个类，但也必须编写类（在switch……case中创建对象，这样可能不会用到该类）</strong>。依赖性太强</li>
<li>动态加载：运行时加载需要的类，如果运行时不用该类则不报错</li>
</ol>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663419595624.png" alt=""></p>
<p><strong>类加载时机</strong></p>
<ul>
<li>当创建对象时（new）<strong>静态加载</strong></li>
<li>当子类被加载时 <strong>静态加载</strong></li>
<li>调用类中的静态成员时 <strong>静态加载</strong></li>
<li>通过反射 <strong>动态加载</strong></li>
</ul>
<h3 id="获取Class对象的方式"><a class="header-anchor" href="#获取Class对象的方式">¶</a>获取Class对象的方式</h3>
<ol>
<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象，<strong>多用于配置文件，将类名定义在配置文件中，读取文件、加载类</strong></li>
<li><strong>当类已经加载进内存中</strong> 类名.class：通过类名的属性class获取，<strong>多用于参数的传递</strong></li>
<li><strong>当创建好对象</strong>，对象.getclass()：getclass方法在object中定义着，所有对象都有这个方法。，<strong>多用于对象的获取获取字节码方式</strong>——常用</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class cls1=Class.forName(<span class="string">"com.hspedu.super01.B"</span>);<span class="comment">//必须是全类名路径</span></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        </span><br><span class="line">        Class cls2=B.class;</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line"></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        Class cls3=b.getClass();</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//因为每一个Class只会在内存中创造一个Class类对象，所以这三者是一样的</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="Class类对象的功能"><a class="header-anchor" href="#Class类对象的功能">¶</a>Class类对象的功能</h3>
<ol>
<li>
<p>获取成员变量们</p>
<ul>
<li>Field[] getFields()//获取多个</li>
<li>Field getField(String name)//获取一个</li>
<li>Field[] getDeclaredFields()，<strong>获取所有的成员变量，不管修饰符</strong>，此时我们就可以操作私有的成员变量</li>
<li>Field getDeclareField(String name)</li>
</ul>
</li>
<li>
<p>获取构造方法们</p>
<p>同样也有getconstructor等方法</p>
</li>
<li>
<p>获取成员方法们</p>
<p>同上</p>
</li>
<li>
<p>获取类名：String getName()</p>
</li>
</ol>
<h3 id="获取Field"><a class="header-anchor" href="#获取Field">¶</a>获取Field</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Field fields[]=bClass.getFields();<span class="comment">//这个方法是用来获取所有public的成员变量</span></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields){</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>获取到了两个对象</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663291619627.png" alt=""></p>
<blockquote>
<p><strong>getFields()用来获取所有public的成员变量</strong></p>
</blockquote>
<p><strong>获取到字段之后使用get和set对成员变量的值进行操作，参数为对象，因为成员变量是在对象内的</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Field fields[]=bClass.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field:fields){</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        }</span><br><span class="line">        Field a=bClass.getField(<span class="string">"name"</span>);<span class="comment">//首先通过Class对象获取到字段</span></span><br><span class="line">        B b=<span class="keyword">new</span> B();</span><br><span class="line">        Object fin=a.get(b);<span class="comment">//创建对象后传入</span></span><br><span class="line">        System.out.println(fin);</span><br><span class="line"></span><br><span class="line">        a.set(b,<span class="string">"11111"</span>);<span class="comment">//将b对象中的字段的值设置为11111</span></span><br><span class="line">        System.out.println(b.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">       Field[] field=bClass.getDeclaredFields();</span><br><span class="line">       <span class="keyword">for</span>(Field field1:field){</span><br><span class="line">           System.out.println(field1);</span><br><span class="line">       }</span><br><span class="line">       Field m=bClass.getDeclaredField(<span class="string">"m"</span>);</span><br><span class="line">       B b=<span class="keyword">new</span> B();</span><br><span class="line">       m.setAccessible(<span class="keyword">true</span>);<span class="comment">//因为是私有的，需要设置暴力反射</span></span><br><span class="line">       Object obj=m.get(b);</span><br><span class="line">       System.out.println(obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="获取Constructor"><a class="header-anchor" href="#获取Constructor">¶</a>获取Constructor</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">       Class bClass=B.class;</span><br><span class="line">        Constructor con=bClass.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(con);<span class="comment">//获取构造器，可以指定参数获取不同的构造器，空参构造器可以直接使用bClass.newInstance()来创建对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//constructor可以用于创建对象</span></span><br><span class="line">        Object text=con.newInstance(<span class="string">"Jack"</span>,<span class="number">12</span>);</span><br><span class="line">        <span class="comment">//使用B的父类Object接收</span></span><br><span class="line">        System.out.println(text);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="获取Method"><a class="header-anchor" href="#获取Method">¶</a>获取Method</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Method method=bClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line">        B b=<span class="keyword">new</span> B();<span class="comment">//无参函数</span></span><br><span class="line">        method.invoke(b);<span class="comment">//直接调用</span></span><br><span class="line"></span><br><span class="line">        Method method1=bClass.getMethod(<span class="string">"eat"</span>,String.class);<span class="comment">//参数类型</span></span><br><span class="line">        System.out.println(method1.getName());<span class="comment">//获取方法名</span></span><br><span class="line">        method1.invoke(b,<span class="string">"apple"</span>);</span><br><span class="line"></span><br><span class="line">        Class aClass=Class.forName(<span class="string">"com.hspedu.super01.A"</span>);</span><br><span class="line">        <span class="comment">//Object父类方法也会被获取到，方法也支持暴力反射</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="整个过程的使用"><a class="header-anchor" href="#整个过程的使用">¶</a>整个过程的使用</h3>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class bClass=B.class;</span><br><span class="line">        Constructor con=bClass.getConstructor(String.class,<span class="keyword">int</span>.class);<span class="comment">//获取构造器</span></span><br><span class="line">        <span class="comment">//通过构造器创建对象，因为在java中，调用方法是通过p.Method()来进行的，所以需要通过实例来进行</span></span><br><span class="line">        Object b=con.newInstance(<span class="string">"jack"</span>,<span class="number">12</span>);</span><br><span class="line">        Method method=bClass.getMethod(<span class="string">"eat"</span>);</span><br><span class="line"></span><br><span class="line">        method.invoke(b);<span class="comment">//直接调用</span></span><br><span class="line">        Method method1=bClass.getMethod(<span class="string">"eat"</span>,String.class);<span class="comment">//参数类型</span></span><br><span class="line">        System.out.println(method1.getName());<span class="comment">//获取方法名</span></span><br><span class="line">        method1.invoke(b,<span class="string">"apple"</span>);</span><br><span class="line"></span><br><span class="line">        Class aClass=Class.forName(<span class="string">"com.hspedu.super01.A"</span>);</span><br><span class="line">        <span class="comment">//Object父类方法也会被获取到，方法也支持暴力反射</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="泛型"><a class="header-anchor" href="#泛型">¶</a>泛型</h2>
<h2 id="多态-v2"><a class="header-anchor" href="#多态-v2">¶</a>多态</h2>
<p><strong>解决代码复用性不高且不利于代码维护的问题</strong></p>
<p>所谓的多态就是一个对象同时具备多种属性，比如小明既是学生也是人</p>
<p>下面以一个例子来看多态的好处，我们要实现主人喂动物这个操作，此时需要在master这个类中定义两种Feed方法</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663482436003.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663482673581.png" alt=""></p>
<p>而是用多态只需要一个方法即可</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663482730147.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663482743705.png" alt=""></p>
<blockquote>
<p><strong>父类类型 引用名=new 子类类型()</strong>，即为多态，<strong>也是多态中的向上转型</strong> 也就类似先在堆中new一个子类对象，接着使用父类的引用指向该对象地址，<strong>编译类型(编译时)看等号左边、运行类型(程序运行时)看等号右边</strong>，编译类型在定义对象时就确定了，运行类型是可以变化的。<strong>一个对象的编译类型和运行类型可以不一样</strong>，比如上面的dog定义为Animal类(编译类型)，但在运行时指向Dog类(运行类型)，<strong>成员变量是编译类型，方法是运行类型</strong></p>
</blockquote>
<p><strong>此时可以访问父类的所有成员以及调用子类中重写父类的方法、但是不能访问子类的特有方法，如果要访问，只能再向下转型，要注意的是向下转型对象的类型必须一致</strong>，这个操作就相当于重写使用一个cat引用名指向new出来的Cat对象，但是不能使用cat引用名指向new出来的Dog对象</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663483447057.png" alt=""></p>
<p><strong>多态的前提是两个对象存在继承关系</strong></p>
<h2 id="接口"><a class="header-anchor" href="#接口">¶</a>接口</h2>
<h3 id="抽象"><a class="header-anchor" href="#抽象">¶</a>抽象</h3>
<p>如果父类方法不确定如何进行方法体实现，那么这就是一个抽象方法。将图形作为父类，子类为长方形、圆形、三角形，我们可以<strong>通过不同的面积公式</strong>来求得各个图形的面积，但是我们没有办法直接求解图形的面积</p>
<blockquote>
<p>此时就需要抽象方法来定义，<strong>父类定义抽象方法(不需要函数体，因为每个图形对应的方法都是不同的)，然后子类继承父类后必须重写父类的抽象方法，但不用声明为abstract</strong></p>
</blockquote>
<p><strong>抽象方法所在的类必须是抽象类，抽象类不能直接new对象，抽象方法的调用：先通过实现类完成对抽象方法的实现，再通过实现类的对象调用</strong></p>
<p>测试代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super01</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//抽象类不能new对象</span></span><br><span class="line">        Rabbit rabbit1=<span class="keyword">new</span> Rabbit();</span><br><span class="line">        rabbit1.print();</span><br><span class="line"></span><br><span class="line">        Wolf wolf=<span class="keyword">new</span> Wolf();</span><br><span class="line">        wolf.print();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>父类，print是抽象方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;<span class="comment">//定义一个抽象方法，不需要方法体，需要子类自己重写</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>两个子类，<strong>使用@Override对父类的抽象方法进行重写，也可以说是实现，将其具体化</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Wolf"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>{</span><br><span class="line">    <span class="comment">//必须对父类的抽象方法进行实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Rabbit"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="接口-v2"><a class="header-anchor" href="#接口-v2">¶</a>接口</h3>
<blockquote>
<p><strong>接口就是一种公共的规范标准，相当于模板</strong></p>
</blockquote>
<p>比如USB接口，只要符合USB的标准就可以使用USB，打印机、U盘等，<strong>接口没有静态代码块和构造方法</strong></p>
<h4 id="抽象方法"><a class="header-anchor" href="#抽象方法">¶</a>抽象方法</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口中默认声明为public abstract</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口中定义抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Method01</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method02</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>导入接口并使用<strong>implement表示对该接口进行实现</strong>，然后重写接口中<strong>所有的抽象方法</strong>，如果没有重写所有，则需要将实现类定义为<strong>抽象类</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.InterFace;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">InterFace</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method01</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Method01"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method02</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Method02"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后创建实现类的对象后，通过实现类的对象调用即可</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test test=<span class="keyword">new</span> Test();</span><br><span class="line">test.Method01();</span><br><span class="line">test.Method02();</span><br></pre></td></tr></tbody></table></figure>
<h4 id="默认方法"><a class="header-anchor" href="#默认方法">¶</a>默认方法</h4>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于接口中的抽象方法都需要实现，当我们需要在接口中添加方法时就需要修改使用了该接口的类</span></span><br><span class="line">   <span class="comment">//这时候就需要添加默认方法即可，此时就不需要在类中重写，关键字为default，需要加入方法体</span></span><br><span class="line">   <span class="comment">//默认方法也可以被覆盖重写</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">Method03</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"This is Method03"</span>);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<h4 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h4>
<p><strong>静态方法：接口中不希望被被实现类使用的方法，关键字为static，只能通过接口名称调用，只能是public static</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Method04</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"This is Method04"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>静态方法的调用</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1663417512103.png" alt=""></p>
<h4 id="私有方法"><a class="header-anchor" href="#私有方法">¶</a>私有方法</h4>
<p><strong>Java9开始接口中允许定义私有方法</strong>，<strong>private的方法只有接口自己可以调用，不能被实现类或别人调用</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通私有方法</span></span><br><span class="line"><span class="keyword">private</span> 返回值类型 方法名(参数列表){方法体};</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态私有方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名(参数列表){方法体};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="常量"><a class="header-anchor" href="#常量">¶</a>常量</h4>
<blockquote>
<p><strong>常量关键字为public static final，final表明为这个值不可被修改</strong></p>
</blockquote>
<h4 id="一个类实现多个接口"><a class="header-anchor" href="#一个类实现多个接口">¶</a>一个类实现多个接口</h4>
<p><strong>一个类的直接父类是唯一的，但是一个类可以同时实现多个接口</strong></p>
<p>注意事项</p>
<ol>
<li>如果实现类所实现的多个接口中存在多个重复的抽象方法，<strong>只需要覆盖重写一次即可</strong></li>
<li>如果实现类没有覆盖重写所有抽象方法，则需要将实现类定义为<strong>抽象类</strong></li>
<li>如果实现类所实现的多个接口中存在重复的默认方法，那么<strong>需要对默认方法进行覆盖重写</strong></li>
<li>如果实现类的父类方法和接口中的默认方法冲突时，优先调用父类的方法</li>
</ol>
<h1 id="移动端攻防技术"><a class="header-anchor" href="#移动端攻防技术">¶</a>移动端攻防技术</h1>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/4960">LLVM</a></p>
<h1 id="Xposed框架介绍"><a class="header-anchor" href="#Xposed框架介绍">¶</a>Xposed框架介绍</h1>
<p>Xposed更适用于长久化的使用，但是每次安装框架之后都需要重启，这也是其麻烦的一点</p>
<h2 id="AS编写Xposed框架"><a class="header-anchor" href="#AS编写Xposed框架">¶</a>AS编写Xposed框架</h2>
<p>Xposed框架本质上也是APK，但是我们需要让其被Xposed识别，所以我们先要安装好环境，由于Xposed很久没有发布了，不支持较高版本的Android8.0、8.1以上，但是Magisk有<strong>Edxposed</strong>来代替</p>
<p><a href="https://gitee.com/dev_dX/riruxposed#https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2FElderDrivers%2FEdXposed%2Freleases">Root手机刷入Edxposed</a></p>
<h1 id="抓包详解"><a class="header-anchor" href="#抓包详解">¶</a>抓包详解</h1>
<blockquote>
<p><strong>在安卓App的逆向分析中，抓包通常是指通过一些手段来获取App与服务器之间传输的明文网络数据信息</strong>，我们可以通过获取到的信息快速定位关键接口函数的位置</p>
</blockquote>
<p><strong>主要有Hook抓包和中间人抓包</strong></p>
<ol>
<li><strong>Hook抓包</strong>：Hook抓包实际上是通过对发包函数的Hook来达到抓包的目的</li>
<li><strong>中间人抓包</strong>：将一段完整的客户端-服务器的通信方式割裂为两段客户端-服务器通信<img src="/2022/08/31/Android-Reverse-Engineering/1663657312049.png" alt=""></li>
</ol>
<p><strong>抓包的主要工具有Wireshark、BurpSuite、Charles、Fiddler</strong>，Fiddler不推荐使用</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7f17061dbcbf?u_atoken=14182ace-0e0e-463f-9996-75c3d3185b89&amp;u_asession=01GKVj8-YWn0KueCdhU4ZSk658Da2FBjfO1JCBfh1Gr43oHEhvmXVEe8R5g-jOXD4fX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K9jobxe0zzCvOSFHghz6zYUkC1LUOsbnJoxzzl_EpVkQGBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=057B1HkqRcx00OK6N3B0TcaE5gAgguwngpuL6XYrGrnQfO-96XeptSZb0njPdZzroKKo_AyXFGwNvJgSrvJ4tPI7b5CAbw2ZXNkU3nT-gKy4hb0e7JHInY4BO5hKuzfsRZMoOuMaSf8YHl-pI56SBKYIe6smrNB6XbY-woE5mor2v9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzQMgAchpo_DngDnbnyfG1xD4wmivQt_BGPIdIwfuKPQjUDrMH9U5oL9icxwFsJSlo-3h9VXwMyh6PgyDIVSG1W-GXTIg1qMl4qfyOkBxxkWx6rN4WnkP27a0CQVvwR6dMvxujFdoiwZ9o5RqXUmYm7FT7neMKWToEY6c9-kDqUzamWspDxyAEEo4kbsryBKb9Q&amp;u_aref=Iy6h6y%2F3KS4PUfgkF%2BqPATFN9Ns%3D">Charles抓包</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35835118/article/details/94381177">Charles破解</a></p>
<p>其中手机中输入的代理主机名应为下面这个地址，使用ipconfig获取</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664076582081.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664111445479.png" alt=""></p>
<h1 id="安卓攻防技术"><a class="header-anchor" href="#安卓攻防技术">¶</a>安卓攻防技术</h1>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/246020">面试问题</a></p>
<ol>
<li><strong>动态加载方案</strong>：将u需要保护的代码单独编译成一个二进制文件，将其加密后保存在一个外部的二进制文件中。<strong>在外部程序运行的过程中再将保护的二进制文件解密并使用ClassLoader类加载器来动态加载和运行被保护的代码</strong>，<strong>Android中每个Java类都是由ClassLoader类加载器加载和运行的</strong></li>
<li><strong>App加固</strong>：最难绕过的保护手段就是App加固</li>
<li><strong>Root检测</strong></li>
<li><strong>NDK</strong>：将关键代码写入native层，Java层只作为加载器和调用端</li>
<li><strong>云端存储数据</strong></li>
<li><strong>反调试</strong>：<strong>运行时检测和事先阻止</strong>，<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/mobile/291894.html">反调试</a>
<ul>
<li><strong>运行时检测</strong>：如果调用ptrace()函数进行进程附加，/proc/<pid>/status文件中的TracePid变量会在进程被附加后由0变为附加进程的pid，<strong>如果此时代码本身单开一个线程对这个文件的TracePid值进行循环检测，异常时则退出进程，就做到了阻止进程被破解者调试</strong></pid></li>
<li><strong>时间差检测</strong>：调试的时候指令执行时间较长，我们可以基于此进行检测</li>
<li><strong>双进程保护</strong>：主要是基于<strong>一个进程最多只能被一个进程ptrace附加的特性</strong>，实现fork一个子进程ptrace，然后ptrace自己</li>
</ul>
</li>
<li><strong>代码混淆</strong>
<ul>
<li>符号混淆：Google自带的混淆器<strong>ProGuard</strong>，主要是将有意义的名称改为a、b这种无符号的名称</li>
<li>压缩文件大小：只要修改App/build/grale文件，将buildTypes中的minifyEnabled对应的值改为true即可</li>
<li><strong>DexGuard</strong>：收费商业软件，是ProGuard的升级版，支持<strong>字符串加密、花指令、资源加密等</strong></li>
</ul>
</li>
</ol>
<p>攻击：</p>
<ol>
<li>静态分析和动态分析结合：IDA、GDB对so文件进行调试，Jeb、AS调试smali</li>
<li><strong>Hook和Trace</strong></li>
<li>反反调试：手动patch<strong>检测代码逻辑</strong>后重新打包</li>
</ol>
<h2 id="App加固"><a class="header-anchor" href="#App加固">¶</a>App加固</h2>
<blockquote>
<p><strong>App加固，类似动态加载，用加固厂商的壳程序包裹真实的App，在真实动态运行时再通过壳程序执行释放出来的真正的App</strong></p>
</blockquote>
<p>App加固的发展主要可以分为三个阶段</p>
<h3 id="DEX整体加固"><a class="header-anchor" href="#DEX整体加固">¶</a>DEX整体加固</h3>
<p>这个阶段的App加固的核心原理就是<strong>将DEX整体加密后动态加载</strong>，在对加密的文件解密之后调用<strong>DexClassLoader或者其他类加载函数</strong>来加载解密后的文件，由于对文件的操作过于明显，进阶为<strong>将加密的DEX在内存中进行加载的加固技术</strong>，<strong>但还是可以通过在内存中搜索DEX文件头或在加载DEX的函数上下断点、进行Hook就可以找到解密数据</strong></p>
<blockquote>
<p><strong>由于DEX整体加固总是将代码数据完整地存储在一段内存中，只要绕过反注入和反调试技术即可获取到数据</strong></p>
</blockquote>
<h4 id="Frida脱壳"><a class="header-anchor" href="#Frida脱壳">¶</a>Frida脱壳</h4>
<p>主要是基于Hook <strong>libart.so导出的OpenMemory函数</strong>，只在Android8.0以下才有</p>
<h3 id="代码抽取保护"><a class="header-anchor" href="#代码抽取保护">¶</a>代码抽取保护</h3>
<p>这个阶段App加固的关键在于<strong>真正的代码数据并不与DEX的整体结构数据存储在一起</strong>，就算DEX被完整地dump出来，也无法看到真正的代码逻辑</p>
<p><strong>核心原理是利用私有函数，通过对其自身进程的Hook来拦截函数被调用时的路径，在抽取的函数被真实调用之前，将无意义代码数据填充到对应的代码区中</strong>（将Dex文件中的指令编码部分与Dex文件主体分离并独立执行加密操作，<strong>而原先的指令转为NOP指令</strong>，这样加载进内存中的Dex反编译后代码部分就是空的）</p>
<p>代码抽取技术并不会对App中所有的函数进行抽取保护，特别是<strong>第三方库</strong>。并且，代码抽取技术通常在函数被第一次调用后就不再将函数内容重新置空，<strong>因此只需要在App运行时多处发几次程序逻辑，然后再进行DEX的dump即可得到更加完整的DEX文件</strong></p>
<h4 id="FART脱壳"><a class="header-anchor" href="#FART脱壳">¶</a>FART脱壳</h4>
<blockquote>
<p><strong>对抗指令抽取的首要目标就是要获取正确的被抽取的方法指令，而方法指令被执行前一定会被解密，可以借助Android调用类方法的机制，通过系统加载指令的函数访问到内存中解密的指令，进而导出</strong></p>
</blockquote>
<p><strong>ART环境中常用的脱壳点：脱动态加载壳的本质是要获取在内存中处于解密状态的Dex文件，因此需要准确定位Dex文件在内存中的位置和大小，ART加载链接类时，Android会先调用LoadClass()函数去加载Dex文件中的类，然后调用LoadClassMembers()函数去初始化类的所有变量以及函数对象</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassLinker::LoadClassMembers</span><span class="params">(Thread* self, <span class="keyword">const</span> DexFile&amp; dex_file,<span class="keyword">const</span> <span class="keyword">uint8_t</span>* class_data,Handle&lt;mirror::Class&gt; klass,<span class="keyword">const</span> OatFile::OatClass* oat_class)</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>其中第二个参数就是对当前处理的dex对象的引用，<strong>在这个引用中我们可以得到Dex对象，从而获取Dex文件在内存中的地址以及长度</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/hanbinglengyue/FART">Fart脱壳源码</a></p>
<h4 id="DexHunter脱壳"><a class="header-anchor" href="#DexHunter脱壳">¶</a>DexHunter脱壳</h4>
<p><strong>通过主动加载DEX中的所有类并dump处所有方法对应的代码，最后将代码重构再填充回被抽取的DEX中</strong></p>
<h3 id="VMP与Dex2C"><a class="header-anchor" href="#VMP与Dex2C">¶</a>VMP与Dex2C</h3>
<p><strong>将所有的Java代码变成最终的native代码</strong></p>
<p>区别</p>
<h2 id="Ollvm"><a class="header-anchor" href="#Ollvm">¶</a>Ollvm</h2>
<p><a target="_blank" rel="noopener" href="https://jev0n.com/2022/07/08/ollvm-1.html">https://jev0n.com/2022/07/08/ollvm-1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html">https://blog.quarkslab.com/deobfuscation-recovering-an-ollvm-protected-program.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1488350-1-1.html">https://www.52pojie.cn/thread-1488350-1-1.html</a></p>
<p><a target="_blank" rel="noopener" href="https://mrt4ntr4.github.io/MODeflattener/">https://mrt4ntr4.github.io/MODeflattener/</a></p>
<h3 id="OLLVM环境配置与编译so文件"><a class="header-anchor" href="#OLLVM环境配置与编译so文件">¶</a>OLLVM环境配置与编译so文件</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013314647/article/details/117740784?spm=1001.2014.3001.5506">OLLVM环境配置</a></p>
<p><a target="_blank" rel="noopener" href="https://jev0n.com/2022/07/07/ollvm-0.html">参数详细说明</a></p>
<p>首先先配置好前面安装的NDK进行编译</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664171372070.png" alt=""></p>
<p>然后创建jni目录，在jni目录下创建<strong><a target="_blank" rel="noopener" href="http://Android.mk">Android.mk</a>,<a target="_blank" rel="noopener" href="http://Application.mk">Application.mk</a>，C/C++源文件</strong></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664171003366.png" alt=""></p>
<p>添加如下内容</p>
<p><strong>Android.mk文件</strong></p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_MODULE := hello</span><br><span class="line">LOCAL_LDLIBS := -lm -llog</span><br><span class="line">LOCAL_SRC_FILES := hello.cpp   <span class="comment">#自己的.c or .cpp文件</span></span><br><span class="line">LOCAL_CFLAGS := -mllvm -sub -mllvm -bcf -mllvm -bcf_loop=3  -mllvm -bcf_prob=40 -mllvm -fla -mllvm -split_num=10</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight diff"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//不同命令对应的混淆方式</span><br><span class="line"><span class="deletion">-mllvm -fla：控制流扁平化</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-mllvm -sub：指令替换</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-mllvm -bcf：虚假控制流程</span></span><br><span class="line"></span><br><span class="line"><span class="deletion">-mllvm -sobf： 字符串加密</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>Application.mk文件</strong></p>
<figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">APP_ABI := all</span><br><span class="line"></span><br><span class="line">APP_PLATFORM=android-19</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>hello.cpp</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">//需要注意函数的命名</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">{	</span><br><span class="line"><span class="function">jstring <span class="title">Java_com_example_myapplication_MainActivity_getStringFromJni</span><span class="params">(JNIEnv* jni, jobject obj)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> jni-&gt;<span class="built_in">NewStringUTF</span>(<span class="string">"Hello jni!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来cd到jni目录中，执行<strong>ndk-build</strong>即可</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664171707347.png" alt=""></p>
<p>然后在jni同路径下的libs目录即可找到编译完成的so文件</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664171751666.png" alt=""></p>
<p>混淆效果展示</p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664171777960.png" alt=""></p>
<p><img src="/2022/08/31/Android-Reverse-Engineering/1664171791787.png" alt=""></p>
<h3 id="指令替换混淆"><a class="header-anchor" href="#指令替换混淆">¶</a>指令替换混淆</h3>
<h3 id="控制流平坦化"><a class="header-anchor" href="#控制流平坦化">¶</a>控制流平坦化</h3>
<h3 id="伪造控制流"><a class="header-anchor" href="#伪造控制流">¶</a>伪造控制流</h3>
<h1 id="Android反调试"><a class="header-anchor" href="#Android反调试">¶</a>Android反调试</h1>
<p><a target="_blank" rel="noopener" href="https://www.lxiaoyu.com/p/366552">init段的反调试</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Reverse/" rel="tag"># Reverse</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/30/IDAPython/" rel="prev" title="IDAPython">
                  <i class="fa fa-chevron-left"></i> IDAPython
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/06/Learning/" rel="next" title="Learning">
                  Learning <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">513k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:46</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"GhjDb9gbtgwnrtsySW3fcGac-MdYXbMMI","appKey":"0Qw5kecTryGX5eSrEvShaWPw","serverURLs":"https://ghjdb9gb.api.lncldglobal.com","placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":"false# Article reading statistic","comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"el":"#valine-comments","path":"/2022/08/31/Android-Reverse-Engineering/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
