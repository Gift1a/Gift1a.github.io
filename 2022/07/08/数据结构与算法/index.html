<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="¶数据结构 ¶基本概念和术语 ¶数据 数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录 数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位 数据对象：是性质相同的数据元素的集合，是数据的子集 ¶结构 不同数据元素之间不是独立的，而是存在">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="¶数据结构 ¶基本概念和术语 ¶数据 数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录 数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位 数据对象：是性质相同的数据元素的集合，是数据的子集 ¶结构 不同数据元素之间不是独立的，而是存在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501980892.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502028932.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502086807.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502487332.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502635250.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657503293323.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657504108330.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510055411.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510171290.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514042881.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514222426.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514307777.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516394208.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516611507.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516871062.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516922060.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657620383741.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634024878.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634585653.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657635089691.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636505788.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636794584.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657677859248.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678031412.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678420041.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678529526.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657680434915.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682240174.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682220519.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682407800.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684222256.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684273946.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684630710.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657688706889.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689038037.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689312633.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689418201.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689587176.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689730159.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691539985.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691779653.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710307674.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710665197.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657711606663.png">
<meta property="article:published_time" content="2022-07-08T08:38:10.000Z">
<meta property="article:modified_time" content="2022-07-13T12:27:43.632Z">
<meta property="article:author" content="Gift1a">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png">


<link rel="canonical" href="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","path":"2022/07/08/数据结构与算法/","title":"数据结构与算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构与算法 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念和术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">逻辑结构与物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">集合结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">线性结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">树形结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">图形结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">物理结构——存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">链式存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-v2"><span class="nav-number">1.3.2.</span> <span class="nav-text">抽象数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">算法时间和空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">时间复杂度的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.2.</span> <span class="nav-text">空间复杂度的计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">线性表的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">线性表的顺序存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">3.2.1.</span> <span class="nav-text">顺序存储结构的插入与删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">线性表的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">3.3.1.</span> <span class="nav-text">单链表的读取、插入和删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">3.4.</span> <span class="nav-text">静态链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.1.</span> <span class="nav-text">静态链表的插入和删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">静态链表插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">静态链表删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">3.5.</span> <span class="nav-text">循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">3.5.1.</span> <span class="nav-text">两个循环链表的合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.6.</span> <span class="nav-text">双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">3.6.1.</span> <span class="nav-text">双向链表的查找、插入和删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">4.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">栈的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">栈的顺序存储及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="nav-number">4.2.1.</span> <span class="nav-text">两栈共享空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">栈的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88"><span class="nav-number">4.3.1.</span> <span class="nav-text">链栈的入栈和出栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">栈的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.5.</span> <span class="nav-text">栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">4.5.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">4.5.2.</span> <span class="nav-text">四则运算表达式求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">队列的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">5.2.1.</span> <span class="nav-text">队列顺序存储的不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.2.2.</span> <span class="nav-text">循环队列的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">队列的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%85%A5%E9%98%9F%E5%92%8C%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.1.</span> <span class="nav-text">链队列的入队和出队操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">串</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gift1a"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Gift1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gift1a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://1.12.239.117:8090/" title="http:&#x2F;&#x2F;1.12.239.117:8090&#x2F;" rel="noopener" target="_blank">Fallw1nd</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://equinox-shame.github.io/" title="https:&#x2F;&#x2F;equinox-shame.github.io&#x2F;" rel="noopener" target="_blank">梓曰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://a2ur2.github.io/" title="https:&#x2F;&#x2F;a2ur2.github.io&#x2F;" rel="noopener" target="_blank">A2ure</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/spmonkey/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;spmonkey&#x2F;" rel="noopener" target="_blank">星空</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构与算法 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 16:38:10" itemprop="dateCreated datePublished" datetime="2022-07-08T16:38:10+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-13 20:27:43" itemprop="dateModified" datetime="2022-07-13T20:27:43+08:00">2022-07-13</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>
<h1 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h1>
<h2 id="基本概念和术语"><a class="header-anchor" href="#基本概念和术语">¶</a>基本概念和术语</h2>
<h3 id="数据"><a class="header-anchor" href="#数据">¶</a>数据</h3>
<p>数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</p>
<p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录</p>
<p>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位</p>
<p>数据对象：是性质相同的数据元素的集合，是数据的子集</p>
<h3 id="结构"><a class="header-anchor" href="#结构">¶</a>结构</h3>
<p>不同数据元素之间不是独立的，而是存在特定的关系，而这些关系就是结构</p>
<p><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</strong></p>
<h2 id="逻辑结构与物理结构"><a class="header-anchor" href="#逻辑结构与物理结构">¶</a>逻辑结构与物理结构</h2>
<p>逻辑结构是面向问题的，物理结构就是面向计算机的，其基本的目标就是将数据及逻辑关系存储到计算机的内存中</p>
<h3 id="逻辑结构"><a class="header-anchor" href="#逻辑结构">¶</a>逻辑结构</h3>
<p>逻辑结构：<strong>是指数据对象数据元素之间的相互关系</strong>，这也是我们今后需要关注的地方</p>
<h4 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h4>
<p>使用示意图表示数据的逻辑结构时，要注意两点：</p>
<ul>
<li>将每一个数据元素看作一个结点，用圆圈表示</li>
<li>元素之间的逻辑关系用结点之间的连线表示，如果这个给关系是由方向的，那么用带箭头的连线表示</li>
</ul>
<h4 id="集合结构"><a class="header-anchor" href="#集合结构">¶</a>集合结构</h4>
<p><strong>集合结构：集合结构中的数据元素除了同属于一个集合外</strong>，它们之间没有其他关系，类似于数学中的集合</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png" alt="集合结构"></p>
<h4 id="线性结构"><a class="header-anchor" href="#线性结构">¶</a>线性结构</h4>
<p><strong>线性结构：线性结构中的数据元素是一对一的关系</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501980892.png" alt="线性结构"></p>
<h4 id="树形结构"><a class="header-anchor" href="#树形结构">¶</a>树形结构</h4>
<p><strong>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502028932.png" alt="树形结构"></p>
<h4 id="图形结构"><a class="header-anchor" href="#图形结构">¶</a>图形结构</h4>
<p><strong>图形结构：图形结构的数据元素是多对多的关系</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502086807.png" alt="图形结构"></p>
<h3 id="物理结构——存储结构"><a class="header-anchor" href="#物理结构——存储结构">¶</a>物理结构——存储结构</h3>
<p><strong>物理结构：是指数据的逻辑结构在计算机中的存储形式</strong></p>
<p>数据的存储结构应正确反映数据元素之间的逻辑关系</p>
<h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构">¶</a>顺序存储结构</h4>
<p><strong>顺序存储结构：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502487332.png" alt="顺序存储结构"></p>
<h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构">¶</a>链式存储结构</h4>
<p><strong>链式存储结构：是把数据元素存放在任意的存储单元中，这组存储单元可以是连续的，也可以是不连续的</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502635250.png" alt="链式存储结构"></p>
<p>此时数据元素的存储关系不能反映其逻辑关系，所以需要一个指针存放数据元素的地址，通过指针可以找到相关联数据元素的地址。相较于顺序存储结构，链式存储结构更为灵活，<strong>也更适合处理需要变化的结构</strong>，比如排队，当队伍中需要添加或者删去成员时，使用顺序存储结构则需要处理大量数据</p>
<h2 id="抽象数据类型"><a class="header-anchor" href="#抽象数据类型">¶</a>抽象数据类型</h2>
<h3 id="数据类型"><a class="header-anchor" href="#数据类型">¶</a>数据类型</h3>
<p><strong>数据类型：是指一组性质形同的值的集合及定义在此集合上的一些操作的总称</strong></p>
<h3 id="抽象数据类型-v2"><a class="header-anchor" href="#抽象数据类型-v2">¶</a>抽象数据类型</h3>
<p><strong>抽象数据类型：是指一个数据建模及定义在该模型上的一组操作</strong>，比如整型</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657503293323.png" alt="抽象数据类型标准格式"></p>
<h1 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h1>
<p><strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列。并且每条指令表示一个或多个操作</strong></p>
<p><strong>算法的基本特性：输入、输出、有穷性、确定性、可行性</strong></p>
<p><strong>算法的基本要求：</strong></p>
<ul>
<li>正确性</li>
<li>可读性：便于阅读、理解和交流</li>
<li>健壮性：当输入数据不合法时算法能做出相关处理</li>
<li>时间效率高和存储量低</li>
</ul>
<h2 id="算法时间和空间复杂度"><a class="header-anchor" href="#算法时间和空间复杂度">¶</a>算法时间和空间复杂度</h2>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657504108330.png" alt="算法时间复杂度定义"><br>
$$<br>
O(1)叫做常数阶、O(n)叫做线性阶、O(n^2)叫做平方阶<br>
$$</p>
<h3 id="时间复杂度的计算"><a class="header-anchor" href="#时间复杂度的计算">¶</a>时间复杂度的计算</h3>
<p>推导大O阶：</p>
<ul>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常数阶</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//这里代码的执行次数和问题的大小n无关，所以为常数，也就是O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//以上代码会执行n次，所以位O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数阶</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;n)</span><br><span class="line">{</span><br><span class="line">    count=count*<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//程序不再执行的条件是2^(count)&gt;=n，也就是count=log2n，所以这个循环的时间复杂度为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平方阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//因为上述程序为嵌套循环，所以会执行n*n次，所以时间复杂度为O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于下述循环嵌套，时间复杂度计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对于上述程序，我们先计算程序的执行次数，因为外层循环执行次数必定为n，主要看内层循环，内层循环执行次数总和为n+(n-1)+(n-2)+……=(n+1)/2，最终得到n^2/2+n/2</span></span><br><span class="line"><span class="comment">//按照上面的大O推导法，1、没有加法常数不予考虑，2、只保留最高阶也就是n^2/2，3、去除这个项的系数，得到n^2，所以时间复杂度为O(n^2)</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510055411.png" alt="常见的时间复杂度"></p>
<h3 id="空间复杂度的计算"><a class="header-anchor" href="#空间复杂度的计算">¶</a>空间复杂度的计算</h3>
<p>算法的空间复杂度通过计算算法所需要的存储空间实现</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510171290.png" alt=""></p>
<p>主要是数组大小，变量只占一个存储单元</p>
<h1 id="线性表"><a class="header-anchor" href="#线性表">¶</a>线性表</h1>
<p>线性表：零个或多个数据元素的有限序列，元素之间是有序的<img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514042881.png" alt="线性表的数学语言定义"></p>
<p>所以线性表元素的个数n定义为线性表的长度，当n=0时为空表</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514222426.png" alt="位序"></p>
<p><strong>在较复杂的线性表中，一个数据元素可以由若干个数据项组成</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514307777.png" alt="复杂线性表"></p>
<h2 id="线性表的抽象数据类型"><a class="header-anchor" href="#线性表的抽象数据类型">¶</a>线性表的抽象数据类型</h2>
<p>前面说过抽象数据类型分为数据和操作</p>
<p>在这里线性表的抽象数据类型定义如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">    DATA</span><br><span class="line">    	线性表的数据对象集合为(a1,a2,a3……，an)，每个元素的类型均为DataType。除了第一个元素a1外，其余元素都有且只有一个直接前驱元素，除最后一个元素外，其余元素都有且只有一个直接后继元素。数据元素之间的关系是一对一的关系</span><br><span class="line">    <span class="function">Operation</span></span><br><span class="line"><span class="function">    	<span class="title">InitList</span><span class="params">(*L)</span>	<span class="comment">//初始化操作，建立一个空的线性表</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListEmpty</span><span class="params">(*L)</span>	<span class="comment">//若线性表为空，返回true，否则返回false</span></span></span><br><span class="line"><span class="function">    	<span class="title">ClearList</span><span class="params">(*L)</span>	<span class="comment">//将线性表清空</span></span></span><br><span class="line"><span class="function">    	<span class="title">GetElem</span><span class="params">(L,i,*e)</span>	<span class="comment">//将线性表L中的第i个位置元素值返回给e</span></span></span><br><span class="line"><span class="function">    	<span class="title">LocateElem</span><span class="params">(L,e)</span> <span class="comment">//在线性表L中查找和e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则返回0表示失败</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListInsert</span><span class="params">(*L,i,e)</span>	<span class="comment">//在线性表L的第i个位置擦汗如新元素e</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListDelete</span><span class="params">(*L,i,*e)</span>	<span class="comment">//删除线性表L中的第i个未知元素，并用e返回其值</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListLength</span><span class="params">(L)</span>	<span class="comment">//返回线性表L的元素个数</span></span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>以上只是线性表的基础操作，对于复杂的一些操作可以分解为简单的操作，比如求A和B集合的并集这一操作可以分解为遍历B表，将A表中不存在的元素插入到A表中</strong></p>
</blockquote>
<h2 id="线性表的顺序存储结构"><a class="header-anchor" href="#线性表的顺序存储结构">¶</a>线性表的顺序存储结构</h2>
<p><strong>线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素</strong></p>
<p>描述顺序存储结构需要三个特性：</p>
<ul>
<li>存储空间的起始位置：数组data，他的存储位置就是存储空间的存储位置</li>
<li>线性表的最大存储容量：数组长度MaxSize</li>
<li>线性表的当前长度：length</li>
</ul>
<h3 id="顺序存储结构的插入与删除"><a class="header-anchor" href="#顺序存储结构的插入与删除">¶</a>顺序存储结构的插入与删除</h3>
<p>这两者其实是比较麻烦的，对于插入数据，插入位置之后的元素都需要后移，删除则为前移。</p>
<p>插入算法的思路：</p>
<ul>
<li>如果插入位置不合理，抛出异常</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将他们往后移动一个位置</li>
<li>将要插入的元素填入位置i处</li>
<li>表长+1</li>
</ul>
<p>删除算法也是类似的</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516394208.png" alt="线性表的优缺点"></p>
<h2 id="线性表的链式存储结构"><a class="header-anchor" href="#线性表的链式存储结构">¶</a>线性表的链式存储结构</h2>
<p><strong>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素</strong>，由于是任意的，我们还需要存储当前元素的后继元素地址</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516611507.png" alt="单链表的定义"></p>
<p><strong>一般会在单链表的第一个结点前附设一个头结点，在其数据域存储线性表的长度，然后让头结点的指针指向第一个结点</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516871062.png" alt="头指针与头结点的异同"></p>
<p>为了更好地理解，贴出下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516922060.png" alt=""></p>
<h3 id="单链表的读取、插入和删除"><a class="header-anchor" href="#单链表的读取、插入和删除">¶</a>单链表的读取、插入和删除</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//类型</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">}List;<span class="comment">//名称</span></span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">InsertNode</span><span class="params">(List* <span class="built_in">list</span>)</span><span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">		tmp-&gt;data = i;</span><br><span class="line">		tmp-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">		<span class="built_in">list</span>-&gt;next = tmp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">List* <span class="title">CreateList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	List* Node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	Node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建空的头结点</span></span><br><span class="line">	<span class="keyword">return</span> InsertNode(Node);<span class="comment">//插入结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (Linklist-&gt;next != <span class="literal">NULL</span>)<span class="comment">//第一个是空结点，所以先指向第一个结点</span></span><br><span class="line">	{</span><br><span class="line">		Linklist = Linklist-&gt;next;<span class="comment">//遍历单向链表</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Linklist-&gt;data);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">DeteleNode</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> goal = <span class="number">3</span>;<span class="comment">//删除结点需要先记录前一个结点的位置</span></span><br><span class="line">	List* p = Linklist, * q;<span class="comment">//初始化p用于遍历链表</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;data == goal)<span class="comment">//当前节点下一结点的值为3</span></span><br><span class="line">		{</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(q);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Linklist;<span class="comment">//返回的是头节点</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">List* <span class="title">InsertBytail</span><span class="params">(List* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	List* tmplist = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">		tmp-&gt;data = i;</span><br><span class="line">		tmp-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建新节点</span></span><br><span class="line">		<span class="comment">//从尾部插入</span></span><br><span class="line">		tmplist-&gt;next = tmp;</span><br><span class="line">		tmplist = tmplist-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	List* Linklist;</span><br><span class="line">	Linklist= CreateList();</span><br><span class="line">	<span class="comment">//PrintList(Linklist);</span></span><br><span class="line">	Linklist=DeteleNode(Linklist);</span><br><span class="line">	PrintList(Linklist);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>链表创建时可以使用尾插法和头插法，尾插法就是创建的结点从尾部插入，而头插法则反之</p>
<h2 id="静态链表"><a class="header-anchor" href="#静态链表">¶</a>静态链表</h2>
<p>即使用结构体数组来替代指针来描述单链表</p>
<blockquote>
<p><strong>首先让结构体数组拥有两个成员，data和cur。数据域data原来存放数据元素，也就是我们要处理的元素。而游标cur相当于单链表中的next指针，存放该元素的后继元素在数组中的下标，但是为了方便插入数据，通常需要把数组建立得大一些</strong></p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//游标Cursor，为0时表示无指向</span></span><br><span class="line">}Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure>
<p>同时我们需要对第一个元素和最后一个元素进行特殊元素处理，不存放数据。<strong>我们通常把未被使用得数组元素称为备用链表</strong></p>
<blockquote>
<p>数组第一个元素即下标为0的元素cur就存放备用链表(空位置)的第一个结点的下标。而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表的头结点的作用</p>
</blockquote>
<h3 id="静态链表的插入和删除操作"><a class="header-anchor" href="#静态链表的插入和删除操作">¶</a>静态链表的插入和删除操作</h3>
<p>前面可知，动态链表结点的申请和释放分别借用malloc和free函数。<strong>而在静态链表中，操作的是数组</strong>，为了区分哪些数组是被使用过的，我们可以将所有未被使用过的以及已经被删除的分量用游标链成一个备用的链表（使cur指向下一个空位置）</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657620383741.png" alt="静态链表"></p>
<h4 id="静态链表插入"><a class="header-anchor" href="#静态链表插入">¶</a>静态链表插入</h4>
<p>首先我们需要在备用链表中找到一个空位置，相当于(malloc)，然后将该位置的元素加入数据链表中此时当前的空位置会被占用，所以list[0]-&gt;cur也需要改变。</p>
<h4 id="静态链表删除"><a class="header-anchor" href="#静态链表删除">¶</a>静态链表删除</h4>
<p>和插入一样，都需要对备用链和数据链进行更改</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line">}Component, StaticList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//找到备用链表中的空位置</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur)<span class="comment">//如果备用链表已被使用过</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[i]-&gt;cur;<span class="comment">//因为当前位置被占用，所以从备用链表中解除</span></span><br><span class="line">		<span class="keyword">return</span> i;<span class="comment">//返回空位置的下标</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateList</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxsize - <span class="number">1</span>; ++i)<span class="comment">//初始化备用链表，此时空间都没被使用，所以list[0]-&gt;cur为0</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">list</span>[i]-&gt;cur = i + <span class="number">1</span>;<span class="comment">//cur相当于next，指向下一个结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//结尾的结点的cur赋值为0</span></span><br><span class="line">	<span class="built_in">list</span>[Maxsize - <span class="number">1</span>]-&gt;cur = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//从备用链表中获取空结点的位置,从而创建数据链表的头节点</span></span><br><span class="line">	<span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">int</span> head = k;<span class="comment">//返回头节点的位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//申请数据结点</span></span><br><span class="line">		<span class="keyword">int</span> s = Malloc(<span class="built_in">list</span>);</span><br><span class="line">		<span class="built_in">list</span>[s]-&gt;data = i;</span><br><span class="line">		k = s;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">list</span>[k]-&gt;cur = <span class="number">0</span>;<span class="comment">//数据链表的末尾结尾以0结尾，表示cur指向NULL</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//因为第一个是头结点无数据，所以跳过</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">		head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//插入的位置，首先在备用链表中获取空结点的下标</span></span><br><span class="line">	<span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">list</span>[k]-&gt;data = <span class="number">10</span>;<span class="comment">//给指定位置的元素赋值，下一步将其从中间插入，同时备用链表也需要改变</span></span><br><span class="line">	<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[k]-&gt;cur;<span class="comment">//这样就实现了不移动元素在中间插入数据</span></span><br><span class="line">	<span class="built_in">list</span>[<span class="number">4</span>]-&gt;cur = k;</span><br><span class="line">	<span class="built_in">list</span>[k]-&gt;cur = <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;data == <span class="number">10</span>)<span class="comment">//当前结点的后一个结点数值为10</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//当找到我们刚才插入的结点时，备用链表和数据链表都需要进行做出改变</span></span><br><span class="line">			<span class="comment">//首先改变数据链表</span></span><br><span class="line">			<span class="built_in">list</span>[head]-&gt;cur = <span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur;<span class="comment">//跳过下一结点</span></span><br><span class="line">			<span class="comment">//接下来改变备用链表，将其看作备用链表的结点</span></span><br><span class="line">			<span class="keyword">int</span> tmp = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line">			<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">			<span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur = tmp;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//后移</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	StaticList <span class="built_in">list</span>[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> head = CreateList(<span class="built_in">list</span>);</span><br><span class="line">	InsertNode(<span class="built_in">list</span>);</span><br><span class="line">	DeleteNode(<span class="built_in">list</span>, head);</span><br><span class="line">	PrintList(<span class="built_in">list</span>, head);</span><br><span class="line">	InsertNode(<span class="built_in">list</span>);</span><br><span class="line">	PrintList(<span class="built_in">list</span>, head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634024878.png" alt="静态链表的优缺点"></p>
<h2 id="循环链表"><a class="header-anchor" href="#循环链表">¶</a>循环链表</h2>
<p>之前提到的单链表都只存储向后的指针，所以没办法找到他的前驱节点。而我们只要将链表改为一个环就可以解决这样的问题，而这样的链表就是循环链表——解决了一个问题（如何从当中的一个结点出发，访问到链表的全部结点）</p>
<p><strong>将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为但循环链表，简称循环链表</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634585653.png" alt="循环链表和单链表的差异"></p>
<p>循环链表如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657635089691.png" alt="循环链表"></p>
<p>在单链表中，我们有了头结点时，可以用O(1)的时间访问第一个结点，但是要访问到最后一个结点则需要O(n)时间，因为所有结点都要访问一遍。</p>
<p>我们可以改造一下上面的循环链表，不用头指针，而是用<strong>指向终端结点的尾指针来表示循环链表</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636505788.png" alt=""></p>
<h3 id="两个循环链表的合并"><a class="header-anchor" href="#两个循环链表的合并">¶</a>两个循环链表的合并</h3>
<p>有了尾结点合并时就会比较简单</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636794584.png" alt="流程图"></p>
<p>rearA和rearB是两条循环链表的尾指针</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=readA-&gt;next;<span class="comment">//保存A表的头结点</span></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next;<span class="comment">//将B链的第一个结点（不是头结点）赋值给rearA-&gt;next</span></span><br><span class="line">readB-&gt;next=p;</span><br><span class="line"><span class="built_in">free</span>(p)<span class="comment">//释放p</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h2>
<p>在单向链表中，由于存在next指针，所以我们访问下一节点的时间复杂度为O(1)，而访问前一个结点则需要O(n)，所以设计出了双向链表。</p>
<p><strong>双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域</strong>，所以在双向链表中的每个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">prior</span>;</span><span class="comment">//直接前驱结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">next</span>;</span><span class="comment">//直接后继结点</span></span><br><span class="line">}DulNode,*DuLinkList;</span><br></pre></td></tr></tbody></table></figure>
<p>双向链表也可以是循环表</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657677859248.png" alt="双向循环链表"></p>
<h3 id="双向链表的查找、插入和删除"><a class="header-anchor" href="#双向链表的查找、插入和删除">¶</a>双向链表的查找、插入和删除</h3>
<p>查找的话只需要往一个方向遍历即可，不需要使用两个指针。</p>
<p>但是在插入和删除的时候需要同时对两个指针变量作出修改</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678031412.png" alt="插入的流程图"></p>
<blockquote>
<p>在编写代码时一定要注意顺序</p>
</blockquote>
<p>双向链表是使用空间换取时间的例子。</p>
<h1 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h1>
<p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong></p>
<blockquote>
<p><strong>栈顶——允许插入和删除，栈顶的另一端就是栈底，不含任何元素的叫空栈。栈又被称为后进先出的线性表</strong>，简称LIFO结构</p>
</blockquote>
<p><strong>栈的插入操作叫作进栈，也可以叫做压栈、入栈；栈的删除操作叫做出栈</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678420041.png" alt="出栈入栈图"></p>
<p>相同的元素出栈次序的变化是很多的</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678529526.png" alt="出入栈的例子"></p>
<h2 id="栈的抽象数据类型"><a class="header-anchor" href="#栈的抽象数据类型">¶</a>栈的抽象数据类型</h2>
<p>对于栈的插入和删除操作，我们改名为push和pop</p>
<p><strong>入栈(push)是先移动栈顶指针再压入元素，出栈(pop)是弹出元素再移动栈顶指针</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈</span><br><span class="line">DAta</span><br><span class="line">	同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Opreation</span></span><br><span class="line"><span class="function">	<span class="title">InitStack</span><span class="params">(*S)</span></span>;<span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line">	DestroyStack(*S);<span class="comment">//若栈存在，则销毁他</span></span><br><span class="line">	ClearStack(*S);<span class="comment">//将栈清空</span></span><br><span class="line">	StackEmpty(S);<span class="comment">//判断栈是否为空</span></span><br><span class="line">	GetTop(S,*e);<span class="comment">//若栈不为空，用e返回栈顶元素</span></span><br><span class="line">	Push(*S,e);<span class="comment">//入栈</span></span><br><span class="line">	Pop(*S,*e);<span class="comment">//出栈</span></span><br><span class="line">	StackLength(S);<span class="comment">//返回栈S的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure>
<p>因为栈是线性表，所以也具有顺序和链式存储方式</p>
<h2 id="栈的顺序存储及实现"><a class="header-anchor" href="#栈的顺序存储及实现">¶</a>栈的顺序存储及实现</h2>
<p>栈的顺序存储简称为顺序栈，线性表的顺序存储是用数组表示的，我们将栈底定义在数组下标为0的位置，并且使用top变量来指示栈顶的位置，<strong>当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定为top等于-1</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//用于栈顶指针</span></span><br><span class="line">}Sqstack;</span><br></pre></td></tr></tbody></table></figure>
<p>出栈入栈的代码也是相对简单的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">}Sqstack;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == MaxSize - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断是否满栈</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//先移动栈顶指针，再压入</span></span><br><span class="line">		<span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">		<span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> <span class="keyword">final</span>)</span></span></span><br><span class="line"><span class="function"></span>{	<span class="comment">//判断是否为空栈</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">final</span> = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">		<span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="两栈共享空间"><a class="header-anchor" href="#两栈共享空间">¶</a>两栈共享空间</h3>
<p>在前面的例子中存在很大的一个缺陷，那就是需要事先确定数组存储空间大小，<strong>对于一个栈我们需要设计出合适大小的数组来处理，但是对于两个相同类型的栈，我们却可以做到最大限度地利用其是先开辟地存储空间来进行操作</strong></p>
<p>我们可以使用一个数组类存储两个栈</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657680434915.png" alt="数组存储两个栈"></p>
<p>此时我们需要两个栈顶指针top1和top2，<strong>当top+1==top2时表示两个栈都满了</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top1;</span><br><span class="line">	<span class="keyword">int</span> top2;</span><br><span class="line">}SqdoubleStack;</span><br></pre></td></tr></tbody></table></figure>
<p>对于两栈共享空间的push和pop，还需要有一个用于判断是栈1还是栈2的参数stackNumber</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682240174.png" alt="两栈共享空间push操作"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682220519.png" alt="两栈共享空间pop操作"></p>
<h2 id="栈的链式存储结构"><a class="header-anchor" href="#栈的链式存储结构">¶</a>栈的链式存储结构</h2>
<p>栈的链式存储结构，简称为<strong>链栈</strong></p>
<p>对于链栈来说不需要头结点，因为已经有栈顶了</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682407800.png" alt="链栈"></p>
<p><strong>对于空栈来说链表的原定义头指针指向NULL，那么链栈的空就是top=NULL</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>//栈的结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span><span class="comment">//栈的结点</span></span><br><span class="line">}StackNode, * LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>//栈的链表结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	LinkStackPtr top;<span class="comment">//栈顶</span></span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="链栈的入栈和出栈"><a class="header-anchor" href="#链栈的入栈和出栈">¶</a>链栈的入栈和出栈</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//创建一个新结点</span></span><br><span class="line">	LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">	s-&gt;data = e;<span class="comment">//结点赋值</span></span><br><span class="line">	s-&gt;next = S-&gt;top;<span class="comment">//将新结点与原本的栈顶相连</span></span><br><span class="line">	S-&gt;top = s;<span class="comment">//栈顶指向新的结点</span></span><br><span class="line">	S-&gt;count++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkStackPtr p;</span><br><span class="line">	<span class="comment">//判断链表是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (S-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	e = S-&gt;top-&gt;data;</span><br><span class="line">	p = S-&gt;top;<span class="comment">//将栈顶结点赋值给p，待会free掉</span></span><br><span class="line">	S-&gt;top = S-&gt;top-&gt;next;<span class="comment">//使得栈顶指针后移一个结点</span></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	S-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684222256.png" alt="顺序栈和链栈的对比"></p>
<h2 id="栈的作用"><a class="header-anchor" href="#栈的作用">¶</a>栈的作用</h2>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684273946.png" alt=""></p>
<h2 id="栈的应用"><a class="header-anchor" href="#栈的应用">¶</a>栈的应用</h2>
<h3 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h3>
<p>递归一个典型的例子就是斐波那契数列（每一项的元素都是前两项元素之和）</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684630710.png" alt="斐波那契数列表达式"></p>
<p>这里可以使用递归计算，会比较简单</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Fbi(n - <span class="number">1</span>) + Fbi(n - <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Fbi(i));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657688706889.png" alt="斐波那契数列的执行过程"></p>
<p><strong>递归的定义：间接地调用自己的函数，同时我们需要注意要有递归的出口</strong>，而对于函数的传参和返回值都是使用栈来实现的</p>
<h3 id="四则运算表达式求值"><a class="header-anchor" href="#四则运算表达式求值">¶</a>四则运算表达式求值</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689038037.png" alt="带括号的四则运算"></p>
<p>但是光按照括号来判断是不够的，所以采用以下方法</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689312633.png" alt=""></p>
<p>就是遇到数字就入栈，遇到符号就从栈中取出两个元素（注意先后），做运算后再入栈</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689418201.png" alt="具体过程"></p>
<p>但是上面的方法需要先将中缀表达式先转为后缀表达式</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689587176.png" alt="中缀表达式先转为后缀表达式过程"></p>
<h1 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h1>
<p><strong>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p>
<p><strong>队列是一种先进先出的线性表，简称FIFO，运行插入的一端称为队尾，允许删除的一端叫做队头</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689730159.png" alt="队列的结构图"></p>
<h2 id="队列的抽象数据类型"><a class="header-anchor" href="#队列的抽象数据类型">¶</a>队列的抽象数据类型</h2>
<p>同样是线性表，队列也有类似线性表的各种操作，<strong>不同的就是插入数据只能在队尾插入，删除数据只能在队头进行</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列</span><br><span class="line">Data</span><br><span class="line">	同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">	<span class="title">InitQueue</span><span class="params">(*Q)</span></span>;<span class="comment">//初始化操作，建立一个空队列Q</span></span><br><span class="line">	DestroyQueue(*Q);<span class="comment">//若队列Q存在，则销毁他</span></span><br><span class="line">	ClearQueue(*Q);<span class="comment">//将队列清空</span></span><br><span class="line">	QueueEmpty(*Q);<span class="comment">//判断队列是否为空</span></span><br><span class="line">	GetHead(Q,*e);<span class="comment">//若队列存在且非空，用e返回队列Q的队头元素</span></span><br><span class="line">	EnQueue(*Q,e);<span class="comment">//若队列Q存在，插入新元素e到队列Q中并成为队尾元素</span></span><br><span class="line">	DeQueue(*Q,*e);<span class="comment">//删除队列Q中队头元素，用e返回其值</span></span><br><span class="line">	QueueLength(Q);<span class="comment">//返回队列Q的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure>
<h2 id="循环队列"><a class="header-anchor" href="#循环队列">¶</a>循环队列</h2>
<p>队列作为特殊的线性表也有顺序存储和链式存储</p>
<h3 id="队列顺序存储的不足"><a class="header-anchor" href="#队列顺序存储的不足">¶</a>队列顺序存储的不足</h3>
<p>如果以数组下标为0的位置作为队头，那么入队时只需要在队尾追加元素即可，但是出队的话比较复杂，因为队头之后的所有元素都需要前移，时间复杂度为O(n)</p>
<p>但我们可以不去限制队列的元素必须存储在数组的前n个元素，也就是说<strong>队头不需要一定在下标为0的位置</strong></p>
<p>为了避免当只有一个元素时队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时队列为空</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691539985.png" alt="队列顺序存储的出队和入队"></p>
<p>可以看出当出队后再进行入队时发生了数组越界的情况（无法入队），而数组前两个位置还是空的，<strong>这就是假溢出</strong>，这时候就需要循环队列了</p>
<h3 id="循环队列的定义"><a class="header-anchor" href="#循环队列的定义">¶</a>循环队列的定义</h3>
<p><strong>队列的头尾相接的顺序存储结构叫做循环队列</strong></p>
<p>按照上面的例子，当入队a5时，可以将rear指向数组下标为0的位置</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691779653.png" alt="rear指向0下标处"></p>
<p>这样我们就可以继续入队了</p>
<p>此时新的问题出现了，空队列时front等于rear，当队列满的时候也是front=rear，为了区分，有两种方法</p>
<ul>
<li>设置一个标志量flag，当front==rear，且flag=0时为队列空，当flag=1时为队列满</li>
<li>可以修改队列满的条件，当数组还剩下一个空闲单元时我们就认为队列满了</li>
</ul>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710307674.png" alt="条件2"></p>
<p>下面重点讨论第二种方法</p>
<p>由于rear可能比fornt大，也可能小，所以不能仅凭二者相差1来判断是否为满队列（因为可能相差整整一圈）</p>
<p>设队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710665197.png" alt="队列长度计算"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;<span class="comment">//尾指针，若队列不空指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的入队操作，首先判断是否为满队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//尾指针后移，如果为最后则转到数组头部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的出队操作，队头出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    <span class="comment">//队头后移</span></span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="队列的链式存储结构"><a class="header-anchor" href="#队列的链式存储结构">¶</a>队列的链式存储结构</h2>
<p>队列的链式存储结构其实就是线性表的单链表，只不过他只能尾进头出而已。我们称之为<strong>链队列</strong></p>
<p>为了操作方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657711606663.png" alt="链队列"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>//结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//队列的链表结构</span></span><br><span class="line">	QueuePtr front, rear;<span class="comment">//队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="链队列的入队和出队操作"><a class="header-anchor" href="#链队列的入队和出队操作">¶</a>链队列的入队和出队操作</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化结点</span></span><br><span class="line">	<span class="comment">//链接上队列，队尾插入</span></span><br><span class="line">	Q-&gt;rear-&gt;next = s;</span><br><span class="line">	Q-&gt;rear = s;<span class="comment">//把当前结点设置为队尾结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//使用变量p暂时存储需要删除的结点</span></span><br><span class="line">	p = Q-&gt;front-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	Q-&gt;front-&gt;next = p-&gt;next;<span class="comment">//队头指针后移</span></span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">//如果队尾指向第一个数据结点，则删除之后恢复空队列</span></span><br><span class="line">	{</span><br><span class="line">		Q-&gt;rear = Q-&gt;front;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>——————下划线——————</p>
<p>刷题巩固一下我的🐖脑</p>
<h1 id="串"><a class="header-anchor" href="#串">¶</a>串</h1>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="prev" title="TLS和main前的初始化">
                  <i class="fa fa-chevron-left"></i> TLS和main前的初始化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/" rel="next" title="JAVA学习">
                  JAVA学习 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">349k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:17</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"GhjDb9gbtgwnrtsySW3fcGac-MdYXbMMI","appKey":"0Qw5kecTryGX5eSrEvShaWPw","serverURLs":"https://ghjdb9gb.api.lncldglobal.com","placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":"false# Article reading statistic","comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"el":"#valine-comments","path":"/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
