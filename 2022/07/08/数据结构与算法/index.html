<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="title: 数据结构与算法 数据结构与算法">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title: 数据结构与算法 数据结构与算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501980892.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502028932.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502086807.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502487332.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502635250.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657503293323.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657504108330.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510055411.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510171290.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514042881.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514222426.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514307777.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516394208.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516611507.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516871062.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516922060.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657620383741.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634024878.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634585653.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657635089691.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636505788.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636794584.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657677859248.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678031412.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678420041.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678529526.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657680434915.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682240174.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682220519.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682407800.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684222256.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684273946.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684630710.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657688706889.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689038037.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689312633.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689418201.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689587176.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689730159.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691539985.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691779653.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710307674.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710665197.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657711606663.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658123888513.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658245851001.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658246082896.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658246312528.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658247591189.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658248876847.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658283222671.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658283403139.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284025306.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284102069.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284266466.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284621215.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284864446.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658295908560.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658296711020.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658296844289.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285177849.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285240432.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285325411.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285589499.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285780007.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285898473.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285942270.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285978054.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658299227922.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658301382777.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326018314.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326372469.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326404928.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326812794.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326874291.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658327278373.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328073829.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328318770.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328570902.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658329348770.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658329839317.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658333093630.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658333931260.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371418983.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371646629.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371693564.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372050513.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372793932.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372917054.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658373145515.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388031089.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388393575.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388476010.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388579944.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389028020.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389266516.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389350501.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389761608.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389991208.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658390559641.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658390961739.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391006060.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391313478.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391555792.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391801250.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658392330019.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658410756146.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658410788739.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658414870561.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658415381940.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658416056518.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658416112659.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658456052300.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658456133754.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658457363746.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658459926402.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658460850375.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658461230926.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658471975240.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474794616.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474905887.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474962728.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658475067397.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658475507875.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658492477590.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493307449.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493319282.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493362584.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494223805.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493967428.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494167497.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494234357.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494824396.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494855213.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494922433.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658506790378.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658506813144.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507035312.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507064079.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507189949.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507433419.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507763980.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507826201.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508217686.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508278580.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508543901.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508680038.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508771955.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508996796.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509086094.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509572350.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509634251.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659013775048.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509870590.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658510316515.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559123775.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559712143.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559797254.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559961774.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560072053.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560213917.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560596124.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561214345.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561472350.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659014166220.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561990643.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658562778894.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658562890868.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658582916769.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658583879842.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658584667202.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659014906155.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659028717214.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659028914337.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659106849346.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659031094651.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659032578715.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659033043654.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659077593147.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659076471338.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659033906924.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075758476.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075956216.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075986634.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659076130788.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659509892924.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659100456751.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659101707889.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659101404959.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659292214785.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659292941199.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659102484953.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294269254.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294503426.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294711806.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294750516.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294852056.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659330246464.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659330361377.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659452604497.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659453562717.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659461189305.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659462504467.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659379228604.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659379249838.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659465238751.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659465489274.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466302538.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466327933.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466387849.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659507694259.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659508159107.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659508786474.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659509341995.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659536020777.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659537159826.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659537180219.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538233859.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538411703.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538440517.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659539034196.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659549838521.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723716756.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659550444650.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659715674738.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723458435.png">
<meta property="og:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723857157.png">
<meta property="article:published_time" content="2022-07-08T08:38:10.238Z">
<meta property="article:modified_time" content="2022-08-05T18:40:38.420Z">
<meta property="article:author" content="Gift1a">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png">


<link rel="canonical" href="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/","path":"2022/07/08/数据结构与算法/","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title> | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>留言板</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念和术语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E4%B8%8E%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">逻辑结构与物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">逻辑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">集合结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">线性结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">树形结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">图形结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.</span> <span class="nav-text">物理结构——存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">链式存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-v2"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-v2"><span class="nav-number">1.3.2.</span> <span class="nav-text">抽象数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">算法时间和空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.1.</span> <span class="nav-text">时间复杂度的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-number">2.1.2.</span> <span class="nav-text">空间复杂度的计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">线性表的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">线性表的顺序存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="nav-number">3.2.1.</span> <span class="nav-text">顺序存储结构的插入与删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">线性表的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">3.3.1.</span> <span class="nav-text">单链表的读取、插入和删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">3.4.</span> <span class="nav-text">静态链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.1.</span> <span class="nav-text">静态链表的插入和删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">静态链表插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">静态链表删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">3.5.</span> <span class="nav-text">循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">3.5.1.</span> <span class="nav-text">两个循环链表的合并</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.6.</span> <span class="nav-text">双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">3.6.1.</span> <span class="nav-text">双向链表的查找、插入和删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">4.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">栈的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">栈的顺序存储及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4"><span class="nav-number">4.2.1.</span> <span class="nav-text">两栈共享空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.</span> <span class="nav-text">栈的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%85%A5%E6%A0%88%E5%92%8C%E5%87%BA%E6%A0%88"><span class="nav-number">4.3.1.</span> <span class="nav-text">链栈的入栈和出栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">栈的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.5.</span> <span class="nav-text">栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">4.5.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">4.5.2.</span> <span class="nav-text">四则运算表达式求值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">队列的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">5.2.</span> <span class="nav-text">循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="nav-number">5.2.1.</span> <span class="nav-text">队列顺序存储的不足</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">5.2.2.</span> <span class="nav-text">循环队列的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.</span> <span class="nav-text">队列的链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E7%9A%84%E5%85%A5%E9%98%9F%E5%92%8C%E5%87%BA%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.1.</span> <span class="nav-text">链队列的入队和出队操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%B2"><span class="nav-number">6.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.</span> <span class="nav-text">串的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.</span> <span class="nav-text">串的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.1.</span> <span class="nav-text">串的顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">6.2.2.</span> <span class="nav-text">串的链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">朴素的模式匹配算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">KMP模式匹配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#next%E7%9A%84%E6%89%8B%E5%8A%A8%E8%AE%A1%E7%AE%97"><span class="nav-number">6.4.0.1.</span> <span class="nav-text">next的手动计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#next%E7%9A%84%E4%BB%A3%E7%A0%81%E8%AE%A1%E7%AE%97"><span class="nav-number">6.4.0.2.</span> <span class="nav-text">next的代码计算</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-v5"><span class="nav-number">6.4.0.2.1.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B"><span class="nav-number">6.4.1.</span> <span class="nav-text">改进</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E5%88%86%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">结点分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.2.</span> <span class="nav-text">结点间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">7.3.</span> <span class="nav-text">树的其他相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-number">7.3.1.</span> <span class="nav-text">结点的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E4%B8%8E%E6%97%A0%E5%BA%8F"><span class="nav-number">7.3.2.</span> <span class="nav-text">有序与无序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97"><span class="nav-number">7.3.3.</span> <span class="nav-text">森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">7.3.4.</span> <span class="nav-text">树结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.4.</span> <span class="nav-text">树的抽象数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.5.</span> <span class="nav-text">树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">7.5.1.</span> <span class="nav-text">双亲表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">7.5.2.</span> <span class="nav-text">孩子表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80"><span class="nav-number">7.5.2.1.</span> <span class="nav-text">方案一</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="nav-number">7.5.3.</span> <span class="nav-text">方案二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95-v2"><span class="nav-number">7.5.3.1.</span> <span class="nav-text">孩子表示法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">7.5.4.</span> <span class="nav-text">孩子兄弟表示法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%89%B9%E7%82%B9"><span class="nav-number">7.6.1.</span> <span class="nav-text">二叉树特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.2.</span> <span class="nav-text">特殊二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%9C%E6%A0%91"><span class="nav-number">7.6.2.1.</span> <span class="nav-text">斜树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.2.2.</span> <span class="nav-text">满二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.6.2.3.</span> <span class="nav-text">完全二叉树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%A7%E8%B4%A8"><span class="nav-number">7.6.3.</span> <span class="nav-text">二叉树性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A81"><span class="nav-number">7.6.4.</span> <span class="nav-text">性质1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A82"><span class="nav-number">7.6.5.</span> <span class="nav-text">性质2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A83"><span class="nav-number">7.6.6.</span> <span class="nav-text">性质3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A84"><span class="nav-number">7.6.7.</span> <span class="nav-text">性质4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%B4%A85"><span class="nav-number">7.6.8.</span> <span class="nav-text">性质5</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.7.</span> <span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">7.7.1.</span> <span class="nav-text">二叉树的顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="nav-number">7.7.2.</span> <span class="nav-text">二叉链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.8.</span> <span class="nav-text">遍历二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.8.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.8.2.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.8.3.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">7.8.4.</span> <span class="nav-text">层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">7.8.5.</span> <span class="nav-text">多种遍历方法的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">7.8.6.</span> <span class="nav-text">前中后序遍历算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E5%AF%BC%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C"><span class="nav-number">7.8.7.</span> <span class="nav-text">推导遍历结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">7.9.</span> <span class="nav-text">二叉树的建立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.10.</span> <span class="nav-text">线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-v6"><span class="nav-number">7.10.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.10.2.</span> <span class="nav-text">线索二叉树结构实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.11.</span> <span class="nav-text">树、森林与二叉树的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.11.1.</span> <span class="nav-text">树转换为二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.11.2.</span> <span class="nav-text">森林转换为二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="nav-number">7.11.3.</span> <span class="nav-text">二叉树转换为树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="nav-number">7.11.4.</span> <span class="nav-text">二叉树转换为森林</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">7.11.5.</span> <span class="nav-text">树与森林的遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.12.</span> <span class="nav-text">赫夫曼树及其应用——最优二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E4%BE%8B"><span class="nav-number">7.12.1.</span> <span class="nav-text">引例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="nav-number">7.12.2.</span> <span class="nav-text">赫夫曼树定义与原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">7.12.3.</span> <span class="nav-text">赫夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90-v7"><span class="nav-number">7.12.3.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%AE%9A%E4%B9%89"><span class="nav-number">7.12.3.2.</span> <span class="nav-text">赫夫曼编码定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">7.12.4.</span> <span class="nav-text">树的总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.</span> <span class="nav-text">图的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E5%9B%BE%E5%AE%9A%E4%B9%89"><span class="nav-number">8.1.1.</span> <span class="nav-text">各种图定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%A1%B6%E7%82%B9%E4%B8%8E%E8%BE%B9%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">8.1.2.</span> <span class="nav-text">图的顶点与边间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="nav-number">8.1.3.</span> <span class="nav-text">连通图相关术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AF%E8%AF%AD%E6%80%BB%E7%BB%93"><span class="nav-number">8.1.4.</span> <span class="nav-text">图的定义与术语总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">图的抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">8.2.1.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">8.2.1.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-number">8.2.1.2.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-number">8.2.1.3.</span> <span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-number">8.2.1.4.</span> <span class="nav-text">邻接多重表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84"><span class="nav-number">8.2.1.5.</span> <span class="nav-text">边集数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">8.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94DFS"><span class="nav-number">8.3.1.</span> <span class="nav-text">深度优先遍历——DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E2%80%94%E2%80%94BFS"><span class="nav-number">8.3.2.</span> <span class="nav-text">广度优先遍历——BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">8.3.3.</span> <span class="nav-text">邻接矩阵的深度优先遍历和广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">广度优先遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">8.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86-Prim-%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.1.</span> <span class="nav-text">普里姆(Prim)算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94-Kruskal-%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.2.</span> <span class="nav-text">克鲁斯卡尔(Kruskal)算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">8.4.2.1.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-number">8.4.2.2.</span> <span class="nav-text">代码详解与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">8.4.2.2.1.</span> <span class="nav-text">存储结构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">8.5.</span> <span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">8.5.1.</span> <span class="nav-text">迪杰斯特拉(Dijkstra)算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF%E5%92%8C%E6%95%B0%E7%BB%84%E8%AF%B4%E6%98%8E"><span class="nav-number">8.5.1.1.</span> <span class="nav-text">思路和数组说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.5.1.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">8.5.1.3.</span> <span class="nav-text">选择最短路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-number">8.5.1.4.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D"><span class="nav-number">8.5.1.5.</span> <span class="nav-text">重复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd%E7%AE%97%E6%B3%95"><span class="nav-number">8.5.2.</span> <span class="nav-text">弗洛伊德-Floyd算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-v2"><span class="nav-number">8.5.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E4%BF%AE%E6%94%B9"><span class="nav-number">8.5.2.2.</span> <span class="nav-text">遍历修改</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">8.5.2.3.</span> <span class="nav-text">求最短路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">8.6.</span> <span class="nav-text">拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">8.6.1.</span> <span class="nav-text">拓扑排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.6.2.</span> <span class="nav-text">拓扑排序代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">8.6.3.</span> <span class="nav-text">逆拓扑排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">8.7.</span> <span class="nav-text">关键路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="nav-number">8.7.1.</span> <span class="nav-text">关键路径算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-number">8.7.2.</span> <span class="nav-text">关键路径算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE-v2"><span class="nav-number">9.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F-v2"><span class="nav-number">10.</span> <span class="nav-text">排序</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Gift1a"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Gift1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gift1a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友链
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://1.12.239.117:8090/" title="http:&#x2F;&#x2F;1.12.239.117:8090&#x2F;" rel="noopener" target="_blank">Fallw1nd</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://equinox-shame.github.io/" title="https:&#x2F;&#x2F;equinox-shame.github.io&#x2F;" rel="noopener" target="_blank">梓曰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://a2ur2.github.io/" title="https:&#x2F;&#x2F;a2ur2.github.io&#x2F;" rel="noopener" target="_blank">A2ure</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/spmonkey/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;spmonkey&#x2F;" rel="noopener" target="_blank">星空</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 16:38:10" itemprop="dateCreated datePublished" datetime="2022-07-08T16:38:10+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-08-06 02:40:38" itemprop="dateModified" datetime="2022-08-06T02:40:38+08:00">2022-08-06</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>49k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>45 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>title: 数据结构与算法</p>
<p>数据结构与算法</p>
<span id="more"></span> 
<h1 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h1>
<h2 id="基本概念和术语"><a class="header-anchor" href="#基本概念和术语">¶</a>基本概念和术语</h2>
<h3 id="数据"><a class="header-anchor" href="#数据">¶</a>数据</h3>
<p>数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合</p>
<p>数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录</p>
<p>数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位</p>
<p>数据对象：是性质相同的数据元素的集合，是数据的子集</p>
<h3 id="结构"><a class="header-anchor" href="#结构">¶</a>结构</h3>
<p>不同数据元素之间不是独立的，而是存在特定的关系，而这些关系就是结构</p>
<p><strong>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合</strong></p>
<h2 id="逻辑结构与物理结构"><a class="header-anchor" href="#逻辑结构与物理结构">¶</a>逻辑结构与物理结构</h2>
<p>逻辑结构是面向问题的，物理结构就是面向计算机的，其基本的目标就是将数据及逻辑关系存储到计算机的内存中</p>
<h3 id="逻辑结构"><a class="header-anchor" href="#逻辑结构">¶</a>逻辑结构</h3>
<p>逻辑结构：<strong>是指数据对象数据元素之间的相互关系</strong>，这也是我们今后需要关注的地方</p>
<h4 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h4>
<p>使用示意图表示数据的逻辑结构时，要注意两点：</p>
<ul>
<li>将每一个数据元素看作一个结点，用圆圈表示</li>
<li>元素之间的逻辑关系用结点之间的连线表示，如果这个给关系是由方向的，那么用带箭头的连线表示</li>
</ul>
<h4 id="集合结构"><a class="header-anchor" href="#集合结构">¶</a>集合结构</h4>
<p><strong>集合结构：集合结构中的数据元素除了同属于一个集合外</strong>，它们之间没有其他关系，类似于数学中的集合</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501967903.png" alt="集合结构"></p>
<h4 id="线性结构"><a class="header-anchor" href="#线性结构">¶</a>线性结构</h4>
<p><strong>线性结构：线性结构中的数据元素是一对一的关系</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657501980892.png" alt="线性结构"></p>
<h4 id="树形结构"><a class="header-anchor" href="#树形结构">¶</a>树形结构</h4>
<p><strong>树形结构：树形结构中的数据元素之间存在一种一对多的层次关系</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502028932.png" alt="树形结构"></p>
<h4 id="图形结构"><a class="header-anchor" href="#图形结构">¶</a>图形结构</h4>
<p><strong>图形结构：图形结构的数据元素是多对多的关系</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502086807.png" alt="图形结构"></p>
<h3 id="物理结构——存储结构"><a class="header-anchor" href="#物理结构——存储结构">¶</a>物理结构——存储结构</h3>
<p><strong>物理结构：是指数据的逻辑结构在计算机中的存储形式</strong></p>
<p>数据的存储结构应正确反映数据元素之间的逻辑关系</p>
<h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构">¶</a>顺序存储结构</h4>
<p><strong>顺序存储结构：是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系和物理关系是一致的</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502487332.png" alt="顺序存储结构"></p>
<h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构">¶</a>链式存储结构</h4>
<p><strong>链式存储结构：是把数据元素存放在任意的存储单元中，这组存储单元可以是连续的，也可以是不连续的</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657502635250.png" alt="链式存储结构"></p>
<p>此时数据元素的存储关系不能反映其逻辑关系，所以需要一个指针存放数据元素的地址，通过指针可以找到相关联数据元素的地址。相较于顺序存储结构，链式存储结构更为灵活，<strong>也更适合处理需要变化的结构</strong>，比如排队，当队伍中需要添加或者删去成员时，使用顺序存储结构则需要处理大量数据</p>
<h2 id="抽象数据类型"><a class="header-anchor" href="#抽象数据类型">¶</a>抽象数据类型</h2>
<h3 id="数据类型-v2"><a class="header-anchor" href="#数据类型-v2">¶</a>数据类型</h3>
<p><strong>数据类型：是指一组性质形同的值的集合及定义在此集合上的一些操作的总称</strong></p>
<h3 id="抽象数据类型-v2"><a class="header-anchor" href="#抽象数据类型-v2">¶</a>抽象数据类型</h3>
<p><strong>抽象数据类型：是指一个数据建模及定义在该模型上的一组操作</strong>，比如整型</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657503293323.png" alt="抽象数据类型标准格式"></p>
<h1 id="算法"><a class="header-anchor" href="#算法">¶</a>算法</h1>
<p><strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列。并且每条指令表示一个或多个操作</strong></p>
<p><strong>算法的基本特性：输入、输出、有穷性、确定性、可行性</strong></p>
<p><strong>算法的基本要求：</strong></p>
<ul>
<li>正确性</li>
<li>可读性：便于阅读、理解和交流</li>
<li>健壮性：当输入数据不合法时算法能做出相关处理</li>
<li>时间效率高和存储量低</li>
</ul>
<h2 id="算法时间和空间复杂度"><a class="header-anchor" href="#算法时间和空间复杂度">¶</a>算法时间和空间复杂度</h2>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657504108330.png" alt="算法时间复杂度定义"><br>
$$<br>
O(1)叫做常数阶、O(n)叫做线性阶、O(n^2)叫做平方阶<br>
$$</p>
<h3 id="时间复杂度的计算"><a class="header-anchor" href="#时间复杂度的计算">¶</a>时间复杂度的计算</h3>
<p>推导大O阶：</p>
<ul>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶项存在且不是1，则去除与这个项相乘的常数</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常数阶</span></span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,n=<span class="number">100</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line">sum=(<span class="number">1</span>+n)*n/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//这里代码的执行次数和问题的大小n无关，所以为常数，也就是O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//以上代码会执行n次，所以位O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数阶</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count&lt;n)</span><br><span class="line">{</span><br><span class="line">    count=count*<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//程序不再执行的条件是2^(count)&gt;=n，也就是count=log2n，所以这个循环的时间复杂度为O(logn)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//平方阶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//因为上述程序为嵌套循环，所以会执行n*n次，所以时间复杂度为O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于下述循环嵌套，时间复杂度计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;++j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)的程序步骤</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对于上述程序，我们先计算程序的执行次数，因为外层循环执行次数必定为n，主要看内层循环，内层循环执行次数总和为n+(n-1)+(n-2)+……=(n+1)/2，最终得到n^2/2+n/2</span></span><br><span class="line"><span class="comment">//按照上面的大O推导法，1、没有加法常数不予考虑，2、只保留最高阶也就是n^2/2，3、去除这个项的系数，得到n^2，所以时间复杂度为O(n^2)</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510055411.png" alt="常见的时间复杂度"></p>
<h3 id="空间复杂度的计算"><a class="header-anchor" href="#空间复杂度的计算">¶</a>空间复杂度的计算</h3>
<p>算法的空间复杂度通过计算算法所需要的存储空间实现</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657510171290.png" alt=""></p>
<p>主要是数组大小，变量只占一个存储单元</p>
<h1 id="线性表"><a class="header-anchor" href="#线性表">¶</a>线性表</h1>
<p>线性表：零个或多个数据元素的有限序列，元素之间是有序的<img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514042881.png" alt="线性表的数学语言定义"></p>
<p>所以线性表元素的个数n定义为线性表的长度，当n=0时为空表</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514222426.png" alt="位序"></p>
<p><strong>在较复杂的线性表中，一个数据元素可以由若干个数据项组成</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657514307777.png" alt="复杂线性表"></p>
<h2 id="线性表的抽象数据类型"><a class="header-anchor" href="#线性表的抽象数据类型">¶</a>线性表的抽象数据类型</h2>
<p>前面说过抽象数据类型分为数据和操作</p>
<p>在这里线性表的抽象数据类型定义如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 线性表(List)</span><br><span class="line">    DATA</span><br><span class="line">    	线性表的数据对象集合为(a1,a2,a3……，an)，每个元素的类型均为DataType。除了第一个元素a1外，其余元素都有且只有一个直接前驱元素，除最后一个元素外，其余元素都有且只有一个直接后继元素。数据元素之间的关系是一对一的关系</span><br><span class="line">    <span class="function">Operation</span></span><br><span class="line"><span class="function">    	<span class="title">InitList</span><span class="params">(*L)</span>	<span class="comment">//初始化操作，建立一个空的线性表</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListEmpty</span><span class="params">(*L)</span>	<span class="comment">//若线性表为空，返回true，否则返回false</span></span></span><br><span class="line"><span class="function">    	<span class="title">ClearList</span><span class="params">(*L)</span>	<span class="comment">//将线性表清空</span></span></span><br><span class="line"><span class="function">    	<span class="title">GetElem</span><span class="params">(L,i,*e)</span>	<span class="comment">//将线性表L中的第i个位置元素值返回给e</span></span></span><br><span class="line"><span class="function">    	<span class="title">LocateElem</span><span class="params">(L,e)</span> <span class="comment">//在线性表L中查找和e相等的元素，如果查找成功，返回该元素在表中的序号表示成功，否则返回0表示失败</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListInsert</span><span class="params">(*L,i,e)</span>	<span class="comment">//在线性表L的第i个位置擦汗如新元素e</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListDelete</span><span class="params">(*L,i,*e)</span>	<span class="comment">//删除线性表L中的第i个未知元素，并用e返回其值</span></span></span><br><span class="line"><span class="function">    	<span class="title">ListLength</span><span class="params">(L)</span>	<span class="comment">//返回线性表L的元素个数</span></span></span><br><span class="line"><span class="function">endADT</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>以上只是线性表的基础操作，对于复杂的一些操作可以分解为简单的操作，比如求A和B集合的并集这一操作可以分解为遍历B表，将A表中不存在的元素插入到A表中</strong></p>
</blockquote>
<h2 id="线性表的顺序存储结构"><a class="header-anchor" href="#线性表的顺序存储结构">¶</a>线性表的顺序存储结构</h2>
<p><strong>线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素</strong></p>
<p>描述顺序存储结构需要三个特性：</p>
<ul>
<li>存储空间的起始位置：数组data，他的存储位置就是存储空间的存储位置</li>
<li>线性表的最大存储容量：数组长度MaxSize</li>
<li>线性表的当前长度：length</li>
</ul>
<h3 id="顺序存储结构的插入与删除"><a class="header-anchor" href="#顺序存储结构的插入与删除">¶</a>顺序存储结构的插入与删除</h3>
<p>这两者其实是比较麻烦的，对于插入数据，插入位置之后的元素都需要后移，删除则为前移。</p>
<p>插入算法的思路：</p>
<ul>
<li>如果插入位置不合理，抛出异常</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或者动态增加容量</li>
<li>从最后一个元素开始向前遍历到第i个位置，分别将他们往后移动一个位置</li>
<li>将要插入的元素填入位置i处</li>
<li>表长+1</li>
</ul>
<p>删除算法也是类似的</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516394208.png" alt="线性表的优缺点"></p>
<h2 id="线性表的链式存储结构"><a class="header-anchor" href="#线性表的链式存储结构">¶</a>线性表的链式存储结构</h2>
<p><strong>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素</strong>，由于是任意的，我们还需要存储当前元素的后继元素地址</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516611507.png" alt="单链表的定义"></p>
<p><strong>一般会在单链表的第一个结点前附设一个头结点，在其数据域存储线性表的长度，然后让头结点的指针指向第一个结点</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516871062.png" alt="头指针与头结点的异同"></p>
<p>为了更好地理解，贴出下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657516922060.png" alt=""></p>
<h3 id="单链表的读取、插入和删除"><a class="header-anchor" href="#单链表的读取、插入和删除">¶</a>单链表的读取、插入和删除</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>//类型</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">}List;<span class="comment">//名称</span></span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">InsertNode</span><span class="params">(List* <span class="built_in">list</span>)</span><span class="comment">//头插法</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">		tmp-&gt;data = i;</span><br><span class="line">		tmp-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">		<span class="built_in">list</span>-&gt;next = tmp;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function">List* <span class="title">CreateList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	List* Node = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">	Node-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建空的头结点</span></span><br><span class="line">	<span class="keyword">return</span> InsertNode(Node);<span class="comment">//插入结点</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (Linklist-&gt;next != <span class="literal">NULL</span>)<span class="comment">//第一个是空结点，所以先指向第一个结点</span></span><br><span class="line">	{</span><br><span class="line">		Linklist = Linklist-&gt;next;<span class="comment">//遍历单向链表</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Linklist-&gt;data);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">DeteleNode</span><span class="params">(List* Linklist)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> goal = <span class="number">3</span>;<span class="comment">//删除结点需要先记录前一个结点的位置</span></span><br><span class="line">	List* p = Linklist, * q;<span class="comment">//初始化p用于遍历链表</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;next-&gt;data == goal)<span class="comment">//当前节点下一结点的值为3</span></span><br><span class="line">		{</span><br><span class="line">			q = p-&gt;next;</span><br><span class="line">			p-&gt;next = q-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(q);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Linklist;<span class="comment">//返回的是头节点</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function">List* <span class="title">InsertBytail</span><span class="params">(List* <span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	List* tmplist = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		List* tmp = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">		tmp-&gt;data = i;</span><br><span class="line">		tmp-&gt;next = <span class="literal">NULL</span>;<span class="comment">//创建新节点</span></span><br><span class="line">		<span class="comment">//从尾部插入</span></span><br><span class="line">		tmplist-&gt;next = tmp;</span><br><span class="line">		tmplist = tmplist-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	List* Linklist;</span><br><span class="line">	Linklist= CreateList();</span><br><span class="line">	<span class="comment">//PrintList(Linklist);</span></span><br><span class="line">	Linklist=DeteleNode(Linklist);</span><br><span class="line">	PrintList(Linklist);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>链表创建时可以使用尾插法和头插法，尾插法就是创建的结点从尾部插入，而头插法则反之</p>
<h2 id="静态链表"><a class="header-anchor" href="#静态链表">¶</a>静态链表</h2>
<p>即使用结构体数组来替代指针来描述单链表</p>
<blockquote>
<p><strong>首先让结构体数组拥有两个成员，data和cur。数据域data原来存放数据元素，也就是我们要处理的元素。而游标cur相当于单链表中的next指针，存放该元素的后继元素在数组中的下标，但是为了方便插入数据，通常需要把数组建立得大一些</strong></p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;<span class="comment">//游标Cursor，为0时表示无指向</span></span><br><span class="line">}Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></tbody></table></figure>
<p>同时我们需要对第一个元素和最后一个元素进行特殊元素处理，不存放数据。<strong>我们通常把未被使用得数组元素称为备用链表</strong></p>
<blockquote>
<p>数组第一个元素即下标为0的元素cur就存放备用链表(空位置)的第一个结点的下标。而数组的最后一个元素的cur则存放第一个有数值的元素的下标，相当于单链表的头结点的作用</p>
</blockquote>
<h3 id="静态链表的插入和删除操作"><a class="header-anchor" href="#静态链表的插入和删除操作">¶</a>静态链表的插入和删除操作</h3>
<p>前面可知，动态链表结点的申请和释放分别借用malloc和free函数。<strong>而在静态链表中，操作的是数组</strong>，为了区分哪些数组是被使用过的，我们可以将所有未被使用过的以及已经被删除的分量用游标链成一个备用的链表（使cur指向下一个空位置）</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657620383741.png" alt="静态链表"></p>
<h4 id="静态链表插入"><a class="header-anchor" href="#静态链表插入">¶</a>静态链表插入</h4>
<p>首先我们需要在备用链表中找到一个空位置，相当于(malloc)，然后将该位置的元素加入数据链表中此时当前的空位置会被占用，所以list[0]-&gt;cur也需要改变。</p>
<h4 id="静态链表删除"><a class="header-anchor" href="#静态链表删除">¶</a>静态链表删除</h4>
<p>和插入一样，都需要对备用链和数据链进行更改</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxsize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line">}Component, StaticList[Maxsize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//找到备用链表中的空位置</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur)<span class="comment">//如果备用链表已被使用过</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[i]-&gt;cur;<span class="comment">//因为当前位置被占用，所以从备用链表中解除</span></span><br><span class="line">		<span class="keyword">return</span> i;<span class="comment">//返回空位置的下标</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateList</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxsize - <span class="number">1</span>; ++i)<span class="comment">//初始化备用链表，此时空间都没被使用，所以list[0]-&gt;cur为0</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">list</span>[i]-&gt;cur = i + <span class="number">1</span>;<span class="comment">//cur相当于next，指向下一个结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//结尾的结点的cur赋值为0</span></span><br><span class="line">	<span class="built_in">list</span>[Maxsize - <span class="number">1</span>]-&gt;cur = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//从备用链表中获取空结点的位置,从而创建数据链表的头节点</span></span><br><span class="line">	<span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">int</span> head = k;<span class="comment">//返回头节点的位置</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//申请数据结点</span></span><br><span class="line">		<span class="keyword">int</span> s = Malloc(<span class="built_in">list</span>);</span><br><span class="line">		<span class="built_in">list</span>[s]-&gt;data = i;</span><br><span class="line">		k = s;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">list</span>[k]-&gt;cur = <span class="number">0</span>;<span class="comment">//数据链表的末尾结尾以0结尾，表示cur指向NULL</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//因为第一个是头结点无数据，所以跳过</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">		head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">list</span>[head]-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNode</span><span class="params">(StaticList <span class="built_in">list</span>[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//插入的位置，首先在备用链表中获取空结点的下标</span></span><br><span class="line">	<span class="keyword">int</span> k = Malloc(<span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">list</span>[k]-&gt;data = <span class="number">10</span>;<span class="comment">//给指定位置的元素赋值，下一步将其从中间插入，同时备用链表也需要改变</span></span><br><span class="line">	<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[k]-&gt;cur;<span class="comment">//这样就实现了不移动元素在中间插入数据</span></span><br><span class="line">	<span class="built_in">list</span>[<span class="number">4</span>]-&gt;cur = k;</span><br><span class="line">	<span class="built_in">list</span>[k]-&gt;cur = <span class="number">5</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(StaticList <span class="built_in">list</span>[], <span class="keyword">int</span> head)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	head = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>[head]-&gt;cur != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;data == <span class="number">10</span>)<span class="comment">//当前结点的后一个结点数值为10</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//当找到我们刚才插入的结点时，备用链表和数据链表都需要进行做出改变</span></span><br><span class="line">			<span class="comment">//首先改变数据链表</span></span><br><span class="line">			<span class="built_in">list</span>[head]-&gt;cur = <span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur;<span class="comment">//跳过下一结点</span></span><br><span class="line">			<span class="comment">//接下来改变备用链表，将其看作备用链表的结点</span></span><br><span class="line">			<span class="keyword">int</span> tmp = <span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur;</span><br><span class="line">			<span class="built_in">list</span>[<span class="number">0</span>]-&gt;cur = <span class="built_in">list</span>[head]-&gt;cur;</span><br><span class="line">			<span class="built_in">list</span>[<span class="built_in">list</span>[head]-&gt;cur]-&gt;cur = tmp;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">		head = <span class="built_in">list</span>[head]-&gt;cur;<span class="comment">//后移</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	StaticList <span class="built_in">list</span>[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> head = CreateList(<span class="built_in">list</span>);</span><br><span class="line">	InsertNode(<span class="built_in">list</span>);</span><br><span class="line">	DeleteNode(<span class="built_in">list</span>, head);</span><br><span class="line">	PrintList(<span class="built_in">list</span>, head);</span><br><span class="line">	InsertNode(<span class="built_in">list</span>);</span><br><span class="line">	PrintList(<span class="built_in">list</span>, head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634024878.png" alt="静态链表的优缺点"></p>
<h2 id="循环链表"><a class="header-anchor" href="#循环链表">¶</a>循环链表</h2>
<p>之前提到的单链表都只存储向后的指针，所以没办法找到他的前驱节点。而我们只要将链表改为一个环就可以解决这样的问题，而这样的链表就是循环链表——解决了一个问题（如何从当中的一个结点出发，访问到链表的全部结点）</p>
<p><strong>将单链表中终端结点的指针由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为但循环链表，简称循环链表</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657634585653.png" alt="循环链表和单链表的差异"></p>
<p>循环链表如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657635089691.png" alt="循环链表"></p>
<p>在单链表中，我们有了头结点时，可以用O(1)的时间访问第一个结点，但是要访问到最后一个结点则需要O(n)时间，因为所有结点都要访问一遍。</p>
<p>我们可以改造一下上面的循环链表，不用头指针，而是用<strong>指向终端结点的尾指针来表示循环链表</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636505788.png" alt=""></p>
<h3 id="两个循环链表的合并"><a class="header-anchor" href="#两个循环链表的合并">¶</a>两个循环链表的合并</h3>
<p>有了尾结点合并时就会比较简单</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657636794584.png" alt="流程图"></p>
<p>rearA和rearB是两条循环链表的尾指针</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p=readA-&gt;next;<span class="comment">//保存A表的头结点</span></span><br><span class="line">rearA-&gt;next=rearB-&gt;next-&gt;next;<span class="comment">//将B链的第一个结点（不是头结点）赋值给rearA-&gt;next</span></span><br><span class="line">readB-&gt;next=p;</span><br><span class="line"><span class="built_in">free</span>(p)<span class="comment">//释放p</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h2>
<p>在单向链表中，由于存在next指针，所以我们访问下一节点的时间复杂度为O(1)，而访问前一个结点则需要O(n)，所以设计出了双向链表。</p>
<p><strong>双向链表是在单链表的每个结点中，再设置一个指向其前驱节点的指针域</strong>，所以在双向链表中的每个结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">prior</span>;</span><span class="comment">//直接前驱结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span>*<span class="title">next</span>;</span><span class="comment">//直接后继结点</span></span><br><span class="line">}DulNode,*DuLinkList;</span><br></pre></td></tr></tbody></table></figure>
<p>双向链表也可以是循环表</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657677859248.png" alt="双向循环链表"></p>
<h3 id="双向链表的查找、插入和删除"><a class="header-anchor" href="#双向链表的查找、插入和删除">¶</a>双向链表的查找、插入和删除</h3>
<p>查找的话只需要往一个方向遍历即可，不需要使用两个指针。</p>
<p>但是在插入和删除的时候需要同时对两个指针变量作出修改</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678031412.png" alt="插入的流程图"></p>
<blockquote>
<p>在编写代码时一定要注意顺序</p>
</blockquote>
<p>双向链表是使用空间换取时间的例子。</p>
<h1 id="栈"><a class="header-anchor" href="#栈">¶</a>栈</h1>
<p><strong>栈是限定仅在表尾进行插入和删除操作的线性表</strong></p>
<blockquote>
<p><strong>栈顶——允许插入和删除，栈顶的另一端就是栈底，不含任何元素的叫空栈。栈又被称为后进先出的线性表</strong>，简称LIFO结构</p>
</blockquote>
<p><strong>栈的插入操作叫作进栈，也可以叫做压栈、入栈；栈的删除操作叫做出栈</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678420041.png" alt="出栈入栈图"></p>
<p>相同的元素出栈次序的变化是很多的</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657678529526.png" alt="出入栈的例子"></p>
<h2 id="栈的抽象数据类型"><a class="header-anchor" href="#栈的抽象数据类型">¶</a>栈的抽象数据类型</h2>
<p>对于栈的插入和删除操作，我们改名为push和pop</p>
<p><strong>入栈(push)是先移动栈顶指针再压入元素，出栈(pop)是弹出元素再移动栈顶指针</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈</span><br><span class="line">DAta</span><br><span class="line">	同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Opreation</span></span><br><span class="line"><span class="function">	<span class="title">InitStack</span><span class="params">(*S)</span></span>;<span class="comment">//初始化操作，建立一个空栈</span></span><br><span class="line">	DestroyStack(*S);<span class="comment">//若栈存在，则销毁他</span></span><br><span class="line">	ClearStack(*S);<span class="comment">//将栈清空</span></span><br><span class="line">	StackEmpty(S);<span class="comment">//判断栈是否为空</span></span><br><span class="line">	GetTop(S,*e);<span class="comment">//若栈不为空，用e返回栈顶元素</span></span><br><span class="line">	Push(*S,e);<span class="comment">//入栈</span></span><br><span class="line">	Pop(*S,*e);<span class="comment">//出栈</span></span><br><span class="line">	StackLength(S);<span class="comment">//返回栈S的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure>
<p>因为栈是线性表，所以也具有顺序和链式存储方式</p>
<h2 id="栈的顺序存储及实现"><a class="header-anchor" href="#栈的顺序存储及实现">¶</a>栈的顺序存储及实现</h2>
<p>栈的顺序存储简称为顺序栈，线性表的顺序存储是用数组表示的，我们将栈底定义在数组下标为0的位置，并且使用top变量来指示栈顶的位置，<strong>当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定为top等于-1</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//用于栈顶指针</span></span><br><span class="line">}Sqstack;</span><br></pre></td></tr></tbody></table></figure>
<p>出栈入栈的代码也是相对简单的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data[MaxSize];</span><br><span class="line">	<span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">}Sqstack;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == MaxSize - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判断是否满栈</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//先移动栈顶指针，再压入</span></span><br><span class="line">		<span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">		<span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Sqstack* <span class="built_in">stack</span>, <span class="keyword">int</span> <span class="keyword">final</span>)</span></span></span><br><span class="line"><span class="function"></span>{	<span class="comment">//判断是否为空栈</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">final</span> = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">		<span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="两栈共享空间"><a class="header-anchor" href="#两栈共享空间">¶</a>两栈共享空间</h3>
<p>在前面的例子中存在很大的一个缺陷，那就是需要事先确定数组存储空间大小，<strong>对于一个栈我们需要设计出合适大小的数组来处理，但是对于两个相同类型的栈，我们却可以做到最大限度地利用其是先开辟地存储空间来进行操作</strong></p>
<p>我们可以使用一个数组类存储两个栈</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657680434915.png" alt="数组存储两个栈"></p>
<p>此时我们需要两个栈顶指针top1和top2，<strong>当top+1==top2时表示两个栈都满了</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两栈共享空间结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top1;</span><br><span class="line">	<span class="keyword">int</span> top2;</span><br><span class="line">}SqdoubleStack;</span><br></pre></td></tr></tbody></table></figure>
<p>对于两栈共享空间的push和pop，还需要有一个用于判断是栈1还是栈2的参数stackNumber</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682240174.png" alt="两栈共享空间push操作"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682220519.png" alt="两栈共享空间pop操作"></p>
<h2 id="栈的链式存储结构"><a class="header-anchor" href="#栈的链式存储结构">¶</a>栈的链式存储结构</h2>
<p>栈的链式存储结构，简称为<strong>链栈</strong></p>
<p>对于链栈来说不需要头结点，因为已经有栈顶了</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657682407800.png" alt="链栈"></p>
<p><strong>对于空栈来说链表的原定义头指针指向NULL，那么链栈的空就是top=NULL</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>//栈的结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">next</span>;</span><span class="comment">//栈的结点</span></span><br><span class="line">}StackNode, * LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span>//栈的链表结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	LinkStackPtr top;<span class="comment">//栈顶</span></span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">}LinkStack;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="链栈的入栈和出栈"><a class="header-anchor" href="#链栈的入栈和出栈">¶</a>链栈的入栈和出栈</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//创建一个新结点</span></span><br><span class="line">	LinkStackPtr s = (LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">	s-&gt;data = e;<span class="comment">//结点赋值</span></span><br><span class="line">	s-&gt;next = S-&gt;top;<span class="comment">//将新结点与原本的栈顶相连</span></span><br><span class="line">	S-&gt;top = s;<span class="comment">//栈顶指向新的结点</span></span><br><span class="line">	S-&gt;count++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(LinkStack* S, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkStackPtr p;</span><br><span class="line">	<span class="comment">//判断链表是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (S-&gt;top == <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	e = S-&gt;top-&gt;data;</span><br><span class="line">	p = S-&gt;top;<span class="comment">//将栈顶结点赋值给p，待会free掉</span></span><br><span class="line">	S-&gt;top = S-&gt;top-&gt;next;<span class="comment">//使得栈顶指针后移一个结点</span></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	S-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684222256.png" alt="顺序栈和链栈的对比"></p>
<h2 id="栈的作用"><a class="header-anchor" href="#栈的作用">¶</a>栈的作用</h2>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684273946.png" alt=""></p>
<h2 id="栈的应用"><a class="header-anchor" href="#栈的应用">¶</a>栈的应用</h2>
<h3 id="递归"><a class="header-anchor" href="#递归">¶</a>递归</h3>
<p>递归一个典型的例子就是斐波那契数列（每一项的元素都是前两项元素之和）</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657684630710.png" alt="斐波那契数列表达式"></p>
<p>这里可以使用递归计算，会比较简单</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fbi</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> Fbi(n - <span class="number">1</span>) + Fbi(n - <span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">40</span>; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Fbi(i));</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657688706889.png" alt="斐波那契数列的执行过程"></p>
<p><strong>递归的定义：间接地调用自己的函数，同时我们需要注意要有递归的出口</strong>，而对于函数的传参和返回值都是使用栈来实现的</p>
<h3 id="四则运算表达式求值"><a class="header-anchor" href="#四则运算表达式求值">¶</a>四则运算表达式求值</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689038037.png" alt="带括号的四则运算"></p>
<p>但是光按照括号来判断是不够的，所以采用以下方法</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689312633.png" alt=""></p>
<p>就是遇到数字就入栈，遇到符号就从栈中取出两个元素（注意先后），做运算后再入栈</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689418201.png" alt="具体过程"></p>
<p>但是上面的方法需要先将中缀表达式先转为后缀表达式</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689587176.png" alt="中缀表达式先转为后缀表达式过程"></p>
<h1 id="队列"><a class="header-anchor" href="#队列">¶</a>队列</h1>
<p><strong>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</strong></p>
<p><strong>队列是一种先进先出的线性表，简称FIFO，运行插入的一端称为队尾，允许删除的一端叫做队头</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657689730159.png" alt="队列的结构图"></p>
<h2 id="队列的抽象数据类型"><a class="header-anchor" href="#队列的抽象数据类型">¶</a>队列的抽象数据类型</h2>
<p>同样是线性表，队列也有类似线性表的各种操作，<strong>不同的就是插入数据只能在队尾插入，删除数据只能在队头进行</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列</span><br><span class="line">Data</span><br><span class="line">	同线性表，元素具有相同的类型，相邻元素具有前驱和后继关系</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">	<span class="title">InitQueue</span><span class="params">(*Q)</span></span>;<span class="comment">//初始化操作，建立一个空队列Q</span></span><br><span class="line">	DestroyQueue(*Q);<span class="comment">//若队列Q存在，则销毁他</span></span><br><span class="line">	ClearQueue(*Q);<span class="comment">//将队列清空</span></span><br><span class="line">	QueueEmpty(*Q);<span class="comment">//判断队列是否为空</span></span><br><span class="line">	GetHead(Q,*e);<span class="comment">//若队列存在且非空，用e返回队列Q的队头元素</span></span><br><span class="line">	EnQueue(*Q,e);<span class="comment">//若队列Q存在，插入新元素e到队列Q中并成为队尾元素</span></span><br><span class="line">	DeQueue(*Q,*e);<span class="comment">//删除队列Q中队头元素，用e返回其值</span></span><br><span class="line">	QueueLength(Q);<span class="comment">//返回队列Q的元素个数</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure>
<h2 id="循环队列"><a class="header-anchor" href="#循环队列">¶</a>循环队列</h2>
<p>队列作为特殊的线性表也有顺序存储和链式存储</p>
<h3 id="队列顺序存储的不足"><a class="header-anchor" href="#队列顺序存储的不足">¶</a>队列顺序存储的不足</h3>
<p>如果以数组下标为0的位置作为队头，那么入队时只需要在队尾追加元素即可，但是出队的话比较复杂，因为队头之后的所有元素都需要前移，时间复杂度为O(n)</p>
<p>但我们可以不去限制队列的元素必须存储在数组的前n个元素，也就是说<strong>队头不需要一定在下标为0的位置</strong></p>
<p>为了避免当只有一个元素时队头和队尾重合使处理变得麻烦，所以引入两个指针，<strong>front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等于rear时队列为空</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691539985.png" alt="队列顺序存储的出队和入队"></p>
<p>可以看出当出队后再进行入队时发生了数组越界的情况（无法入队），而数组前两个位置还是空的，<strong>这就是假溢出</strong>，这时候就需要循环队列了</p>
<h3 id="循环队列的定义"><a class="header-anchor" href="#循环队列的定义">¶</a>循环队列的定义</h3>
<p><strong>队列的头尾相接的顺序存储结构叫做循环队列</strong></p>
<p>按照上面的例子，当入队a5时，可以将rear指向数组下标为0的位置</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657691779653.png" alt="rear指向0下标处"></p>
<p>这样我们就可以继续入队了</p>
<p>此时新的问题出现了，空队列时front等于rear，当队列满的时候也是front=rear，为了区分，有两种方法</p>
<ul>
<li>设置一个标志量flag，当front==rear，且flag=0时为队列空，当flag=1时为队列满</li>
<li>可以修改队列满的条件，当数组还剩下一个空闲单元时我们就认为队列满了</li>
</ul>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710307674.png" alt="条件2"></p>
<p>下面重点讨论第二种方法</p>
<p>由于rear可能比fornt大，也可能小，所以不能仅凭二者相差1来判断是否为满队列（因为可能相差整整一圈）</p>
<p>设队列的最大尺寸为QueueSize，那么队列满的条件是(rear+1)%QueueSize==front</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657710665197.png" alt="队列长度计算"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> Data[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> front;<span class="comment">//头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;<span class="comment">//尾指针，若队列不空指向队列尾元素的下一个位置</span></span><br><span class="line">}SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化循环队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitQueue</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Q-&gt;front=<span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列求长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的入队操作，首先判断是否为满队列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear+<span class="number">1</span>)%MAXSIZE==Q-&gt;front)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    Q-&gt;data[Q-&gt;rear]=e;</span><br><span class="line">    Q-&gt;rear=(Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;<span class="comment">//尾指针后移，如果为最后则转到数组头部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环队列的出队操作，队头出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(SqQueue *Q,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=Q-&gt;data[Q-&gt;front];</span><br><span class="line">    <span class="comment">//队头后移</span></span><br><span class="line">    Q-&gt;front=(Q-&gt;front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="队列的链式存储结构"><a class="header-anchor" href="#队列的链式存储结构">¶</a>队列的链式存储结构</h2>
<p>队列的链式存储结构其实就是线性表的单链表，只不过他只能尾进头出而已。我们称之为<strong>链队列</strong></p>
<p>为了操作方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点。</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1657711606663.png" alt="链队列"></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>//结点结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>* <span class="title">next</span>;</span></span><br><span class="line">}QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//队列的链表结构</span></span><br><span class="line">	QueuePtr front, rear;<span class="comment">//队头和队尾指针</span></span><br><span class="line">}LinkQueue;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="链队列的入队和出队操作"><a class="header-anchor" href="#链队列的入队和出队操作">¶</a>链队列的入队和出队操作</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化结点</span></span><br><span class="line">	<span class="comment">//链接上队列，队尾插入</span></span><br><span class="line">	Q-&gt;rear-&gt;next = s;</span><br><span class="line">	Q-&gt;rear = s;<span class="comment">//把当前结点设置为队尾结点</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//使用变量p暂时存储需要删除的结点</span></span><br><span class="line">	p = Q-&gt;front-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	Q-&gt;front-&gt;next = p-&gt;next;<span class="comment">//队头指针后移</span></span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;rear == p)<span class="comment">//如果队尾指向第一个数据结点，则删除之后恢复空队列</span></span><br><span class="line">	{</span><br><span class="line">		Q-&gt;rear = Q-&gt;front;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>——————下划线——————</p>
<p>刷题巩固一下我的🐖脑</p>
<h1 id="串"><a class="header-anchor" href="#串">¶</a>串</h1>
<p><strong>串是由零个或者多个字符组成的有限序列，又名叫字符串</strong></p>
<h2 id="串的抽象数据类型"><a class="header-anchor" href="#串的抽象数据类型">¶</a>串的抽象数据类型</h2>
<p>相较于线性表的更关注单个元素的操作，比如查找删除插入一个元素，但串中更多的是查找子串的位置、得到指定位置的子串替换子串等操作</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串</span><br><span class="line">Data</span><br><span class="line">	串中的一个元素仅由一个字符组成</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">    <span class="title">StrAssion</span><span class="params">(T,*chars)</span></span>;<span class="comment">//生成一个其值等于字符串常量chars的串T</span></span><br><span class="line">    StrCopy(T,S);<span class="comment">//串S存在，由串S复制得到串T</span></span><br><span class="line">    ClearString(S);<span class="comment">//串S存在，将该串清空</span></span><br><span class="line">    StringEmpty(S);<span class="comment">//判断串是否为空</span></span><br><span class="line">	StrLength(S);<span class="comment">//返回串S的元素个数，即串的长度</span></span><br><span class="line">	StrCompare(S,T);<span class="comment">//字符串比较，若S&gt;T则返回值&gt;0,S=T,返回值=0，S&lt;T,返回值&lt;0，</span></span><br><span class="line">	Concat(T,S1,S2);<span class="comment">//用T返回由S1和S2连接而成的新串</span></span><br><span class="line">	SubString(Sub,pos,len);<span class="comment">//用Sub返回串S的第pos个字符串起长度为len的子串</span></span><br><span class="line">	Index(S,T,pos);<span class="comment">//若主串S中存在和串T值相同的子串，则返回他在主串S中第pos个字符之后第一次出现的位置，否则则返回0</span></span><br><span class="line">	Replace(S,T,V);<span class="comment">//用V替换主串S中出现的所有与T相等的不重叠的子串</span></span><br><span class="line">	StrInsert(S,pos,T);<span class="comment">//在串S的第pos个字符之前插入串T</span></span><br><span class="line">	StrDelete(S,pos,len);<span class="comment">//从串S中删除第pos个字符起长度为len的子串</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure>
<h2 id="串的存储结构"><a class="header-anchor" href="#串的存储结构">¶</a>串的存储结构</h2>
<h3 id="串的顺序存储结构"><a class="header-anchor" href="#串的顺序存储结构">¶</a>串的顺序存储结构</h3>
<p><strong>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的</strong>，顺序存储结构需要规定数组的大小，但是涉及两串的连接，新串的插入以及字符串的替换都会超过数组的最大长度Maxsize，<strong>于是对于串的顺序存储，串值的存储空间可在程序执行过程中动态分配而得，也就是使用堆</strong></p>
<h3 id="串的链式存储结构"><a class="header-anchor" href="#串的链式存储结构">¶</a>串的链式存储结构</h3>
<p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个数据元素是一个字符，如果仍使用一个结点来存储一个字符，会造成大量的空间浪费。<strong>因此一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以使用其他非串值字符进行补齐</strong>，由于链式存储结构需要确定一个结点存储多少个字符，比较麻烦，所以一般使用顺序存储结构</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658123888513.png" alt=""></p>
<h2 id="朴素的模式匹配算法"><a class="header-anchor" href="#朴素的模式匹配算法">¶</a>朴素的模式匹配算法</h2>
<p>也就是BF算法</p>
<p><strong>子串的定位操作通常称作串的模式匹配</strong></p>
<p>就是对主串的每一个字母作为子串的开头，与要匹配的字符串进行匹配。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> i = pos;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;<span class="built_in">strlen</span>(S) &amp;&amp; j &lt;<span class="built_in">strlen</span>(T))<span class="comment">//下标小于子串和主串长度</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (S[i] == T[j])<span class="comment">//当前位置的字符串匹配成功则继续往后匹配</span></span><br><span class="line">		{</span><br><span class="line">			++i;</span><br><span class="line">			++j;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span><span class="comment">//</span></span><br><span class="line">		{</span><br><span class="line">			i = i - j + <span class="number">1</span>;<span class="comment">//i返回上次匹配首位的下一位</span></span><br><span class="line">			j = <span class="number">1</span>;<span class="comment">//重新回到子串首位进行匹配</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (j &gt; <span class="built_in">strlen</span>(T))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> i - <span class="built_in">strlen</span>(T);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当每次不成功的匹配都发生在串T的最后一个字符，此时时间复杂度会非常大，可见这种匹配方式较为低效</p>
<h2 id="KMP模式匹配算法"><a class="header-anchor" href="#KMP模式匹配算法">¶</a>KMP模式匹配算法</h2>
<p><strong>KMP常用于相同字符较少的字符串中，效率较高</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658245851001.png" alt=""></p>
<p>可以看到由于望江楼前三个不同且成功匹配，那么第一个红框内的判断是多余的，我们可以直接进行回溯进行比较，而i都是往后的所以不需要回溯，只需要回溯j指针</p>
<p>下图就是KMP算法的匹配流程</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658246082896.png" alt=""></p>
<p>我们把T串每个位置的j值的变化定义为一个数组next</p>
<p>上面的是针对子串T中无重复元素的，下面我们来看一下T串中含有重复串如何使用KMP算法</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658246312528.png" alt=""></p>
<p>首先需要计算未匹配位置前字符串的前缀和后缀，其最长前缀、后缀有共同元素"望江"，长度为2，<strong>所以j指针回溯为2，也就是将"楼"字（下标为2）对应上次未成功匹配的位置</strong>。</p>
<p><strong>这是因为由于前缀和后缀具有相同的元素的话，j指针移动相同元素对应长度就可以做到匹配。</strong>（看图就可以理解了）</p>
<p>接下来我们可以看一下一段快完善的KMP算法代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IndexKmp</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span>* next = genNext(T);<span class="comment">//生成next表</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(S) &amp;&amp; j &lt; <span class="built_in">strlen</span>(T))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (S[i] == T[j])</span><br><span class="line">		{</span><br><span class="line">			i++;</span><br><span class="line">			j++;<span class="comment">//匹配的话，模式串和原串指针都后移</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			j = next[j];<span class="comment">//j指针回溯</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> j = <span class="built_in">strlen</span>(T) ? i - j : <span class="number">1</span>;<span class="comment">//有无匹配的字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="next的手动计算"><a class="header-anchor" href="#next的手动计算">¶</a>next的手动计算</h4>
<p><strong>计算next数组前，我们首先要先知道前后缀是什么，举个例子就能明白了，假如字符串S为"abcdef"，那么S的前缀集合为{a,ab,abc,abcd,abcde}，后缀集合为{f,ef,def,cdef,bcdef}</strong></p>
<p>接下来我们手动计算next数组</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658247591189.png" alt=""></p>
<p><strong>对于下标为5的字符"江"，其前面的字符串是"望江楼上望"，前后缀相同的元素为"望"，长度为1，所以该位置的next数组元素为1</strong>，也就是说下次匹配时将从下标为1的位置进行匹配。</p>
<p>从这里可以看出，如果第一个模式串元素不匹配，那么next[0]=0，由于串S的i指针不会移动，此时会陷入while的死循环。</p>
<p>所以对next数组进行改进，且修改KMP算法的代码（其实多加一个特判即可）</p>
<p><strong>我们在0下标前添加一个万能字符，表示可以和所有字符进行匹配，然后改next[0]=-1</strong>，这样的话当第一个元素不匹配时，d=next[0]=-1，因为-1下标处为万能字符，所以必定匹配，进入if条件中</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658248876847.png" alt=""></p>
<p>代码修改为</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IndexKmp</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span>* next = genNext(T);<span class="comment">//生成next表</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(S) &amp;&amp; j &lt; <span class="built_in">strlen</span>(T))</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || S[i] == T[j])</span><br><span class="line">		{</span><br><span class="line">			i++;</span><br><span class="line">			j++;<span class="comment">//匹配的话，模式串和原串指针都后移</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			j = next[j];<span class="comment">//j指针回溯</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> j = <span class="built_in">strlen</span>(T) ? i - j : <span class="number">1</span>;<span class="comment">//有无匹配的字符串</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="next的代码计算"><a class="header-anchor" href="#next的代码计算">¶</a>next的代码计算</h4>
<p>就是计算出相同的最长前后缀的长度，这个过程和我们进行子串匹配极为类似，所以也可以采用类似的思想</p>
<p>先贴代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">genNext</span><span class="params">(<span class="keyword">char</span>* T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span>* next = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="built_in">strlen</span>(T),<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;<span class="comment">//此时比较的母串和模式串都是其本身</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(T) - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">-1</span> || T[i] == T[j])</span><br><span class="line">		{</span><br><span class="line">			i++;</span><br><span class="line">			j++;<span class="comment">//因为已经++，所以接下来作比较就是下一个字符了</span></span><br><span class="line">			next[i] = (T[i] != T[j] ? j : next[j]);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			j = next[j];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们看看是如何得到这段代码的</p>
<p>分为两种情况</p>
<ul>
<li>匹配：next[i+1]=next[i]+1=j+1;</li>
<li>失配：j=next[j];</li>
</ul>
<p>将其自身与自身进行匹配，找到相同的字符就相当于找到了相同的真前缀和真后缀，画个图进行理解</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658283222671.png" alt=""></p>
<p>当我们成功匹配时，由于是自身进行匹配，那么两个位置处的字符相等，而这两个字符分别是前后缀。（此时next为1）在此基础上，长串指针和短串指针都后移继续进行匹配，若仍匹配成功</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658283403139.png" alt=""></p>
<p>由于前一个匹配成功，后一位置也匹配成功，所以next的值为前一位next+1，也就是next[i+1]=next[i]+1;</p>
<p>当失配时，j指针需要回溯</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284025306.png" alt=""></p>
<p>假如在当前位置失配，d指针回溯的位置应该是d位置处的next值，即下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284102069.png" alt=""></p>
<p>这样即可继续往后匹配</p>
<h5 id="例子-v5"><a class="header-anchor" href="#例子-v5">¶</a>例子</h5>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284266466.png" alt=""></p>
<p>从当前位置红色区域开始，若下标为10的位置成功匹配，那么"流"位置的next值为4+1</p>
<p>但当前位置的字符失配，所以j指针需要回溯，回溯的距离为相同最大真后前缀长度，也就是"望江"的长度，<strong>代码表示为j=next[j]</strong>，如下图所示**</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284621215.png" alt=""></p>
<p>然后接着进行匹配，还是失配，j指针继续回溯，此时无相同真前缀和真后缀，所以回溯到0位置，"江"和"望"依旧无法匹配，所以"流"位置的next值为0</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658284864446.png" alt=""></p>
<h3 id="改进"><a class="header-anchor" href="#改进">¶</a>改进</h3>
<p>在开始讲之前我们先来看一个KMP的匹配</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658295908560.png" alt=""></p>
<p>可以看到如果子串为"望江楼望江流"时，红框中第一次是"望"和","作比较，第二次也是，这样子是重复的。于是需要对next表进行改进，如果当前两字符相等，该位置回溯的值（也就是next数组中的值）需要继续往前找相同前后缀</p>
<p>原来的next表为</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658296711020.png" alt=""></p>
<p>由于下标为4的"望"的next为0，而T[0]=“望”，所以修改为T[0]处的next值，下标为5的"江"同理改为0</p>
<p>修改之后的next表为</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658296844289.png" alt=""></p>
<h1 id="树"><a class="header-anchor" href="#树">¶</a>树</h1>
<p>之前接触的一对一的线性结构，但是我们会遇到很多一对多的问题，这时候就需要研究这种数据结构——树</p>
<blockquote>
<p><strong>树是n(n&gt;=0)个结点的有限集，n=0时为空树。在任意一棵非空树中：1、有且仅有一个特定的称为根的结点；2、当n&gt;1时，其余结点可分为m个互不相交的有限集T1、T2、……，其中每一个集合本身又是一棵树，并称为根的子树</strong></p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285177849.png" alt="树的结构图"></p>
<p>在上图中，有左子树T1和右子树T2</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285240432.png" alt=""></p>
<p>对于树的定义需要注意两点</p>
<ul>
<li>根节点是唯一的</li>
<li>子树的个数没有限制，但他们一定是互不相交的</li>
</ul>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285325411.png" alt="不符合树的定义"></p>
<h2 id="结点分类"><a class="header-anchor" href="#结点分类">¶</a>结点分类</h2>
<p>结点拥有的子树数称为结点的度，度为0的结点称为叶结点或者终端结点，其他结点称为非终端结点或者分支结点。根结点和分支结点都被称为内部结点。<strong>树的度是树内各结点的度的最大值</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285589499.png" alt="树的结点分类"></p>
<h2 id="结点间的关系"><a class="header-anchor" href="#结点间的关系">¶</a>结点间的关系</h2>
<p>结点的子树的根称为该结点的孩子，该结点即为孩子的双亲。<strong>同一双亲的孩子之间互称兄弟，结点的祖先是从根到该结点所经分支上的所有结点</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285780007.png" alt="树的关系图"></p>
<h2 id="树的其他相关概念"><a class="header-anchor" href="#树的其他相关概念">¶</a>树的其他相关概念</h2>
<h3 id="结点的层次"><a class="header-anchor" href="#结点的层次">¶</a>结点的层次</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285898473.png" alt=""></p>
<h3 id="有序与无序"><a class="header-anchor" href="#有序与无序">¶</a>有序与无序</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285942270.png" alt=""></p>
<h3 id="森林"><a class="header-anchor" href="#森林">¶</a>森林</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658285978054.png" alt=""></p>
<h3 id="树结构"><a class="header-anchor" href="#树结构">¶</a>树结构</h3>
<ul>
<li>根结点：无双亲，唯一</li>
<li>叶结点：无孩子，可以多个</li>
<li>中间节点，一个双亲多个孩子</li>
</ul>
<h2 id="树的抽象数据类型"><a class="header-anchor" href="#树的抽象数据类型">¶</a>树的抽象数据类型</h2>
<p>相较于线性结构，树的操作有很大的变化</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树</span><br><span class="line">Data</span><br><span class="line">	树是由一个根节点和若干棵子树构成，树中结点具有相同的数据类型和层次关系</span><br><span class="line"><span class="function">Operation</span></span><br><span class="line"><span class="function">	<span class="title">InitTree</span><span class="params">(*T)</span></span>;<span class="comment">//构造空树</span></span><br><span class="line">	DestroyTree(*T);<span class="comment">//销毁树</span></span><br><span class="line">    CreationTree(*T,definition);<span class="comment">//按definition中给出树的定义来构造树</span></span><br><span class="line">	ClearTree(*T);<span class="comment">//若树T存在，则将树T清为空树</span></span><br><span class="line">	TreeEmpty(*T);<span class="comment">//判断树是否为空</span></span><br><span class="line">	TreeDepth(*T);<span class="comment">//计算树的深度</span></span><br><span class="line">	Root(T);<span class="comment">//返回T的根结点</span></span><br><span class="line">	Value(T,cur_e);<span class="comment">//返回树T中cur_e的值</span></span><br><span class="line">	Assign(T,cur_e,value);<span class="comment">//赋值</span></span><br><span class="line">	Parent(T,cur_e);<span class="comment">//返回其双亲，根节点除外</span></span><br><span class="line">	LeftChild(T,cur_e);<span class="comment">//若cur_e为树的非叶结点，则返回它的最左孩子，否则返回空</span></span><br><span class="line">	RightSibling(T,cur_e);<span class="comment">//返回该结点的右兄弟</span></span><br><span class="line">	InsertChild(*T,*p,i,c);<span class="comment">//p指向树T的某个结点，i为所指结点p的度加上1，非空树c与T不相交，操作结果为插入c为树T中p指结点的第i棵子树</span></span><br><span class="line">	DeleteChile(*T,*p,i);<span class="comment">//删除T中p所指结点的第i棵子树</span></span><br><span class="line">endADT</span><br></pre></td></tr></tbody></table></figure>
<h2 id="树的存储结构"><a class="header-anchor" href="#树的存储结构">¶</a>树的存储结构</h2>
<p>由于树的某个结点可以有多个孩子，所以我们无论以何种顺序将树中所有结点存储到数组中，<strong>结点的存储位置都无法直接反映逻辑关系</strong></p>
<p>所以需要充分利用顺序存储和链式存储的特点实现对树的存储结构的表示，有三种表示法</p>
<ul>
<li>双亲表示法</li>
<li>孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<h3 id="双亲表示法"><a class="header-anchor" href="#双亲表示法">¶</a>双亲表示法</h3>
<p>我们假设以一组连续空间存储树的结点，<strong>同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置</strong>，也就是说每个结点除了知道自己是谁以外，还知道它的双亲在哪</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658299227922.png" alt="结点结构"></p>
<p>其中data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的双亲表示法结点结构定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置</span></span><br><span class="line">}PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//树结构</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//根的位置和结点数</span></span><br><span class="line">}pTree;</span><br></pre></td></tr></tbody></table></figure>
<p>由于根结点是没有双亲的，所以我们约定根结点的位置域设置为-1，这就意味着我们所有的结点都存有它双亲的位置</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658301382777.png" alt="树结构和树双亲表示"></p>
<p>这样我们可以根据结点的parent指针很容易找到它的双亲结点，时间复杂度为O(1)，直到当parent=-1，表示此时找到了树结点的根。但如果我们想知道结点的孩子是什么，则需要遍历树。</p>
<p><strong>我们可以增加一个结点最左边孩子的域，也就是长子域</strong>，这样就可以很容易得到结点的孩子下标。对于没有孩子的结点，长子域设置为-1</p>
<p>如图所示</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326018314.png" alt=""></p>
<p>如此一来，对于有0、1、2个孩子的节点来说，这样的结构解决了要找结点孩子的问题。</p>
<p><strong>如果更关注兄弟之间的关系，双亲表示法无法体现，此时需要增加一个右兄弟域</strong>，也就是说，每一个结点如果它存在右兄弟，则记录下右兄弟的下标，不存在右兄弟则为-1</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326372469.png" alt=""></p>
<p>我们需要根据不同的情况来选择存储结构</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326404928.png" alt=""></p>
<h3 id="孩子表示法"><a class="header-anchor" href="#孩子表示法">¶</a>孩子表示法</h3>
<p>换一种考虑方式，由于树中的每个结点可能有多棵子树，，可以使用多重链表，即<strong>每个结点有多个指针域，其中每个指针指向一棵子树的结点</strong>，这就是多重链表表示法。不过树的每个结点的度，也就是他的孩子个数是不同的，下面设计两种方案</p>
<h4 id="方案一"><a class="header-anchor" href="#方案一">¶</a>方案一</h4>
<p><strong>指针域的个数等于树的度</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326812794.png" alt="结构链表"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658326874291.png" alt=""></p>
<p>可以看到A结点存储两个指针，分别指向其子树B和C，其他也是这样</p>
<p><strong>由于每个结点都需要存储度个数的指针，所以对于空间浪费较大</strong>，但当树中各结点的度相距较小时，这样反而是优点（因为存储的空间被充分利用了）</p>
<h3 id="方案二"><a class="header-anchor" href="#方案二">¶</a>方案二</h3>
<p><strong>每个结点指针域的个数等于该结点的度，同时我们专门取一个位置来存储结点指针域的个数</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658327278373.png" alt="方案二结构流程图"></p>
<p>这种方法克服了浪费空间的缺点，但由于各个结点的链表是不同的结构，加上要计算结点的度的数值，会消耗较多时间。</p>
<h4 id="孩子表示法-v2"><a class="header-anchor" href="#孩子表示法-v2">¶</a>孩子表示法</h4>
<p><strong>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328073829.png" alt=""></p>
<p>为此我们设计两种结点结构，一种是<strong>孩子链表的孩子结点</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328318770.png" alt="孩子结点"></p>
<p>其中child是数据域，<strong>用于存储某个结点在表头数组中的下标</strong>，next是指针域，用于存储某结点的下一个孩子结点的指针</p>
<p>另一种是<strong>表头数组的表头结点</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658328570902.png" alt="表头结点"></p>
<p>孩子表示法的结构定义代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的孩子表示法结构定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//孩子结点的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>*<span class="title">next</span>;</span><span class="comment">//next指针</span></span><br><span class="line">}*ChildPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span><span class="comment">//表头结构</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">}CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//树结构</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];<span class="comment">//结点数组</span></span><br><span class="line">    <span class="keyword">int</span> r,n;<span class="comment">//根的位置和结点数</span></span><br><span class="line">}CTree;</span><br></pre></td></tr></tbody></table></figure>
<p>这样查找某个结点的孩子或者兄弟，只需要查找这个结点的孩子单链表即可。当我们需要遍历整棵树也只需要对头结点的数据进行循环即可</p>
<p>但是当我们想要知道某个结点的双亲是谁时需要整棵树遍历才行。所以可以将双亲表示法和孩子表示法结合一下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658329348770.png" alt="双亲孩子表示法"></p>
<h3 id="孩子兄弟表示法"><a class="header-anchor" href="#孩子兄弟表示法">¶</a>孩子兄弟表示法</h3>
<p>刚才我们分别从双亲的角度和孩子的角度研究树的存储结构，接下来我们从树结点的兄弟角度来看，但是<strong>对于树这种层级结构，之研究结点的兄弟是不行的</strong>。这是因为<strong>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658329839317.png" alt="结点结构"></p>
<p>代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的孩子兄弟表示法结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>*<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">}CSNOde,*CSTree;</span><br></pre></td></tr></tbody></table></figure>
<p>对于图6-4-1的树来说，孩子兄弟表示法结构实现的示意图如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658333093630.png" alt=""></p>
<p>数据后跟的分别是第一个孩子结点的指针和第一个孩子结点的右兄弟结点指针。</p>
<p>这种表示法，给<strong>查找某个结点的某个孩子带来了方便，只需要通过firstchild找到此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到找到具体的孩子</strong>，当然如果想找到某个结点的双亲，该表示法是有缺陷的。<strong>所以可以再增加一个parent指针域来解决快速查找双亲的问题</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658333931260.png" alt=""></p>
<p>将孩子兄弟表示法的结构体变形一下就成了这个样子，<strong>也就是二叉树</strong></p>
<h2 id="二叉树"><a class="header-anchor" href="#二叉树">¶</a>二叉树</h2>
<p><strong>对于在某个阶段都是两种结果的情形，比如开和关、0和1、真和假等，都适合用树状结构来建模，而这种树是一种特殊的树状结构——二叉树</strong></p>
<blockquote>
<p><strong>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成</strong></p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371418983.png" alt="二叉树结构图"></p>
<h3 id="二叉树特点"><a class="header-anchor" href="#二叉树特点">¶</a>二叉树特点</h3>
<ul>
<li><strong>每个结点最多有两棵子树</strong>，所以二叉树综不存在度大于2的结点</li>
<li><strong>左子树和右子树是有顺序的，次序不能颠倒</strong></li>
<li><strong>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树</strong></li>
</ul>
<p>二叉树具有五种基本情况</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371646629.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658371693564.png" alt=""></p>
<h3 id="特殊二叉树"><a class="header-anchor" href="#特殊二叉树">¶</a>特殊二叉树</h3>
<h4 id="斜树"><a class="header-anchor" href="#斜树">¶</a>斜树</h4>
<p><strong>所有的结点都只有左子树的二叉树叫左斜树，所有结点都只有右子树的二叉树叫右斜树，两者统称为斜树</strong></p>
<h4 id="满二叉树"><a class="header-anchor" href="#满二叉树">¶</a>满二叉树</h4>
<p><strong>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372050513.png" alt="满二叉树"></p>
<p>满二叉树的特点</p>
<ul>
<li><strong>叶子只能出现在最下一层</strong>，出现在其他层就不可能达成平衡</li>
<li><strong>非叶子结点的度一定是2</strong></li>
<li><strong>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多</strong></li>
</ul>
<h4 id="完全二叉树"><a class="header-anchor" href="#完全二叉树">¶</a>完全二叉树</h4>
<p><strong>对一棵具有n个结点的二叉树按层序编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树</strong></p>
<p>满二叉树一定是一棵完全二叉树，而完全二叉树不一定是满的</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372793932.png" alt="完全二叉树"></p>
<p>下面给出判断的例子来增进理解</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658372917054.png" alt=""></p>
<p>完全二叉树的特点</p>
<ul>
<li><strong>叶子结点只能出现在最下两层</strong></li>
<li><strong>最下层的叶子一定集中在左部连续位置</strong></li>
<li>倒数二层，若有叶子结点，一定都在右部连续位置</li>
<li>如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况（因为这样必定空出一个位置）</li>
<li><strong>同样结点数的二叉树，完全二叉树的深度最小</strong></li>
</ul>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658373145515.png" alt="完全二叉树判断"></p>
<h3 id="二叉树性质"><a class="header-anchor" href="#二叉树性质">¶</a>二叉树性质</h3>
<h3 id="性质1"><a class="header-anchor" href="#性质1">¶</a>性质1</h3>
<p><strong>在二叉树的第i层上至多有2^(i-1)个结点</strong></p>
<h3 id="性质2"><a class="header-anchor" href="#性质2">¶</a>性质2</h3>
<p><strong>深度为k的二叉树至多有2^k-1个结点</strong></p>
<h3 id="性质3"><a class="header-anchor" href="#性质3">¶</a>性质3</h3>
<p><strong>对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，那么n0=n2+1</strong></p>
<p>由分支数和结点个数可以进行推导</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388031089.png" alt=""></p>
<h3 id="性质4"><a class="header-anchor" href="#性质4">¶</a>性质4</h3>
<p><strong>具有n个结点的完全二叉树深度为[log2(n)]+1（[x]表示不大于x的最大整数）</strong></p>
<p>由满二叉树的定义，深度为k的满二叉树结点数一定为2^k-1，因为这是最多的节点个数，然后倒推回去就可以得到公式k=log2(n+1)</p>
<p>而根据完全二叉树的定义</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388393575.png" alt=""></p>
<h3 id="性质5"><a class="header-anchor" href="#性质5">¶</a>性质5</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388476010.png" alt=""></p>
<p>性质5的例子</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658388579944.png" alt=""></p>
<h2 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构">¶</a>二叉树的存储结构</h2>
<h3 id="二叉树的顺序存储结构"><a class="header-anchor" href="#二叉树的顺序存储结构">¶</a>二叉树的顺序存储结构</h3>
<p><strong>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系</strong></p>
<p>顺序存储结构一般只用于完全二叉树，这是因为对于普通的二叉树，可以将其按照安全二叉树编号，把不存在的结点设置为空</p>
<p>如下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389028020.png" alt=""></p>
<p>但是这种情况仍需要分配2^k-1的空间，浪费了空间</p>
<h3 id="二叉链表"><a class="header-anchor" href="#二叉链表">¶</a>二叉链表</h3>
<p>顺序结构的适用性不强，所以考虑链式结构。</p>
<p><strong>二叉树每个结点最多有两个孩子，所以为他设计一个数据域和两个指针域</strong>，这样的链表叫做二叉链表</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389266516.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链表的结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span>*<span class="title">lchild</span>,<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">}BitNode,*BitTree;</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389350501.png" alt="二叉链表结构示意图"></p>
<h2 id="遍历二叉树"><a class="header-anchor" href="#遍历二叉树">¶</a>遍历二叉树</h2>
<p>对于二叉树的遍历来说，<strong>次序较为重要</strong></p>
<blockquote>
<p><strong>二叉树的遍历是指从根结点开始，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次</strong></p>
</blockquote>
<h3 id="前序遍历"><a class="header-anchor" href="#前序遍历">¶</a>前序遍历</h3>
<p><strong>根结点-&gt;左子树-&gt;右子树</strong></p>
<p><strong>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389761608.png" alt=""></p>
<p>先前序遍历根结点的左子树，从B结点开始，到D结点，再到G，此时对于D的左子树已经遍历完成，接下来前序遍历D的右子树，再之后A的左子树遍历完成，就到C，E，I，F</p>
<h3 id="中序遍历"><a class="header-anchor" href="#中序遍历">¶</a>中序遍历</h3>
<p><strong>左子树-&gt;根-&gt;右子树</strong></p>
<p><strong>若二叉树为空，则空操作返回，否则从根结点开始(注意并不是先访问根结点)，中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658389991208.png" alt=""></p>
<p>先从根结点开始，中序遍历左子树，也就是B的那一部分，把B看作B子树的根结点，然后按照中序遍历左子树D，还是按照中序遍历，G是D的左孩子，先对其遍历，再到G的根结点D，再到右子树H，往上层回溯，此时B的左子树遍历完成，到B，而B无右子树，跳过对B右子树的遍历，再到A，最后对A的右子树遍历。（这里对于E，只有右子树，没有左子树，所以访问顺序先E再I）</p>
<h3 id="后序遍历"><a class="header-anchor" href="#后序遍历">¶</a>后序遍历</h3>
<p><strong>左子树-&gt;右子树-&gt;根结点</strong></p>
<p><strong>若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点</strong></p>
<p>也可以根据左子树-&gt;右子树-&gt;根结点依次进行后序遍历的方式进行</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658390559641.png" alt=""></p>
<p>先对左子树B开始，B有左子树，对其进行后序遍历，D的左孩子为G，先对其访问，然后是右孩子H，再到根结点D，B的左子树遍历完成，无右子树，直接访问B，再到根结点的右子树进行后序遍历。</p>
<h3 id="层序遍历"><a class="header-anchor" href="#层序遍历">¶</a>层序遍历</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658390961739.png" alt="层序遍历结构图"></p>
<h3 id="多种遍历方法的意义"><a class="header-anchor" href="#多种遍历方法的意义">¶</a>多种遍历方法的意义</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391006060.png" alt=""></p>
<h3 id="前中后序遍历算法"><a class="header-anchor" href="#前中后序遍历算法">¶</a>前中后序遍历算法</h3>
<p>其实就是上面说的遍历顺序的不同</p>
<ul>
<li>前序：根-&gt;左子树-&gt;右子树</li>
<li>中序：左子树-&gt;根-&gt;右子树</li>
<li>后序：左子树-&gt;右子树-&gt;根</li>
</ul>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391313478.png" alt="前序遍历算法"></p>
<p>其他都差不多，而对于遍历过程也已经在上面提及了，就不赘述了</p>
<h3 id="推导遍历结果"><a class="header-anchor" href="#推导遍历结果">¶</a>推导遍历结果</h3>
<p>和离散数学中的推导一致，只需要知道各种遍历的遍历特点，再根据递归即可根据遍历结果即可还原出原本的二叉树</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391555792.png" alt="二叉树遍历的性质"></p>
<h2 id="二叉树的建立"><a class="header-anchor" href="#二叉树的建立">¶</a>二叉树的建立</h2>
<p>如果我们要在内存中建立一个如图6-9-1左图这样的树，为了能让每个结点确认是否有左右孩子，我们对他进行了扩展，变成右图的样子，<strong>也就是将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如’#'</strong>，我们称这种处理后的二叉树为原二叉树的扩展二叉树。<strong>扩展二叉树可以做到：如果已知一个遍历序列就可以确定一棵二叉树</strong>，这也是为什么我们先对二叉树进行扩展，比如左图的前序遍历序列为AB#D##C##</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658391801250.png" alt=""></p>
<p>有了此准备，我们可以看看如何生成一棵二叉树</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按前序输入二叉树中结点的值（一个字符）</span></span><br><span class="line"><span class="comment">//#表示空树，构造二叉链表示二叉树T</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitNode</span>*<span class="title">lchild</span>,<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">}BitNode,*BitTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBitTree</span><span class="params">(BitTree*T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%C"</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>)</span><br><span class="line">    {</span><br><span class="line">        *T=<span class="literal">NULL</span>;<span class="comment">//表示结点为空</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        *T=(BitTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BitNode));</span><br><span class="line">        <span class="keyword">if</span>(!*T)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//开辟失败</span></span><br><span class="line">        }</span><br><span class="line">        (*T)-&gt;data=ch;</span><br><span class="line">        CreateBitTree(&amp;(*T)-&gt;lchild);<span class="comment">//构造左子树</span></span><br><span class="line">        CreateBitTree(&amp;(*T)-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658392330019.png" alt="生成二叉树的原理"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658410756146.png" alt="中序后续构造二叉树"></p>
<h2 id="线索二叉树"><a class="header-anchor" href="#线索二叉树">¶</a>线索二叉树</h2>
<p>对于二叉链表，我们可以看到有许多空指针的存在，浪费了大量的空间</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658410788739.png" alt=""></p>
<p>另一方面我们在遍历完二叉树后知道每个结点的前驱和后继结点是哪个，可是这是建立在遍历过的基础之上。<strong>在二叉链表上，我们只知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱或后驱结点是谁</strong>。要是想知道，必须遍历一次，且以后每次需要知道时，都必须先遍历一次。那么我们可以考虑<strong>子啊创建时就记住前驱和后继结点</strong>，这将会节省时间</p>
<p><strong>所以我们可以考虑利用那些空地址，存放指向结点在某种遍历次序下的前驱和后继结点</strong></p>
<p>我们把这种<strong>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树</strong></p>
<h3 id="例子-v6"><a class="header-anchor" href="#例子-v6">¶</a>例子</h3>
<p>如下图我们对这棵树进行中序遍历之后，将所有的空指针域中的rchild改为指向它的后继结点</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658414870561.png" alt=""></p>
<p>于是我们可以通过指针知道H的后继节点是D（图中的1），I的后继是B，J的后继是E，E的后继是A，F的后继是C，G的后继因为不存在而指向NULL，此时有6个空指针域被利用</p>
<p>再如下图将这棵二叉树的所有空指针域中的lchild改为指向当前结点的前驱，H的前驱是NULL，I的前驱是D，J的前驱是B，F的前驱是A，G的前驱是C，一共5个空指针域被利用。结合前面，总共11个空指针域被利用。</p>
<p>通过下图更容易看出(空心箭头实现为前驱，虚线黑箭头为后继)：<strong>其实线索二叉树相当于把一棵二叉树转为了一个双向链表</strong>，这样对于我们查找、插入、删除结点都带来了便利。我们把<strong>对二叉树以某种次序遍历使其成为线索二叉树的过程称为线索化</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658415381940.png" alt=""></p>
<p>但仍然有问题需要解决，那就是我们如何知道某一结点的lchild是指向它的左孩子还是指向前驱？rchild是指向右孩子还是后继？比如E结点的lchild是指向它的左孩子J，而rchild却是指向它的后继A。因此，<strong>我们在每个结点再增设两个标志域ltag和ratg，注意ltag和rtag只是存放0或1数字的布尔变量</strong>，其占用的内存空间要小于像lchild和rchild指针变量。</p>
<p>结点结构体如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658416056518.png" alt=""></p>
<p>因此对于二叉链表图可以修改为下图的样子</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658416112659.png" alt=""></p>
<h3 id="线索二叉树结构实现"><a class="header-anchor" href="#线索二叉树结构实现">¶</a>线索二叉树结构实现</h3>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的二叉线索存储结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span>Link,Thread} PointerTag;<span class="comment">//Link==0表示指向左右孩子指针，Thread==1表示指向前驱或者后缀的线索</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BitThrNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">//结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BitThrNode</span>*<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">    PointerTag LTag;</span><br><span class="line">    PoniterTag RTag;<span class="comment">//左右标志</span></span><br><span class="line">}BitThrNode,*BitThrTree;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>线索化的实质就是将二叉链表中的空指针改为指向前驱或者后继的线索</strong>，由于前驱和后继的信息只有在遍历该二叉树才能得到，所以<strong>线索化的过程就是在遍历的过程中修改空指针的过程</strong></p>
<p>中序遍历线索化的递归函数代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BitThrThree pre;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BitThrTree p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    {</span><br><span class="line">        InThreading(p-&gt;lchild);<span class="comment">//递归左子树线索化</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//如果没有左孩子</span></span><br><span class="line">    {</span><br><span class="line">        p-&gt;LTag=Thread;<span class="comment">//前驱线索</span></span><br><span class="line">        p-&gt;lchild=pre;<span class="comment">//左孩子指针指向前驱</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//前驱没有右孩子</span></span><br><span class="line">    {</span><br><span class="line">        pre-&gt;RTag=Thread;<span class="comment">//后驱线索</span></span><br><span class="line">        pre-&gt;rchild=p;<span class="comment">//前驱右孩子指针指向后继(当前结点p)</span></span><br><span class="line">    }</span><br><span class="line">    pre=p;<span class="comment">//保持pre指向p的前驱</span></span><br><span class="line">    InThreading(p-&gt;rchild);<span class="comment">//递归右子树线索化</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658456052300.png" alt="线索化的思路"></p>
<p>有了线索二叉树之后，我们对其遍历时发现，其实就相当于是操作一个双向链表</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658456133754.png" alt="双向链表遍历"></p>
<p>遍历的代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T指向头结点，头结点左链lchild指向根结点，头结点右链指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse_Thr</span><span class="params">(BitThrTree T)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    BItThrTree p;</span><br><span class="line">    p=T-&gt;lchild;<span class="comment">//p指向根结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=T)<span class="comment">//空树或遍历结束时，p==T（头结点）</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag==Link)<span class="comment">//当LTag==0时，表示其没有左孩子，循环到中序序列的第一个结点</span></span><br><span class="line">        {</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//打印结点数据</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag==Thread&amp;&amp;p-&gt;rchild!=T)</span><br><span class="line">        {<span class="comment">//存在后继结点，不存在右孩子且不指向头结点</span></span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,p-&gt;data);<span class="comment">//D因为存在右孩子，所以不进入循环</span></span><br><span class="line">        }</span><br><span class="line">        p=p-&gt;rchild;<span class="comment">//指向结点D的右孩子I</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658457363746.png" alt="代码解释"></p>
<p><strong>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构是不错的选择</strong></p>
<h2 id="树、森林与二叉树的转换"><a class="header-anchor" href="#树、森林与二叉树的转换">¶</a>树、森林与二叉树的转换</h2>
<p>在将树的存储结构时，我们提到了树的孩子兄弟法可以将一棵树用二叉链表进行存储，<strong>所以借助二叉链表，树和二叉树可以相互进行转换</strong></p>
<h3 id="树转换为二叉树"><a class="header-anchor" href="#树转换为二叉树">¶</a>树转换为二叉树</h3>
<ol>
<li>加线。在所有兄弟结点之间加一条连线</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。<strong>注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子</strong></li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658459926402.png" alt=""></p>
<h3 id="森林转换为二叉树"><a class="header-anchor" href="#森林转换为二叉树">¶</a>森林转换为二叉树</h3>
<p>森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作，步骤如下</p>
<ol>
<li>把每个树转换为二叉树</li>
<li>第一棵二叉树不动，<strong>从第二棵二叉树开始，一次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子</strong>，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658460850375.png" alt="森林转为二叉树"></p>
<h3 id="二叉树转换为树"><a class="header-anchor" href="#二叉树转换为树">¶</a>二叉树转换为树</h3>
<p>也就是树转换为二叉树的逆过程，步骤如下</p>
<ol>
<li>加线。若某结点的左孩子存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点……与该结点连线。</li>
<li>去线。删除二叉树中所有结点与其右孩子结点的连线</li>
<li>层次调整</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658461230926.png" alt=""></p>
<h3 id="二叉树转换为森林"><a class="header-anchor" href="#二叉树转换为森林">¶</a>二叉树转换为森林</h3>
<p>判断一棵二叉树能够转换为一棵树还是森林，<strong>只需要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树</strong>，如果是转换成森林，步骤如下</p>
<ol>
<li>从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分类的二叉树</li>
<li>再将每棵分离后的二叉树转化为树即可。</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658471975240.png" alt=""></p>
<h3 id="树与森林的遍历"><a class="header-anchor" href="#树与森林的遍历">¶</a>树与森林的遍历</h3>
<p>树的遍历方式分为两种方式</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点</li>
</ol>
<p>森林的遍历也分为两种方式</p>
<ol>
<li><strong>前序遍历</strong>：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样的方式白遍历除去第一棵树的剩余数构成的森林，比如前面一张图中的森林按照前序遍历序列的结果是ABCDEFGHJI</li>
<li><strong>后序遍历</strong>：先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次以同样的方式遍历除去第一棵树的剩余树构成的森林，还是以上面的森林图为例，按照后序遍历的结果就是BCDAFEJHIG</li>
</ol>
<p>我们可以发现，森林的前序遍历和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历结果相同。</p>
<p>这就告诉我们，<strong>当以二叉链表作为书的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现</strong></p>
<h2 id="赫夫曼树及其应用——最优二叉树"><a class="header-anchor" href="#赫夫曼树及其应用——最优二叉树">¶</a>赫夫曼树及其应用——最优二叉树</h2>
<p>赫夫曼编码是最基本的压缩编码方式，在编码中用到的特殊的二叉树称之为赫夫曼树</p>
<h3 id="引例"><a class="header-anchor" href="#引例">¶</a>引例</h3>
<p>首先举一个例子</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474794616.png" alt=""></p>
<p>我们用上面这一段代码来判断学僧的五级分制等级，其对应的流程图如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474905887.png" alt=""></p>
<p>但是在实际生活中，每个分数段占比是不同的，分布规律如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658474962728.png" alt="分布规律"></p>
<p>那么对于70分以上大约占总数的80%的成绩都需要经过3次以上的判断才能得到结果，所以对其进行优化，得到下面的二叉树</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658475067397.png" alt=""></p>
<h3 id="赫夫曼树定义与原理"><a class="header-anchor" href="#赫夫曼树定义与原理">¶</a>赫夫曼树定义与原理</h3>
<p>我们先把这两棵二叉树简化成叶子结点带权的二叉树，如下图所示，其中A表示不及格、B表示及格、C表示中等、D表示良好、E表示优秀。<strong>每个叶子的分支线上的数字就是刚才我们提到的五级分制的成绩所占比例数</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658475507875.png" alt=""></p>
<p><strong>从树中的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度</strong>，如二叉树a中，根结点到结点D的路径长度就为4，二叉树b中根结点到D结点的路径长度为2。<strong>树的路径长度就是从树根到每一结点的路径长度之和</strong>。二叉树a的路径长度为1+1+2+2+3+3+4+4=20，二叉树b的路径长度为1+2+3+3+2+1+2+2=16</p>
<p>如果考虑到带权的结点，<strong>结点的带权的路径长度为从该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和</strong></p>
<blockquote>
<p><strong>假设有n个权值(w1,w2,w3……,wn)，构造一棵有n个结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，则其中带权路径长度WPL最小的二叉树称为赫夫曼树</strong>，也叫做最优二叉树</p>
</blockquote>
<p>有了上述定义，我们可以计算上面两棵树的WPL值</p>
<p>二叉树a的WPL=5×1+15×2+40×3+30×4+10×4=315</p>
<p>注意：<strong>这里5是A叶子的权，1是A叶子的路径长度，其他同理</strong></p>
<p>二叉树b的WPL=5×3+15×3+40×2+30×2+10×2=220</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658492477590.png" alt="WPL值的用处"></p>
<p>那么这样的二叉树是如何构造出来的，这样的二叉树是不是就是最优的赫夫曼树呢</p>
<p>下面给出解决办法</p>
<ol>
<li>先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即A5，E10，B15，D30，C40。</li>
<li>取头两个最小权值的结点作为一个新节点N1的两个子结点，注意相对较小的作为左孩子，这里就是A为N1的左孩子，E为N1的右孩子，此时新结点的权值为15</li>
<li>将N1替换A和E，插入有序序列中，保持从小到大排列，即N1结点15，B15，D20，C40</li>
<li>重复步骤2，将N1与B作为新节点N2的两个子节点，N2的权值为30</li>
<li>接下来就是重复上述步骤</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493307449.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493319282.png" alt=""></p>
<p>上图即为流程图，此时二叉树的带权路径长度WPL为205小于二叉树b的WPL220，显然此时构造的二叉树才是最优的赫夫曼树</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493362584.png" alt="赫夫曼树的算法描述"></p>
<h3 id="赫夫曼编码"><a class="header-anchor" href="#赫夫曼编码">¶</a>赫夫曼编码</h3>
<p>赫夫曼树主要适用于解决数据传输的最优化问题</p>
<p>由于在各种语言中，字母或者汉字的出现频率是不同的</p>
<h4 id="例子-v7"><a class="header-anchor" href="#例子-v7">¶</a>例子</h4>
<p>假设要传输一段文字内容为"BADCADFEED"，我们会想到用二进制0和1来表示</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494223805.png" alt=""></p>
<p>我们假设六个字母的频率为A 27，B 8，C 15，D 15，E 30，F 5，合起来正好是100%，所以我们可以重新按照赫夫曼树来规划它们</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658493967428.png" alt="构造后的赫夫曼树"></p>
<p>此时我们对这六个字母<strong>用其从树根到叶子所经过路径的0或1来编码，可以得到如下定义</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494167497.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494234357.png" alt=""></p>
<p>可以看到使用赫夫曼树节约了存储和传输的成本</p>
<p>当我们接收到赫夫曼树压缩过后的新编码时，该如何进行解码是一个问题</p>
<p>由于每个字符的编码长度不等，所以<strong>若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符编码的前缀，这种编码称作前缀编码</strong></p>
<p>我们可以发现赫夫曼树对于字母的编码不存在容易与1001、1000混淆的"10"和"100"编码</p>
<p>但是我们在解码的时候还是需要约定好同样的赫夫曼编码规则</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494824396.png" alt=""></p>
<h4 id="赫夫曼编码定义"><a class="header-anchor" href="#赫夫曼编码定义">¶</a>赫夫曼编码定义</h4>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494855213.png" alt=""></p>
<h3 id="树的总结"><a class="header-anchor" href="#树的总结">¶</a>树的总结</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658494922433.png" alt=""></p>
<h1 id="图"><a class="header-anchor" href="#图">¶</a>图</h1>
<h2 id="图的定义"><a class="header-anchor" href="#图的定义">¶</a>图的定义</h2>
<blockquote>
<p>在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继元素。在树状结构中，数据元素之间有着明显的层次关系西，并且每一层上的数据元素可能和下一层中的多个元素相关，但只能和上一层中一个元素相关（就好比一对父母可以有多个孩子，但是一个孩纸只有一对父母）。</p>
</blockquote>
<blockquote>
<p><strong>图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关</strong></p>
</blockquote>
<p><strong>图是由顶点的有穷非空集合和顶点之间变得集合组成的，通常表示为：G(V,E)。其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合</strong></p>
<p>对于图的定义，我们需要明确几点</p>
<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，<strong>在图中数据元素叫做顶点</strong></li>
<li>在线性表可以有空表，在树中可以有空树。<strong>但是在图结构中，不允许没有顶点</strong>。在定义中，若V是顶点的集合，则强调了顶级集合V有穷非空</li>
<li>在图中，<strong>任何两个顶点之间都可能有关系，顶点之间的逻辑关系用边表示</strong></li>
</ul>
<h3 id="各种图定义"><a class="header-anchor" href="#各种图定义">¶</a>各种图定义</h3>
<blockquote>
<p><strong>无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边，用无序偶对(Vi,Vj)来表示</strong>。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图</p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658506790378.png" alt="无向图"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658506813144.png" alt="无向图的定义"></p>
<blockquote>
<p><strong>有向边：若从顶点Vi到Vj的边有方向，则称这条边为有向边，也成为弧，用有序偶&lt;Vi,Vj&gt;，Vi称为弧尾，Vj称为弧头</strong>。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图</p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507035312.png" alt="有向图"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507064079.png" alt=""></p>
<p>需要注意弧头和弧尾的位置</p>
<p><strong>注意无向边是用()表示的，有向边是用&lt;&gt;表示的</strong></p>
<p><strong>在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507189949.png" alt="非简单图"></p>
<p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图</strong>。含有n个结点的无向完全图有n×(n-1)/2条边</p>
<blockquote>
<p>因为对于无向完全图，任意两个结点都需要存在边，那么任选一个结点，其连接的边数为n-1，有n个结点，乘以n即可，又因为是无向的，所以有重复的，需要除以2</p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507433419.png" alt="无向完全图"></p>
<p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图</strong>。含有n个顶点的有向完全图有n×(n-1)条边（推导方法同上）</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507763980.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658507826201.png" alt="有向图和无向图边数范围"></p>
<p><strong>有很多条边或弧的图称为稀疏图，反之称之为稠密图</strong>。这里的稀释和稠密都是相对概念</p>
<p>有些图的边或弧具有与他相关的数字，<strong>这种与图的边或弧相关的数叫做权</strong>。这些权可以表示从一个顶点到另一个顶点的距离或者耗费。<strong>这种带权的图通常称之为网</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508217686.png" alt="网"></p>
<p>下面是子图的定义</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508278580.png" alt=""></p>
<h3 id="图的顶点与边间的关系"><a class="header-anchor" href="#图的顶点与边间的关系">¶</a>图的顶点与边间的关系</h3>
<p><strong>无向图顶点的度和邻接点、关联</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508543901.png" alt=""></p>
<p><strong>有向图顶点的邻接、出入度</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508680038.png" alt=""></p>
<p><strong>无向图顶点之间的路径表示</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508771955.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658508996796.png" alt="无向图顶点路径"></p>
<p>上图即为顶点B到顶点D的四种不同</p>
<p>有向图间顶点路径表示</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509086094.png" alt=""></p>
<p><strong>树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的</strong></p>
<p><strong>路径的长度是路径上的边或弧的数目</strong>，上图左侧路径长度为2，右侧长度为3</p>
<p><strong>第一个顶点到最后一个顶点相同的路径称为回路或环，序列中顶点不重复出现的路径称之为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称之为简单回路或者简单环</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509572350.png" alt="环与简单环的区分"></p>
<h3 id="连通图相关术语"><a class="header-anchor" href="#连通图相关术语">¶</a>连通图相关术语</h3>
<p><strong>连通图的定义</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509634251.png" alt=""></p>
<p><strong>无向图中的极大连通子图称为连通分量</strong>。连通分量强调：</p>
<ul>
<li>是子图</li>
<li>子图是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边</li>
<li><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659013775048.png" alt="连通分量例子"></li>
</ul>
<p>上图蓝色和黄色环都是连通分量</p>
<p>图1是一个无向非连通图，但是他有两个连通分量，即图2和图3，而图4尽管是图1的子图，但它却不满足连通子图的极大顶点数</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658509870590.png" alt=""></p>
<p><strong>强连通图的定义</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658510316515.png" alt=""></p>
<p><strong>连通图的生成树定义</strong></p>
<p>所谓的<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559123775.png" alt=""></p>
<p><strong>如果一个图有n个顶点和小于n-1条边，则是非连通图，如果它多于n-1条边，一定会构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径</strong>。不过有n-1条边并不一定是生成树</p>
<p><strong>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树</strong>。对于有向树的理解，可以把入度为0的顶点看作树中的根结点，其余顶点入度为1表明树中非根结点的双亲只有一个</p>
<p><strong>一个有向图的生成森林由若干棵有向树组成，含有图中的全部顶点，但只有足以构成若干棵不相交的有向树的弧</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559712143.png" alt="有向树和生成森林"></p>
<h3 id="图的定义与术语总结"><a class="header-anchor" href="#图的定义与术语总结">¶</a>图的定义与术语总结</h3>
<p>先前也有介绍，这里是汇总</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559797254.png" alt=""></p>
<h2 id="图的抽象数据类型"><a class="header-anchor" href="#图的抽象数据类型">¶</a>图的抽象数据类型</h2>
<p>图作为一种数据结构，它的抽象数据类型带有自己特点，不同应用需要不同的运算集合，构造不同的抽象数据操作</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658559961774.png" alt=""></p>
<h3 id="图的存储结构"><a class="header-anchor" href="#图的存储结构">¶</a>图的存储结构</h3>
<p>从图的逻辑结构定义来看，<strong>图上任意一个顶点都可以被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系</strong></p>
<p>以下四张图片其实都是一个图，只不过顶点的位置不同</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560072053.png" alt=""></p>
<p><strong>由于任意两个顶点之间都可能存在联系，因此无法以数据元素在内存中的物理位置来表示元素之间的关系</strong></p>
<p>先前的存储方式来存储图结构的不可行性</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560213917.png" alt=""></p>
<h4 id="邻接矩阵"><a class="header-anchor" href="#邻接矩阵">¶</a>邻接矩阵</h4>
<blockquote>
<p><strong>图的邻接矩阵存储方式是用两个数组来表示图，一个一维数组存储图中结点信息，一个二维数组(称为邻接矩阵)促成农户图中的边或弧的信息</strong></p>
</blockquote>
<p>下面是邻接矩阵存储图结构的一个例子</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658560596124.png" alt=""></p>
<p>知道邻接矩阵之后，我们可以获取如下信息</p>
<ul>
<li>可以判定任意两顶点是否有边无边</li>
<li>要知道某个顶点的度，其实就是这个元素Vi在邻接矩阵中第i行或第i列的元素之和（这是因为无向图的边数组是个对称矩阵）。对于顶点V1的度就是1+0+1+0=2</li>
<li>求顶点Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，该处位置值为1则表示是邻接点</li>
</ul>
<p>下面是有向图的邻接矩阵</p>
<p><strong>有向图中由于存在出度入度，顶点V1的入度为1，是第V1列各数之和，顶点V1的出度为2，即第V1行的各数之和</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561214345.png" alt=""></p>
<p>对于网来说，每条边上都带有权，接下来使用邻接矩阵来表示网</p>
<p>此时边数组中的元素为权值，无法到达使用无穷符号来表示，自身到自身权值为0</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561472350.png" alt=""></p>
<p>邻接矩阵实现图的结构定义和代码实现如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659014166220.png" alt=""></p>
<h4 id="邻接表"><a class="header-anchor" href="#邻接表">¶</a>邻接表</h4>
<p>对于边数相对顶点较少的稀疏图，邻接矩阵是对存储空间的极大浪费。如下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658561990643.png" alt=""></p>
<p>为了解决顺序存储结构预先分配内存造成的空间浪费问题，我们引出了链式存储的结构。所以我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。</p>
<p><strong>类比树中孩子表示法将结点存入数组，并对结点的孩子进行链式存储。我们把这种数组与链表相结合的存储方法称为邻接表</strong></p>
<p>邻接表的处理方法如下</p>
<ol>
<li>图中顶点用一个一维数组存储，使用数组可以较容易地读取顶点信息。此外，每个数据元素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息</li>
<li>图中每个顶点Vi的所有邻接点构成一个线性表，由于邻接点的个数不确定，所以用单链表存储，<strong>无向图称为顶点Vi的边表，有向图则称为顶点Vi作为弧尾的出边表</strong></li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658562778894.png" alt="无向图邻接表"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658562890868.png" alt=""></p>
<p><strong>当我们想知道某个顶点的度时，就去查找这个顶点的边表中结点的个数。若要判断顶点Vi到Vj是否存在边，只需要测试顶点Vi的边表adjvex是否存在结点Vj的下标j就行了。若求顶点的所有邻接点，其实就是对此顶点的边表进行遍历，得到的adjvex域对应的顶点就是邻接点</strong></p>
<p>若是有向图，邻接表的结构是类似的。<strong>要注意的是有向图由于有方向，我们是以顶点为弧尾(起点)来存储边表的，这样很容易得到每个顶点的出度。但有时为了便于确定顶点的入度或以顶点尾弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点Vi都建立一个链接为Vi为弧头的表</strong></p>
<p>逆邻接表只需要按照求有向图的邻接表逆向求得即可</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658582916769.png" alt=""></p>
<p><strong>此时我们很容易就可以算出某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现</strong></p>
<p>对于带权值的网图，<strong>可以在边表结点定义中再增加一个weight的数据域，存储权信息即可</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658583879842.png" alt=""></p>
<p>结构定义和代码实现如下</p>
<h4 id="十字链表"><a class="header-anchor" href="#十字链表">¶</a>十字链表</h4>
<p>十字链表的存储结构代码实现</p>
<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/323.html">http://data.biancheng.net/view/323.html</a></p>
<p>对于有向图来说，邻接表是有缺陷的。关心了出度问题，<strong>想了解入度就必须要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况</strong>。而十字链表就是解决这种问题的——<strong>将出边表与入边表结合起来</strong>，也就是每个顶点具有两条链表，一条是入边链表，另一条则是出边链表</p>
<p>对于顶点表和边表的结点结构重新定义</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1658584667202.png" alt=""></p>
<blockquote>
<p>以下图为例，总共有六条弧，我们根据其起点和终点画出边表的结构(结点前两个位置是起点和终点，后两个位置是指向终点相同的下一条边和指向起点相同的下一条边)，然后进行连接。</p>
<p>对于A0顶点，后两个位置分别为入边表指针和出边表指针，黑线是出边表，对于A0，出边即以0为起点，此时只有01这个结点，所以指向01结点，而因为此时没有以0为起点的结点，所以01结点后两个位置设置为NULL。A1、A2、A3同理。</p>
<p>对于A4，43结点链接到出边表之后，还有一个42起点也是由4为起点的结点，所以43结点的第四个位置(也就是起点相同的下一条边)</p>
</blockquote>
<p><strong>对于入边表也是同理</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659014906155.png" alt=""></p>
<h4 id="邻接多重表"><a class="header-anchor" href="#邻接多重表">¶</a>邻接多重表</h4>
<p>邻接多重表代码实现</p>
<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/324.html">http://data.biancheng.net/view/324.html</a></p>
<p>十字链表是用于有向图的，而邻接多重表则适用于无向图，由于无向图不考虑方向，<strong>此时使用邻接表则会出现重复的情况</strong></p>
<p>在邻接表中，同样是将顶点存储于顺序表中，然后为每一个顶点配备一条链表，<strong>链表的每个结点存储的都是和当前顶点有直接关联的边</strong></p>
<p>顶点的定义和邻接表的相同</p>
<p>边表的结点结构体定义如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659028717214.png" alt=""></p>
<p>下面简单看个例子</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659028914337.png" alt=""></p>
<p>由于是无向边，所以ivex和jvex的位置可以互换，但是为了方便画图还是将与当前顶点相关的放在前面。</p>
<p>总共有01、02、12、23、30结点，开始进行连线，和当前顶点有关则链入链表中</p>
<p>对于V0，首先和01结点相连，接下来ilnk指向下一个与当前顶点相关的边，也就是5号路径，同理进行6号路径（此时没有与0相关的边，所以将ilink设置为NULL）。对于1，和当前V0结点无关，其下一边暂时标记为NULL。对于V1，则有关，所以使用7号路径进行连接。其他也是同理</p>
<h4 id="边集数组"><a class="header-anchor" href="#边集数组">¶</a>边集数组</h4>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659106849346.png" alt=""></p>
<h2 id="图的遍历"><a class="header-anchor" href="#图的遍历">¶</a>图的遍历</h2>
<blockquote>
<p><strong>图的遍历，即从图中某一顶点出发访问图中其余顶点，使得每一个顶点被访问且仅访问一次</strong></p>
</blockquote>
<p>其实对于两种遍历方式的不同，举个例子就可以进行理解</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659031094651.png" alt=""></p>
<p>以上述无向图的遍历为例，对两种遍历方式进行区分</p>
<p>深度遍历和广度遍历的代码</p>
<p><a target="_blank" rel="noopener" href="http://data.biancheng.net/view/326.html">http://data.biancheng.net/view/326.html</a></p>
<h3 id="深度优先遍历——DFS"><a class="header-anchor" href="#深度优先遍历——DFS">¶</a>深度优先遍历——DFS</h3>
<p>所谓深度优先搜索，就是从图中的某个顶点出发，不停的寻找相邻的、尚未访问的顶点：<strong>图的深度优先遍历类似树的前序遍历</strong></p>
<ul>
<li>如果找到多个，则任选一个顶点，然后继续从该顶点出发；</li>
<li>如果一个都没有找到，则回退到之前访问过的顶点，看看是否有漏掉的；</li>
</ul>
<p>对于上述无向图的遍历过程</p>
<ol>
<li>V1与V2和V3相邻，且这两个结点都没被访问过，任选一个，我们先选V2</li>
<li>对于V2同理，V2和未被访问过的V4和V5相邻，选择V4</li>
<li>V4和未被访问的V8相邻，选择V8，然后再到V5</li>
<li>到V5时，此时和V5相邻的V8和V5都已经被访问过，需要回退到V8，对V8进行该过程，直到V1</li>
<li>此时对V3那边重复上述过程进行遍历</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659032578715.png" alt="顶点访问顺序"></p>
<h3 id="广度优先遍历——BFS"><a class="header-anchor" href="#广度优先遍历——BFS">¶</a>广度优先遍历——BFS</h3>
<p>所谓广度优先搜索，就是从图中的某个顶点出发，寻找紧邻的、尚未访问的顶点，找到多少就访问多少，然后分别从找到的这些顶点出发，继续寻找紧邻的、尚未访问的顶点。 <strong>图的广度优先遍历类似树的层序遍历</strong></p>
<p>步骤</p>
<ol>
<li>首先访问V1结点，此时有两个未被访问的与V1相邻的V2和V3结点，对他们两个结点进行访问（先后顺序自己决定）</li>
<li>然后再进行V2这边的遍历，V4和V5都是未被访问的与V2相邻的结点，对其进行访问，接着就是V8**，自 V8 之后，访问序列中再无其它顶点，意味着从 V1 顶点出发，无法再找到尚未访问的顶点。这种情况下，广度优先搜索算法会从图的所有顶点中重新选择一个尚未访问的顶点，然后从此顶点出发，以同样的思路继续寻找其它尚未访问的顶点。**</li>
<li>对于V3这一边的也是同理</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659033043654.png" alt="访问顺序"></p>
<p>对于上述过程使用队列来实现较为方便</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659077593147.png" alt=""></p>
<p>过程</p>
<ol>
<li>首先将第一个访问的顶点入队</li>
<li>然后队头A出队，将与A结点相邻且未被访问的顶点从左至右入队</li>
<li>接着队头B出队，将与B相邻且未被访问的顶点入队，也就是CIG</li>
<li>接着就是队头F出队，将与F相邻且未被访问的顶点出队，因为G被访问过，所以只有E入队</li>
<li>后面也是相同的，直到队列为空</li>
</ol>
<p><strong>使用队列的入队出队正好满足先对一个顶点的相邻且未被访问的顶点进行访问</strong></p>
<p>代码如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659076471338.png" alt=""></p>
<h3 id="邻接矩阵的深度优先遍历和广度优先遍历"><a class="header-anchor" href="#邻接矩阵的深度优先遍历和广度优先遍历">¶</a>邻接矩阵的深度优先遍历和广度优先遍历</h3>
<p>我们知道对于图是可以用邻接矩阵进行存储的，也就是通过0和1来表示两顶点之间的关系</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659033906924.png" alt=""></p>
<p>对于上面的邻接矩阵，我们分别进行深度优先遍历和广度优先遍历</p>
<h4 id="深度优先遍历"><a class="header-anchor" href="#深度优先遍历">¶</a>深度优先遍历</h4>
<ol>
<li>我们假设从0结点开始，然后在第0行寻找值为1的位置，表示两个结点间具有边，此时有1、2、3、4、6，我们选取1结点进行深度遍历。因为要回溯，<strong>我们还需要存储前一个结点的位置</strong></li>
<li>对第1行寻找值为1且未被遍历过的位置，也就是3，回溯的结点为0</li>
<li>接下来对结点3所在行进行查找，也就是2，回溯的结点是3</li>
<li>重复上述步骤，直到所有结点都被遍历完成</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075758476.png" alt="遍历的顺序"></p>
<p>图中上面一行存储的是回溯的位置（因为第二行中所有有边的结点都已经被遍历，回溯到4结点，所以2下一个是5）</p>
<p>代码</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075956216.png" alt=""></p>
<p>邻接表的深度优先遍历代码</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659075986634.png" alt=""></p>
<h4 id="广度优先遍历"><a class="header-anchor" href="#广度优先遍历">¶</a>广度优先遍历</h4>
<ol>
<li>先对与0结点有边的进行遍历，有1、2、3、4、6</li>
<li>接着分别对1、2、3、4、6结点重复上述操作，直到所有结点都被遍历</li>
<li>最终在3结点发现其与5结点有边</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659076130788.png" alt=""></p>
<p>箭头表示从该结点出发进行遍历</p>
<p>邻接表的广度优先算法</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659509892924.png" alt=""></p>
<h2 id="最小生成树"><a class="header-anchor" href="#最小生成树">¶</a>最小生成树</h2>
<p>我们曾经提到过，<strong>一个连通图的生成树是一个极小的连通子图，它含有图中全部的结点，但只有足以构成一棵树的n-1条边（也就是说在生成树任意链接两个结点都会形成环）</strong></p>
<p><strong>我们把构造连通网的最小代价生成树（即每条边的权值和最小）称为最小生成树</strong></p>
<p><strong>下面两种算法都是求最小生成树的算法，其本质都是贪心算法，但是贪心的策略不同</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pT4y1v7Pm?spm_id_from=333.999.0.0&amp;vd_source=673ee828d0176702765d0a486b2a4554">最小生成树算法讲解</a></p>
<h3 id="普里姆-Prim-算法"><a class="header-anchor" href="#普里姆-Prim-算法">¶</a>普里姆(Prim)算法</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659100456751.png" alt="Prim算法的定义"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659101707889.png" alt=""></p>
<p>也就是说先创建一个只有初始结点的点集和空的边集，然后在找到与点集中相关的边，然后比较权值选出权最小的边，且边的另一顶点不在点集中(否则会形成环)，此时将该边加入到边集中，将另一顶点加入到点集中</p>
<p>例子如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659101404959.png" alt=""></p>
<p>对于上面这个连通图</p>
<ol>
<li>首先初始化已生成的点集为{1}，边集为空</li>
<li>找到和点集相关的边，其中17边权最小，且顶点7不在已生成边的点集中，所以将17边加入边集，顶点7加入点集，此时点集为{1,7}</li>
<li>然后重复上面的过程，和顶点1、7相邻的权最小的边是边76，顶点6不在点集中，则76边加入边集，顶点6加入点集</li>
<li>和上面一样，但是这里出现了一个问题，边16的权最小，但是由于6已经在点集中，所以边16不能加入边集，否则会形成环。所以选择边13</li>
<li>接下来就是重复上面的步骤，直至所有顶点都加入边集中</li>
</ol>
<p><strong>而代码实现，是基于邻接矩阵的</strong>，所系需要先创建邻接矩阵</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wh411o7Lc?p=5&amp;vd_source=673ee828d0176702765d0a486b2a4554">Prim算法代码讲解</a></p>
<p>下面的代码求得最小生成树的权值和</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 65537</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">float</span> MGraph[][n], <span class="keyword">int</span> v0, <span class="keyword">float</span>  sum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> lowCost[n], vSet[n];</span><br><span class="line">	<span class="keyword">int</span> v, k, min;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	{</span><br><span class="line">		lowCost[i] = MGraph[v0][i];<span class="comment">//权值赋值</span></span><br><span class="line">		vSet[i] = <span class="number">0</span>;<span class="comment">//设置为未在树中</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	v = v0;</span><br><span class="line">	vSet[v] = <span class="number">1</span>;<span class="comment">//表示v0结点已经被访问</span></span><br><span class="line">	sum = <span class="number">0</span>;<span class="comment">//初始化最小生成树的权值为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="comment">//将剩余顶点加入树中</span></span><br><span class="line">	{</span><br><span class="line">		min = INF;<span class="comment">//初始化设置一个较大的数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		{<span class="comment">//遍历树中顶点到树外顶点的权</span></span><br><span class="line">			<span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; lowCost[j] &lt; min)</span><br><span class="line">			{</span><br><span class="line">				min = lowCost[j];<span class="comment">//如果不在树中</span></span><br><span class="line">				k = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		vSet[k] = <span class="number">1</span>;<span class="comment">//设置该顶点已经在树中</span></span><br><span class="line">		v = k;</span><br><span class="line">		sum += min;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; MGraph[v][j] &lt; lowCost[j])<span class="comment">//更新未加入树顶点的权值</span></span><br><span class="line">			{</span><br><span class="line">				lowCost[j] = MGraph[v][j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在开始讲解代码之前，我们先来看一下代码中的变量，<strong>V0表示生成树的初始顶点，lowCost数组当前生成树到图中其余顶点的边的最小权值，vSet数组存储各顶点被加入生成树的状态，1表示已经加入，0表示未加入，n表示顶点个数，MGraph数组是邻接矩阵，min表示最小权值，V始终指向刚并入树中的顶点</strong>（注意：顶点到顶点自身的权值在这里设置为无穷大）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	{</span><br><span class="line">		lowCost[i] = MGraph[v0][i];<span class="comment">//权值赋值</span></span><br><span class="line">		vSet[i] = <span class="number">0</span>;<span class="comment">//设置为未在树中</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	v = v0;</span><br><span class="line">	vSet[v] = <span class="number">1</span>;<span class="comment">//表示v0结点已经被访问</span></span><br><span class="line">	sum = <span class="number">0</span>;<span class="comment">//初始化最小生成树的权值为0</span></span><br></pre></td></tr></tbody></table></figure>
<p>表示并入树的第一个顶点为V0</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659292214785.png" alt=""></p>
<p>对于图中的图最小生成树初始化如上图</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)<span class="comment">//将剩余顶点加入树中</span></span><br><span class="line">	{</span><br><span class="line">		min = INF;<span class="comment">//初始化设置一个较大的数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		{<span class="comment">//遍历树中顶点到树外顶点的权</span></span><br><span class="line">			<span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; lowCost[j] &lt; min)</span><br><span class="line">			{</span><br><span class="line">				min = lowCost[j];<span class="comment">//如果不在树中</span></span><br><span class="line">				k = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		vSet[k] = <span class="number">1</span>;<span class="comment">//设置该顶点已经在树中</span></span><br><span class="line">		v = k;</span><br><span class="line">		sum += min;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (vSet[j] == <span class="number">0</span> &amp;&amp; MGraph[v][j] &lt; lowCost[j])<span class="comment">//更新权值</span></span><br><span class="line">			{</span><br><span class="line">				lowCost[j] = MGraph[v][j];</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面就是生成最小生成树的过程</p>
<p>首先整个大循环就是对其余n-1个顶点加入生成树的过程</p>
<ol>
<li>
<p>第一个for循环：遍历当前顶点的lowCost数组，找到其中最小的权值并赋值给min（以便后续计算sum），并且标记最小权值的边的顶点（设置为已加入树中）</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659292941199.png" alt=""></p>
</li>
<li>
<p>第二个for循环：由于树的长大，当前生成树树到其余顶点的权值（lowCost数组的值）也会发生变化，需要使用此for循环进行改变，而由于存储的是最小权值，所以<strong>需要小于lowCost对应位置的值</strong>。而<strong>对于已经并入树的顶点，其权值已经进行了比较，所以只针对那些vSet值为0的顶点</strong></p>
</li>
</ol>
<h3 id="克鲁斯卡尔-Kruskal-算法"><a class="header-anchor" href="#克鲁斯卡尔-Kruskal-算法">¶</a>克鲁斯卡尔(Kruskal)算法</h3>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659102484953.png" alt="Kruskal的定义"></p>
<p><strong>Kruskal算法直接以边为目标去构建</strong>，因为权值是在边上的，直接去找最小权值的边来构建生成树是很自然的想法，<strong>不过在构建时需要判断是否会形成环</strong></p>
<p>还是以上面的连通图为例子，使用Kruskal算法进行最小生成树的构造</p>
<ol>
<li>首先先对每条边的权值进行由小到大的排序，并将每个点各自生成一个集合</li>
<li>权值2最小，我们选取6、7顶点，因为这两者不在同一集合中，不会形成环。接着将6、7顶点各自的集合合并为一个集合，也就是{6,7}。对于4、5也是同理</li>
<li>接着就是权值3，因为{6,7}集合中没有1，所以不会星辰环，合并后的集合为{1,6,7}</li>
<li>下一步为权值4，但是顶点1、6在同一集合中，所以不行</li>
<li>后面的也是同理，接着是权值为6、7的边，在这之后，集合为{1,6,7,3,2}，还有一个{4,5}</li>
<li>对于权值为8，23边显然不行，因为2、3顶点在同一集合中，所以只能是3、4边，此时加入集合的是{4,5}这一含顶点4的整个集合。所以最后结果为{1,6,7,3,2,4,5}</li>
</ol>
<p><strong>使用代码进行实现时，依旧是邻接矩阵为输入数据的</strong></p>
<h4 id="并查集"><a class="header-anchor" href="#并查集">¶</a>并查集</h4>
<p>上面所说的判断是否处于同一集合，正是并查集</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1mb4y1x7cH?spm_id_from=333.337.search-card.all.click&amp;vd_source=673ee828d0176702765d0a486b2a4554">并查集视频讲解</a></p>
<ol>
<li>并查集的初始情况</li>
</ol>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294269254.png" alt=""></p>
<p>2.找到权值最小的边并且判断一条边的两个顶点是否属于一棵树，然后将边的终点作为起点的子树</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294503426.png" alt=""></p>
<p><strong>使用代码判断两个顶点是否属于同一棵树则需要一直往其根结点找，如果两顶点所在树的根结点不同，表示不属于同一棵树</strong>，代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (p != v[p])</span><br><span class="line">	{</span><br><span class="line">		p = v[p];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3.最终效果</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294711806.png" alt=""></p>
<h4 id="代码详解与分析"><a class="header-anchor" href="#代码详解与分析">¶</a>代码详解与分析</h4>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1wh411o7Lc?p=6&amp;vd_source=673ee828d0176702765d0a486b2a4554">Kruskal算法代码讲解</a></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> a, b;<span class="comment">//a表示边的起始顶点，b表示边的终点顶点</span></span><br><span class="line">	<span class="keyword">int</span> w;<span class="comment">//边的权</span></span><br><span class="line">}Road;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 100</span></span><br><span class="line"><span class="keyword">int</span> v[<span class="number">100</span>];<span class="comment">//存储并查集的结构，在这里存储其父结点的下标</span></span><br><span class="line">Road road[maxSize];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (p != v[p])<span class="comment">//当它的父结点不是本身，往上层找到其根结点，只有根结点才会保证其存储的值和其下标相同</span></span><br><span class="line">	{</span><br><span class="line">		p = v[p];</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Road roda[], <span class="keyword">int</span> n, <span class="keyword">int</span> e, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	{</span><br><span class="line">		v[i] = i;<span class="comment">//初始化并查集数组，将数组下标赋值给下标位置处，表示每个顶点都是根结点</span></span><br><span class="line">	}</span><br><span class="line">	sort(road, e);<span class="comment">//权值排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; ++i)</span><br><span class="line">	{</span><br><span class="line">		a = Getroot(road[i].a);</span><br><span class="line">		b = Getroot(road[i].b);</span><br><span class="line">		<span class="keyword">if</span> (a != b)<span class="comment">//根结点不同，表示</span></span><br><span class="line">		{</span><br><span class="line">			v[a] = b;<span class="comment">//生成子树</span></span><br><span class="line">			sum += road[i].w;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="存储结构"><a class="header-anchor" href="#存储结构">¶</a>存储结构</h5>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294750516.png" alt=""></p>
<p>按照代码最终可得</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659294852056.png" alt=""></p>
<p>在v数组中，下标为3位置存储的值为0，<strong>表示3下标的顶点其父结点为下标为0的顶点</strong>。</p>
<h2 id="最短路径"><a class="header-anchor" href="#最短路径">¶</a>最短路径</h2>
<p><strong>对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点</strong></p>
<blockquote>
<p>最短路径：<strong>在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径</strong></p>
</blockquote>
<p>最短路径与最小生成树不同，<strong>路径上不一定包含n个顶点，也不一定包含n-1条边</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659330246464.png" alt="网图"></p>
<h3 id="迪杰斯特拉-Dijkstra-算法"><a class="header-anchor" href="#迪杰斯特拉-Dijkstra-算法">¶</a>迪杰斯特拉(Dijkstra)算法</h3>
<p><strong>适用于解决单源最短路径</strong></p>
<p>这是一个按照路径长度递增的次序产生最短路径的算法</p>
<p>下面是迪杰斯特拉算法的整个过程</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659330361377.png" alt=""></p>
<blockquote>
<p><strong>整个过程就是一步步求出他们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径</strong></p>
</blockquote>
<p>上面的图可以简化成三个步骤</p>
<ol>
<li>
<p>**初始化：**先找出从源点V0到各终点Vk的直达路径(V0,Vk)，即通过一条弧到达的路径</p>
</li>
<li>
<p>**选择：**从这些路径中找出一条长度最短的路径（V0,u）</p>
</li>
<li>
<p>**更新：**然后对其余各条路径进行适当调整，<strong>若在图中存在弧(u,Vk)，且(V0,u)+(u,Vk)&lt;(V0,Vk)，则以路径(V0,u,Vk)代替(V0,Vk)</strong></p>
<p><strong>简单点理解就是两条弧的权值之和小于原本一条弧的权值</strong></p>
</li>
<li>
<p>在调整后的各条路径中，再找长度最短的路径，以此类推</p>
</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVEX 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFINITY 65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Pathmatrix[MAXVEX];<span class="comment">//用于存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX];<span class="comment">//用于存储到各点最短路径的权值和</span></span><br><span class="line"><span class="comment">/*Dijkstra算法，求有向网G的V0顶点到其余顶点V最短路径P[v]及带权长度D[v]</span></span><br><span class="line"><span class="comment">* P[v]的值为前驱顶点下标，D[v]表示从V0到v的最短路径长度和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortPath_Dijkstra</span><span class="params">(MGraph G, <span class="keyword">int</span> v0, Pathmatrix p, ShortPathTable D)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> v, w, k, min;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">final</span>[MAXVEX];<span class="comment">//final[w]=表示求得顶点V0到Vw的最短路径</span></span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++)<span class="comment">//初始化数据</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">final</span>[v] = <span class="number">0</span>;<span class="comment">//全部顶点初始化为未知最短路径状态</span></span><br><span class="line">		D[v] = G.matrix[v0][v];<span class="comment">//将与v0有连线的顶点加上权值</span></span><br><span class="line">		p[v] = <span class="number">0</span>;<span class="comment">//初始化路径数组P为0</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	D[v0] = <span class="number">0</span>;<span class="comment">//v0到v0的路径为0</span></span><br><span class="line">	<span class="keyword">final</span>[v0] = <span class="number">1</span>;<span class="comment">//v0到v0不需要求路径</span></span><br><span class="line">	<span class="comment">//开始主循环，每次求得V0到某个v顶点的最短路径</span></span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">1</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">	{</span><br><span class="line">		min = INFINITY;<span class="comment">//当前所指离V0顶点的最近距离</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[w] &lt; min)</span><br><span class="line">			{</span><br><span class="line">				k = w;</span><br><span class="line">				min = D[w];<span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">final</span>[k] = <span class="number">1</span>;<span class="comment">//将目前找到的最近的顶点置为1</span></span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//修正当前最短路径及距离</span></span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//如果经过v顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (min + G.matrix[k][w]) &lt; D[w])</span><br><span class="line">			{</span><br><span class="line">				<span class="comment">//说明找到了更短的路径，修改D[w]和p[w]</span></span><br><span class="line">				D[w] = min + G.matrix[k][w];<span class="comment">//修改当前路径长度</span></span><br><span class="line">				p[w] = k;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结合代码和算法的步骤进行讲解</p>
<h4 id="思路和数组说明"><a class="header-anchor" href="#思路和数组说明">¶</a>思路和数组说明</h4>
<p>首先将顶点分为两组，S集合表示已求出最短路径的顶点的集合，T集合表示尚未确定最短路径的顶点集合，<strong>在代码中使用final数组存储各顶点是否被确定最短路径，值为1表示已被确定，在S集合中，0则为未被确定，在T集合中</strong>。其中我们需要保证两点：</p>
<ol>
<li>从源点V0到S中各顶点的最短路径长度都不大于从V0到T中任何顶点的最短路径长度</li>
<li>每个顶点对应一个距离值：S中顶点对应从V0到此顶点的最短路径，T中顶点对应从V0到此顶点的只包括S中顶点作中间顶点的最短路径长度</li>
</ol>
<p><strong>使用D数组存储该顶点到其他顶点的最短路径，当无法直达的时候，D的值记为无穷大，到自身的值记为0</strong>。代码中的G表示图的邻接矩阵，p数组用于存储最短路径的顶点下标，V0表示源点</p>
<h4 id="初始化"><a class="header-anchor" href="#初始化">¶</a>初始化</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; v++)<span class="comment">//初始化数据</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">final</span>[v] = <span class="number">0</span>;<span class="comment">//全部顶点初始化为未知最短路径状态</span></span><br><span class="line">		D[v] = G.matrix[v0][v];<span class="comment">//将与v0有连线的顶点加上权值</span></span><br><span class="line">		p[v] = <span class="number">0</span>;<span class="comment">//初始化路径数组P为0</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	D[v0] = <span class="number">0</span>;<span class="comment">//v0到v0的路径为0</span></span><br><span class="line">	<span class="keyword">final</span>[v0] = <span class="number">1</span>;<span class="comment">//v0到v0不需要求路径</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面这一段代码只将源点V0的final值设置为1，表示已经确定最短路径，其最短路径D的值为0（到自身）</p>
<h4 id="选择最短路径"><a class="header-anchor" href="#选择最短路径">¶</a>选择最短路径</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">min = INFINITY;<span class="comment">//当前所指离V0顶点的最近距离</span></span><br><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; D[w] &lt; min)</span><br><span class="line">	{</span><br><span class="line">		k = w;</span><br><span class="line">		min = D[w];<span class="comment">//w顶点离v0顶点更近</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">final</span>[k] = <span class="number">1</span>;<span class="comment">//将目前找到的最近的顶点置为1</span></span><br></pre></td></tr></tbody></table></figure>
<p>初始化完成后，先遍历与V0相关的邻接矩阵的权值，找到最小的权值的边，将其加入S集合中，如下图所示</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659452604497.png" alt=""></p>
<h4 id="更新"><a class="header-anchor" href="#更新">¶</a>更新</h4>
<p>因为S集合出现新的顶点，到某顶点可以直达，也可以中转，所以要更新最短路径</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//修正当前最短路径及距离</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//如果经过v顶点的路径比现在这条路径的长度短的话</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">final</span>[w] &amp;&amp; (min + G.matrix[k][w]) &lt; D[w])</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//说明找到了更短的路径，修改D[w]和p[w]</span></span><br><span class="line">		D[w] = min + G.matrix[k][w];<span class="comment">//修改当前路径长度</span></span><br><span class="line">		p[w] = k;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>以上述例子讲解，对D中的所有元素进行修改，<strong>如果该顶点未被加入S集合并且源点V0到V2顶点V的最短路径+V2顶点与V3顶点的权值要&lt;从源点直达V3顶点的权值的话，则需要修改V0与V3顶点的最短路径值D</strong>，显然这里需要，因为V0与V3无直达路径，所以V0与V3权值为无穷大。并且将k赋值给p数组中V3对应的值，<strong>表示V3顶点所在最短路径的前一个顶点是V2</strong></p>
<p>如下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659453562717.png" alt=""></p>
<h4 id="重复"><a class="header-anchor" href="#重复">¶</a>重复</h4>
<p><strong>接下来就是重复上述步骤，直至final数组中的值全为1</strong></p>
<h3 id="弗洛伊德-Floyd算法"><a class="header-anchor" href="#弗洛伊德-Floyd算法">¶</a>弗洛伊德-Floyd算法</h3>
<p><strong>适用于解决所有顶点间的最短路径</strong></p>
<p>在Dijkstra算法中，我们知道了如何计算某个顶点到其余顶点的最短路径，但有时候我们需要求得图中所有顶点到其余顶点的最短路径，此时可以进行n次Dijkstra算法，也可以采用接下来介绍的这种算法</p>
<p>算法思想：</p>
<ol>
<li>逐个顶点试探</li>
<li>从Vi到Vj的所有可能存在的路径中</li>
<li>选出一条长度最短的路径</li>
</ol>
<p>求最短路径步骤：</p>
<ol>
<li>首先画出图的邻接矩阵</li>
<li><strong>接着逐步试着在原直接路径中增加中间顶点，若加入中间顶点后路径变短，则修改之，否则维持原值。当所有顶点试探完毕，算法结束</strong></li>
</ol>
<p>整个过程如下图</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659461189305.png" alt=""></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Pathmatrix[MAXVEX][MAXVEX];<span class="comment">//用于存储中间结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="comment">//Floyd算法，求网图G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortPath_Floyd</span><span class="params">(MGraph G, Pathmatrix P, ShortPathTable D)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">int</span> v, w, k;</span><br><span class="line">	<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)<span class="comment">//初始化D与P</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//D[v][w]值即为对应点间的权值</span></span><br><span class="line">		{</span><br><span class="line">			D[v][w] = G.matrix[v][w];</span><br><span class="line">			P[v][w] = <span class="number">-1</span>;<span class="comment">//初始化P</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.numVertexes; ++k)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (D[v][w] &gt; D[v][k] + D[k][w])</span><br><span class="line">				{</span><br><span class="line">					<span class="comment">//如果经过下标为k顶点路径比原两点间路径更短</span></span><br><span class="line">					<span class="comment">//将当前两点间权值设置为更小的一个</span></span><br><span class="line">					D[v][w] = D[v][k] + D[k][w];</span><br><span class="line">					P[v][w] = k;<span class="comment">//路径设置为下标为k的顶点</span></span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="初始化-v2"><a class="header-anchor" href="#初始化-v2">¶</a>初始化</h4>
<p><strong>D数组存储的是顶点之间最短路径的值，P数组存储顶点之间的中间顶点，如果是两顶点直达，则P中的值为-1，表示没有中间顶点</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)<span class="comment">//初始化D与P</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)<span class="comment">//D[v][w]值即为对应点间的权值</span></span><br><span class="line">	{</span><br><span class="line">		D[v][w] = G.matrix[v][w];</span><br><span class="line">		P[v][w] = <span class="number">-1</span>;<span class="comment">//初始化P</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将邻接矩阵赋值到D数组进行初始化</p>
<p>将P中的值全部赋值为-1，因为开始时没有中间顶点，所以全部为-1</p>
<h4 id="遍历修改"><a class="header-anchor" href="#遍历修改">¶</a>遍历修改</h4>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.numVertexes; ++k)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.numVertexes; ++v)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.numVertexes; ++w)</span><br><span class="line">			{</span><br><span class="line">				<span class="keyword">if</span> (D[v][w] &gt; D[v][k] + D[k][w])</span><br><span class="line">				{</span><br><span class="line">					<span class="comment">//如果经过下标为k顶点路径比原两点间路径更短</span></span><br><span class="line">					<span class="comment">//将当前两点间权值设置为更小的一个</span></span><br><span class="line">					D[v][w] = D[v][k] + D[k][w];</span><br><span class="line">					P[v][w] = k;<span class="comment">//路径设置为下标为k的顶点</span></span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来的三层循环，就是不断在两顶点直达路径中加入中间顶点，然后与直达的权值进行比较，得到最小的权值。并且将P数组中对应位置的值改为中间顶点k，<strong>表示两顶点以该顶点k为中间顶点时路径长度最短</strong></p>
<h4 id="求最短路径"><a class="header-anchor" href="#求最短路径">¶</a>求最短路径</h4>
<p>经过上述过程，我们得到了P数组，其存储的是中间顶点的信息，我们可以通过P数组打印每个顶点的最短路径</p>
<p>代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPath</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> path[][MAXVEX])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (path[u][v] == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//直接输出</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">int</span> mid = path[u][v];</span><br><span class="line">	printPath(u, mid, path);</span><br><span class="line">	printPath(mid, v, path);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当path数组的值为-1，表示两顶点可以直达，也就是无中间顶点</p>
<p>u、v表示通过path数组寻找u、v顶点之间的最短路径</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659462504467.png" alt=""></p>
<p>以上图为例手动查找从顶点1到顶点0最短路径：</p>
<ol>
<li>首先看P【1】【0】位置处为3，表示10顶点之间的最短路径存在中间顶点3，1-&gt;3-&gt;0</li>
<li>首先看P【1】【3】位置处为-1，表示13顶点之间的最短路径是直达的</li>
<li>接着是P【3】【0】位置处为2，表示30顶点之间的最短路径存在中间顶点2，1-&gt;3-&gt;2-&gt;0</li>
<li>首先看P【3】【2】位置处为-1，表示32顶点之间的最短路径是直达的</li>
<li>最后P【2】【0】位置处为-1，表示20顶点之间的最短路径是直达的，此时10顶点最短路径已确定，为1-&gt;3-&gt;2-&gt;0</li>
</ol>
<p>整个过程就是递归的过程，代入代码中理解即可</p>
<h2 id="拓扑排序"><a class="header-anchor" href="#拓扑排序">¶</a>拓扑排序</h2>
<p><strong>主要针对有向无环图</strong></p>
<blockquote>
<p>有向无环图：无环的有向图，简称DAG图</p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659379228604.png" alt="有向无环图"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659379249838.png" alt="有向无环图的实际例子"></p>
<blockquote>
<p><strong>AOV网</strong>：用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以<strong>顶点表示活动，弧表示活动之间的优先制约关系，称这种有向图为顶点表示活动的网，简称AOV网</strong>。<strong>AOV网中不能存在回路</strong>，举个例子：让某个活动的开始要以自己完成作为先决条件，这显然是不可能的</p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659465238751.png" alt="AOV网"></p>
<blockquote>
<p><strong>拓扑序列</strong>：设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列V1，V2，V3……，Vn，满足若从顶点Vi到Vj有一条路径，则在顶点序列中顶点Vi必须在Vj之前，则我们成这样的顶点序列为一个拓扑序列</p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659465489274.png" alt=""></p>
<p><strong>拓扑排序其实就是对一个有向图构造拓朴序列的过程</strong>。构造时会有两种结果：</p>
<ol>
<li>此网的全部顶点都被输出，则<strong>说明它是不存在环的AOV网</strong></li>
<li>如果输出的定点少了，则<strong>说明这个网存在环，不是AOV网</strong></li>
</ol>
<h3 id="拓扑排序算法"><a class="header-anchor" href="#拓扑排序算法">¶</a>拓扑排序算法</h3>
<p>对AOV网进行拓朴排序的基本思路是：<strong>从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止</strong></p>
<p>在拓扑排序中，由于要删除顶点，<strong>所以使用邻接表更为方便</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466302538.png" alt="数据结构"></p>
<p><strong>其中in表示入度</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466327933.png" alt=""></p>
<p>对于这样的一幅图AOV网，其邻接表如下</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659466387849.png" alt=""></p>
<h3 id="拓扑排序代码实现"><a class="header-anchor" href="#拓扑排序代码实现">¶</a>拓扑排序代码实现</h3>
<p><strong>栈只是用于存储入度为0的顶点，只作为容器，也可以使用其他数据结构进行存储</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>//边表结点</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;<span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line">	<span class="keyword">int</span> weight;<span class="comment">//用于存储权值，对于非网图可以不需要</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span><span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">}EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> in;<span class="comment">//顶点入度</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//顶点域。存储顶点信息</span></span><br><span class="line">	EdgeNode* firstedge;<span class="comment">//边表头指针</span></span><br><span class="line">}VertexNode,AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	AdjList adjList;</span><br><span class="line">	<span class="keyword">int</span> numVertexes, numEdges;<span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">}qraphAdjList,*GraphAdjList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	EdgeNode* e;</span><br><span class="line">	<span class="keyword">int</span> i, k, gettop;</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">0</span>;<span class="comment">//用于栈指针下标</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用于统计输出顶点的个数</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="built_in">stack</span>;<span class="comment">//建立栈存储入度为0的顶点</span></span><br><span class="line">	<span class="built_in">stack</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">stack</span>[++top] = i;<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span> (top != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		gettop = <span class="built_in">stack</span>[top--];<span class="comment">//出栈</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d -&gt;"</span>, GL-&gt;adjList[gettop].data);</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge;e; e = e-&gt;next)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//对此顶点弧表遍历</span></span><br><span class="line">			k = e-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))<span class="comment">//将k号顶点邻接点的入度减1</span></span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">stack</span>[++top] = k;<span class="comment">//若为0则入栈，以便于下次循环输出</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (count &lt; GL-&gt;numVertexes)<span class="comment">//如果count小于顶点数，说明存在环</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们以上面的AOV网为例，跟着代码走一遍</p>
<p>​	1.首先初始化一些数据</p>
<p>​	2.然后将入度为0的顶点入栈</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">stack</span>[++top] = i;<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此时stack应该为{0,1,3}</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659507694259.png" alt=""></p>
<p>​	3.while循环，当栈中有数据元素时，始终寻呼那</p>
<p>​	4.接下来V3出栈，gettop=3，然后count+1表示输出顶点个数+1</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gettop = <span class="built_in">stack</span>[top--];<span class="comment">//出栈</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d -&gt;"</span>, GL-&gt;adjList[gettop].data);</span><br><span class="line">count++;</span><br></pre></td></tr></tbody></table></figure>
<p>​	5.然后<strong>对V3顶点对应的弧链表进行遍历</strong>，找到V3连接的两个顶点V2和V13，<strong>并且将他们的入度减少一位</strong>，此时V2和V13的in值都为1.<strong>他的目的是为了将V3顶点上的弧删除</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//对此顶点弧表遍历</span></span><br><span class="line">		k = e-&gt;adjvex;</span><br><span class="line">		<span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))<span class="comment">//将k号顶点邻接点的入度减1</span></span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">stack</span>[++top] = k;<span class="comment">//若为0则入栈，以便于下次循环输出</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659508159107.png" alt=""></p>
<p>6.再次循环，此时处理的是V1顶点。经过出栈、打印、count=2后，我们对V1到V2、V4、V8的弧进行遍历。并同样减少了它们的入度数，<strong>此时V2的入度为0</strong>，由if语句判断入度是否为0，<strong>V2入栈</strong>。<strong>如果没有在顶点表中加入in这个入度数据域，if的判断则必须是循环（循环遍历找到入度为0的结点），这显然是要消耗时间的</strong>。而引入in数据域是利用空间换取了时间</p>
<p>7.接下来就是重复上述步骤</p>
<p>8.<strong>最终拓扑排序打印结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;7-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11</strong>，<strong>当然这结果并不是唯一的一种拓扑排序方案</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659508786474.png" alt=""></p>
<h3 id="逆拓扑排序"><a class="header-anchor" href="#逆拓扑排序">¶</a>逆拓扑排序</h3>
<p>逆拓扑排序类似拓扑排序，<strong>不过将入度改为出度</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659509341995.png" alt=""></p>
<p><strong>可以使用深度优先遍历来进行逆拓扑排序</strong>，也可以修改拓扑排序的代码进行逆拓扑排序</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659536020777.png" alt=""></p>
<p>对上图进行深搜，先从0开始，接下来是1顶点，由于1顶点有后继顶点，继续进行，访问顶点3，而顶点3无后继顶点，<strong>也就是出度为0</strong>，输出顶点3，<strong>并且删除边13和23</strong>，按照深搜此时需要回溯到顶点1，<strong>由于删除了边13，所以1的出度为0</strong>，符合出度为0的顶点，输出顶点1，<strong>并且删除边01</strong>，按照深搜，接下来访问2顶点，<strong>2顶点出度为0</strong>，输出顶点2，最后输出顶点0。<strong>上述过程中每次访问顶点都需要修改visit数组中的值为1，表示已经访问</strong></p>
<p>同时，我们也可以在访问的时候入栈，输出时（即出度为0时）出栈</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659537159826.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659537180219.png" alt=""></p>
<p>逆拓扑排序：3-&gt;1-&gt;2-&gt;0</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span>  v, AGraph* G)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	visit[v] = <span class="number">1</span>;</span><br><span class="line">	ArcNode* q = G-&gt;adjList[v].first;</span><br><span class="line">	<span class="keyword">while</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (visit[q-&gt;adjV] == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			DFS(q-&gt;adjV, G);</span><br><span class="line">		}</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="关键路径"><a class="header-anchor" href="#关键路径">¶</a>关键路径</h2>
<p><strong>主要针对有向无环图</strong></p>
<p>拓扑排序主要是为了解决一个工程能否顺序进行的问题，但有时我们还需要解决工程完成需要的最短时间问题</p>
<p><strong>因此我们如果要对一个流程图获得最短时间，就必须要分析它们的拓扑关系，比能找到当中的关键路径，这个流程的时间就是最短时间</strong></p>
<blockquote>
<p><strong>AOE网:在表示一个工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网</strong>，其中，<strong>没有出边的顶点称为终点或汇点，没有入边的顶点称之为始点或源点</strong></p>
</blockquote>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538233859.png" alt=""></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538411703.png" alt="AOE网的特点"></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659538440517.png" alt=""></p>
<blockquote>
<p><strong>我们把路径上各个活动所持续的是简直和称为路径长度，从源点到汇点足有最大长度的路径叫关键路径</strong></p>
</blockquote>
<p>在上图的AOE网中，开始-&gt;发动机完成-&gt;部件集中到位-&gt;组装完成就是关键路径，路径长度为5.5</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659539034196.png" alt="关键路径的应用"></p>
<h3 id="关键路径算法原理"><a class="header-anchor" href="#关键路径算法原理">¶</a>关键路径算法原理</h3>
<p>关键路径实例理解</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659549838521.png" alt=""></p>
<blockquote>
<p>也就是说，<strong>我们只需要找到所有活动的最早开始时间和最晚开始时间，并且比较他们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。否则不是</strong></p>
</blockquote>
<p>所以我们需要定义如下几个参数</p>
<blockquote>
<p><strong>事件既可以表示前一个活动的结束，也可以用于表示下一个活动的开始</strong>，如下图，V2既可以表示a1活动的结束，也可以表示a2活动的开始，而只有a1活动完成后a2活动才能开始，所以a2的最早开始事件（也就是V2事件最早发生时间）的值为30</p>
</blockquote>
<ol>
<li>事件的最早发生时间etv(earlist time of vertex)：即顶点Vk的最早发生时间</li>
<li>事件的最晚发生时间ltv(latesttime of vertex)：即顶点Vk的最晚发生时间，<strong>也就是每个顶点对应的事件最晚需要开始的事件</strong>，超出此事件将会延误整个工期</li>
<li>活动的最早开工时间ete(earlist time of edge)：即弧ak的最早发生时间</li>
<li>活动的最晚开工时间lte(latest time of edge)：即弧ak的最晚发生时间，也就是不推迟工期的最晚开工时间</li>
</ol>
<p><strong>我们是由1和2可以求得3和4，然后再根据ete[k]是否与lte[k]相等来判断ak是否为关键活动</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723716756.png" alt=""></p>
<h3 id="关键路径算法"><a class="header-anchor" href="#关键路径算法">¶</a>关键路径算法</h3>
<p>关于过程，可以看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1nJ411V7bd?p=136&amp;spm_id_from=pageDriver&amp;vd_source=673ee828d0176702765d0a486b2a4554">关键路径讲解</a></p>
<p>将下图的AOE网转化为邻接表的结构图，与拓扑排序时邻接表结构不同的地方在于，<strong>这里的弧链表增加了weight域，用于存储弧的权值</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659550444650.png" alt=""></p>
<p><strong>求事件的最早发生时间，也就是顶点的先后次序，就是我们从头到尾找拓扑序列的过程</strong>。因此在求关键路径之前，需要先调用依次拓扑序列算法的代码来计算etv和拓扑排序列表</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>//边表结点</span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;<span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line">	<span class="keyword">int</span> weight;<span class="comment">//用于存储权值，对于非网图可以不需要</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span><span class="comment">//链域，指向下一个邻接点</span></span><br><span class="line">}EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	<span class="keyword">int</span> in;<span class="comment">//顶点入度</span></span><br><span class="line">	<span class="keyword">int</span> data;<span class="comment">//顶点域。存储顶点信息</span></span><br><span class="line">	EdgeNode* firstedge;<span class="comment">//边表头指针</span></span><br><span class="line">}VertexNode,AdjList[MAXVEX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">	AdjList adjList;</span><br><span class="line">	<span class="keyword">int</span> numVertexes, numEdges;<span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">}qraphAdjList,*GraphAdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* etv, * ltv;<span class="comment">//事件最早发生时间和最迟发生时间</span></span><br><span class="line"><span class="keyword">int</span>* stack2;<span class="comment">//用于存储拓扑序列的栈</span></span><br><span class="line"><span class="keyword">int</span> top2;<span class="comment">//用于stack2的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopologicalSort</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	EdgeNode* e;</span><br><span class="line">	<span class="keyword">int</span> i, k, gettop;</span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">0</span>;<span class="comment">//用于栈指针下标</span></span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用于统计输出顶点的个数</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="built_in">stack</span>;<span class="comment">//建立栈存储入度为0的顶点</span></span><br><span class="line">	<span class="built_in">stack</span> = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (GL-&gt;adjList[i].in == <span class="number">0</span>)</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">stack</span>[++top] = i;<span class="comment">//将入度为0的顶点入栈</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	top2 = <span class="number">0</span>;<span class="comment">//初始化栈指针为0</span></span><br><span class="line">	etv = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//事件最早发生时间</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">	{</span><br><span class="line">		etv[i] = <span class="number">0</span>;<span class="comment">//初始化为0</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	stack2 = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//初始话</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (top != <span class="number">0</span>)</span><br><span class="line">	{</span><br><span class="line">		gettop = <span class="built_in">stack</span>[top--];<span class="comment">//出栈</span></span><br><span class="line">		count++;</span><br><span class="line">		stack2[++top2] = gettop;<span class="comment">//将弹出的顶点序号压入拓扑序列的栈</span></span><br><span class="line">		<span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//对此顶点弧表遍历</span></span><br><span class="line">			k = e-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span> (!(--GL-&gt;adjList[k].in))<span class="comment">//将k号顶点邻接点的入度减1</span></span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">stack</span>[++top] = k;<span class="comment">//若为0则入栈，以便于下次循环输出</span></span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> ((etv[gettop] + e-&gt;weight &gt; etv[k]))<span class="comment">//求各顶点事件最早发生时间</span></span><br><span class="line">			{</span><br><span class="line">				etv[k] = etv[gettop] + e-&gt;weight;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (count &lt; GL-&gt;numVertexes)<span class="comment">//如果count小于顶点数，说明存在环</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码和拓扑排序算法差不多，就是加了一些代码，在讲解这些代码之前，我们先来看看<strong>如何计算事件的最早发生时间</strong>，也就是etv的值(边是活动，顶点表示事件的开始和结束)。</p>
<p>事件的最早发生时间就是前一事件最早发生时间+活动持续时间的最大值——<strong>从源点开始</strong></p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659715674738.png" alt=""></p>
<p>这是因为需要同时满足四个条件才能到达图中的Vj，所以需要取最大值88，所以V觉得最早发生时间为0+88=88。</p>
<p><strong>事件的最晚发生时间计算</strong>：(后一事件的最晚发生时间-活动持续时间)的最小值</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723458435.png" alt=""></p>
<p>因为要保证最后一定保证这四个都完成，所以最晚从3开始</p>
<p><strong>活动的最早发生时间</strong>：活动的最早发生时间就是事件的最早发生事件</p>
<p><strong>活动的最晚发生时间</strong>：活动的最晚发生时间（边）就是事件的最晚发生时间减去活动的持续时间。</p>
<p><img src="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1659723857157.png" alt="关键路径求解步骤"></p>
<p>求关键路径的算法代码</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CriticalPath</span><span class="params">(GraphAdjList GL)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	EdgeNode* e;</span><br><span class="line">	<span class="keyword">int</span> i, gettop, k, j;</span><br><span class="line">	<span class="keyword">int</span> ete, lte;<span class="comment">//声明活动最早发生时间和最迟发生时间变量</span></span><br><span class="line">	TopologicalSort(GL);<span class="comment">//求拓扑序列，计算数组etv的stack2的值</span></span><br><span class="line">	ltv = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//事件最晚发生时间</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; GL-&gt;numVertexes; ++i)</span><br><span class="line">	{</span><br><span class="line">		ltv[i] = etv[GL-&gt;numVertexes - <span class="number">1</span>];<span class="comment">//初始化ltv</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">while</span> (top2 != <span class="number">0</span>)<span class="comment">//计算ltv</span></span><br><span class="line">	{</span><br><span class="line">		gettop = stack2[top2--];<span class="comment">//将拓扑序列出栈，后进先出</span></span><br><span class="line">		<span class="keyword">for</span> (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next)</span><br><span class="line">		{</span><br><span class="line">			<span class="comment">//求各顶点事件的最迟发生时间ltv值</span></span><br><span class="line">			k = e-&gt;adjvex;</span><br><span class="line">			<span class="keyword">if</span> (ltv[k] - e-&gt;weight &lt; ltv[gettop])</span><br><span class="line">			{</span><br><span class="line">				ltv[gettop] = ltv[k] - e-&gt;weight;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; GL-&gt;numVertexes; ++j)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">for</span> (e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next)</span><br><span class="line">		{</span><br><span class="line">			k = e-&gt;adjvex;</span><br><span class="line">			ete = etv[j];<span class="comment">//活动最早发生时间</span></span><br><span class="line">			lte = ltv[k] - e-&gt;weight;<span class="comment">//活动最迟发生时间</span></span><br><span class="line">			<span class="keyword">if</span> (ete == lte)<span class="comment">//两者相等即在关键路径上</span></span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"&lt;v%d,v%d&gt;length:%d,"</span>, GL-&gt;adjList[j].data, GL-&gt;adjList[k].data, e-&gt;weight);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="查找-v2"><a class="header-anchor" href="#查找-v2">¶</a>查找</h1>
<h1 id="排序-v2"><a class="header-anchor" href="#排序-v2">¶</a>排序</h1>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/18/TLS%E5%92%8Cmain%E5%89%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/" rel="prev" title="TLS和main前的初始化">
                  <i class="fa fa-chevron-left"></i> TLS和main前的初始化
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/09/JAVA%E5%AD%A6%E4%B9%A0/" rel="next" title="JAVA学习">
                  JAVA学习 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">489k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:25</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






<script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"GhjDb9gbtgwnrtsySW3fcGac-MdYXbMMI","appKey":"0Qw5kecTryGX5eSrEvShaWPw","serverURLs":"https://ghjdb9gb.api.lncldglobal.com","placeholder":"Just go go","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":"false# Article reading statistic","comment_count":true,"recordIP":true,"enableQQ":true,"requiredFields":[],"el":"#valine-comments","path":"/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
