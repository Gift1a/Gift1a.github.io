<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="打印PE文件头部和节区信息#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;malloc.h&gt; #include&lt;Windows.h&gt;  &#x2F;&#x2F;宏定义，方便后续使用  &#x2F;&#x2F;定义变量 IMAGE_DOS_HEADER myDOS; LONG elf_">
<meta property="og:type" content="article">
<meta property="og:title" content="PE解析代码实现">
<meta property="og:url" content="https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Welcome">
<meta property="og:description" content="打印PE文件头部和节区信息#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;malloc.h&gt; #include&lt;Windows.h&gt;  &#x2F;&#x2F;宏定义，方便后续使用  &#x2F;&#x2F;定义变量 IMAGE_DOS_HEADER myDOS; LONG elf_">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-11T05:19:10.000Z">
<meta property="article:modified_time" content="2022-04-08T08:44:01.359Z">
<meta property="article:author" content="Gift1a">
<meta property="article:tag" content="PE">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","path":"2022/03/11/PE解析代码实现/","title":"PE解析代码实现"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PE解析代码实现 | Welcome</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Welcome" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Welcome</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">勿在浮沙建高塔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8D%B0PE%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E5%92%8C%E8%8A%82%E5%8C%BA%E4%BF%A1%E6%81%AF"><span class="nav-number">1.</span> <span class="nav-text">打印PE文件头部和节区信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RVA%E8%BD%ACFOA"><span class="nav-number">2.</span> <span class="nav-text">RVA转FOA</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PE%E6%8F%92%E5%85%A5shellcode"><span class="nav-number">3.</span> <span class="nav-text">PE插入shellcode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PE%E6%96%87%E4%BB%B6%E6%96%B0%E5%A2%9E%E8%8A%82"><span class="nav-number">4.</span> <span class="nav-text">PE文件新增节</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E5%AF%BC%E5%87%BA%E8%A1%A8%E4%BF%A1%E6%81%AF-%E6%8C%89%E5%90%8D%E7%A7%B0%E5%AF%BC%E5%87%BA"><span class="nav-number">5.</span> <span class="nav-text">打印导出表信息-按名称导出</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Gift1a" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Gift1a" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2973414642@qq.com" title="E-Mail → mailto:2973414642@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://1.12.239.117:8090/" title="http:&#x2F;&#x2F;1.12.239.117:8090&#x2F;" rel="noopener" target="_blank">Fallwind</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/03/11/PE%E8%A7%A3%E6%9E%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Welcome">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="PE解析代码实现 | Welcome">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PE解析代码实现
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-11 13:19:10" itemprop="dateCreated datePublished" datetime="2022-03-11T13:19:10+08:00">2022-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 16:44:01" itemprop="dateModified" datetime="2022-04-08T16:44:01+08:00">2022-04-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="打印PE文件头部和节区信息"><a href="#打印PE文件头部和节区信息" class="headerlink" title="打印PE文件头部和节区信息"></a>打印PE文件头部和节区信息</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;malloc.h&gt;
#include&lt;Windows.h&gt;

//宏定义，方便后续使用

//定义变量
IMAGE_DOS_HEADER myDOS;
LONG elf_new;
IMAGE_NT_HEADERS32 myNTheader;
IMAGE_OPTIONAL_HEADER32 myOPTIONheader;
IMAGE_SECTION_HEADER mysection[100];

int NUM_SECTION;

int main()
{
	FILE* pfile;
	pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");//打开文件
	fseek(pfile, 0, SEEK_SET);//参数说明，将fp指针从文件开头移动到0的位置
	fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);//表示从fp开始的地方读取一次长度为sizeof(IMAGE_DOS_HEADER)的字节，存储到myDOS中
	//DOS
	printf("==============IMAGE_DOS_HEADER==============\n");
	printf("DOS头：          %08X\n", myDOS.e_magic);
	printf("NT头所在位置：   %08X\n", myDOS.e_lfanew);
	elf_new = myDOS.e_lfanew;//将NT头的偏移存储起来

	//NT头
	fseek(pfile, elf_new, SEEK_SET);//注意不是sizeof(elf_new)
	fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS), 1, pfile);
	printf("==============IMAGE_NT_HEADERS==============\n");
	//打印PE标志
	printf("PE标志：         %08X\n", myNTheader.Signature);

	//打印标准PE头信息
	printf("==============IMAGE_FILE_HEADERS==============\n");
	printf("节区数量：       %08X\n", myNTheader.FileHeader.NumberOfSections);
	NUM_SECTION = myNTheader.FileHeader.NumberOfSections;
	printf("可选PE头大小：   %08X\n", myNTheader.FileHeader.SizeOfOptionalHeader);
	//打印ASLR的信息，方便查看和修改
	printf("ASLR属性：       %08X\n", (myNTheader.FileHeader.Characteristics ) &amp; 1);

	//打印可选PE头信息
	printf("==============IMAGE_OPTIONAL_HEADERS==============\n");
	fseek(pfile, elf_new+sizeof(IMAGE_FILE_HEADER)+sizeof(myNTheader.Signature), SEEK_SET);//因为标准PE头长度为20
	fread(&amp;myOPTIONheader, sizeof(IMAGE_OPTIONAL_HEADER), 1, pfile);
	printf("DWORD AddressOfEntryPoint：   %08llX\n", myOPTIONheader.AddressOfEntryPoint);
	printf("基址：				%08X\n", myOPTIONheader.ImageBase);//注意这里的可选PE头类型必须是IMAGE_OPTIONAL_HEADER32
	printf("文件对齐大小：		%08X\n", myOPTIONheader.FileAlignment);
	printf("内存对齐大小：		%08X\n", myOPTIONheader.SectionAlignment);
	printf("文件头和节表大小：  %08X\n", myOPTIONheader.SizeOfHeaders);
	printf("内存拉伸大小：		%08X\n", myOPTIONheader.SizeOfImage);

	//打印节表信息，前面我们已经存储了节表数量了
	printf("==============IMAGE_SECTION_HEADER SectionHeaders==============\n");
	fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);
	fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);
	for (int i = 0; i &lt; NUM_SECTION; ++i)
	{
		printf("NAME：        %s\n", mysection[i].Name);
		printf("DWORD VirtualAddress：        %08X\n", mysection[i].VirtualAddress);
		printf("DWORD SizeOfRawData：        %08X\n", mysection[i].SizeOfRawData);
		printf("DWORD PointerToRawData：        %08X\n", mysection[i].PointerToRawData);
		printf("DWORD VirtualSize：        %08X\n", mysection[i].Misc.VirtualSize);
	}
	fclose(pfile);//关闭文件
	return 0;
}</code></pre>

<h1 id="RVA转FOA"><a href="#RVA转FOA" class="headerlink" title="RVA转FOA"></a>RVA转FOA</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
/*
* RVA转FOA的思路
* 1、先判断所在节区，设计思路：首先我们必须拿的是内存对齐后的来比较大小，先把RVA-virtualaddress，再和max(MISC,SizeofRawData)按照内存对齐的值作比较
* 2、循环判断节区
* 3、计算FOA，偏移是一样的，那就是RVA-virtualaddress+节区的PointerOfdata
*/
IMAGE_NT_HEADERS32 myNTheader;
IMAGE_DOS_HEADER myDOS;//因为PE头长度不变，所以我们只需要找到elf_new的内容就可以知道节区的起始地址
IMAGE_SECTION_HEADER mysection[10];
int NUM_SECTION;//我们还需要知道节区的数量
int elf_new;
int RVA = 0x20d000;
long long MAX(DWORD a, DWORD b)
{//计算MISC和SizeOFRAWDATA，并返回按照内存对齐后的值
	if (a &gt; b)
	{
		return (a%myNTheader.OptionalHeader.SectionAlignment)?((a / myNTheader.OptionalHeader.SectionAlignment)+1) * myNTheader.OptionalHeader.SectionAlignment : ((a / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;
	}
	else
		return (b % myNTheader.OptionalHeader.SectionAlignment) ? ((b / myNTheader.OptionalHeader.SectionAlignment) + 1) * myNTheader.OptionalHeader.SectionAlignment : ((b / myNTheader.OptionalHeader.SectionAlignment)) * myNTheader.OptionalHeader.SectionAlignment;;
}
int main()
{
	FILE* pfile;
	pfile = fopen("D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe", "r");
	fseek(pfile,0, SEEK_SET);
	fread(&amp;myDOS, sizeof(IMAGE_DOS_HEADER), 1, pfile);
	elf_new = myDOS.e_lfanew;
	fseek(pfile, elf_new, SEEK_SET);
	fread(&amp;myNTheader, sizeof(IMAGE_NT_HEADERS32), 1, pfile);
	NUM_SECTION = myNTheader.FileHeader.NumberOfSections;
	
	//得到节区
	fseek(pfile, elf_new + sizeof(IMAGE_NT_HEADERS32), SEEK_SET);
	fread(&amp;mysection, sizeof(IMAGE_SECTION_HEADER) * NUM_SECTION, 1, pfile);
	for (int i = 0; i &lt; NUM_SECTION; ++i)
	{
		if (RVA - mysection[i].VirtualAddress &lt; MAX(mysection[i].Misc.VirtualSize, mysection[i].SizeOfRawData))
		{
			printf("所在节区为：%s\n", mysection[i].Name);
			printf("FOA为：%08X", RVA - mysection[i].VirtualAddress + mysection[i].PointerToRawData);
		}
	}
	fclose(pfile);
	return 0;
}</code></pre>

<h1 id="PE插入shellcode"><a href="#PE插入shellcode" class="headerlink" title="PE插入shellcode"></a>PE插入shellcode</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;Windows.h&gt;
#include&lt;malloc.h&gt;
#include&lt;stdlib.h&gt;

#define MessageBoxA_ADDR 0x76C20F40//MessageBoxA的地址
#define shellcode_len 0x12//定义shellcode的长度
//输入路径和输出路径
char file_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe";
char final_path[] = "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\5.exe";

//插入的shellcode
BYTE shellcode[] = {
	0x6A,0x00,0x6A,0x00,0x6A,0x00,0x6A,0x00,
	0xE8,0x00,0x00,0x00,0x00,
	0xE9,0x00,0x00,0x00,0x00
};
int LoadPE(LPVOID*pFileBuffer)//二级指针存储的是一级指针的地址
{
	FILE* pfile;
	DWORD FileSize = 0;
	LPVOID pTempBuffer;
	pfile = fopen(file_path, "rb");
	//通过fseek和ftell返回文件长度，fseek将fp指针设置在文件尾，ftell获取当前fp指针的位置与文件首的偏移
	fseek(pfile, 0, SEEK_END);
	FileSize = ftell(pfile);

	//重新设置回开头
	fseek(pfile, 0, SEEK_SET);
	//开辟空间，malloc函数返回开辟空间的起始地址
	pTempBuffer = malloc(FileSize);

	//将文件中的内容读取到临时Buffer中
	fread(pTempBuffer, FileSize, 1, pfile);

	//将分配返回的地址存储到FileBuffer中
	*pFileBuffer = pTempBuffer;
	//temp指针指向空
	pTempBuffer = NULL;
	fclose(pfile);
	return FileSize;
}

int CopyFileBufferToImageBuffer(LPVOID pFileBuffer,LPVOID* pImageBuffer)//pImageBuffer是void类型指针，指向的是读取到内存中的文件内容首地址
{
	//初始化PE结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	//初始化tempBuffer
	LPVOID pTempBuffer = NULL;
	//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息
	pDOSHeader = PIMAGE_DOS_HEADER(pFileBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pFileBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);
	
	//分配ImageBuffer内存
	pTempBuffer = malloc(pOptionalHeader-&gt;SizeOfImage);
	//初始化ImageBuffer内存
	memset(pTempBuffer, 0, pOptionalHeader-&gt;SizeOfImage);
	//拷贝数据
	memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);//参数说明，目标数据、被使用数据，长度
	
	//循环拷贝节表信息
	PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;
	for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++,pTempSectionHeader++)
	{
		//因为memcpy只接受void类型的指针，所以要先强制转换
		memcpy((void*)((DWORD)pTempBuffer + pTempSectionHeader-&gt;VirtualAddress), (void*)((DWORD)pFileBuffer + pTempSectionHeader-&gt;PointerToRawData), pTempSectionHeader-&gt;SizeOfRawData);
	}
	//赋值给pImageBuffer
	*pImageBuffer = pTempBuffer;
	pTempBuffer = NULL;
	return pOptionalHeader-&gt;SizeOfImage;
}

int CopyImageBufferToNewBuffer(LPVOID pImageBuffer,LPVOID* pNewBuffer)
{
	//初始化PE结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	//初始化TempBuffer
	LPVOID pTempBuffer = NULL;

	//结构体强制转换
	pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);

	//计算NewBuffer大小
	DWORD new_buffer_size = pOptionalHeader-&gt;SizeOfHeaders;
	//节表大小计算
	PIMAGE_SECTION_HEADER pTempSectionHeader = pSectionHeader;
	//注意这里要使用临时变量，否则循环的时候，结构体指针后移，指向改变
	for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, pTempSectionHeader++)
	{
		new_buffer_size += pTempSectionHeader-&gt;SizeOfRawData;
		//printf("%X\n", pSectionHeader-&gt;SizeOfRawData);
	}
	printf("%X\n", new_buffer_size);
	//开辟空间并且设置为0
	pTempBuffer = malloc(new_buffer_size);
	memset(pTempBuffer, 0, new_buffer_size);
	//复制ImageBuffer信息
	memcpy(pTempBuffer, pDOSHeader, pOptionalHeader-&gt;SizeOfHeaders);
	//复制节表信息
	pTempSectionHeader = pSectionHeader;
	for (int i = 0; i &lt; pFileHeader-&gt;NumberOfSections; i++, ++pTempSectionHeader)
	{
		//因为memcpy只接受void类型的指针，所以要先强制转换
		memcpy((PWORD)((DWORD)pTempBuffer + pTempSectionHeader-&gt;PointerToRawData), (PWORD)((DWORD)pImageBuffer + pTempSectionHeader-&gt;VirtualAddress), pTempSectionHeader-&gt;SizeOfRawData);
	}
	//赋值给pImageBuffer
	*pNewBuffer = pTempBuffer;
	pTempBuffer = NULL;
	return new_buffer_size;
}
void newbuffer_write2_exe(PVOID NewFileBuffer, DWORD FileSize, char* FilePath)
{
	FILE* fp1 = fopen(FilePath, "wb");
	if (fp1 != NULL)
	{
		fwrite(NewFileBuffer, FileSize, 1, fp1);
		printf("成功存盘");
	}
	fclose(fp1);
	return ;

}
void ADD_Opcode(LPVOID pImageBuffer, LPVOID* pNewBuffer)
{
	//初始化PE结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS pNTHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	//通过强制转换类型来限制长度,转为Dos头的指针那么得到的就是Dos头的信息
	pDOSHeader = PIMAGE_DOS_HEADER(pImageBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pImageBuffer + pDOSHeader-&gt;e_lfanew);//因为void类型的指针不能直接运算，所以将其转为int整型，再做加减得到其他地址
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + IMAGE_SIZEOF_FILE_HEADER);
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);
	//判断能否插入
	if (shellcode_len &gt; pSectionHeader-&gt;SizeOfRawData - pSectionHeader-&gt;Misc.VirtualSize)
	{
		printf("长度不足，无法插入\n");
		free(pImageBuffer);
	}

	//计算空白位置，转为char*指针
	PBYTE code_begin = (PBYTE)((DWORD)pImageBuffer + pSectionHeader-&gt;VirtualAddress+ pSectionHeader-&gt;Misc.VirtualSize);
	//插入shellcode
	memcpy(code_begin, shellcode, shellcode_len);
	//计算E8地址
	DWORD callADDr = (MessageBoxA_ADDR - (pOptionalHeader-&gt;ImageBase + pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;Misc.VirtualSize + 0xD));
	//将callADDR插入到E8之后,填充数据
	*(PDWORD)((DWORD)code_begin + 0x09) = callADDr;

	//计算jmp地址,跳转的值=真实地址-下一条指令地址
	DWORD jmpADDr = pOptionalHeader-&gt;ImageBase + pOptionalHeader-&gt;AddressOfEntryPoint - ((DWORD)code_begin + pOptionalHeader-&gt;ImageBase + shellcode_len-(DWORD)pImageBuffer);
	*(PDWORD)((code_begin + 14)) = jmpADDr;

	//修改OEP
	pOptionalHeader-&gt;AddressOfEntryPoint = ((DWORD)code_begin - (DWORD)pImageBuffer);//也可以使用VirtualAddress+VirtualSize

	//还原为NewBuffer
	DWORD ret2=CopyImageBufferToNewBuffer(pImageBuffer, pNewBuffer);
	
	//存盘
	newbuffer_write2_exe(*pNewBuffer,ret2, final_path);
	return ;
}
void operate_pe()
{
	LPVOID pFileBuffer = NULL;//LPVOID相当于void*
	LPVOID pNewBuffer = NULL;
	LPVOID pImageBuffer = NULL;
	//读取文件内容到FileBuffer中d
	DWORD file_size = LoadPE(&amp;pFileBuffer);//二级指针void**,将存储指针的地址传过去
	printf("文件长度为：  %08X\n", file_size);

	//将FileBuffer拉伸为ImageBuffer
	DWORD Image_Size = CopyFileBufferToImageBuffer(pFileBuffer,&amp;pImageBuffer);
	printf("拉伸后的大小为：  %08X\n",Image_Size);

	//添加opcode
	ADD_Opcode(pImageBuffer, &amp;pNewBuffer);

	//开辟的内存需要free掉
	free(pFileBuffer);
	free(pNewBuffer);
	free(pImageBuffer);
	return;
}
int main()
{
	operate_pe();
	return 0;
}</code></pre>

<h1 id="PE文件新增节"><a href="#PE文件新增节" class="headerlink" title="PE文件新增节"></a>PE文件新增节</h1><pre class="language-c" data-language="c"><code class="language-c">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;windows.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;malloc.h&gt;


/*
思路：
1、读取文件信息到buffer中
判断节区信息够不够大小，两个节表的大小
2、找到节区的最后位置，开辟指定大小的空间
3、修改信息-NumberOfSection、SizeOfRawData、VirtualSize（注意要对齐）
*/
#define New_Buffer_Size 0x1000
#define File_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\notepad++.exe"
#define Final_Path "D:\\new\\Notepadx32\\Notepad++.7.6.1.bin.x32\\Notepad++.7.6.1.bin.x32\\6++.exe"
int Open_File(LPVOID *pFileBuffer)
{
	FILE* pfile = NULL;
	
	LPVOID TempBuffer = NULL;
	pfile = fopen(File_Path, "rb");
	fseek(pfile, 0, SEEK_END);
	DWORD file_size = ftell(pfile);
	//设置文件指针到文件头
	fseek(pfile, 0, SEEK_SET);
	TempBuffer = malloc(file_size);
	fread(TempBuffer , file_size, 1, pfile);
	
	*pFileBuffer = TempBuffer;
	TempBuffer = NULL;
	fclose(pfile);
	return file_size;
}
int Add_Section(LPVOID FileBuffer, LPVOID* pNewBuffer,DWORD file_size)
{
	//定义结构体指针
	PIMAGE_DOS_HEADER pDOSHeader = NULL;
	PIMAGE_NT_HEADERS32 pNTHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSection = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PVOID pNewTempBuffer = NULL;
	DWORD New_File_Size = 0;
	
	
	//新增节
	New_File_Size = file_size + 0x1000;
	pNewTempBuffer = (PVOID)malloc(New_File_Size);
	// 判断开辟空间是否成功
	if (!pNewTempBuffer)
	{
		printf("pNewTempBuffer开辟空间失败!\n");
		return 0;
	}
	// 初始化内存
	memset(pNewTempBuffer, 0, New_File_Size);
	// 将旧空间的内容copy到新的空间
	memcpy(pNewTempBuffer, FileBuffer, file_size);

	//读取信息
	pDOSHeader = (PIMAGE_DOS_HEADER)(pNewTempBuffer);
	pNTHeader = (PIMAGE_NT_HEADERS32)((DWORD)pNewTempBuffer + pDOSHeader-&gt;e_lfanew);
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNTHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));
	pSection = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));

	//找到节表的最后位置
	PIMAGE_SECTION_HEADER pfinal_Section = &amp;(pSection[pFileHeader-&gt;NumberOfSections - 1]);

	//判断能否插入节表,因为在文件和内存中PE头和DOS头大小不变，直接计算即可
	DWORD remain_size = (pOptionalHeader-&gt;SizeOfHeaders - pDOSHeader-&gt;e_lfanew - 4 - sizeof(IMAGE_FILE_HEADER) - sizeof(IMAGE_OPTIONAL_HEADER32) - sizeof(IMAGE_SECTION_HEADER) * pFileHeader-&gt;NumberOfSections);
	if (remain_size &lt; 2 * sizeof(IMAGE_SECTION_HEADER))
	{
		printf("位置不够捏，想想其他办法吧~\n");
	}
	

	//修改信息
	// 初始化新增节信息
	PVOID pSecName = &amp;pSection[pFileHeader-&gt;NumberOfSections].Name;
	PDWORD pSecMisc = &amp;pSection[pFileHeader-&gt;NumberOfSections].Misc.VirtualSize;
	PDWORD pSecVirtualAddress = &amp;pSection[pFileHeader-&gt;NumberOfSections].VirtualAddress;
	PDWORD pSecSizeofRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].SizeOfRawData;
	PDWORD pSecPointerToRawData = &amp;pSection[pFileHeader-&gt;NumberOfSections].PointerToRawData;
	PDWORD pSecCharacteristic = &amp;pSection[pFileHeader-&gt;NumberOfSections].Characteristics;
	//名字
	memcpy(pSecName, ".mycode", 8);
	//Misc
	*pSecMisc = 0x1000;
	//计算VirtualAddress=前一个节的VA+sizeofrawdata或者virtualSize内存对齐大小
	DWORD Sec_Size = (pfinal_Section-&gt;SizeOfRawData &gt; pfinal_Section-&gt;Misc.VirtualSize) ? pfinal_Section-&gt;SizeOfRawData : pfinal_Section-&gt;Misc.VirtualSize;
	//内存对齐
	Sec_Size= (Sec_Size % pOptionalHeader-&gt;SectionAlignment) ? ((Sec_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : Sec_Size;
	//修改VirtualAddress
	*pSecVirtualAddress = pfinal_Section-&gt;VirtualAddress + Sec_Size;
	//修改sizeofRawData
	*pSecSizeofRawData = 0x1000;
	//修改Pointer
	DWORD size = pfinal_Section-&gt;SizeOfRawData;
	DWORD File_Size= (size % pOptionalHeader-&gt;FileAlignment) ? ((size / pOptionalHeader-&gt;FileAlignment) + 1) * pOptionalHeader-&gt;FileAlignment : size;
	*pSecPointerToRawData = pfinal_Section-&gt;PointerToRawData + File_Size;

	*pSecCharacteristic = 0xFFFFFFFF;

	//头部信息,先计算增加的长度在内存和文件拉伸的长度
	DWORD Sec_ADD = (New_Buffer_Size % pOptionalHeader-&gt;SectionAlignment) ? ((New_Buffer_Size / pOptionalHeader-&gt;SectionAlignment) + 1) * pOptionalHeader-&gt;SectionAlignment : New_Buffer_Size;
	DWORD File_ADD = 
	pOptionalHeader-&gt;SizeOfImage += Sec_ADD;
	pFileHeader-&gt;NumberOfSections += 1;

	*pNewBuffer = pNewTempBuffer;
	pNewTempBuffer = NULL;
	return New_File_Size;
}
void Write_To_Newfile(DWORD New_File_Size, LPVOID pNewBuffer)
{
	FILE* fp;
	fp = fopen(Final_Path, "wb");
	fwrite(pNewBuffer, New_File_Size, 1, fp);
	fclose(fp);
	return ;
}
void PE_operate()
{
	DWORD new_file_size = 0;
	PVOID pNewBuffer = NULL;
	PVOID FileBuffer = NULL;
	DWORD file_size = 0;
	DWORD New_File_Size = 0;
	//打开文件读取信息
	file_size = Open_File(&amp;FileBuffer);
	//新增节并且修改信息
	New_File_Size=Add_Section(FileBuffer,&amp;pNewBuffer,file_size);

	Write_To_Newfile(New_File_Size, pNewBuffer);
}
int main()
{
	PE_operate();
	return 0;
}</code></pre>

<h1 id="打印导出表信息-按名称导出"><a href="#打印导出表信息-按名称导出" class="headerlink" title="打印导出表信息-按名称导出"></a>打印导出表信息-按名称导出</h1><pre class="language-c" data-language="c"><code class="language-c">#define  _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;windows.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;
#define FilePath "D:\\OneDrive\\桌面\\reverse\\吾爱破解专用版Ollydbg\\DBGHELP.DLL"

void ReadFileToBuffer(LPVOID *FileBuffer)
{
	LPVOID pTempBuffer;
	//打开文件并读取到Buffer中
	FILE* pfile = NULL;
	pfile = fopen(FilePath, "r");
	fseek(pfile, 0, SEEK_END);
	//读取文件大小
	DWORD file_size = ftell(pfile);
	//设置到开头进行读取
	fseek(pfile, 0, SEEK_SET);
	//先开辟空间
	pTempBuffer = (void*)malloc(file_size);
	//读取信息
	fread(pTempBuffer, file_size, 1, pfile);
	//如果是一级指针，读取完之后就会被释放掉
	*FileBuffer = pTempBuffer;
	pTempBuffer = NULL;
	fclose(pfile);
	return ;
}

/*
* RVA转FOA
* 先看在哪个节区，减去该节区的RVA+该节区的PointerOfRawData
*/
DWORD RVATOFOA(PIMAGE_SECTION_HEADER pSectionHeader, DWORD RVA,DWORD NumberOfSection)
{
	DWORD FOA = 0;
	for (int i = 0; i &lt; NumberOfSection; i++, pSectionHeader++)
	{
		//如果小于RVA+节区的大小，说明在节区内
		if (RVA &lt; pSectionHeader-&gt;VirtualAddress + max(pSectionHeader-&gt;SizeOfRawData, pSectionHeader-&gt;Misc.VirtualSize))
		{
			FOA = RVA - pSectionHeader-&gt;VirtualAddress + pSectionHeader-&gt;PointerToRawData;
			return FOA;
		}
	}
}

void PrintExportTable(LPVOID FileBuffer)
{
	PIMAGE_DOS_HEADER pDosHeader = NULL;
	PIMAGE_NT_HEADERS32 pNtHeader = NULL;
	PIMAGE_FILE_HEADER pFileHeader = NULL;
	PIMAGE_OPTIONAL_HEADER32 pOptionalHeader = NULL;
	PIMAGE_SECTION_HEADER pSectionHeader = NULL;
	PIMAGE_EXPORT_DIRECTORY pExportTable = NULL;
	PIMAGE_DATA_DIRECTORY pDataTable= NULL;
	//读取DLL信息
	pDosHeader = (PIMAGE_DOS_HEADER)(FileBuffer);
	pNtHeader = (PIMAGE_NT_HEADERS32)((DWORD)FileBuffer + pDosHeader-&gt;e_lfanew);
	pFileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNtHeader + 4);
	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pFileHeader + sizeof(IMAGE_FILE_HEADER));
	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + sizeof(IMAGE_OPTIONAL_HEADER32));
	//获取导出表基本信息
	pDataTable = (PIMAGE_DATA_DIRECTORY)(pOptionalHeader-&gt;DataDirectory);
	printf("导出表的RVA为：%X\n", pDataTable[0].VirtualAddress);
	printf("导出表的大小为：%X\n", pDataTable[0].Size);
	//打印导出表
	DWORD ExportTable_FOA = RVATOFOA(pSectionHeader, pDataTable[0].VirtualAddress,pFileHeader-&gt;NumberOfSections);
	printf("导出表在文件中的位置为：%X\n", ExportTable_FOA);
	//获取导出表信息
	pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + ExportTable_FOA);

	//打印导出表信息，获取DLL名称，导出函数名称表，导出函数地址表，导出函数序号表
	//先打印导出表按名字导出函数的个数
	printf("按名称导出的函数个数为：%X\n", pExportTable-&gt;NumberOfFunctions);
	printf("按名称导出的函数个数为：%X\n", pExportTable-&gt;NumberOfNames);

	//打印DLL名称，导出函数名称表，导出函数地址表，导出函数序号表
	DWORD NameFOA = RVATOFOA(pSectionHeader, pExportTable-&gt;Name, pFileHeader-&gt;NumberOfSections);
	char* nameofdll = (char*)((DWORD)pDosHeader + NameFOA);
	printf("DLL的名称为：%s\n", nameofdll);
	DWORD FOAOfName= RVATOFOA(pSectionHeader,pExportTable-&gt;AddressOfNames, pFileHeader-&gt;NumberOfSections);
	DWORD FOAOfNameOdinals= RVATOFOA(pSectionHeader, pExportTable-&gt;AddressOfNameOrdinals, pFileHeader-&gt;NumberOfSections);
	DWORD FOAOfFunctions= RVATOFOA(pSectionHeader, pExportTable-&gt;AddressOfFunctions, pFileHeader-&gt;NumberOfSections);
	printf("文件中导出函数地址表为：%X\n文件中函数名称地址表为：%X\n文件中函数序号地址表为：%X\n", FOAOfFunctions, FOAOfName, FOAOfNameOdinals);
	int * FuncTable = (int*)((DWORD)pDosHeader + FOAOfFunctions);
	int* NameTable = (int*)((DWORD)pDosHeader + FOAOfName);
	short* Ordinals = (short*)((DWORD)pDosHeader + FOAOfNameOdinals);

	////注意下面是随机打印的
	//for(int i = 0; i &lt; pExportTable-&gt;NumberOfNames; ++i)
	//{
	//	printf("导出函数地址为：%X ", RVATOFOA(pSectionHeader, *FuncTable, pFileHeader-&gt;NumberOfSections));
	//	
	//	char*name=(char*)pDosHeader + (RVATOFOA(pSectionHeader, *NameTable, pFileHeader-&gt;NumberOfSections));
	//	printf("名称为：%s ", name);
	//	//函数序号存储的不是RVA，而是序号,直接解引用即可，但是要注意是short型
	//	printf("函数序号为：%X\n", *Ordinals);
	//	NameTable++;
	//	FuncTable++;
	//	Ordinals++;
	//}
	

	//按函数名称导出
	char funcname[] = "WinDbgExtensionDllInit";
	for (int i = 0; i &lt; pExportTable-&gt;NumberOfNames; ++i)
	{
		char* name = (char*)pDosHeader + (RVATOFOA(pSectionHeader, *NameTable, pFileHeader-&gt;NumberOfSections));
		//printf("函数名称为：%s\n", name);
		//如果找到我们的函数名时，先把下标去序号表找，然后取出里面的值，再拿去函数地址表找
		if (strcmp(funcname, name) == 0)
		{
			Ordinals += i;
			printf("函数名称为：%s\n", name);
			printf("函数序号为：%X\n", *Ordinals);
			printf("导出函数地址为：%X ", RVATOFOA(pSectionHeader, *(FuncTable+*Ordinals), pFileHeader-&gt;NumberOfSections));
			break;
		}
		else//否则就是按照序号导出的，只需要将
		{

		}
		NameTable++;
	}
	return;
}
void oprate_pe()
{
	LPVOID FileBuffer = NULL;
	ReadFileToBuffer(&amp;FileBuffer);
	PrintExportTable(FileBuffer);
	return ;
}
int main()
{
	oprate_pe();
	return 0;
}</code></pre>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/PE/" rel="tag"># PE</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/03/03/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" rel="prev" title="PE文件结构">
                  <i class="fa fa-chevron-left"></i> PE文件结构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/11/PE-%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0/" rel="next" title="PE-滴水逆向-手动实现">
                  PE-滴水逆向-手动实现 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">278k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:13</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
