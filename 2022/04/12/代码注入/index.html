<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gift1a.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="0x00-前言感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限 于是翻阅到了这篇文章 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1270499-1-1.html 0x01-原理在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL  实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以">
<meta property="og:type" content="article">
<meta property="og:title" content="代码注入">
<meta property="og:url" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="0x00-前言感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限 于是翻阅到了这篇文章 https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-1270499-1-1.html 0x01-原理在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL  实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649916449939.png">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922555004.png">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922580481.png">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922621425.png">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922671867.png">
<meta property="og:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649923028194.png">
<meta property="article:published_time" content="2022-04-12T03:41:45.000Z">
<meta property="article:modified_time" content="2022-04-14T14:07:08.493Z">
<meta property="article:author" content="Gift1a">
<meta property="article:tag" content="Windows">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png">


<link rel="canonical" href="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/","path":"2022/04/12/代码注入/","title":"代码注入"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>代码注入 | Hexo</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00-前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">0x01-原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">2.1.</span> <span class="nav-text">定义函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF%E5%9D%97"><span class="nav-number">2.2.</span> <span class="nav-text">定义线程信息块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF%E5%9D%97%E8%B5%8B%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">线程信息块赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">打开目标进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E8%BE%9F%E5%86%85%E5%AD%98%E5%B9%B6%E5%86%99%E5%85%A5%E7%BA%BF%E7%A8%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">2.5.</span> <span class="nav-text">开辟内存并写入线程信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.6.</span> <span class="nav-text">开启远程线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8"><span class="nav-number">2.7.</span> <span class="nav-text">线程函数实现调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x02-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">0x02-代码实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x03-%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C"><span class="nav-number">4.</span> <span class="nav-text">0x03-最终效果</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x04-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E8%B0%83%E8%AF%95%E7%BB%83%E4%B9%A0"><span class="nav-number">5.</span> <span class="nav-text">0x04-代码注入调试练习</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gift1a</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gift1a.github.io/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gift1a">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="代码注入 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          代码注入
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-12 11:41:45" itemprop="dateCreated datePublished" datetime="2022-04-12T11:41:45+08:00">2022-04-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-14 22:07:08" itemprop="dateModified" datetime="2022-04-14T22:07:08+08:00">2022-04-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00-前言"></a>0x00-前言</h1><p>感觉《逆向工程核心原理》只是进行了一点介绍，但是我理解能力有限</p>
<p>于是翻阅到了这篇文章</p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1270499-1-1.html">https://www.52pojie.cn/thread-1270499-1-1.html</a></p>
<h1 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01-原理"></a>0x01-原理</h1><p>在DLL注入中，我们通过远程线程在目标进程中调用LoadLibraryA()函数加载我们的DLL</p>
<p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649738932188.png"></p>
<p>实际上只要我们定义的函数符合CreateRemoteThread参数中定义的函数模板，就可以通过远程线程的方式去执行它，而不限于LoadLibraryA</p>
<pre class="language-c" data-language="c"><code class="language-c">DWORD WINAPI ThreadProc(
  _In_ LPVOID lpParameter
);</code></pre>

<p>所以我们只要定义一个只有一个参数的函数，把它转换成 LPTHREAD_START_ROUTINE（CreateRemoteThread的参数）即可。</p>
<p>但是这里产生了一个问题，如果我们的函数具有多个参数怎么办呢，要成功调用函数的话，我们的参数也需要在目标进程的虚拟内存中</p>
<blockquote>
<p>对于将我们的参数写入虚拟内存中，我们可以使用VirtualAllocEx函数向目标申请内存虚拟空间</p>
<p>对于多个参数，我们可以构建一个结构体存放所有的参数，然后在调用的时候通过内存偏移来访问参数</p>
</blockquote>
<pre class="language-c" data-language="c"><code class="language-c">typedef struct _INJECT_DATA
{
    char lpText[8];  //参数1
    char lpCaption[8];  //参数2
}INJECT_DATA;</code></pre>

<p>下面以MessageBoxA函数为例</p>
<h2 id="定义函数指针"><a href="#定义函数指针" class="headerlink" title="定义函数指针"></a>定义函数指针</h2><p>首先先进行定义我们要使用到的函数指针</p>
<p>因为我们要调用user32.dll中的MessageBoxA，所以要使用LoadLibraryA()加载user32.dll，并且使用GetProcAddress()获取MessageBoxA的函数地址</p>
<pre class="language-c" data-language="c"><code class="language-c">//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数
typedef HMODULE(WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName);//前面的是返回值，中间是类型

typedef FARPROC(WINAPI *PFGETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName);//返回值是一个回调函数

typedef int (WINAPI *PFMESSAGEBOXA)(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);</code></pre>

<h2 id="定义线程信息块"><a href="#定义线程信息块" class="headerlink" title="定义线程信息块"></a>定义线程信息块</h2><p>使用结构体存储我们要调用的函数信息</p>
<pre class="language-c" data-language="c"><code class="language-c">//创建一个存储线程信息的结构体
typedef struct _THREAD_PARAM//定义线程信息
{
    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()  
    char    szBuf[4][128];          // "user32.dll", "MessageBoxA", "Inject Success!!", "Hint"  
} THREAD_PARAM, * PTHREAD_PARAM;//分别是线程信息块和指向线程信息的指针
</code></pre>

<h2 id="线程信息块赋值"><a href="#线程信息块赋值" class="headerlink" title="线程信息块赋值"></a>线程信息块赋值</h2><pre class="language-c" data-language="c"><code class="language-c">hMod = GetModuleHandleA("kernel32.dll");

//先给线程信息块赋值 
param.pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");
param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//因为kernel32在内存中优先被装载，所以在不同进程中都一样
strcpy_s(param.szBuf[0], "user32.dll");
strcpy_s(param.szBuf[1], "MessageBoxA");
strcpy_s(param.szBuf[2], "InjectCode Success!!");
strcpy_s(param.szBuf[3], "Hint");</code></pre>

<h2 id="打开目标进程"><a href="#打开目标进程" class="headerlink" title="打开目标进程"></a>打开目标进程</h2><pre class="language-c" data-language="c"><code class="language-c">//开启进程  
    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))              
    {
        printf("OpenProcess() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }</code></pre>

<h2 id="开辟内存并写入线程信息"><a href="#开辟内存并写入线程信息" class="headerlink" title="开辟内存并写入线程信息"></a>开辟内存并写入线程信息</h2><p>第一次写入的是线程函数要调用的函数信息</p>
<pre class="language-c" data-language="c"><code class="language-c">//为注入的线程信息块中的第一个函数开辟内存 
    dwSize = sizeof(THREAD_PARAM);
    if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_READWRITE)))    
    {
        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }
    //写入线程信息块中函数的值和参数到进程中
    if (!WriteProcessMemory(hProcess,pRemoteBuf[0],(LPVOID)&amp;param,dwSize,NULL))
    {
        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }</code></pre>

<p>第二次将线程函数写入内存</p>
<pre class="language-c" data-language="c"><code class="language-c">//再次开辟  
    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;
    if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))
    {
        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }

    //函数调用
    if (!WriteProcessMemory(hProcess,pRemoteBuf[1],(LPVOID)ThreadProc,dwSize,NULL))
    {
        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }</code></pre>

<h2 id="开启远程线程"><a href="#开启远程线程" class="headerlink" title="开启远程线程"></a>开启远程线程</h2><p>在目标线程中开启远程线程</p>
<pre class="language-c" data-language="c"><code class="language-c">if (!(hThread = CreateRemoteThread(hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pRemoteBuf[1],pRemoteBuf[0],0,NULL)))
    {
        printf("CreateRemoteThread() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }</code></pre>

<h2 id="线程函数实现调用"><a href="#线程函数实现调用" class="headerlink" title="线程函数实现调用"></a>线程函数实现调用</h2><p>开启线程后会调用线程函数，把我们写入进程内存中的信息读取到要调用的函数中，最后实现调用</p>
<pre class="language-c" data-language="c"><code class="language-c">//这里的WINAPI是调用约定，相当于__stdcall
//线程函数，线程开始的地方
DWORD WINAPI ThreadProc(LPVOID lParam)
{
    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;
    HMODULE         hMod = NULL;
    FARPROC         pFunc = NULL;

    // LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数
    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // "user32.dll"，第二个括号内的是函数的参数
    if (!hMod)
        return 1;

    // GetProcAddress()，返回值是回调函数，pFunc就是函数指针
    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // "MessageBoxA" ，获取到MessageBoxA的地址 
    if (!pFunc)
        return 1;

    // MessageBoxA()  
    ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);//最后的调用

    return 0;
}</code></pre>

<h1 id="0x02-代码实现"><a href="#0x02-代码实现" class="headerlink" title="0x02-代码实现"></a>0x02-代码实现</h1><pre class="language-c" data-language="c"><code class="language-c">#include&lt;string.h&gt;
#include "windows.h"  
#include "stdio.h" 

//创建一个存储线程信息的结构体
typedef struct _THREAD_PARAM//定义线程信息
{
    FARPROC pFunc[2];               // LoadLibraryA(), GetProcAddress()  
    char    szBuf[4][128];          // "user32.dll", "MessageBoxA", "www.reversecore.com", "ReverseCore"  
} THREAD_PARAM, * PTHREAD_PARAM;//分别是线程信息块和指向线程信息的指针

//定义函数指针，方便调用HOMDULE是返回值，WINAPI也就是__stdcall，是调用约定，类型名为PFLOADLIBRARYA，lpLivFileName是参数
typedef HMODULE(WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName);//前面的是返回值，中间是类型

typedef FARPROC(WINAPI *PFGETPROCADDRESS)(HMODULE hModule,LPCSTR lpProcName);//返回值是一个回调函数

typedef int (WINAPI *PFMESSAGEBOXA)(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);

//这里的WINAPI是调用约定，相当于__stdcall
//线程函数，线程开始的地方
DWORD WINAPI ThreadProc(LPVOID lParam)
{
    PTHREAD_PARAM   pParam = (PTHREAD_PARAM)lParam;
    HMODULE         hMod = NULL;
    FARPROC         pFunc = NULL;

    // LoadLibrary()，将pFunc[0]强制转换为这样类型的函数指针，pParam-&gt;szBuf[0]是该函数的参数
    hMod = ((PFLOADLIBRARYA)pParam-&gt;pFunc[0])(pParam-&gt;szBuf[0]);    // "user32.dll"，第二个括号内的是函数的参数
    if (!hMod)
        return 1;

    // GetProcAddress()，返回值是回调函数，pFunc就是函数指针
    pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-&gt;pFunc[1])(hMod, pParam-&gt;szBuf[1]);  // "MessageBoxA" ，获取到MessageBoxA的地址 
    if (!pFunc)
        return 1;

    // MessageBoxA()  
    ((PFMESSAGEBOXA)pFunc)(NULL, pParam-&gt;szBuf[2], pParam-&gt;szBuf[3], MB_OK);//最后的调用

    return 0;
}

BOOL InjectCode(DWORD dwPID)
{
    HMODULE         hMod = NULL;
    THREAD_PARAM    param = { 0, };
    HANDLE          hProcess = NULL;
    HANDLE          hThread = NULL;
    LPVOID          pRemoteBuf[2] = { 0, };
    DWORD           dwSize = 0;

    hMod = GetModuleHandleA("kernel32.dll");

    //先给线程信息块赋值 
    param.pFunc[0] = GetProcAddress(hMod, "LoadLibraryA");
    param.pFunc[1] = GetProcAddress(hMod, "GetProcAddress");//因为kernel32在内存中优先被装载，所以在不同进程中都一样
    strcpy_s(param.szBuf[0], "user32.dll");
    strcpy_s(param.szBuf[1], "MessageBoxA");
    strcpy_s(param.szBuf[2], "InjectCode Success!!");
    strcpy_s(param.szBuf[3], "Hint");

    //开启进程  
    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwPID)))              
    {
        printf("OpenProcess() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }

    //为注入的线程信息块中的第一个函数开辟内存 
    dwSize = sizeof(THREAD_PARAM);
    if (!(pRemoteBuf[0] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_READWRITE)))    
    {
        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }
    //写入线程信息块中函数的值和参数到进程中
    if (!WriteProcessMemory(hProcess,pRemoteBuf[0],(LPVOID)&amp;param,dwSize,NULL))
    {
        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }

    //再次开辟  
    dwSize = (DWORD)InjectCode - (DWORD)ThreadProc;
    if (!(pRemoteBuf[1] = VirtualAllocEx(hProcess,NULL,dwSize,MEM_COMMIT,PAGE_EXECUTE_READWRITE)))
    {
        printf("VirtualAllocEx() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }

    //函数调用
    if (!WriteProcessMemory(hProcess,pRemoteBuf[1],(LPVOID)ThreadProc,dwSize,NULL))
    {
        printf("WriteProcessMemory() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }
    //开启远程线程，LPTHREAD_START_ROUTINE指向一个回调函数，pRemoteBuf[1]是函数，pRemoteBufe[0]是函数的值和参数
    if (!(hThread = CreateRemoteThread(hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pRemoteBuf[1],pRemoteBuf[0],0,NULL)))
    {
        printf("CreateRemoteThread() fail : err_code = %d\n", GetLastError());
        return FALSE;
    }

    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);
    CloseHandle(hProcess);

    return TRUE;
}

BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken;
    LUID luid;

    if (!OpenProcessToken(GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &amp;hToken))
    {
        printf("OpenProcessToken error: %u\n", GetLastError());
        return FALSE;
    }

    if (!LookupPrivilegeValue(NULL,           // lookup privilege on local system  
        lpszPrivilege,  // privilege to lookup   
        &amp;luid))        // receives LUID of privilege  
    {
        printf("LookupPrivilegeValue error: %u\n", GetLastError());
        return FALSE;
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    if (bEnablePrivilege)
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    else
        tp.Privileges[0].Attributes = 0;

    // Enable the privilege or disable all privileges.  
    if (!AdjustTokenPrivileges(hToken,
        FALSE,
        &amp;tp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES)NULL,
        (PDWORD)NULL))
    {
        printf("AdjustTokenPrivileges error: %u\n", GetLastError());
        return FALSE;
    }

    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        printf("The token does not have the specified privilege. \n");
        return FALSE;
    }

    return TRUE;
}

int main(int argc, char* argv[])
{
    DWORD dwPID = 0;

    if (argc != 2)
    {
        printf("\n USAGE  : %s &lt;pid&gt;\n", argv[0]);
        return 1;
    }

    //进程提权
    if (!SetPrivilege(SE_DEBUG_NAME, TRUE))
        return 1;

    //code injection  
    dwPID = (DWORD)atol(argv[1]);
    dwPID = 9432;
    InjectCode(dwPID);

    return 0;
}</code></pre>

<h1 id="0x03-最终效果"><a href="#0x03-最终效果" class="headerlink" title="0x03-最终效果"></a>0x03-最终效果</h1><p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649916449939.png"></p>
<h1 id="0x04-代码注入调试练习"><a href="#0x04-代码注入调试练习" class="headerlink" title="0x04-代码注入调试练习"></a>0x04-代码注入调试练习</h1><p>先使用OD打开notepad++，并F9直至notepad++处于运行状态</p>
<p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922555004.png" alt="进行设置"></p>
<p>然后查看notepad++ PID并注入</p>
<p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922580481.png"></p>
<p>注入之后会断在ThreadProc函数</p>
<p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922621425.png"></p>
<p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649922671867.png"></p>
<p>在x32中</p>
<p><img src="/2022/04/12/%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/1649923028194.png"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Windows/" rel="tag"># Windows</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/11/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/" rel="prev" title="基础知识补充">
                  <i class="fa fa-chevron-left"></i> 基础知识补充
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/13/Windows%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/" rel="next" title="Windows核心编程">
                  Windows核心编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gift1a</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
